{"ast":null,"code":"import _regeneratorRuntime from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { Buffer } from \"buffer\";\nimport { XXHandshake } from \"./handshake-xx\";\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from \"./utils\";\nimport { logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey } from \"./logger\";\nimport { decode0, decode1 } from \"./encoder\";\nexport var XXFallbackHandshake = /*#__PURE__*/function (_XXHandshake) {\n  _inherits(XXFallbackHandshake, _XXHandshake);\n\n  var _super = _createSuper(XXFallbackHandshake);\n\n  function XXFallbackHandshake(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    var _this;\n\n    _classCallCheck(this, XXFallbackHandshake);\n\n    _this = _super.call(this, isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    _defineProperty(_assertThisInitialized(_this), \"ephemeralKeys\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"initialMsg\", void 0);\n\n    if (ephemeralKeys) {\n      _this.ephemeralKeys = ephemeralKeys;\n    }\n\n    _this.initialMsg = initialMsg;\n    return _this;\n  } // stage 0\n\n\n  _createClass(XXFallbackHandshake, [{\n    key: \"propose\",\n    value: function () {\n      var _propose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var receivedMessageBuffer, _this$xx$recvMessage, valid;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.isInitiator) {\n                  _context.next = 6;\n                  break;\n                }\n\n                this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys);\n                logger(\"XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.\");\n                logLocalEphemeralKeys(this.session.hs.e);\n                _context.next = 13;\n                break;\n\n              case 6:\n                logger(\"XX Fallback Stage 0 - Responder decoding initial msg from IK.\");\n                receivedMessageBuffer = decode0(this.initialMsg);\n                _this$xx$recvMessage = this.xx.recvMessage(this.session, {\n                  ne: receivedMessageBuffer.ne,\n                  ns: Buffer.alloc(0),\n                  ciphertext: Buffer.alloc(0)\n                }), valid = _this$xx$recvMessage.valid;\n\n                if (valid) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"xx fallback stage 0 decryption validation fail\");\n\n              case 11:\n                logger(\"XX Fallback Stage 0 - Responder used received message from IK.\");\n                logRemoteEphemeralKey(this.session.hs.re);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function propose() {\n        return _propose.apply(this, arguments);\n      }\n\n      return propose;\n    }() // stage 1\n\n  }, {\n    key: \"exchange\",\n    value: function () {\n      var _exchange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var receivedMessageBuffer, _this$xx$recvMessage2, plaintext, valid, decodedPayload;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.isInitiator) {\n                  _context2.next = 30;\n                  break;\n                }\n\n                receivedMessageBuffer = decode1(this.initialMsg);\n                _this$xx$recvMessage2 = this.xx.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$xx$recvMessage2.plaintext, valid = _this$xx$recvMessage2.valid;\n\n                if (valid) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new Error(\"xx fallback stage 1 decryption validation fail\");\n\n              case 5:\n                logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n                logRemoteEphemeralKey(this.session.hs.re);\n                logRemoteStaticKey(this.session.hs.rs);\n                logger(\"Initiator going to check remote's signature...\");\n                _context2.prev = 9;\n                _context2.next = 12;\n                return decodePayload(plaintext);\n\n              case 12:\n                decodedPayload = _context2.sent;\n                _context2.t0 = this.remotePeer;\n\n                if (_context2.t0) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                _context2.next = 17;\n                return getPeerIdFromPayload(decodedPayload);\n\n              case 17:\n                _context2.t0 = _context2.sent;\n\n              case 18:\n                this.remotePeer = _context2.t0;\n                _context2.next = 21;\n                return verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n\n              case 21:\n                this.setRemoteEarlyData(decodedPayload.data);\n                _context2.next = 27;\n                break;\n\n              case 24:\n                _context2.prev = 24;\n                _context2.t1 = _context2[\"catch\"](9);\n                throw new Error(\"Error occurred while verifying signed payload from responder: \".concat(_context2.t1.message));\n\n              case 27:\n                logger(\"All good with the signature!\");\n                _context2.next = 34;\n                break;\n\n              case 30:\n                logger(\"XX Fallback Stage 1 - Responder start\");\n                _context2.next = 33;\n                return _get(_getPrototypeOf(XXFallbackHandshake.prototype), \"exchange\", this).call(this);\n\n              case 33:\n                logger(\"XX Fallback Stage 1 - Responder end\");\n\n              case 34:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[9, 24]]);\n      }));\n\n      function exchange() {\n        return _exchange.apply(this, arguments);\n      }\n\n      return exchange;\n    }()\n  }]);\n\n  return XXFallbackHandshake;\n}(XXHandshake);","map":{"version":3,"sources":["../src/handshake-xx-fallback.ts"],"names":["constructor","Buffer","logger","logLocalEphemeralKeys","receivedMessageBuffer","decode0","valid","ne","ns","ciphertext","logRemoteEphemeralKey","decode1","logRemoteStaticKey","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","e"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,MAAA,QAAA,QAAA;AACA,SAAA,WAAA,QAAA,gBAAA;AAIA,SAAA,aAAA,EAAA,oBAAA,EAAA,mBAAA,QAAA,SAAA;AACA,SAAA,MAAA,EAAA,qBAAA,EAAA,qBAAA,EAAA,kBAAA,QAAA,UAAA;AAEA,SAAA,OAAA,EAAA,OAAA,QAAA,WAAA;AAGA,WAAO,mBAAP;AAAA;;AAAA;;AAIEA,+BAAW,WAAXA,EAAW,OAAXA,EAAW,QAAXA,EAAW,aAAXA,EAAW,UAAXA,EAAW,UAAXA,EAAW,UAAXA,EAAW,aAAXA,EAAW,SAAXA,EAUE;AAAA;;AAAA;;AACA,8BAAA,WAAA,EAAA,OAAA,EAAA,QAAA,EAAA,aAAA,EAAA,UAAA,EAAA,UAAA,EAAA,SAAA;;AADA,IAAA,eAAA,gCAAA,eAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,gCAAA,YAAA,EAAA,KAAA,CAAA,CAAA;;AAEA,QAAA,aAAA,EAAmB;AACjB,YAAA,aAAA,GAAA,aAAA;AACD;;AACD,UAAA,UAAA,GAAA,UAAA;AALA;AAdiD,GAArD,CAsBE;;;AAtBF;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBAwBQ,KAAJ,WAxBJ;AAAA;AAAA;AAAA;;AAyBM,qBAAA,EAAA,CAAA,WAAA,CAAoB,KAApB,OAAA,EAAkCC,MAAM,CAANA,KAAAA,CAAlC,CAAkCA,CAAlC,EAAmD,KAAnD,aAAA;AACAC,gBAAAA,MAAM,CAANA,qFAAM,CAANA;AACAC,gBAAAA,qBAAqB,CAAC,KAAA,OAAA,CAAA,EAAA,CAAtBA,CAAqB,CAArBA;AA3BN;AAAA;;AAAA;AA6BMD,gBAAAA,MAAM,CAANA,+DAAM,CAANA;AACME,gBAAAA,qBA9BZ,GA8BoCC,OAAO,CAAC,KAAtC,UAAqC,CA9B3C;AAAA,uCA+BsB,KAAA,EAAA,CAAA,WAAA,CAAoB,KAApB,OAAA,EAAkC;AAChDE,kBAAAA,EAAE,EAAEH,qBAAqB,CADuB,EAAA;AAEhDI,kBAAAA,EAAE,EAAEP,MAAM,CAANA,KAAAA,CAF4C,CAE5CA,CAF4C;AAGhDQ,kBAAAA,UAAU,EAAER,MAAM,CAANA,KAAAA,CAAAA,CAAAA;AAHoC,iBAAlC,CA/BtB,EA+BaK,KA/Bb,wBA+BaA,KA/Bb;;AAAA,oBAoCM,KApCN;AAAA;AAAA;AAAA;;AAAA,sBAqCc,IAAA,KAAA,CAAN,gDAAM,CArCd;;AAAA;AAuCMJ,gBAAAA,MAAM,CAANA,gEAAM,CAANA;AACAQ,gBAAAA,qBAAqB,CAAC,KAAA,OAAA,CAAA,EAAA,CAAtBA,EAAqB,CAArBA;;AAxCN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,QA4CE;;AA5CF;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,qBA8CQ,KAAJ,WA9CJ;AAAA;AAAA;AAAA;;AA+CYN,gBAAAA,qBA/CZ,GA+CoCO,OAAO,CAAC,KAAtC,UAAqC,CA/C3C;AAAA,wCAgDiC,KAAA,EAAA,CAAA,WAAA,CAAoB,KAApB,OAAA,EAA3B,qBAA2B,CAhDjC,EAgDY,SAhDZ,yBAgDY,SAhDZ,EAgDwBL,KAhDxB,yBAgDwBA,KAhDxB;;AAAA,oBAiDM,KAjDN;AAAA;AAAA;AAAA;;AAAA,sBAkDc,IAAA,KAAA,CAAN,gDAAM,CAlDd;;AAAA;AAoDMJ,gBAAAA,MAAM,CAANA,gEAAM,CAANA;AACAQ,gBAAAA,qBAAqB,CAAC,KAAA,OAAA,CAAA,EAAA,CAAtBA,EAAqB,CAArBA;AACAE,gBAAAA,kBAAkB,CAAC,KAAA,OAAA,CAAA,EAAA,CAAnBA,EAAkB,CAAlBA;AAEAV,gBAAAA,MAAM,CAANA,gDAAM,CAANA;AAxDN;AAAA;AAAA,uBA0DqCY,aAAa,CAA1C,SAA0C,CA1DlD;;AAAA;AA0DcD,gBAAAA,cA1Dd;AAAA,+BA2D0B,KAAA,UA3D1B;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBA2DmDE,oBAAoB,CAA/D,cAA+D,CA3DvE;;AAAA;AAAA;;AAAA;AA2DQ,qBAAA,UA3DR;AAAA;AAAA,uBA4DcC,mBAAmB,CAAC,KAAA,OAAA,CAAA,EAAA,CAAD,EAAA,EAAA,cAAA,EAAqC,KAA9D,UAAyB,CA5DjC;;AAAA;AA6DQ,qBAAA,kBAAA,CAAwBH,cAAc,CAAtC,IAAA;AA7DR;AAAA;;AAAA;AAAA;AAAA;AAAA,sBA+Dc,IAAA,KAAA,CAAA,iEAAA,MAAA,CAA2EI,aAAjF,OAAM,CAAA,CA/Dd;;AAAA;AAiEMf,gBAAAA,MAAM,CAANA,8BAAM,CAANA;AAjEN;AAAA;;AAAA;AAmEMA,gBAAAA,MAAM,CAANA,uCAAM,CAANA;AAnEN;AAAA;;AAAA;AAqEMA,gBAAAA,MAAM,CAANA,qCAAM,CAANA;;AArEN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,EAAO,WAAP","sourcesContent":["import {Buffer} from \"buffer\";\nimport {XXHandshake} from \"./handshake-xx\";\nimport {XX} from \"./handshakes/xx\";\nimport {KeyPair} from \"./@types/libp2p\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {decodePayload, getPeerIdFromPayload, verifySignedPayload} from \"./utils\";\nimport {logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey} from \"./logger\";\nimport {WrappedConnection} from \"./noise\";\nimport {decode0, decode1} from \"./encoder\";\nimport PeerId from \"peer-id\";\n\nexport class XXFallbackHandshake extends XXHandshake {\n  private ephemeralKeys?: KeyPair;\n  private initialMsg: bytes;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    initialMsg: bytes,\n    remotePeer?: PeerId,\n    ephemeralKeys?: KeyPair,\n    handshake?: XX,\n  ) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n    this.initialMsg = initialMsg;\n  }\n\n  // stage 0\n  public async propose(): Promise<void> {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys);\n      logger(\"XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"XX Fallback Stage 0 - Responder decoding initial msg from IK.\");\n      const receivedMessageBuffer = decode0(this.initialMsg);\n      const {valid} = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: Buffer.alloc(0),\n        ciphertext: Buffer.alloc(0),\n      });\n      if(!valid) {\n        throw new Error(\"xx fallback stage 0 decryption validation fail\");\n      }\n      logger(\"XX Fallback Stage 0 - Responder used received message from IK.\");\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange(): Promise<void> {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = decode1(this.initialMsg);\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx fallback stage 1 decryption validation fail\");\n      }\n      logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\");\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`);\n      }\n      logger(\"All good with the signature!\");\n    } else {\n      logger(\"XX Fallback Stage 1 - Responder start\");\n      await super.exchange();\n      logger(\"XX Fallback Stage 1 - Responder end\");\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}