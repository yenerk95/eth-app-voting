{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar PeerId = require('peer-id');\n\nvar AddressBook = require('./address-book');\n\nvar KeyBook = require('./key-book');\n\nvar MetadataBook = require('./metadata-book');\n\nvar ProtoBook = require('./proto-book');\n\nvar _require2 = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require2.ERR_INVALID_PARAMETERS;\n/**\n * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\n\n\nvar PeerStore = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PeerStore, _EventEmitter);\n\n  var _super = _createSuper(PeerStore);\n\n  /**\n   * Peer object\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Array<Address>} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {Array<string>} protocols peer's supported protocols.\n   */\n\n  /**\n   * @constructor\n   */\n  function PeerStore() {\n    var _this;\n\n    _classCallCheck(this, PeerStore);\n\n    _this = _super.call(this);\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n\n    _this.addressBook = new AddressBook(_assertThisInitialized(_this));\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n\n    _this.keyBook = new KeyBook(_assertThisInitialized(_this));\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n\n    _this.metadataBook = new MetadataBook(_assertThisInitialized(_this));\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n\n    _this.protoBook = new ProtoBook(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Start the PeerStore.\n   */\n\n\n  _createClass(PeerStore, [{\n    key: \"start\",\n    value: function start() {}\n    /**\n     * Stop the PeerStore.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {}\n    /**\n     * Get all the stored information of every peer.\n     * @returns {Map<string, Peer>}\n     */\n\n  }, {\n    key: \"delete\",\n\n    /**\n     * Delete the information of the given peer in every book.\n     * @param {PeerId} peerId\n     * @returns {boolean} true if found and removed\n     */\n    value: function _delete(peerId) {\n      var addressesDeleted = this.addressBook.delete(peerId);\n      var keyDeleted = this.keyBook.delete(peerId);\n      var protocolsDeleted = this.protoBook.delete(peerId);\n      var metadataDeleted = this.metadataBook.delete(peerId);\n      return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;\n    }\n    /**\n     * Get the stored information of a given peer.\n     * @param {PeerId} peerId\n     * @returns {Peer}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(peerId) {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var id = this.keyBook.data.get(peerId.toB58String());\n      var addresses = this.addressBook.get(peerId);\n      var metadata = this.metadataBook.get(peerId);\n      var protocols = this.protoBook.get(peerId);\n\n      if (!id && !addresses && !metadata && !protocols) {\n        return undefined;\n      }\n\n      return {\n        id: id || peerId,\n        addresses: addresses || [],\n        protocols: protocols || [],\n        metadata: metadata\n      };\n    }\n  }, {\n    key: \"peers\",\n    get: function get() {\n      var _this2 = this;\n\n      var storedPeers = new Set([].concat(_toConsumableArray(this.addressBook.data.keys()), _toConsumableArray(this.keyBook.data.keys()), _toConsumableArray(this.protoBook.data.keys()), _toConsumableArray(this.metadataBook.data.keys())));\n      var peersData = new Map();\n      storedPeers.forEach(function (idStr) {\n        peersData.set(idStr, _this2.get(PeerId.createFromCID(idStr)));\n      });\n      return peersData;\n    }\n  }]);\n\n  return PeerStore;\n}(EventEmitter);\n\nmodule.exports = PeerStore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/peer-store/index.js"],"names":["errcode","require","debug","log","error","EventEmitter","PeerId","AddressBook","KeyBook","MetadataBook","ProtoBook","ERR_INVALID_PARAMETERS","PeerStore","addressBook","keyBook","metadataBook","protoBook","peerId","addressesDeleted","delete","keyDeleted","protocolsDeleted","metadataDeleted","isPeerId","Error","id","data","get","toB58String","addresses","metadata","protocols","undefined","storedPeers","Set","keys","peersData","Map","forEach","idStr","set","createFromCID","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('libp2p:peer-store')\nlog.error = debug('libp2p:peer-store:error')\n\nconst { EventEmitter } = require('events')\nconst PeerId = require('peer-id')\n\nconst AddressBook = require('./address-book')\nconst KeyBook = require('./key-book')\nconst MetadataBook = require('./metadata-book')\nconst ProtoBook = require('./proto-book')\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors')\n\n/**\n * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Array<Address>} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {Array<string>} protocols peer's supported protocols.\n   */\n\n  /**\n   * @constructor\n   */\n  constructor () {\n    super()\n\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n    this.addressBook = new AddressBook(this)\n\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n    this.keyBook = new KeyBook(this)\n\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n    this.metadataBook = new MetadataBook(this)\n\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n    this.protoBook = new ProtoBook(this)\n  }\n\n  /**\n   * Start the PeerStore.\n   */\n  start () {}\n\n  /**\n   * Stop the PeerStore.\n   */\n  stop () {}\n\n  /**\n   * Get all the stored information of every peer.\n   * @returns {Map<string, Peer>}\n   */\n  get peers () {\n    const storedPeers = new Set([\n      ...this.addressBook.data.keys(),\n      ...this.keyBook.data.keys(),\n      ...this.protoBook.data.keys(),\n      ...this.metadataBook.data.keys()\n    ])\n\n    const peersData = new Map()\n    storedPeers.forEach((idStr) => {\n      peersData.set(idStr, this.get(PeerId.createFromCID(idStr)))\n    })\n\n    return peersData\n  }\n\n  /**\n   * Delete the information of the given peer in every book.\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n  delete (peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId)\n    const keyDeleted = this.keyBook.delete(peerId)\n    const protocolsDeleted = this.protoBook.delete(peerId)\n    const metadataDeleted = this.metadataBook.delete(peerId)\n\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted\n  }\n\n  /**\n   * Get the stored information of a given peer.\n   * @param {PeerId} peerId\n   * @returns {Peer}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String())\n    const addresses = this.addressBook.get(peerId)\n    const metadata = this.metadataBook.get(peerId)\n    const protocols = this.protoBook.get(peerId)\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    }\n  }\n}\n\nmodule.exports = PeerStore\n"]},"metadata":{},"sourceType":"script"}