{"ast":null,"code":"'use strict'; // JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BITS_PER_BYTE = 7;\n\nmodule.exports = /*#__PURE__*/function () {\n  function SparseArray() {\n    _classCallCheck(this, SparseArray);\n\n    this._bitArrays = [];\n    this._data = [];\n    this._length = 0;\n    this._changedLength = false;\n    this._changedData = false;\n  }\n\n  _createClass(SparseArray, [{\n    key: \"set\",\n    value: function set(index, value) {\n      var pos = this._internalPositionFor(index, false);\n\n      if (value === undefined) {\n        // unsetting\n        if (pos !== -1) {\n          // remove item from bit array and array itself\n          this._unsetInternalPos(pos);\n\n          this._unsetBit(index);\n\n          this._changedLength = true;\n          this._changedData = true;\n        }\n      } else {\n        var needsSort = false;\n\n        if (pos === -1) {\n          pos = this._data.length;\n\n          this._setBit(index);\n\n          this._changedData = true;\n        } else {\n          needsSort = true;\n        }\n\n        this._setInternalPos(pos, index, value, needsSort);\n\n        this._changedLength = true;\n      }\n    }\n  }, {\n    key: \"unset\",\n    value: function unset(index) {\n      this.set(index, undefined);\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      this._sortData();\n\n      var pos = this._internalPositionFor(index, true);\n\n      if (pos === -1) {\n        return undefined;\n      }\n\n      return this._data[pos][1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      this.set(this.length, value);\n      return this.length;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(iterator) {\n      var i = 0;\n\n      while (i < this.length) {\n        iterator(this.get(i), i, this);\n        i++;\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(iterator) {\n      var i = 0;\n      var mapped = new Array(this.length);\n\n      while (i < this.length) {\n        mapped[i] = iterator(this.get(i), i, this);\n        i++;\n      }\n\n      return mapped;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(reducer, initialValue) {\n      var i = 0;\n      var acc = initialValue;\n\n      while (i < this.length) {\n        var value = this.get(i);\n        acc = reducer(acc, value, i);\n        i++;\n      }\n\n      return acc;\n    }\n  }, {\n    key: \"find\",\n    value: function find(finder) {\n      var i = 0,\n          found,\n          last;\n\n      while (i < this.length && !found) {\n        last = this.get(i);\n        found = finder(last);\n        i++;\n      }\n\n      return found ? last : undefined;\n    }\n  }, {\n    key: \"_internalPositionFor\",\n    value: function _internalPositionFor(index, noCreate) {\n      var bytePos = this._bytePosFor(index, noCreate);\n\n      if (bytePos >= this._bitArrays.length) {\n        return -1;\n      }\n\n      var byte = this._bitArrays[bytePos];\n      var bitPos = index - bytePos * BITS_PER_BYTE;\n      var exists = (byte & 1 << bitPos) > 0;\n\n      if (!exists) {\n        return -1;\n      }\n\n      var previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);\n\n      var mask = ~(0xffffffff << bitPos + 1);\n      var bytePopCount = popCount(byte & mask);\n      var arrayPos = previousPopCount + bytePopCount - 1;\n      return arrayPos;\n    }\n  }, {\n    key: \"_bytePosFor\",\n    value: function _bytePosFor(index, noCreate) {\n      var bytePos = Math.floor(index / BITS_PER_BYTE);\n      var targetLength = bytePos + 1;\n\n      while (!noCreate && this._bitArrays.length < targetLength) {\n        this._bitArrays.push(0);\n      }\n\n      return bytePos;\n    }\n  }, {\n    key: \"_setBit\",\n    value: function _setBit(index) {\n      var bytePos = this._bytePosFor(index, false);\n\n      this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;\n    }\n  }, {\n    key: \"_unsetBit\",\n    value: function _unsetBit(index) {\n      var bytePos = this._bytePosFor(index, false);\n\n      this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);\n    }\n  }, {\n    key: \"_setInternalPos\",\n    value: function _setInternalPos(pos, index, value, needsSort) {\n      var data = this._data;\n      var elem = [index, value];\n\n      if (needsSort) {\n        this._sortData();\n\n        data[pos] = elem;\n      } else {\n        // new element. just shove it into the array\n        // but be nice about where we shove it\n        // in order to make sorting it later easier\n        if (data.length) {\n          if (data[data.length - 1][0] >= index) {\n            data.push(elem);\n          } else if (data[0][0] <= index) {\n            data.unshift(elem);\n          } else {\n            var randomIndex = Math.round(data.length / 2);\n            this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));\n          }\n        } else {\n          this._data.push(elem);\n        }\n\n        this._changedData = true;\n        this._changedLength = true;\n      }\n    }\n  }, {\n    key: \"_unsetInternalPos\",\n    value: function _unsetInternalPos(pos) {\n      this._data.splice(pos, 1);\n    }\n  }, {\n    key: \"_sortData\",\n    value: function _sortData() {\n      if (this._changedData) {\n        this._data.sort(sortInternal);\n      }\n\n      this._changedData = false;\n    }\n  }, {\n    key: \"bitField\",\n    value: function bitField() {\n      var bytes = [];\n      var pendingBitsForResultingByte = 8;\n      var pendingBitsForNewByte = 0;\n      var resultingByte = 0;\n      var newByte;\n\n      var pending = this._bitArrays.slice();\n\n      while (pending.length || pendingBitsForNewByte) {\n        if (pendingBitsForNewByte === 0) {\n          newByte = pending.shift();\n          pendingBitsForNewByte = 7;\n        }\n\n        var usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);\n        var mask = ~(255 << usingBits);\n        var masked = newByte & mask;\n        resultingByte |= masked << 8 - pendingBitsForResultingByte;\n        newByte = newByte >>> usingBits;\n        pendingBitsForNewByte -= usingBits;\n        pendingBitsForResultingByte -= usingBits;\n\n        if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {\n          bytes.push(resultingByte);\n          resultingByte = 0;\n          pendingBitsForResultingByte = 8;\n        }\n      } // remove trailing zeroes\n\n\n      for (var i = bytes.length - 1; i > 0; i--) {\n        var value = bytes[i];\n\n        if (value === 0) {\n          bytes.pop();\n        } else {\n          break;\n        }\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"compactArray\",\n    value: function compactArray() {\n      this._sortData();\n\n      return this._data.map(valueOnly);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      this._sortData();\n\n      if (this._changedLength) {\n        var last = this._data[this._data.length - 1];\n        this._length = last ? last[0] + 1 : 0;\n        this._changedLength = false;\n      }\n\n      return this._length;\n    }\n  }]);\n\n  return SparseArray;\n}();\n\nfunction popCountReduce(count, byte) {\n  return count + popCount(byte);\n}\n\nfunction popCount(_v) {\n  var v = _v;\n  v = v - (v >> 1 & 0x55555555); // reuse input as temporary\n\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333); // temp\n\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\n\nfunction sortInternal(a, b) {\n  return a[0] - b[0];\n}\n\nfunction valueOnly(elem) {\n  return elem[1];\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/sparse-array/index.js"],"names":["BITS_PER_BYTE","module","exports","_bitArrays","_data","_length","_changedLength","_changedData","index","value","pos","_internalPositionFor","undefined","_unsetInternalPos","_unsetBit","needsSort","length","_setBit","_setInternalPos","set","_sortData","iterator","i","get","mapped","Array","reducer","initialValue","acc","finder","found","last","noCreate","bytePos","_bytePosFor","byte","bitPos","exists","previousPopCount","slice","reduce","popCountReduce","mask","bytePopCount","popCount","arrayPos","Math","floor","targetLength","push","data","elem","unshift","randomIndex","round","concat","splice","sort","sortInternal","bytes","pendingBitsForResultingByte","pendingBitsForNewByte","resultingByte","newByte","pending","shift","usingBits","min","masked","pop","map","valueOnly","count","_v","v","a","b"],"mappings":"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","sourcesContent":["'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}"]},"metadata":{},"sourceType":"script"}