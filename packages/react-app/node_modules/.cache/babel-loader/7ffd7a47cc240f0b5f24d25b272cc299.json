{"ast":null,"code":"'use strict';\n\nconst queue = require('async/queue');\n\nconst promiseToCallback = require('promise-to-callback');\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {DHT} dht\n   * @param {Run} run\n   * @param {Object} path\n   * @param {function} log\n   */\n  constructor(dht, run, path, log) {\n    this.dht = dht;\n    this.run = run;\n    this.path = path;\n    this.log = log;\n    this.concurrency = this.dht.concurrency;\n    this.queue = this.setupQueue(); // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    this.execution = null;\n  }\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Object}\n   */\n\n\n  setupQueue() {\n    const q = queue((peer, cb) => {\n      promiseToCallback(this.processNext(peer))(cb);\n    }, this.concurrency); // If there's an error, stop the worker\n\n    q.error = err => {\n      this.log.error('queue', err);\n      this.stop(err);\n    }; // When all peers in the queue have been processed, stop the worker\n\n\n    q.drain = () => {\n      this.log('queue:drain');\n      this.stop();\n    }; // When a space opens up in the queue, add some more peers\n\n\n    q.unsaturated = () => {\n      if (this.running) {\n        this.fill();\n      }\n    };\n\n    q.buffer = 0;\n    return q;\n  }\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} err\n   */\n\n\n  stop(err) {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n    this.queue.kill();\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length);\n\n    if (err) {\n      this.execution.reject(err);\n    } else {\n      this.execution.resolve();\n    }\n  }\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @return {Promise<void>}\n   */\n\n\n  async execute() {\n    this.running = true; // store the promise resolution functions to be resolved at end of queue\n\n    this.execution = {};\n    const execPromise = new Promise((resolve, reject) => Object.assign(this.execution, {\n      resolve,\n      reject\n    })); // start queue\n\n    this.fill(); // await completion\n\n    await execPromise;\n  }\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continously\n   * being added to the peers-to-query queue.\n   */\n\n\n  fill() {\n    // Note:\n    // - queue.running(): number of items that are currently running\n    // - queue.length(): the number of items that are waiting to be run\n    while (this.queue.running() + this.queue.length() < this.concurrency && this.path.peersToQuery.length > 0) {\n      this.queue.push(this.path.peersToQuery.dequeue());\n    }\n  }\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<void>}\n   */\n\n\n  async processNext(peer) {\n    if (!this.running) {\n      return;\n    } // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    } // Check if we've queried enough peers already\n\n\n    let continueQuerying, continueQueryingError;\n\n    try {\n      continueQuerying = await this.run.continueQuerying(this);\n    } catch (err) {\n      continueQueryingError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError;\n    } // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n\n\n    if (!continueQuerying) {\n      this.stop();\n      return;\n    } // Check if another path has queried this peer in the mean time\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    }\n\n    this.run.peersSeen.add(peer.toB58String()); // Execute the query on the next peer\n\n    this.log('queue:work');\n    let state, execError;\n\n    try {\n      state = await this.execQuery(peer);\n    } catch (err) {\n      execError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    this.log('queue:work:done', execError, state);\n\n    if (execError) {\n      throw execError;\n    } // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n\n\n    if (state && state.queryComplete) {\n      this.log('query:complete');\n      this.run.stop();\n      return;\n    } // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n\n\n    if (state && state.pathComplete) {\n      this.stop();\n    }\n  }\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  async execQuery(peer) {\n    let res, queryError;\n\n    try {\n      res = await this.path.queryFunc(peer);\n    } catch (err) {\n      queryError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError);\n      return;\n    } // Add the peer to the closest peers we have successfully queried\n\n\n    await this.run.peersQueried.add(peer); // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res;\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      };\n    } // If there are closer peers to query, add them to the queue\n\n\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      await Promise.all(res.closerPeers.map(async closer => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return;\n        }\n\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs);\n\n        await this.path.addPeerToQuery(closer.id);\n      }));\n    }\n  }\n\n}\n\nmodule.exports = WorkerQueue;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/query/workerQueue.js"],"names":["queue","require","promiseToCallback","WorkerQueue","constructor","dht","run","path","log","concurrency","setupQueue","execution","q","peer","cb","processNext","error","err","stop","drain","unsaturated","running","fill","buffer","kill","workers","filter","w","length","reject","resolve","execute","execPromise","Promise","Object","assign","peersToQuery","push","dequeue","peersSeen","has","toB58String","continueQuerying","continueQueryingError","add","state","execError","execQuery","queryComplete","pathComplete","res","queryError","queryFunc","errors","peersQueried","closerPeers","all","map","closer","_isSelf","id","_peerDiscovered","multiaddrs","addPeerToQuery","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst queue = require('async/queue')\nconst promiseToCallback = require('promise-to-callback')\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {DHT} dht\n   * @param {Run} run\n   * @param {Object} path\n   * @param {function} log\n   */\n  constructor (dht, run, path, log) {\n    this.dht = dht\n    this.run = run\n    this.path = path\n    this.log = log\n\n    this.concurrency = this.dht.concurrency\n    this.queue = this.setupQueue()\n    // a container for resolve/reject functions that will be populated\n    // when execute() is called\n    this.execution = null\n  }\n\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Object}\n   */\n  setupQueue () {\n    const q = queue((peer, cb) => {\n      promiseToCallback(this.processNext(peer))(cb)\n    }, this.concurrency)\n\n    // If there's an error, stop the worker\n    q.error = (err) => {\n      this.log.error('queue', err)\n      this.stop(err)\n    }\n\n    // When all peers in the queue have been processed, stop the worker\n    q.drain = () => {\n      this.log('queue:drain')\n      this.stop()\n    }\n\n    // When a space opens up in the queue, add some more peers\n    q.unsaturated = () => {\n      if (this.running) {\n        this.fill()\n      }\n    }\n\n    q.buffer = 0\n\n    return q\n  }\n\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} err\n   */\n  stop (err) {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    this.queue.kill()\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length)\n    if (err) {\n      this.execution.reject(err)\n    } else {\n      this.execution.resolve()\n    }\n  }\n\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @return {Promise<void>}\n   */\n  async execute () {\n    this.running = true\n    // store the promise resolution functions to be resolved at end of queue\n    this.execution = {}\n    const execPromise = new Promise((resolve, reject) => Object.assign(this.execution, { resolve, reject }))\n    // start queue\n    this.fill()\n    // await completion\n    await execPromise\n  }\n\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continously\n   * being added to the peers-to-query queue.\n   */\n  fill () {\n    // Note:\n    // - queue.running(): number of items that are currently running\n    // - queue.length(): the number of items that are waiting to be run\n    while (this.queue.running() + this.queue.length() < this.concurrency &&\n           this.path.peersToQuery.length > 0) {\n      this.queue.push(this.path.peersToQuery.dequeue())\n    }\n  }\n\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<void>}\n   */\n  async processNext (peer) {\n    if (!this.running) {\n      return\n    }\n\n    // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n\n    // Check if we've queried enough peers already\n    let continueQuerying, continueQueryingError\n    try {\n      continueQuerying = await this.run.continueQuerying(this)\n    } catch (err) {\n      continueQueryingError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError\n    }\n\n    // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n    if (!continueQuerying) {\n      this.stop()\n      return\n    }\n\n    // Check if another path has queried this peer in the mean time\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return\n    }\n    this.run.peersSeen.add(peer.toB58String())\n\n    // Execute the query on the next peer\n    this.log('queue:work')\n    let state, execError\n    try {\n      state = await this.execQuery(peer)\n    } catch (err) {\n      execError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    this.log('queue:work:done', execError, state)\n\n    if (execError) {\n      throw execError\n    }\n\n    // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n    if (state && state.queryComplete) {\n      this.log('query:complete')\n      this.run.stop()\n      return\n    }\n\n    // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n    if (state && state.pathComplete) {\n      this.stop()\n    }\n  }\n\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<void>}\n   * @private\n   */\n  async execQuery (peer) {\n    let res, queryError\n    try {\n      res = await this.path.queryFunc(peer)\n    } catch (err) {\n      queryError = err\n    }\n\n    // Abort and ignore any error if we're no longer running\n    if (!this.running) {\n      return\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError)\n      return\n    }\n\n    // Add the peer to the closest peers we have successfully queried\n    await this.run.peersQueried.add(peer)\n\n    // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      }\n    }\n\n    // If there are closer peers to query, add them to the queue\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      await Promise.all(res.closerPeers.map(async (closer) => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return\n        }\n        this.dht._peerDiscovered(closer.id, closer.multiaddrs)\n        await this.path.addPeerToQuery(closer.id)\n      }))\n    }\n  }\n}\n\nmodule.exports = WorkerQueue\n"]},"metadata":{},"sourceType":"script"}