{"ast":null,"code":"'use strict';\n\nconst BufferList = require('bl/BufferList');\n\nconst {\n  InvalidCryptoTransmissionError\n} = require('libp2p-interfaces/src/crypto/errors');\n\nexports.createBoxStream = (cipher, mac) => {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const data = await cipher.encrypt(BufferList.isBufferList(chunk) ? chunk.slice() : chunk);\n      const digest = await mac.digest(data);\n      yield new BufferList([data, digest]);\n    }\n  };\n};\n\nexports.createUnboxStream = (decipher, mac) => {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const l = chunk.length;\n      const macSize = mac.length;\n\n      if (l < macSize) {\n        throw new InvalidCryptoTransmissionError(`buffer (${l}) shorter than MAC size (${macSize})`);\n      }\n\n      const mark = l - macSize;\n      const data = chunk.slice(0, mark);\n      const macd = chunk.slice(mark);\n      const expected = await mac.digest(data);\n\n      if (!macd.equals(expected)) {\n        throw new InvalidCryptoTransmissionError(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`);\n      }\n\n      const decrypted = await decipher.decrypt(data);\n      yield decrypted;\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-secio/src/etm.js"],"names":["BufferList","require","InvalidCryptoTransmissionError","exports","createBoxStream","cipher","mac","source","chunk","data","encrypt","isBufferList","slice","digest","createUnboxStream","decipher","l","length","macSize","mark","macd","expected","equals","toString","decrypted","decrypt"],"mappings":"AAAA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAqCD,OAAO,CAAC,qCAAD,CAAlD;;AAEAE,OAAO,CAACC,eAAR,GAA0B,CAACC,MAAD,EAASC,GAAT,KAAiB;AACzC,SAAO,iBAAkBC,MAAlB,EAA0B;AAC/B,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC,YAAME,IAAI,GAAG,MAAMJ,MAAM,CAACK,OAAP,CAAeV,UAAU,CAACW,YAAX,CAAwBH,KAAxB,IAAiCA,KAAK,CAACI,KAAN,EAAjC,GAAiDJ,KAAhE,CAAnB;AACA,YAAMK,MAAM,GAAG,MAAMP,GAAG,CAACO,MAAJ,CAAWJ,IAAX,CAArB;AACA,YAAM,IAAIT,UAAJ,CAAe,CAACS,IAAD,EAAOI,MAAP,CAAf,CAAN;AACD;AACF,GAND;AAOD,CARD;;AAUAV,OAAO,CAACW,iBAAR,GAA4B,CAACC,QAAD,EAAWT,GAAX,KAAmB;AAC7C,SAAO,iBAAkBC,MAAlB,EAA0B;AAC/B,eAAW,MAAMC,KAAjB,IAA0BD,MAA1B,EAAkC;AAChC,YAAMS,CAAC,GAAGR,KAAK,CAACS,MAAhB;AACA,YAAMC,OAAO,GAAGZ,GAAG,CAACW,MAApB;;AAEA,UAAID,CAAC,GAAGE,OAAR,EAAiB;AACf,cAAM,IAAIhB,8BAAJ,CAAoC,WAAUc,CAAE,4BAA2BE,OAAQ,GAAnF,CAAN;AACD;;AAED,YAAMC,IAAI,GAAGH,CAAC,GAAGE,OAAjB;AACA,YAAMT,IAAI,GAAGD,KAAK,CAACI,KAAN,CAAY,CAAZ,EAAeO,IAAf,CAAb;AACA,YAAMC,IAAI,GAAGZ,KAAK,CAACI,KAAN,CAAYO,IAAZ,CAAb;AAEA,YAAME,QAAQ,GAAG,MAAMf,GAAG,CAACO,MAAJ,CAAWJ,IAAX,CAAvB;;AAEA,UAAI,CAACW,IAAI,CAACE,MAAL,CAAYD,QAAZ,CAAL,EAA4B;AAC1B,cAAM,IAAInB,8BAAJ,CAAoC,gBAAekB,IAAI,CAACG,QAAL,CAAc,KAAd,CAAqB,OAAMF,QAAQ,CAACE,QAAT,CAAkB,KAAlB,CAAyB,EAAvG,CAAN;AACD;;AAED,YAAMC,SAAS,GAAG,MAAMT,QAAQ,CAACU,OAAT,CAAiBhB,IAAjB,CAAxB;AAEA,YAAMe,SAAN;AACD;AACF,GAvBD;AAwBD,CAzBD","sourcesContent":["'use strict'\n\nconst BufferList = require('bl/BufferList')\nconst { InvalidCryptoTransmissionError } = require('libp2p-interfaces/src/crypto/errors')\n\nexports.createBoxStream = (cipher, mac) => {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const data = await cipher.encrypt(BufferList.isBufferList(chunk) ? chunk.slice() : chunk)\n      const digest = await mac.digest(data)\n      yield new BufferList([data, digest])\n    }\n  }\n}\n\nexports.createUnboxStream = (decipher, mac) => {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const l = chunk.length\n      const macSize = mac.length\n\n      if (l < macSize) {\n        throw new InvalidCryptoTransmissionError(`buffer (${l}) shorter than MAC size (${macSize})`)\n      }\n\n      const mark = l - macSize\n      const data = chunk.slice(0, mark)\n      const macd = chunk.slice(mark)\n\n      const expected = await mac.digest(data)\n\n      if (!macd.equals(expected)) {\n        throw new InvalidCryptoTransmissionError(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`)\n      }\n\n      const decrypted = await decipher.decrypt(data)\n\n      yield decrypted\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}