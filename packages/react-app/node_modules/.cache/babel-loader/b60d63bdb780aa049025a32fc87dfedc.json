{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst sha = require('multihashing-async/src/sha');\n\nconst protobuf = require('protons');\n\nconst multibase = require('multibase');\n\nconst errcode = require('err-code');\n\nconst crypto = require('./ed25519');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nclass Ed25519PublicKey {\n  constructor(key) {\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return Buffer.from(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor(key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    return new Ed25519PublicKey(this._publicKey);\n  }\n\n  marshal() {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)]);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return multibase.encode('base58btc', hash).toString().slice(1);\n  }\n\n}\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nasync function generateKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKey();\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nasync function generateKeyPairFromSeed(seed) {\n  const {\n    privateKey,\n    publicKey\n  } = await crypto.generateKeyFromSeed(seed);\n  return new Ed25519PrivateKey(privateKey, publicKey);\n}\n\nfunction ensureKey(key, length) {\n  if (Buffer.isBuffer(key)) {\n    key = new Uint8Array(key);\n  }\n\n  if (!(key instanceof Uint8Array) || key.length !== length) {\n    throw errcode(new Error('Key must be a Uint8Array or Buffer of length ' + length), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"names":["Buffer","require","sha","protobuf","multibase","errcode","crypto","pbm","Ed25519PublicKey","constructor","key","_key","ensureKey","publicKeyLength","verify","data","sig","hashAndVerify","marshal","from","bytes","PublicKey","encode","Type","KeyType","Ed25519","Data","equals","hash","multihashing","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","sign","message","hashAndSign","public","concat","PrivateKey","id","toString","slice","unmarshalEd25519PrivateKey","privateKeyBytes","publicKeyBytes","length","unmarshalEd25519PublicKey","generateKeyPair","privateKey","generateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","isBuffer","Uint8Array","Error","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,4BAAD,CAAnB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,SAAD,CAAxB;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAMK,MAAM,GAAGL,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMM,GAAG,GAAGJ,QAAQ,CAACF,OAAO,CAAC,cAAD,CAAR,CAApB;;AAEA,MAAMO,gBAAN,CAAuB;AACrBC,EAAAA,WAAW,CAAEC,GAAF,EAAO;AAChB,SAAKC,IAAL,GAAYC,SAAS,CAACF,GAAD,EAAMJ,MAAM,CAACO,eAAb,CAArB;AACD;;AAED,QAAMC,MAAN,CAAcC,IAAd,EAAoBC,GAApB,EAAyB;AAAE;AACzB,WAAOV,MAAM,CAACW,aAAP,CAAqB,KAAKN,IAA1B,EAAgCK,GAAhC,EAAqCD,IAArC,CAAP;AACD;;AAEDG,EAAAA,OAAO,GAAI;AACT,WAAOlB,MAAM,CAACmB,IAAP,CAAY,KAAKR,IAAjB,CAAP;AACD;;AAED,MAAIS,KAAJ,GAAa;AACX,WAAOb,GAAG,CAACc,SAAJ,CAAcC,MAAd,CAAqB;AAC1BC,MAAAA,IAAI,EAAEhB,GAAG,CAACiB,OAAJ,CAAYC,OADQ;AAE1BC,MAAAA,IAAI,EAAE,KAAKR,OAAL;AAFoB,KAArB,CAAP;AAID;;AAEDS,EAAAA,MAAM,CAAEjB,GAAF,EAAO;AACX,WAAO,KAAKU,KAAL,CAAWO,MAAX,CAAkBjB,GAAG,CAACU,KAAtB,CAAP;AACD;;AAED,QAAMQ,IAAN,GAAc;AAAE;AACd,WAAO1B,GAAG,CAAC2B,YAAJ,CAAiB,KAAKT,KAAtB,EAA6B,UAA7B,CAAP;AACD;;AA1BoB;;AA6BvB,MAAMU,iBAAN,CAAwB;AACtB;AACA;AACArB,EAAAA,WAAW,CAAEC,GAAF,EAAOqB,SAAP,EAAkB;AAC3B,SAAKpB,IAAL,GAAYC,SAAS,CAACF,GAAD,EAAMJ,MAAM,CAAC0B,gBAAb,CAArB;AACA,SAAKC,UAAL,GAAkBrB,SAAS,CAACmB,SAAD,EAAYzB,MAAM,CAACO,eAAnB,CAA3B;AACD;;AAED,QAAMqB,IAAN,CAAYC,OAAZ,EAAqB;AAAE;AACrB,WAAO7B,MAAM,CAAC8B,WAAP,CAAmB,KAAKzB,IAAxB,EAA8BwB,OAA9B,CAAP;AACD;;AAED,MAAIE,MAAJ,GAAc;AACZ,WAAO,IAAI7B,gBAAJ,CAAqB,KAAKyB,UAA1B,CAAP;AACD;;AAEDf,EAAAA,OAAO,GAAI;AACT,WAAOlB,MAAM,CAACsC,MAAP,CAAc,CAACtC,MAAM,CAACmB,IAAP,CAAY,KAAKR,IAAjB,CAAD,EAAyBX,MAAM,CAACmB,IAAP,CAAY,KAAKc,UAAjB,CAAzB,CAAd,CAAP;AACD;;AAED,MAAIb,KAAJ,GAAa;AACX,WAAOb,GAAG,CAACgC,UAAJ,CAAejB,MAAf,CAAsB;AAC3BC,MAAAA,IAAI,EAAEhB,GAAG,CAACiB,OAAJ,CAAYC,OADS;AAE3BC,MAAAA,IAAI,EAAE,KAAKR,OAAL;AAFqB,KAAtB,CAAP;AAID;;AAEDS,EAAAA,MAAM,CAAEjB,GAAF,EAAO;AACX,WAAO,KAAKU,KAAL,CAAWO,MAAX,CAAkBjB,GAAG,CAACU,KAAtB,CAAP;AACD;;AAED,QAAMQ,IAAN,GAAc;AAAE;AACd,WAAO1B,GAAG,CAAC2B,YAAJ,CAAiB,KAAKT,KAAtB,EAA6B,UAA7B,CAAP;AACD;AAED;;;;;;;;;;;AASA,QAAMoB,EAAN,GAAY;AACV,UAAMZ,IAAI,GAAG,MAAM,KAAKS,MAAL,CAAYT,IAAZ,EAAnB;AACA,WAAOxB,SAAS,CAACkB,MAAV,CAAiB,WAAjB,EAA8BM,IAA9B,EAAoCa,QAApC,GAA+CC,KAA/C,CAAqD,CAArD,CAAP;AACD;;AA/CqB;;AAkDxB,SAASC,0BAAT,CAAqCvB,KAArC,EAA4C;AAC1CA,EAAAA,KAAK,GAAGR,SAAS,CAACQ,KAAD,EAAQd,MAAM,CAAC0B,gBAAP,GAA0B1B,MAAM,CAACO,eAAzC,CAAjB;AACA,QAAM+B,eAAe,GAAGxB,KAAK,CAACsB,KAAN,CAAY,CAAZ,EAAepC,MAAM,CAAC0B,gBAAtB,CAAxB;AACA,QAAMa,cAAc,GAAGzB,KAAK,CAACsB,KAAN,CAAYpC,MAAM,CAAC0B,gBAAnB,EAAqCZ,KAAK,CAAC0B,MAA3C,CAAvB;AACA,SAAO,IAAIhB,iBAAJ,CAAsBc,eAAtB,EAAuCC,cAAvC,CAAP;AACD;;AAED,SAASE,yBAAT,CAAoC3B,KAApC,EAA2C;AACzCA,EAAAA,KAAK,GAAGR,SAAS,CAACQ,KAAD,EAAQd,MAAM,CAACO,eAAf,CAAjB;AACA,SAAO,IAAIL,gBAAJ,CAAqBY,KAArB,CAAP;AACD;;AAED,eAAe4B,eAAf,GAAkC;AAChC,QAAM;AAAEC,IAAAA,UAAF;AAAclB,IAAAA;AAAd,MAA4B,MAAMzB,MAAM,CAAC4C,WAAP,EAAxC;AACA,SAAO,IAAIpB,iBAAJ,CAAsBmB,UAAtB,EAAkClB,SAAlC,CAAP;AACD;;AAED,eAAeoB,uBAAf,CAAwCC,IAAxC,EAA8C;AAC5C,QAAM;AAAEH,IAAAA,UAAF;AAAclB,IAAAA;AAAd,MAA4B,MAAMzB,MAAM,CAAC+C,mBAAP,CAA2BD,IAA3B,CAAxC;AACA,SAAO,IAAItB,iBAAJ,CAAsBmB,UAAtB,EAAkClB,SAAlC,CAAP;AACD;;AAED,SAASnB,SAAT,CAAoBF,GAApB,EAAyBoC,MAAzB,EAAiC;AAC/B,MAAI9C,MAAM,CAACsD,QAAP,CAAgB5C,GAAhB,CAAJ,EAA0B;AACxBA,IAAAA,GAAG,GAAG,IAAI6C,UAAJ,CAAe7C,GAAf,CAAN;AACD;;AACD,MAAI,EAAEA,GAAG,YAAY6C,UAAjB,KAAgC7C,GAAG,CAACoC,MAAJ,KAAeA,MAAnD,EAA2D;AACzD,UAAMzC,OAAO,CAAC,IAAImD,KAAJ,CAAU,kDAAkDV,MAA5D,CAAD,EAAsE,sBAAtE,CAAb;AACD;;AACD,SAAOpC,GAAP;AACD;;AAED+C,MAAM,CAACC,OAAP,GAAiB;AACflD,EAAAA,gBADe;AAEfsB,EAAAA,iBAFe;AAGfa,EAAAA,0BAHe;AAIfI,EAAAA,yBAJe;AAKfC,EAAAA,eALe;AAMfG,EAAAA;AANe,CAAjB","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst sha = require('multihashing-async/src/sha')\nconst protobuf = require('protons')\nconst multibase = require('multibase')\nconst errcode = require('err-code')\n\nconst crypto = require('./ed25519')\nconst pbm = protobuf(require('./keys.proto'))\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return Buffer.from(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)])\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return multibase.encode('base58btc', hash).toString().slice(1)\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes) {\n  bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nasync function generateKeyPair () {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nasync function generateKeyPairFromSeed (seed) {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key, length) {\n  if (Buffer.isBuffer(key)) {\n    key = new Uint8Array(key)\n  }\n  if (!(key instanceof Uint8Array) || key.length !== length) {\n    throw errcode(new Error('Key must be a Uint8Array or Buffer of length ' + length), 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"]},"metadata":{},"sourceType":"script"}