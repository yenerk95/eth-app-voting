{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst CID = require('cids');\n\nconst isDomain = require('is-domain-name');\n\nconst log = debug('ipfs:name:resolve');\nlog.error = debug('ipfs:name:resolve:error');\n\nconst {\n  OFFLINE_ERROR,\n  withTimeoutOption\n} = require('../../utils');\n\nconst appendRemainder = async (result, remainder) => {\n  result = await result;\n\n  if (remainder.length) {\n    return result + '/' + remainder.join('/');\n  }\n\n  return result;\n};\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = ({\n  dns,\n  ipns,\n  peerId,\n  isOnline,\n  options: constructorOptions\n}) => {\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n   * @param {Object} options ipfs resolve options.\n   * @param {boolean} options.nocache do not use cached entries.\n   * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n   * @param {function(Error)} [callback]\n   * @returns {Promise|void}\n   */\n  return withTimeoutOption(async function* resolve(name, options) {\n    // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options || {});\n    const {\n      offline\n    } = constructorOptions; // TODO: params related logic should be in the core implementation\n\n    if (offline && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n    } // Set node id as name for being resolved, if it is not received\n\n\n    if (!name) {\n      name = peerId.toB58String();\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`;\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/');\n\n    try {\n      new CID(hash); // eslint-disable-line no-new\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(dns(hash, options), remainder);\n        return;\n      }\n\n      log.error(err);\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n    } // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n\n\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: convert ipns.resolve to return an iterator\n\n\n    yield appendRemainder(ipns.resolve(`/${namespace}/${hash}`, options), remainder);\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/name/resolve.js"],"names":["debug","require","errcode","mergeOptions","CID","isDomain","log","error","OFFLINE_ERROR","withTimeoutOption","appendRemainder","result","remainder","length","join","module","exports","dns","ipns","peerId","isOnline","options","constructorOptions","resolve","name","nocache","recursive","offline","Error","toB58String","startsWith","namespace","hash","slice","split","err"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst CID = require('cids')\nconst isDomain = require('is-domain-name')\n\nconst log = debug('ipfs:name:resolve')\nlog.error = debug('ipfs:name:resolve:error')\n\nconst { OFFLINE_ERROR, withTimeoutOption } = require('../../utils')\n\nconst appendRemainder = async (result, remainder) => {\n  result = await result\n\n  if (remainder.length) {\n    return result + '/' + remainder.join('/')\n  }\n\n  return result\n}\n\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\nmodule.exports = ({ dns, ipns, peerId, isOnline, options: constructorOptions }) => {\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n   * @param {Object} options ipfs resolve options.\n   * @param {boolean} options.nocache do not use cached entries.\n   * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n   * @param {function(Error)} [callback]\n   * @returns {Promise|void}\n   */\n  return withTimeoutOption(async function * resolve (name, options) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options || {})\n\n    const { offline } = constructorOptions\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // Set node id as name for being resolved, if it is not received\n    if (!name) {\n      name = peerId.toB58String()\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/')\n    try {\n      new CID(hash) // eslint-disable-line no-new\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: convert ipns.resolve to return an iterator\n    yield appendRemainder(ipns.resolve(`/${namespace}/${hash}`, options), remainder)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}