{"ast":null,"code":"'use strict';\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst log = require('debug')('ipfs:mfs:stat');\n\nconst errCode = require('err-code');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  withLocal: false,\n  signal: undefined\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsStat(path, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n    log(`Fetching stats for ${path}`);\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path, options);\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n    let file;\n\n    try {\n      file = await exporter(exportPath, context.ipld);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n      }\n\n      throw err;\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(`Cannot stat codec ${file.cid.codec}`);\n    }\n\n    return statters[file.cid.codec](file, options);\n  });\n};\n\nconst statters = {\n  raw: file => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-pb': file => {\n    const blocks = file.node.Links.length;\n    const size = file.node.size;\n    const cumulativeSize = file.node.size;\n    const output = {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n\n    if (file.unixfs) {\n      output.size = file.unixfs.fileSize(); // for go-ipfs compatibility\n\n      if (file.unixfs.type === 'hamt-sharded-directory') {\n        output.type = 'directory';\n      } else {\n        output.type = file.unixfs.type;\n      }\n\n      output.mode = file.unixfs.mode;\n\n      if (file.unixfs.isDirectory()) {\n        output.size = 0;\n        output.cumulativeSize = file.node.size;\n      }\n\n      if (output.type === 'file') {\n        output.blocks = file.unixfs.blockSizes.length;\n      }\n\n      if (file.unixfs.mtime) {\n        output.mtime = file.unixfs.mtime;\n      }\n    }\n\n    return output;\n  },\n  'dag-cbor': file => {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  identity: file => {\n    return {\n      cid: file.cid,\n      size: file.node.digest.length,\n      cumulativeSize: file.node.digest.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/stat.js"],"names":["applyDefaultOptions","require","toMfsPath","exporter","log","errCode","withTimeoutOption","defaultOptions","withLocal","signal","undefined","module","exports","context","mfsStat","path","options","type","cid","mfsPath","exportPath","file","ipld","err","code","Error","statters","codec","raw","size","node","length","cumulativeSize","blocks","local","sizeLocal","withLocality","Links","output","unixfs","fileSize","mode","isDirectory","blockSizes","mtime","identity","digest"],"mappings":"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","sourcesContent":["'use strict'\n\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst exporter = require('ipfs-unixfs-exporter')\nconst log = require('debug')('ipfs:mfs:stat')\nconst errCode = require('err-code')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  withLocal: false,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsStat (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path, options)\n\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath\n    let file\n\n    try {\n      file = await exporter(exportPath, context.ipld)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND')\n      }\n\n      throw err\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(`Cannot stat codec ${file.cid.codec}`)\n    }\n\n    return statters[file.cid.codec](file, options)\n  })\n}\n\nconst statters = {\n  raw: (file) => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file', // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  'dag-pb': (file) => {\n    const blocks = file.node.Links.length\n    const size = file.node.size\n    const cumulativeSize = file.node.size\n\n    const output = {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n\n    if (file.unixfs) {\n      output.size = file.unixfs.fileSize()\n\n      // for go-ipfs compatibility\n      if (file.unixfs.type === 'hamt-sharded-directory') {\n        output.type = 'directory'\n      } else {\n        output.type = file.unixfs.type\n      }\n\n      output.mode = file.unixfs.mode\n\n      if (file.unixfs.isDirectory()) {\n        output.size = 0\n        output.cumulativeSize = file.node.size\n      }\n\n      if (output.type === 'file') {\n        output.blocks = file.unixfs.blockSizes.length\n      }\n\n      if (file.unixfs.mtime) {\n        output.mtime = file.unixfs.mtime\n      }\n    }\n\n    return output\n  },\n  'dag-cbor': (file) => {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  },\n  identity: (file) => {\n    return {\n      cid: file.cid,\n      size: file.node.digest.length,\n      cumulativeSize: file.node.digest.length,\n      blocks: 0,\n      type: 'file', // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}