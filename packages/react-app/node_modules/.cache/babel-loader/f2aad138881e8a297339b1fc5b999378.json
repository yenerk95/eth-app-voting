{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar EventEmitter = require('events');\n\nvar multiaddr = require('multiaddr');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:listener');\nlog.err = debug('libp2p:circuit:error:listener');\n/**\n * @param {*} circuit\n * @returns {Listener} a transport listener\n */\n\nmodule.exports = function (circuit) {\n  var listener = new EventEmitter();\n  var listeningAddrs = new Map();\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} addr\n   * @return {void}\n   */\n\n  listener.listen = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(addr) {\n      var addrString, relayConn, relayedAddr;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              addrString = String(addr).split('/p2p-circuit').find(function (a) {\n                return a !== '';\n              });\n              _context.next = 3;\n              return circuit._dialer.connectToPeer(multiaddr(addrString));\n\n            case 3:\n              relayConn = _context.sent;\n              relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit');\n              listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);\n              listener.emit('listening');\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * TODO: Remove the peers from our topology\n   *\n   * @return {void}\n   */\n\n\n  listener.close = function () {};\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @return {Multiaddr[]}\n   */\n\n\n  listener.getAddrs = function () {\n    var addrs = [];\n\n    var _iterator = _createForOfIteratorHelper(listeningAddrs.values()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var addr = _step.value;\n        addrs.push(addr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return addrs;\n  };\n\n  return listener;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/circuit/listener.js"],"names":["EventEmitter","require","multiaddr","debug","log","err","module","exports","circuit","listener","listeningAddrs","Map","listen","addr","addrString","String","split","find","a","_dialer","connectToPeer","relayConn","relayedAddr","remoteAddr","encapsulate","set","remotePeer","toB58String","emit","close","getAddrs","addrs","values","push"],"mappings":"AAAA;;;;;;;;AAEA,IAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAA5B;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAzB;;AAEA,IAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMG,GAAG,GAAGD,KAAK,CAAC,yBAAD,CAAjB;AACAC,GAAG,CAACC,GAAJ,GAAUF,KAAK,CAAC,+BAAD,CAAf;AAEA;;;;;AAIAG,MAAM,CAACC,OAAP,GAAiB,UAACC,OAAD,EAAa;AAC5B,MAAMC,QAAQ,GAAG,IAAIT,YAAJ,EAAjB;AACA,MAAMU,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AAEA;;;;;;;AAMAF,EAAAA,QAAQ,CAACG,MAAT;AAAA,wEAAkB,iBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACVC,cAAAA,UADU,GACGC,MAAM,CAACF,IAAD,CAAN,CAAaG,KAAb,CAAmB,cAAnB,EAAmCC,IAAnC,CAAwC,UAAAC,CAAC;AAAA,uBAAIA,CAAC,KAAK,EAAV;AAAA,eAAzC,CADH;AAAA;AAAA,qBAGQV,OAAO,CAACW,OAAR,CAAgBC,aAAhB,CAA8BlB,SAAS,CAACY,UAAD,CAAvC,CAHR;;AAAA;AAGVO,cAAAA,SAHU;AAIVC,cAAAA,WAJU,GAIID,SAAS,CAACE,UAAV,CAAqBC,WAArB,CAAiC,cAAjC,CAJJ;AAMhBd,cAAAA,cAAc,CAACe,GAAf,CAAmBJ,SAAS,CAACK,UAAV,CAAqBC,WAArB,EAAnB,EAAuDL,WAAvD;AACAb,cAAAA,QAAQ,CAACmB,IAAT,CAAc,WAAd;;AAPgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAlB;;AAAA;AAAA;AAAA;AAAA;AAUA;;;;;;;AAKAnB,EAAAA,QAAQ,CAACoB,KAAT,GAAiB,YAAM,CAAE,CAAzB;AAEA;;;;;;;;;;;;;;;;;;AAgBApB,EAAAA,QAAQ,CAACqB,QAAT,GAAoB,YAAM;AACxB,QAAMC,KAAK,GAAG,EAAd;;AADwB,+CAELrB,cAAc,CAACsB,MAAf,EAFK;AAAA;;AAAA;AAExB,0DAA4C;AAAA,YAAjCnB,IAAiC;AAC1CkB,QAAAA,KAAK,CAACE,IAAN,CAAWpB,IAAX;AACD;AAJuB;AAAA;AAAA;AAAA;AAAA;;AAKxB,WAAOkB,KAAP;AACD,GAND;;AAQA,SAAOtB,QAAP;AACD,CApDD","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst multiaddr = require('multiaddr')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:listener')\nlog.err = debug('libp2p:circuit:error:listener')\n\n/**\n * @param {*} circuit\n * @returns {Listener} a transport listener\n */\nmodule.exports = (circuit) => {\n  const listener = new EventEmitter()\n  const listeningAddrs = new Map()\n\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} addr\n   * @return {void}\n   */\n  listener.listen = async (addr) => {\n    const addrString = String(addr).split('/p2p-circuit').find(a => a !== '')\n\n    const relayConn = await circuit._dialer.connectToPeer(multiaddr(addrString))\n    const relayedAddr = relayConn.remoteAddr.encapsulate('/p2p-circuit')\n\n    listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr)\n    listener.emit('listening')\n  }\n\n  /**\n   * TODO: Remove the peers from our topology\n   *\n   * @return {void}\n   */\n  listener.close = () => {}\n\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @return {Multiaddr[]}\n   */\n  listener.getAddrs = () => {\n    const addrs = []\n    for (const addr of listeningAddrs.values()) {\n      addrs.push(addr)\n    }\n    return addrs\n  }\n\n  return listener\n}\n"]},"metadata":{},"sourceType":"script"}