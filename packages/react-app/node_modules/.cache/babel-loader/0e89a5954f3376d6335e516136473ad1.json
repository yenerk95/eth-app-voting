{"ast":null,"code":"/*!\n * ecdh.js - ECDH for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://cr.yp.to/ecdh.html\n *   https://cr.yp.to/ecdh/curve25519-20060209.pdf\n *   https://tools.ietf.org/html/rfc7748\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst elliptic = require('./elliptic');\n\nconst rng = require('../random');\n\nconst {\n  padRight\n} = require('../encoding/util');\n/**\n * ECDH\n */\n\n\nclass ECDH {\n  constructor(id, eid, pre) {\n    assert(typeof id === 'string');\n    assert(!eid || typeof eid === 'string');\n    this.id = id;\n    this.type = 'ecdh';\n    this.eid = eid || null;\n    this._pre = pre || null;\n    this._curve = null;\n    this._edwards = null;\n    this.native = 0;\n  }\n\n  get curve() {\n    if (!this._curve) this._curve = elliptic.curve(this.id);\n    return this._curve;\n  }\n\n  get edwards() {\n    if (this.eid && !this._edwards) {\n      this._edwards = elliptic.curve(this.eid, this._pre);\n\n      this._edwards.precompute(rng);\n\n      this._pre = null;\n    }\n\n    return this._edwards;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  privateKeyGenerate() {\n    const key = rng.randomBytes(this.curve.scalarSize);\n    return this.curve.clamp(key);\n  }\n\n  privateKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    return key.length === this.curve.scalarSize;\n  }\n\n  privateKeyExport(key, sign) {\n    const pub = this.publicKeyCreate(key);\n    const {\n      x,\n      y\n    } = this.publicKeyExport(pub, sign);\n    return {\n      d: Buffer.from(key),\n      x,\n      y\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n    return padRight(json.d, this.curve.scalarSize);\n  }\n\n  publicKeyCreate(key) {\n    const a = this.curve.decodeScalar(key);\n    const k = this.curve.reduce(a);\n\n    if (this.edwards && this.edwards.g.pre) {\n      const A = this.edwards.g.mulBlind(k);\n      const P = this.curve.pointFromEdwards(A);\n      return P.encode();\n    }\n\n    const G = this.curve.g.toX();\n    const A = G.mulBlind(k, rng);\n    return A.encode();\n  }\n\n  publicKeyConvert(key, sign) {\n    assert(sign == null || typeof sign === 'boolean');\n    if (!this.edwards) throw new Error('No equivalent edwards curve.');\n    const A = this.curve.decodePoint(key);\n    const P = this.edwards.pointFromMont(A);\n\n    if (sign != null) {\n      if (P.isOdd() !== sign) return P.neg().encode();\n    }\n\n    return P.encode();\n  }\n\n  publicKeyFromUniform(bytes) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u);\n    return A.encode();\n  }\n\n  publicKeyToUniform(key, hint = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    const u = this.curve.pointToUniform(A, hint);\n    return this.curve.encodeUniform(u, hint >>> 8);\n  }\n\n  publicKeyFromHash(bytes, pake = false) {\n    const A = this.curve.pointFromHash(bytes, pake);\n    return A.encode();\n  }\n\n  publicKeyToHash(key, subgroup = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    return this.curve.pointToHash(A, subgroup, rng);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.validate();\n  }\n\n  publicKeyIsSmall(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate()) return false;\n    return A.isSmall();\n  }\n\n  publicKeyHasTorsion(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate()) return false;\n    return A.hasTorsion();\n  }\n\n  publicKeyExport(key, sign) {\n    const {\n      x,\n      y\n    } = this.curve.decodePoint(key, sign);\n    return {\n      x: this.curve.encodeField(x.fromRed()),\n      y: this.curve.encodeField(y.fromRed())\n    };\n  }\n\n  publicKeyImport(json) {\n    assert(json && typeof json === 'object');\n    const x = padRight(json.x, this.curve.fieldSize);\n    const A = this.curve.decodeX(x);\n    if (!A.validate()) throw new Error('Invalid point.');\n    return A.encode();\n  }\n\n  derive(pub, priv) {\n    const A = this.curve.decodeX(pub);\n    const a = this.curve.decodeScalar(priv);\n    const k = this.curve.reduce(a);\n    const P = A.mulConst(k, rng);\n    return P.encode();\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = ECDH;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/bcrypto/lib/js/ecdh.js"],"names":["assert","require","elliptic","rng","padRight","ECDH","constructor","id","eid","pre","type","_pre","_curve","_edwards","native","curve","edwards","precompute","size","fieldSize","bits","fieldBits","privateKeyGenerate","key","randomBytes","scalarSize","clamp","privateKeyVerify","Buffer","isBuffer","length","privateKeyExport","sign","pub","publicKeyCreate","x","y","publicKeyExport","d","from","privateKeyImport","json","a","decodeScalar","k","reduce","g","A","mulBlind","P","pointFromEdwards","encode","G","toX","publicKeyConvert","Error","decodePoint","pointFromMont","isOdd","neg","publicKeyFromUniform","bytes","u","decodeUniform","pointFromUniform","publicKeyToUniform","hint","randomInt","pointToUniform","encodeUniform","publicKeyFromHash","pake","pointFromHash","publicKeyToHash","subgroup","pointToHash","publicKeyVerify","decodeX","e","validate","publicKeyIsSmall","isSmall","publicKeyHasTorsion","hasTorsion","encodeField","fromRed","publicKeyImport","derive","priv","mulConst","module","exports"],"mappings":"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","sourcesContent":["/*!\n * ecdh.js - ECDH for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://cr.yp.to/ecdh.html\n *   https://cr.yp.to/ecdh/curve25519-20060209.pdf\n *   https://tools.ietf.org/html/rfc7748\n */\n\n'use strict';\n\nconst assert = require('../internal/assert');\nconst elliptic = require('./elliptic');\nconst rng = require('../random');\nconst {padRight} = require('../encoding/util');\n\n/**\n * ECDH\n */\n\nclass ECDH {\n  constructor(id, eid, pre) {\n    assert(typeof id === 'string');\n    assert(!eid || typeof eid === 'string');\n\n    this.id = id;\n    this.type = 'ecdh';\n    this.eid = eid || null;\n    this._pre = pre || null;\n    this._curve = null;\n    this._edwards = null;\n    this.native = 0;\n  }\n\n  get curve() {\n    if (!this._curve)\n      this._curve = elliptic.curve(this.id);\n    return this._curve;\n  }\n\n  get edwards() {\n    if (this.eid && !this._edwards) {\n      this._edwards = elliptic.curve(this.eid, this._pre);\n      this._edwards.precompute(rng);\n      this._pre = null;\n    }\n    return this._edwards;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  privateKeyGenerate() {\n    const key = rng.randomBytes(this.curve.scalarSize);\n    return this.curve.clamp(key);\n  }\n\n  privateKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    return key.length === this.curve.scalarSize;\n  }\n\n  privateKeyExport(key, sign) {\n    const pub = this.publicKeyCreate(key);\n    const {x, y} = this.publicKeyExport(pub, sign);\n\n    return {\n      d: Buffer.from(key),\n      x,\n      y\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n\n    return padRight(json.d, this.curve.scalarSize);\n  }\n\n  publicKeyCreate(key) {\n    const a = this.curve.decodeScalar(key);\n    const k = this.curve.reduce(a);\n\n    if (this.edwards && this.edwards.g.pre) {\n      const A = this.edwards.g.mulBlind(k);\n      const P = this.curve.pointFromEdwards(A);\n\n      return P.encode();\n    }\n\n    const G = this.curve.g.toX();\n    const A = G.mulBlind(k, rng);\n\n    return A.encode();\n  }\n\n  publicKeyConvert(key, sign) {\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!this.edwards)\n      throw new Error('No equivalent edwards curve.');\n\n    const A = this.curve.decodePoint(key);\n    const P = this.edwards.pointFromMont(A);\n\n    if (sign != null) {\n      if (P.isOdd() !== sign)\n        return P.neg().encode();\n    }\n\n    return P.encode();\n  }\n\n  publicKeyFromUniform(bytes) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u);\n\n    return A.encode();\n  }\n\n  publicKeyToUniform(key, hint = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    const u = this.curve.pointToUniform(A, hint);\n\n    return this.curve.encodeUniform(u, hint >>> 8);\n  }\n\n  publicKeyFromHash(bytes, pake = false) {\n    const A = this.curve.pointFromHash(bytes, pake);\n\n    return A.encode();\n  }\n\n  publicKeyToHash(key, subgroup = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    return this.curve.pointToHash(A, subgroup, rng);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n\n    let A;\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.validate();\n  }\n\n  publicKeyIsSmall(key) {\n    assert(Buffer.isBuffer(key));\n\n    let A;\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate())\n      return false;\n\n    return A.isSmall();\n  }\n\n  publicKeyHasTorsion(key) {\n    assert(Buffer.isBuffer(key));\n\n    let A;\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate())\n      return false;\n\n    return A.hasTorsion();\n  }\n\n  publicKeyExport(key, sign) {\n    const {x, y} = this.curve.decodePoint(key, sign);\n\n    return {\n      x: this.curve.encodeField(x.fromRed()),\n      y: this.curve.encodeField(y.fromRed())\n    };\n  }\n\n  publicKeyImport(json) {\n    assert(json && typeof json === 'object');\n\n    const x = padRight(json.x, this.curve.fieldSize);\n    const A = this.curve.decodeX(x);\n\n    if (!A.validate())\n      throw new Error('Invalid point.');\n\n    return A.encode();\n  }\n\n  derive(pub, priv) {\n    const A = this.curve.decodeX(pub);\n    const a = this.curve.decodeScalar(priv);\n    const k = this.curve.reduce(a);\n    const P = A.mulConst(k, rng);\n\n    return P.encode();\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = ECDH;\n"]},"metadata":{},"sourceType":"script"}