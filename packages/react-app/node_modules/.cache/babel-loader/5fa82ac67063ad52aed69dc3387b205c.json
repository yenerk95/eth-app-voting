{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _ReadHandlers;\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar BufferList = require('bl/BufferList');\n\nvar varintDecode = require('./varint-decode'); // Maximum length of the length section of the message\n\n\nvar MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nvar MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar Empty = Buffer.alloc(0);\nvar ReadModes = {\n  LENGTH: 'readLength',\n  DATA: 'readData'\n};\nvar ReadHandlers = (_ReadHandlers = {}, _defineProperty(_ReadHandlers, ReadModes.LENGTH, function (chunk, buffer, state, options) {\n  // console.log(ReadModes.LENGTH, chunk.length)\n  buffer = buffer.append(chunk);\n  var dataLength;\n\n  try {\n    dataLength = options.lengthDecoder(buffer);\n  } catch (err) {\n    if (buffer.length > options.maxLengthLength) {\n      throw Object.assign(err, {\n        message: 'message length too long',\n        code: 'ERR_MSG_LENGTH_TOO_LONG'\n      });\n    }\n\n    if (err instanceof RangeError) {\n      return {\n        mode: ReadModes.LENGTH,\n        buffer: buffer\n      };\n    }\n\n    throw err;\n  }\n\n  if (dataLength > options.maxDataLength) {\n    throw Object.assign(new Error('message data too long'), {\n      code: 'ERR_MSG_DATA_TOO_LONG'\n    });\n  }\n\n  chunk = buffer.shallowSlice(options.lengthDecoder.bytes);\n  buffer = new BufferList();\n  if (options.onLength) options.onLength(dataLength);\n\n  if (dataLength <= 0) {\n    if (options.onData) options.onData(Empty);\n    return {\n      mode: ReadModes.LENGTH,\n      chunk: chunk,\n      buffer: buffer,\n      data: Empty\n    };\n  }\n\n  return {\n    mode: ReadModes.DATA,\n    chunk: chunk,\n    buffer: buffer,\n    state: {\n      dataLength: dataLength\n    }\n  };\n}), _defineProperty(_ReadHandlers, ReadModes.DATA, function (chunk, buffer, state, options) {\n  // console.log(ReadModes.DATA, chunk.length)\n  buffer = buffer.append(chunk);\n\n  if (buffer.length < state.dataLength) {\n    return {\n      mode: ReadModes.DATA,\n      buffer: buffer,\n      state: state\n    };\n  }\n\n  var dataLength = state.dataLength;\n  var data = buffer.shallowSlice(0, dataLength);\n  chunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : null;\n  buffer = new BufferList();\n  if (options.onData) options.onData(data);\n  return {\n    mode: ReadModes.LENGTH,\n    chunk: chunk,\n    buffer: buffer,\n    data: data\n  };\n}), _ReadHandlers);\n\nfunction decode(options) {\n  options = options || {};\n  options.lengthDecoder = options.lengthDecoder || varintDecode;\n  options.maxLengthLength = options.maxLengthLength || MAX_LENGTH_LENGTH;\n  options.maxDataLength = options.maxDataLength || MAX_DATA_LENGTH;\n  return function (source) {\n    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var buffer, mode, state, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, result;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              buffer = new BufferList();\n              mode = ReadModes.LENGTH; // current parsing mode\n\n              // accumulated state for the current mode\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 4;\n              _iterator = _asyncIterator(source);\n\n            case 6:\n              _context.next = 8;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 8:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 12;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 12:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 29;\n                break;\n              }\n\n              chunk = _value;\n\n            case 15:\n              if (!chunk) {\n                _context.next = 26;\n                break;\n              }\n\n              result = ReadHandlers[mode](chunk, buffer, state, options);\n              mode = result.mode;\n              chunk = result.chunk;\n              buffer = result.buffer;\n              state = result.state;\n\n              if (!result.data) {\n                _context.next = 24;\n                break;\n              }\n\n              _context.next = 24;\n              return result.data;\n\n            case 24:\n              _context.next = 15;\n              break;\n\n            case 26:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n\n            case 29:\n              _context.next = 35;\n              break;\n\n            case 31:\n              _context.prev = 31;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 35:\n              _context.prev = 35;\n              _context.prev = 36;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 40;\n                break;\n              }\n\n              _context.next = 40;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 40:\n              _context.prev = 40;\n\n              if (!_didIteratorError) {\n                _context.next = 43;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 43:\n              return _context.finish(40);\n\n            case 44:\n              return _context.finish(35);\n\n            case 45:\n              if (!buffer.length) {\n                _context.next = 47;\n                break;\n              }\n\n              throw Object.assign(new Error('unexpected end of input'), {\n                code: 'ERR_UNEXPECTED_EOF'\n              });\n\n            case 47:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 31, 35, 45], [36,, 40, 44]]);\n    }))();\n  };\n}\n\ndecode.fromReader = function (reader, options) {\n  var _varByteSource;\n\n  options = options || {};\n  var byteLength = 1; // Read single byte chunks until the length is known\n\n  var varByteSource = (_varByteSource = {}, _defineProperty(_varByteSource, Symbol.asyncIterator, function () {\n    return this;\n  }), _defineProperty(_varByteSource, \"next\", function () {\n    var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return reader.next(byteLength);\n\n            case 3:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](0);\n\n              if (!(_context2.t0.code === 'ERR_UNDER_READ')) {\n                _context2.next = 10;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                done: true,\n                value: null\n              });\n\n            case 10:\n              throw _context2.t0;\n\n            case 11:\n              _context2.prev = 11;\n              // Reset the byteLength so we continue to check for varints\n              byteLength = 1;\n              return _context2.finish(11);\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 6, 11, 14]]);\n    }));\n\n    function next() {\n      return _next.apply(this, arguments);\n    }\n\n    return next;\n  }()), _varByteSource); // Once the length has been parsed, read chunk for that length\n\n  options.onLength = function (l) {\n    byteLength = l;\n  };\n\n  return decode(options)(varByteSource);\n};\n\nmodule.exports = decode;\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/it-length-prefixed/src/decode.js"],"names":["require","Buffer","BufferList","varintDecode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","Empty","alloc","ReadModes","LENGTH","DATA","ReadHandlers","chunk","buffer","state","options","append","dataLength","lengthDecoder","err","length","maxLengthLength","Object","assign","message","code","RangeError","mode","maxDataLength","Error","shallowSlice","bytes","onLength","onData","data","decode","source","result","fromReader","reader","byteLength","varByteSource","Symbol","asyncIterator","next","done","value","l","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst BufferList = require('bl/BufferList')\nconst varintDecode = require('./varint-decode')\n\n// Maximum length of the length section of the message\nconst MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nconst Empty = Buffer.alloc(0)\nconst ReadModes = { LENGTH: 'readLength', DATA: 'readData' }\n\nconst ReadHandlers = {\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk)\n\n    let dataLength\n    try {\n      dataLength = options.lengthDecoder(buffer)\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })\n      }\n      if (err instanceof RangeError) {\n        return { mode: ReadModes.LENGTH, buffer }\n      }\n      throw err\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes)\n    buffer = new BufferList()\n\n    if (options.onLength) options.onLength(dataLength)\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty)\n      return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty }\n    }\n\n    return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength } }\n  },\n\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk)\n\n    if (buffer.length < state.dataLength) {\n      return { mode: ReadModes.DATA, buffer, state }\n    }\n\n    const { dataLength } = state\n    const data = buffer.shallowSlice(0, dataLength)\n\n    chunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : null\n    buffer = new BufferList()\n\n    if (options.onData) options.onData(data)\n    return { mode: ReadModes.LENGTH, chunk, buffer, data }\n  }\n}\n\nfunction decode (options) {\n  options = options || {}\n  options.lengthDecoder = options.lengthDecoder || varintDecode\n  options.maxLengthLength = options.maxLengthLength || MAX_LENGTH_LENGTH\n  options.maxDataLength = options.maxDataLength || MAX_DATA_LENGTH\n\n  return source => (async function * () {\n    let buffer = new BufferList()\n    let mode = ReadModes.LENGTH // current parsing mode\n    let state // accumulated state for the current mode\n\n    for await (let chunk of source) {\n      // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n      while (chunk) {\n        const result = ReadHandlers[mode](chunk, buffer, state, options)\n        ;({ mode, chunk, buffer, state } = result)\n        if (result.data) yield result.data\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })\n    }\n  })()\n}\n\ndecode.fromReader = (reader, options) => {\n  options = options || {}\n\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = {\n    [Symbol.asyncIterator] () { return this },\n    next: async () => {\n      try {\n        return await reader.next(byteLength)\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  options.onLength = l => { byteLength = l }\n  return decode(options)(varByteSource)\n}\n\nmodule.exports = decode\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH\n"]},"metadata":{},"sourceType":"script"}