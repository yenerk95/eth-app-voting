{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst webcrypto = require('../webcrypto');\n\nconst {\n  bufferToBase64url,\n  base64urlToBuffer\n} = require('../util');\n\nconst validateCurveType = require('./validate-curve-type');\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\n\nexports.generateEphmeralKeyPair = async function (curve) {\n  validateCurveType(Object.keys(bits), curve);\n  const pair = await webcrypto.get().subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']); // forcePrivate is used for testing only\n\n  const genSharedKey = async (theirPub, forcePrivate) => {\n    let privateKey;\n\n    if (forcePrivate) {\n      privateKey = await webcrypto.get().subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, ['deriveBits']);\n    } else {\n      privateKey = pair.privateKey;\n    }\n\n    const keys = [await webcrypto.get().subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n      name: 'ECDH',\n      namedCurve: curve\n    }, false, []), privateKey];\n    return Buffer.from(await webcrypto.get().subtle.deriveBits({\n      name: 'ECDH',\n      namedCurve: curve,\n      public: keys[0]\n    }, keys[1], bits[curve]));\n  };\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey);\n  return {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  };\n};\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}; // Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\n\nfunction marshalPublicKey(jwk) {\n  const byteLen = curveLengths[jwk.crv];\n  return Buffer.concat([Buffer.from([4]), // uncompressed point\n  base64urlToBuffer(jwk.x, byteLen), base64urlToBuffer(jwk.y, byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  const byteLen = curveLengths[curve];\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT');\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: bufferToBase64url(key.slice(1, byteLen + 1), byteLen),\n    y: bufferToBase64url(key.slice(1 + byteLen), byteLen),\n    ext: true\n  };\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({ ...unmarshalPublicKey(curve, key.public),\n  d: bufferToBase64url(key.private)\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"],"names":["errcode","require","Buffer","webcrypto","bufferToBase64url","base64urlToBuffer","validateCurveType","bits","exports","generateEphmeralKeyPair","curve","Object","keys","pair","get","subtle","generateKey","name","namedCurve","genSharedKey","theirPub","forcePrivate","privateKey","importKey","unmarshalPrivateKey","unmarshalPublicKey","from","deriveBits","public","publicKey","exportKey","key","marshalPublicKey","curveLengths","jwk","byteLen","crv","concat","x","y","slice","equals","Error","kty","ext","d","private"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst { Buffer } = require('buffer')\nconst webcrypto = require('../webcrypto')\nconst { bufferToBase64url, base64urlToBuffer } = require('../util')\nconst validateCurveType = require('./validate-curve-type')\n\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n}\n\nexports.generateEphmeralKeyPair = async function (curve) {\n  validateCurveType(Object.keys(bits), curve)\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: curve\n    },\n    true,\n    ['deriveBits']\n  )\n\n  // forcePrivate is used for testing only\n  const genSharedKey = async (theirPub, forcePrivate) => {\n    let privateKey\n\n    if (forcePrivate) {\n      privateKey = await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPrivateKey(curve, forcePrivate),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        ['deriveBits']\n      )\n    } else {\n      privateKey = pair.privateKey\n    }\n\n    const keys = [\n      await webcrypto.get().subtle.importKey(\n        'jwk',\n        unmarshalPublicKey(curve, theirPub),\n        {\n          name: 'ECDH',\n          namedCurve: curve\n        },\n        false,\n        []\n      ),\n      privateKey\n    ]\n\n    return Buffer.from(await webcrypto.get().subtle.deriveBits(\n      {\n        name: 'ECDH',\n        namedCurve: curve,\n        public: keys[0]\n      },\n      keys[1],\n      bits[curve]\n    ))\n  }\n\n  const publicKey = await webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n\n  return {\n    key: marshalPublicKey(publicKey),\n    genSharedKey\n  }\n}\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66\n}\n\n// Marshal converts a jwk encodec ECDH public key into the\n// form specified in section 4.3.6 of ANSI X9.62. (This is the format\n// go-ipfs uses)\nfunction marshalPublicKey (jwk) {\n  const byteLen = curveLengths[jwk.crv]\n\n  return Buffer.concat([\n    Buffer.from([4]), // uncompressed point\n    base64urlToBuffer(jwk.x, byteLen),\n    base64urlToBuffer(jwk.y, byteLen)\n  ], 1 + byteLen * 2)\n}\n\n// Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\nfunction unmarshalPublicKey (curve, key) {\n  const byteLen = curveLengths[curve]\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw errcode(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT')\n  }\n\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: bufferToBase64url(key.slice(1, byteLen + 1), byteLen),\n    y: bufferToBase64url(key.slice(1 + byteLen), byteLen),\n    ext: true\n  }\n}\n\nconst unmarshalPrivateKey = (curve, key) => ({\n  ...unmarshalPublicKey(curve, key.public),\n  d: bufferToBase64url(key.private)\n})\n"]},"metadata":{},"sourceType":"script"}