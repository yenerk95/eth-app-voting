{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\n\nvar _require = require('interface-datastore'),\n    Errors = _require.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\nvar defaultMaximumRecursiveDepth = 32;\n\nvar IpnsResolver = /*#__PURE__*/function () {\n  function IpnsResolver(routing) {\n    _classCallCheck(this, IpnsResolver);\n\n    this._routing = routing;\n  }\n\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name, options) {\n        var recursive, nameSegments, key, depth, res;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = options || {};\n\n                if (!(typeof name !== 'string')) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n\n              case 3:\n                options = options || {};\n                recursive = options.recursive && options.recursive.toString() === 'true';\n                nameSegments = name.split('/');\n\n                if (!(nameSegments.length !== 3 || nameSegments[0] !== '')) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n\n              case 8:\n                key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n                if (recursive) {\n                  depth = defaultMaximumRecursiveDepth;\n                }\n\n                _context.next = 12;\n                return this.resolver(key, depth);\n\n              case 12:\n                res = _context.sent;\n                log(\"\".concat(name, \" was locally resolved correctly\"));\n                return _context.abrupt(\"return\", res);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function resolve(_x, _x2) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }() // Recursive resolver according to the specified depth\n\n  }, {\n    key: \"resolver\",\n    value: function () {\n      var _resolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, depth) {\n        var errMsg, res, nameSegments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(depth === 0)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n\n              case 4:\n                _context2.next = 6;\n                return this._resolveName(name);\n\n              case 6:\n                res = _context2.sent;\n                nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n                if (!(nameSegments[1] === 'ipfs' || !depth)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", res);\n\n              case 10:\n                return _context2.abrupt(\"return\", this.resolver(nameSegments[2], depth - 1));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function resolver(_x3, _x4) {\n        return _resolver.apply(this, arguments);\n      }\n\n      return resolver;\n    }() // resolve ipns entries from the provided routing\n\n  }, {\n    key: \"_resolveName\",\n    value: function () {\n      var _resolveName2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {\n        var peerId, _ipns$getIdKeys, routingKey, record, ipnsEntry, pubKey;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                peerId = PeerId.createFromCID(name);\n                _ipns$getIdKeys = ipns.getIdKeys(peerId.toBytes()), routingKey = _ipns$getIdKeys.routingKey;\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this._routing.get(routingKey.toBuffer());\n\n              case 5:\n                record = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](2);\n                log.error(_context3.t0);\n\n                if (!(_context3.t0.code === ERR_NOT_FOUND)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw errcode(new Error(\"record requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n\n              case 13:\n                throw errcode(new Error(\"unexpected error getting the ipns record \".concat(peerId.id)), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n\n              case 14:\n                _context3.prev = 14;\n                ipnsEntry = ipns.unmarshal(record);\n                _context3.next = 22;\n                break;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t1 = _context3[\"catch\"](14);\n                log.error(_context3.t1);\n                throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n\n              case 22:\n                if (!ipnsEntry.pubKey) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this._validateRecord(peerId, ipnsEntry));\n\n              case 24:\n                _context3.prev = 24;\n                _context3.next = 27;\n                return this._routing.get(routingKey.toBuffer());\n\n              case 27:\n                pubKey = _context3.sent;\n                _context3.next = 36;\n                break;\n\n              case 30:\n                _context3.prev = 30;\n                _context3.t2 = _context3[\"catch\"](24);\n                log.error(_context3.t2);\n\n                if (!(_context3.t2.code === ERR_NOT_FOUND)) {\n                  _context3.next = 35;\n                  break;\n                }\n\n                throw errcode(new Error(\"public key requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n\n              case 35:\n                throw errcode(new Error(\"unexpected error getting the public key for the ipns record \".concat(peerId.id)), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY');\n\n              case 36:\n                _context3.prev = 36;\n                // Insert it into the peer id, in order to be validated by IPNS validator\n                peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey);\n                _context3.next = 44;\n                break;\n\n              case 40:\n                _context3.prev = 40;\n                _context3.t3 = _context3[\"catch\"](36);\n                log.error(_context3.t3);\n                throw errcode(new Error('found public key record that we couldn\\'t convert to a value'), 'ERR_INVALID_PUB_KEY_RECEIVED');\n\n              case 44:\n                return _context3.abrupt(\"return\", this._validateRecord(peerId, ipnsEntry));\n\n              case 45:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 8], [14, 18], [24, 30], [36, 40]]);\n      }));\n\n      function _resolveName(_x5) {\n        return _resolveName2.apply(this, arguments);\n      }\n\n      return _resolveName;\n    }() // validate a resolved record\n\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peerId, ipnsEntry) {\n        var pubKey;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return ipns.extractPublicKey(peerId, ipnsEntry);\n\n              case 2:\n                pubKey = _context4.sent;\n                _context4.next = 5;\n                return ipns.validate(pubKey, ipnsEntry);\n\n              case 5:\n                return _context4.abrupt(\"return\", ipnsEntry.value.toString());\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function _validateRecord(_x6, _x7) {\n        return _validateRecord2.apply(this, arguments);\n      }\n\n      return _validateRecord;\n    }()\n  }]);\n\n  return IpnsResolver;\n}();\n\nexports = module.exports = IpnsResolver;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/ipns/resolver.js"],"names":["ipns","require","crypto","PeerId","errcode","debug","log","error","Errors","ERR_NOT_FOUND","notFoundError","code","defaultMaximumRecursiveDepth","IpnsResolver","routing","_routing","name","options","Error","recursive","toString","nameSegments","split","length","key","depth","resolver","res","errMsg","_resolveName","peerId","createFromCID","getIdKeys","toBytes","routingKey","get","toBuffer","record","id","ipnsEntry","unmarshal","pubKey","_validateRecord","keys","unmarshalPublicKey","extractPublicKey","validate","value","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:resolver')\nlog.error = debug('ipfs:ipns:resolver:error')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\nconst defaultMaximumRecursiveDepth = 32\n\nclass IpnsResolver {\n  constructor (routing) {\n    this._routing = routing\n  }\n\n  async resolve (name, options) {\n    options = options || {}\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    options = options || {}\n    const recursive = options.recursive && options.recursive.toString() === 'true'\n\n    const nameSegments = name.split('/')\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME')\n    }\n\n    const key = nameSegments[2]\n\n    // Define a maximum depth if recursive option enabled\n    let depth\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth\n    }\n\n    const res = await this.resolver(key, depth)\n\n    log(`${name} was locally resolved correctly`)\n    return res\n  }\n\n  // Recursive resolver according to the specified depth\n  async resolver (name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT')\n    }\n\n    const res = await this._resolveName(name)\n    const nameSegments = res.split('/')\n\n    // If obtained a ipfs cid or recursive option is disabled\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res\n    }\n\n    // continue recursively until depth equals 0\n    return this.resolver(nameSegments[2], depth - 1)\n  }\n\n  // resolve ipns entries from the provided routing\n  async _resolveName (name) {\n    const peerId = PeerId.createFromCID(name)\n    const { routingKey } = ipns.getIdKeys(peerId.toBytes())\n    let record\n\n    try {\n      record = await this._routing.get(routingKey.toBuffer())\n    } catch (err) {\n      log.error(err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n    }\n\n    // IPNS entry\n    let ipnsEntry\n    try {\n      ipnsEntry = ipns.unmarshal(record)\n    } catch (err) {\n      log.error(err)\n\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    // if the record has a public key validate it\n    if (ipnsEntry.pubKey) {\n      return this._validateRecord(peerId, ipnsEntry)\n    }\n\n    // Otherwise, try to get the public key from routing\n    let pubKey\n    try {\n      pubKey = await this._routing.get(routingKey.toBuffer())\n    } catch (err) {\n      log.error(err)\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`public key requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND')\n      }\n\n      throw errcode(new Error(`unexpected error getting the public key for the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY')\n    }\n\n    try {\n      // Insert it into the peer id, in order to be validated by IPNS validator\n      peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey)\n    } catch (err) {\n      log.error(err)\n\n      throw errcode(new Error('found public key record that we couldn\\'t convert to a value'), 'ERR_INVALID_PUB_KEY_RECEIVED')\n    }\n\n    return this._validateRecord(peerId, ipnsEntry)\n  }\n\n  // validate a resolved record\n  async _validateRecord (peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry)\n\n    // IPNS entry validation\n    await ipns.validate(pubKey, ipnsEntry)\n\n    return ipnsEntry.value.toString()\n  }\n}\n\nexports = module.exports = IpnsResolver\n"]},"metadata":{},"sourceType":"script"}