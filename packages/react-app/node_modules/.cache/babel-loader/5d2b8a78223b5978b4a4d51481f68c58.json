{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst multibase = require('multibase');\n\nconst {\n  parallelMap,\n  collect\n} = require('streaming-iterables');\n\nconst pipe = require('it-pipe');\n\nconst {\n  resolvePath,\n  withTimeoutOption\n} = require('../../utils');\n\nconst {\n  PinTypes\n} = require('./pin-manager');\n\nconst PIN_RM_CONCURRENCY = 8;\n\nmodule.exports = ({\n  pinManager,\n  gcLock,\n  dag\n}) => {\n  return withTimeoutOption(async function rm(paths, options) {\n    options = options || {};\n    const recursive = options.recursive !== false;\n\n    if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n      throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE');\n    }\n\n    const cids = await resolvePath(dag, paths);\n    const release = await gcLock.readLock();\n\n    try {\n      // verify that each hash can be unpinned\n      const results = await pipe(cids, parallelMap(PIN_RM_CONCURRENCY, async cid => {\n        const {\n          pinned,\n          reason\n        } = await pinManager.isPinnedWithType(cid, PinTypes.all);\n\n        if (!pinned) {\n          throw new Error(`${cid} is not pinned`);\n        }\n\n        if (reason !== PinTypes.recursive && reason !== PinTypes.direct) {\n          throw new Error(`${cid} is pinned indirectly under ${reason}`);\n        }\n\n        if (reason === PinTypes.recursive && !recursive) {\n          throw new Error(`${cid} is pinned recursively`);\n        }\n\n        return cid;\n      }), collect); // update the pin sets in memory\n\n      results.forEach(cid => {\n        if (recursive && pinManager.recursivePins.has(cid.toString())) {\n          pinManager.recursivePins.delete(cid.toString());\n        } else {\n          pinManager.directPins.delete(cid.toString());\n        }\n      }); // persist updated pin sets to datastore\n\n      await pinManager.flushPins();\n      return results.map(cid => ({\n        cid\n      }));\n    } finally {\n      release();\n    }\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/rm.js"],"names":["errCode","require","multibase","parallelMap","collect","pipe","resolvePath","withTimeoutOption","PinTypes","PIN_RM_CONCURRENCY","module","exports","pinManager","gcLock","dag","rm","paths","options","recursive","cidBase","names","includes","Error","cids","release","readLock","results","cid","pinned","reason","isPinnedWithType","all","direct","forEach","recursivePins","has","toString","delete","directPins","flushPins","map"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst multibase = require('multibase')\nconst { parallelMap, collect } = require('streaming-iterables')\nconst pipe = require('it-pipe')\nconst { resolvePath, withTimeoutOption } = require('../../utils')\nconst { PinTypes } = require('./pin-manager')\n\nconst PIN_RM_CONCURRENCY = 8\n\nmodule.exports = ({ pinManager, gcLock, dag }) => {\n  return withTimeoutOption(async function rm (paths, options) {\n    options = options || {}\n\n    const recursive = options.recursive !== false\n\n    if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n      throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE')\n    }\n\n    const cids = await resolvePath(dag, paths)\n    const release = await gcLock.readLock()\n\n    try {\n      // verify that each hash can be unpinned\n      const results = await pipe(\n        cids,\n        parallelMap(PIN_RM_CONCURRENCY, async cid => {\n          const { pinned, reason } = await pinManager.isPinnedWithType(cid, PinTypes.all)\n\n          if (!pinned) {\n            throw new Error(`${cid} is not pinned`)\n          }\n          if (reason !== PinTypes.recursive && reason !== PinTypes.direct) {\n            throw new Error(`${cid} is pinned indirectly under ${reason}`)\n          }\n          if (reason === PinTypes.recursive && !recursive) {\n            throw new Error(`${cid} is pinned recursively`)\n          }\n\n          return cid\n        }),\n        collect\n      )\n\n      // update the pin sets in memory\n      results.forEach(cid => {\n        if (recursive && pinManager.recursivePins.has(cid.toString())) {\n          pinManager.recursivePins.delete(cid.toString())\n        } else {\n          pinManager.directPins.delete(cid.toString())\n        }\n      })\n\n      // persist updated pin sets to datastore\n      await pinManager.flushPins()\n\n      return results.map(cid => ({ cid }))\n    } finally {\n      release()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}