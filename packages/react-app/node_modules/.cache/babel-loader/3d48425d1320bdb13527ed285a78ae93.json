{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst errCode = require('err-code');\n\nconst CID = require('cids');\n\nconst resolve = require('./resolvers');\n\nconst last = require('it-last');\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    };\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nconst walkPath = async function* (path, ipld, options) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toBaseEncodedString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld, options);\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    } // resolve further parts\n\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n};\n\nconst exporter = (path, ipld, options) => {\n  return last(walkPath(path, ipld, options));\n};\n\nconst recursive = async function* (path, ipld, options) {\n  const node = await exporter(path, ipld, options);\n  yield node;\n\n  if (node.unixfs && node.unixfs.type.includes('dir')) {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n\n      if (file.unixfs.type.includes('dir')) {\n        for await (const subFile of recurse(file, options)) {\n          yield subFile;\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = exporter;\nmodule.exports.path = walkPath;\nmodule.exports.recursive = recursive;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs-exporter/src/index.js"],"names":["Buffer","require","errCode","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","isBuffer","cid","toResolve","isCID","indexOf","substring","output","slice","Error","walkPath","ipld","options","name","toBaseEncodedString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","unixfs","type","includes","child","recurse","file","content","subFile","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst errCode = require('err-code')\nconst CID = require('cids')\nconst resolve = require('./resolvers')\nconst last = require('it-last')\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) || [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    }\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')\n}\n\nconst walkPath = async function * (path, ipld, options) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toBaseEncodedString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld, options)\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n    }\n\n    if (result.entry) {\n      yield result.entry\n    }\n\n    if (!result.next) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\nconst exporter = (path, ipld, options) => {\n  return last(walkPath(path, ipld, options))\n}\n\nconst recursive = async function * (path, ipld, options) {\n  const node = await exporter(path, ipld, options)\n\n  yield node\n\n  if (node.unixfs && node.unixfs.type.includes('dir')) {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node, options) {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file.unixfs.type.includes('dir')) {\n        for await (const subFile of recurse(file, options)) {\n          yield subFile\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = exporter\nmodule.exports.path = walkPath\nmodule.exports.recursive = recursive\n"]},"metadata":{},"sourceType":"script"}