{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  Adapter,\n  Key\n} = require('interface-datastore');\n\nconst sh = require('./shard');\n\nconst KeytransformStore = require('./keytransform');\n\nconst shardKey = new Key(sh.SHARDING_FN);\nconst shardReadmeKey = new Key(sh.README_FN);\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nclass ShardingDatastore extends Adapter {\n  constructor(store, shard) {\n    super();\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  open() {\n    return this.child.open();\n  }\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return Key.withNamespaces(key.list().slice(1));\n  }\n\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err;\n    }\n\n    return ShardingDatastore.open(store);\n  }\n\n  static async open(store) {\n    const shard = await sh.readShardFun('/', store);\n    return new ShardingDatastore(store, shard);\n  }\n\n  static async create(store, shard) {\n    const exists = await store.has(shardKey);\n\n    if (!exists) {\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      return Promise.all([put(shardKey, Buffer.from(shard.toString() + '\\n')), put(shardReadmeKey, Buffer.from(sh.readme))]);\n    }\n\n    const diskShard = await sh.readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard.toString();\n    if (a !== b) throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);\n    throw new Error('datastore exists');\n  }\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n\n  query(q, options) {\n    const tq = {\n      keysOnly: q.keysOnly,\n      offset: q.offset,\n      limit: q.limit,\n      filters: [e => e.key.toString() !== shardKey.toString(), e => e.key.toString() !== shardReadmeKey.toString()]\n    };\n\n    if (q.prefix != null) {\n      tq.filters.push(e => {\n        return this._invertKey(e.key).toString().startsWith(q.prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map(f => e => {\n        return f(Object.assign({}, e, {\n          key: this._invertKey(e.key)\n        }));\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => async res => {\n        res.forEach(e => {\n          e.key = this._invertKey(e.key);\n        });\n        const ordered = await o(res);\n        ordered.forEach(e => {\n          e.key = this._convertKey(e.key);\n        });\n        return ordered;\n      });\n    }\n\n    return this.child.query(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}\n\nmodule.exports = ShardingDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-core/src/sharding.js"],"names":["Buffer","require","Adapter","Key","sh","KeytransformStore","shardKey","SHARDING_FN","shardReadmeKey","README_FN","ShardingDatastore","constructor","store","shard","child","convert","_convertKey","bind","invert","_invertKey","open","key","s","toString","parent","fun","withNamespaces","list","slice","createOrOpen","create","err","message","readShardFun","exists","has","put","putRaw","Promise","all","from","readme","diskShard","a","b","Error","val","options","get","delete","batch","query","q","tq","keysOnly","offset","limit","filters","e","prefix","push","startsWith","map","f","Object","assign","concat","orders","o","res","forEach","ordered","close","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst { Adapter, Key } = require('interface-datastore')\nconst sh = require('./shard')\nconst KeytransformStore = require('./keytransform')\n\nconst shardKey = new Key(sh.SHARDING_FN)\nconst shardReadmeKey = new Key(sh.README_FN)\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore extends Adapter {\n  constructor (store, shard) {\n    super()\n\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  _convertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  _invertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  static async createOrOpen (store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard)\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err\n    }\n    return ShardingDatastore.open(store)\n  }\n\n  static async open (store) {\n    const shard = await sh.readShardFun('/', store)\n    return new ShardingDatastore(store, shard)\n  }\n\n  static async create (store, shard) {\n    const exists = await store.has(shardKey)\n    if (!exists) {\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n      return Promise.all([put(shardKey, Buffer.from(shard.toString() + '\\n')),\n        put(shardReadmeKey, Buffer.from(sh.readme))])\n    }\n\n    const diskShard = await sh.readShardFun('/', store)\n    const a = (diskShard || '').toString()\n    const b = shard.toString()\n    if (a !== b) throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    throw new Error('datastore exists')\n  }\n\n  put (key, val, options) {\n    return this.child.put(key, val, options)\n  }\n\n  get (key, options) {\n    return this.child.get(key, options)\n  }\n\n  has (key, options) {\n    return this.child.has(key, options)\n  }\n\n  delete (key, options) {\n    return this.child.delete(key, options)\n  }\n\n  batch () {\n    return this.child.batch()\n  }\n\n  query (q, options) {\n    const tq = {\n      keysOnly: q.keysOnly,\n      offset: q.offset,\n      limit: q.limit,\n      filters: [\n        e => e.key.toString() !== shardKey.toString(),\n        e => e.key.toString() !== shardReadmeKey.toString()\n      ]\n    }\n\n    if (q.prefix != null) {\n      tq.filters.push((e) => {\n        return this._invertKey(e.key).toString().startsWith(q.prefix)\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map((f) => (e) => {\n        return f(Object.assign({}, e, {\n          key: this._invertKey(e.key)\n        }))\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map((o) => async (res) => {\n        res.forEach((e) => { e.key = this._invertKey(e.key) })\n        const ordered = await o(res)\n        ordered.forEach((e) => { e.key = this._convertKey(e.key) })\n        return ordered\n      })\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  close () {\n    return this.child.close()\n  }\n}\n\nmodule.exports = ShardingDatastore\n"]},"metadata":{},"sourceType":"script"}