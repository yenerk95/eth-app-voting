{"ast":null,"code":"import { Buffer } from \"buffer\";\nimport AEAD from 'bcrypto/lib/js/aead';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\nimport { getHkdf } from \"../utils\";\nimport { logger } from \"../logger\";\nexport const MIN_NONCE = 0;\nexport class AbstractHandshake {\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext) {\n    const {\n      plaintext,\n      valid\n    } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  setNonce(cs, nonce) {\n    cs.n = nonce;\n  }\n\n  createEmptyKey() {\n    return Buffer.alloc(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  incrementNonce(n) {\n    return n + 1;\n  }\n\n  nonceToBytes(n) {\n    const nonce = Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n    return nonce;\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    plaintext = Buffer.from(plaintext);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.encrypt(plaintext); // Encryption is done on the sent reference\n\n    return Buffer.concat([plaintext, ctx.final()]);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    ciphertext = Buffer.from(ciphertext);\n    const tag = ciphertext.slice(ciphertext.length - 16);\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.decrypt(ciphertext); // Decryption is done on the sent reference\n\n    return {\n      plaintext: ciphertext,\n      valid: ctx.verify(tag)\n    };\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext,\n        valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      ({\n        plaintext,\n        valid\n      } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derived = x25519.derive(publicKey, privateKey);\n      const result = Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger(e.message);\n      return Buffer.alloc(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    return SHA256.digest(Buffer.from([...a, ...b]));\n  }\n\n  mixKey(ss, ikm) {\n    const [ck, tempK] = getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    const n = MIN_NONCE;\n    return {\n      k,\n      n\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, Buffer.alloc(0));\n    }\n  }\n\n  split(ss) {\n    const [tempk1, tempk2] = getHkdf(ss.ck, Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = Buffer.alloc(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext);\n  }\n\n}","map":{"version":3,"sources":["../../src/handshakes/abstract-handshake.ts"],"names":["MIN_NONCE","encryptWithAd","e","cs","decryptWithAd","valid","hasKey","setNonce","createEmptyKey","Buffer","isEmptyKey","emptyKey","incrementNonce","n","nonceToBytes","nonce","encrypt","ctx","plaintext","encryptAndHash","ss","ciphertext","decrypt","tag","decryptAndHash","dh","derived","x25519","result","logger","mixHash","getHash","SHA256","mixKey","getHkdf","initializeKey","initializeSymmetric","protocolNameBytes","h","ck","key","hashProtocolName","protocolName","split","cs1","cs2","writeMessageRegular","ne","ns","readMessageRegular","message"],"mappings":"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","sourcesContent":["import {Buffer} from \"buffer\";\nimport AEAD from 'bcrypto/lib/js/aead';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\n\nimport {bytes, bytes32, uint32} from \"../@types/basic\";\nimport {CipherState, MessageBuffer, SymmetricState} from \"../@types/handshake\";\nimport {getHkdf} from \"../utils\";\nimport {logger} from \"../logger\";\n\nexport const MIN_NONCE = 0;\n\nexport abstract class AbstractHandshake {\n  public encryptWithAd(cs: CipherState, ad: bytes, plaintext: bytes): bytes {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n\n    return e;\n  }\n\n  public decryptWithAd(cs: CipherState, ad: bytes, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    const {plaintext, valid} = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n\n    return {plaintext, valid};\n  }\n\n\n  // Cipher state related\n  protected hasKey(cs: CipherState): boolean {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  protected setNonce(cs: CipherState, nonce: uint32): void {\n    cs.n = nonce;\n  }\n\n  protected createEmptyKey(): bytes32 {\n    return Buffer.alloc(32);\n  }\n\n  protected isEmptyKey(k: bytes32): boolean {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  protected incrementNonce(n: uint32): uint32 {\n    return n + 1;\n  }\n\n  protected nonceToBytes(n: uint32): bytes {\n    const nonce = Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n\n    return nonce;\n  }\n\n  protected encrypt(k: bytes32, n: uint32, ad: bytes, plaintext: bytes): bytes {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    plaintext = Buffer.from(plaintext);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.encrypt(plaintext);\n\n    // Encryption is done on the sent reference\n    return Buffer.concat([plaintext, ctx.final()]);\n  }\n\n  protected encryptAndHash(ss: SymmetricState, plaintext: bytes): bytes {\n    let ciphertext;\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  protected decrypt(k: bytes32, n: uint32, ad: bytes, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    ciphertext = Buffer.from(ciphertext);\n    const tag = ciphertext.slice(ciphertext.length - 16);\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.decrypt(ciphertext);\n    // Decryption is done on the sent reference\n    return {plaintext: ciphertext, valid: ctx.verify(tag)};\n  }\n\n  protected decryptAndHash(ss: SymmetricState, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    let plaintext: bytes, valid = true;\n    if (this.hasKey(ss.cs)) {\n      ({plaintext, valid} = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {plaintext, valid};\n  }\n\n  protected dh(privateKey: bytes32, publicKey: bytes32): bytes32 {\n    try {\n      const derived = x25519.derive(publicKey, privateKey);\n      const result = Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger(e.message);\n      return Buffer.alloc(32);\n    }\n  }\n\n  protected mixHash(ss: SymmetricState, data: bytes): void {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  protected getHash(a: bytes, b: bytes): bytes32 {\n    return SHA256.digest(Buffer.from([...a, ...b]));\n  }\n\n  protected mixKey(ss: SymmetricState, ikm: bytes32): void {\n    const [ ck, tempK ] = getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK) as CipherState;\n    ss.ck = ck;\n  }\n\n  protected initializeKey(k: bytes32): CipherState {\n    const n = MIN_NONCE;\n    return { k, n };\n  }\n\n  // Symmetric state related\n\n  protected initializeSymmetric(protocolName: string): SymmetricState {\n    const protocolNameBytes: bytes = Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs: CipherState = this.initializeKey(key);\n\n    return { cs, ck, h };\n  }\n\n  protected hashProtocolName(protocolName: bytes): bytes32 {\n    if (protocolName.length <= 32) {\n      const h = Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, Buffer.alloc(0));\n    }\n  }\n\n  protected split(ss: SymmetricState) {\n    const [ tempk1, tempk2 ] = getHkdf(ss.ck, Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n\n    return { cs1, cs2 };\n  }\n\n  protected writeMessageRegular(cs: CipherState, payload: bytes): MessageBuffer {\n    const ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = Buffer.alloc(0);\n\n    return { ne, ns, ciphertext };\n  }\n\n  protected readMessageRegular(cs: CipherState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}