{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar CID = require('cids');\n\nvar _require = require('../../../utils/cid'),\n    cidToString = _require.cidToString;\n\nvar log = require('debug')('ipfs:repo:gc');\n\nvar _require2 = require('../../utils'),\n    MFS_ROOT_KEY = _require2.MFS_ROOT_KEY,\n    withTimeoutOption = _require2.withTimeoutOption;\n\nvar Repo = require('ipfs-repo');\n\nvar _require3 = require('interface-datastore'),\n    Errors = _require3.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\n\nvar _require4 = require('streaming-iterables'),\n    parallelMerge = _require4.parallelMerge,\n    transform = _require4.transform,\n    map = _require4.map; // Limit on the number of parallel block remove operations\n\n\nvar BLOCK_RM_CONCURRENCY = 256; // Perform mark and sweep garbage collection\n\nmodule.exports = function (_ref3) {\n  var gcLock = _ref3.gcLock,\n      pin = _ref3.pin,\n      pinManager = _ref3.pinManager,\n      refs = _ref3.refs,\n      repo = _ref3.repo;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _gc = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var options,\n          start,\n          release,\n          markedSet,\n          blockKeys,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n              start = Date.now();\n              log('Creating set of marked blocks');\n              _context.next = 5;\n              return _awaitAsyncGenerator(gcLock.writeLock());\n\n            case 5:\n              release = _context.sent;\n              _context.prev = 6;\n              _context.next = 9;\n              return _awaitAsyncGenerator(createMarkedSet({\n                pin: pin,\n                pinManager: pinManager,\n                refs: refs,\n                repo: repo\n              }));\n\n            case 9:\n              markedSet = _context.sent;\n              // Get all blocks keys from the blockstore\n              blockKeys = repo.blocks.query({\n                keysOnly: true\n              }); // Delete blocks that are not being used\n\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(deleteUnmarkedBlocks({\n                repo: repo,\n                refs: refs\n              }, markedSet, blockKeys)), _awaitAsyncGenerator), \"t0\", 12);\n\n            case 12:\n              log(\"Complete (\".concat(Date.now() - start, \"ms)\"));\n\n            case 13:\n              _context.prev = 13;\n              release();\n              return _context.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[6,, 13, 16]]);\n    }));\n\n    function gc() {\n      return _gc.apply(this, arguments);\n    }\n\n    return gc;\n  }());\n}; // Get Set of CIDs of blocks to keep\n\n\nfunction createMarkedSet(_x4) {\n  return _createMarkedSet.apply(this, arguments);\n} // Delete all blocks that are not marked as in use\n\n\nfunction _createMarkedSet() {\n  _createMarkedSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref4) {\n    var pin, pinManager, refs, repo, pinsSource, pinInternalsSource, mfsSource, output, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            pin = _ref4.pin, pinManager = _ref4.pinManager, refs = _ref4.refs, repo = _ref4.repo;\n            pinsSource = map(function (_ref8) {\n              var cid = _ref8.cid;\n              return cid;\n            }, pin.ls());\n            pinInternalsSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n              var cids;\n              return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return _awaitAsyncGenerator(pinManager.getInternalBlocks());\n\n                    case 2:\n                      cids = _context4.sent;\n                      return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(cids), _awaitAsyncGenerator), \"t0\", 4);\n\n                    case 4:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4);\n            }))();\n            mfsSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n              var mh, rootCid, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, _value4, ref;\n\n              return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      _context5.prev = 0;\n                      _context5.next = 3;\n                      return _awaitAsyncGenerator(repo.root.get(MFS_ROOT_KEY));\n\n                    case 3:\n                      mh = _context5.sent;\n                      _context5.next = 12;\n                      break;\n\n                    case 6:\n                      _context5.prev = 6;\n                      _context5.t0 = _context5[\"catch\"](0);\n\n                      if (!(_context5.t0.code === ERR_NOT_FOUND)) {\n                        _context5.next = 11;\n                        break;\n                      }\n\n                      log('No blocks in MFS');\n                      return _context5.abrupt(\"return\");\n\n                    case 11:\n                      throw _context5.t0;\n\n                    case 12:\n                      rootCid = new CID(mh);\n                      _context5.next = 15;\n                      return rootCid;\n\n                    case 15:\n                      _iteratorNormalCompletion2 = true;\n                      _didIteratorError2 = false;\n                      _context5.prev = 17;\n                      _iterator2 = _asyncIterator(refs(rootCid, {\n                        recursive: true\n                      }));\n\n                    case 19:\n                      _context5.next = 21;\n                      return _awaitAsyncGenerator(_iterator2.next());\n\n                    case 21:\n                      _step2 = _context5.sent;\n                      _iteratorNormalCompletion2 = _step2.done;\n                      _context5.next = 25;\n                      return _awaitAsyncGenerator(_step2.value);\n\n                    case 25:\n                      _value2 = _context5.sent;\n\n                      if (_iteratorNormalCompletion2) {\n                        _context5.next = 33;\n                        break;\n                      }\n\n                      _value4 = _value2, ref = _value4.ref;\n                      _context5.next = 30;\n                      return new CID(ref);\n\n                    case 30:\n                      _iteratorNormalCompletion2 = true;\n                      _context5.next = 19;\n                      break;\n\n                    case 33:\n                      _context5.next = 39;\n                      break;\n\n                    case 35:\n                      _context5.prev = 35;\n                      _context5.t1 = _context5[\"catch\"](17);\n                      _didIteratorError2 = true;\n                      _iteratorError2 = _context5.t1;\n\n                    case 39:\n                      _context5.prev = 39;\n                      _context5.prev = 40;\n\n                      if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                        _context5.next = 44;\n                        break;\n                      }\n\n                      _context5.next = 44;\n                      return _awaitAsyncGenerator(_iterator2.return());\n\n                    case 44:\n                      _context5.prev = 44;\n\n                      if (!_didIteratorError2) {\n                        _context5.next = 47;\n                        break;\n                      }\n\n                      throw _iteratorError2;\n\n                    case 47:\n                      return _context5.finish(44);\n\n                    case 48:\n                      return _context5.finish(39);\n\n                    case 49:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, null, [[0, 6], [17, 35, 39, 49], [40,, 44, 48]]);\n            }))();\n            output = new Set();\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context6.prev = 7;\n            _iterator = _asyncIterator(parallelMerge(pinsSource, pinInternalsSource, mfsSource));\n\n          case 9:\n            _context6.next = 11;\n            return _iterator.next();\n\n          case 11:\n            _step = _context6.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context6.next = 15;\n            return _step.value;\n\n          case 15:\n            _value = _context6.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context6.next = 22;\n              break;\n            }\n\n            cid = _value;\n            output.add(cidToString(cid, {\n              base: 'base32'\n            }));\n\n          case 19:\n            _iteratorNormalCompletion = true;\n            _context6.next = 9;\n            break;\n\n          case 22:\n            _context6.next = 28;\n            break;\n\n          case 24:\n            _context6.prev = 24;\n            _context6.t0 = _context6[\"catch\"](7);\n            _didIteratorError = true;\n            _iteratorError = _context6.t0;\n\n          case 28:\n            _context6.prev = 28;\n            _context6.prev = 29;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context6.next = 33;\n              break;\n            }\n\n            _context6.next = 33;\n            return _iterator.return();\n\n          case 33:\n            _context6.prev = 33;\n\n            if (!_didIteratorError) {\n              _context6.next = 36;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 36:\n            return _context6.finish(33);\n\n          case 37:\n            return _context6.finish(28);\n\n          case 38:\n            return _context6.abrupt(\"return\", output);\n\n          case 39:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[7, 24, 28, 38], [29,, 33, 37]]);\n  }));\n  return _createMarkedSet.apply(this, arguments);\n}\n\nfunction deleteUnmarkedBlocks(_x, _x2, _x3) {\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}\n\nfunction _deleteUnmarkedBlocks() {\n  _deleteUnmarkedBlocks = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5, markedSet, blockKeys) {\n    var repo, refs, blocksCount, removedBlocksCount, removeBlock, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, res;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            repo = _ref5.repo, refs = _ref5.refs;\n            // Iterate through all blocks and find those that are not in the marked set\n            // blockKeys yields { key: Key() }\n            blocksCount = 0;\n            removedBlocksCount = 0;\n\n            removeBlock = /*#__PURE__*/function () {\n              var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref6) {\n                var k, cid, b32, res, msg;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        k = _ref6.key;\n                        blocksCount++;\n                        _context2.prev = 2;\n                        cid = Repo.utils.blockstore.keyToCid(k);\n                        b32 = cid.toV1().toString('base32');\n\n                        if (!markedSet.has(b32)) {\n                          _context2.next = 7;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", null);\n\n                      case 7:\n                        res = {\n                          cid: cid\n                        };\n                        _context2.prev = 8;\n                        _context2.next = 11;\n                        return repo.blocks.delete(cid);\n\n                      case 11:\n                        removedBlocksCount++;\n                        _context2.next = 17;\n                        break;\n\n                      case 14:\n                        _context2.prev = 14;\n                        _context2.t0 = _context2[\"catch\"](8);\n                        res.err = new Error(\"Could not delete block with CID \".concat(cid, \": \").concat(_context2.t0.message));\n\n                      case 17:\n                        return _context2.abrupt(\"return\", res);\n\n                      case 20:\n                        _context2.prev = 20;\n                        _context2.t1 = _context2[\"catch\"](2);\n                        msg = \"Could not convert block with key '\".concat(k, \"' to CID\");\n                        log(msg, _context2.t1);\n                        return _context2.abrupt(\"return\", {\n                          err: new Error(msg + \": \".concat(_context2.t1.message))\n                        });\n\n                      case 25:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[2, 20], [8, 14]]);\n              }));\n\n              return function removeBlock(_x5) {\n                return _ref7.apply(this, arguments);\n              };\n            }();\n\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context3.prev = 6;\n            _iterator3 = _asyncIterator(transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys));\n\n          case 8:\n            _context3.next = 10;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 10:\n            _step3 = _context3.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context3.next = 14;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 14:\n            _value3 = _context3.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context3.next = 23;\n              break;\n            }\n\n            res = _value3;\n\n            if (!res) {\n              _context3.next = 20;\n              break;\n            }\n\n            _context3.next = 20;\n            return res;\n\n          case 20:\n            _iteratorNormalCompletion3 = true;\n            _context3.next = 8;\n            break;\n\n          case 23:\n            _context3.next = 29;\n            break;\n\n          case 25:\n            _context3.prev = 25;\n            _context3.t0 = _context3[\"catch\"](6);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context3.t0;\n\n          case 29:\n            _context3.prev = 29;\n            _context3.prev = 30;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context3.next = 34;\n              break;\n            }\n\n            _context3.next = 34;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 34:\n            _context3.prev = 34;\n\n            if (!_didIteratorError3) {\n              _context3.next = 37;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 37:\n            return _context3.finish(34);\n\n          case 38:\n            return _context3.finish(29);\n\n          case 39:\n            log(\"Marked set has \".concat(markedSet.size, \" unique blocks. Blockstore has \").concat(blocksCount, \" blocks. \") + \"Deleted \".concat(removedBlocksCount, \" blocks.\"));\n\n          case 40:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[6, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/repo/gc.js"],"names":["CID","require","cidToString","log","MFS_ROOT_KEY","withTimeoutOption","Repo","Errors","ERR_NOT_FOUND","notFoundError","code","parallelMerge","transform","map","BLOCK_RM_CONCURRENCY","module","exports","gcLock","pin","pinManager","refs","repo","options","start","Date","now","writeLock","release","createMarkedSet","markedSet","blockKeys","blocks","query","keysOnly","deleteUnmarkedBlocks","gc","pinsSource","cid","ls","pinInternalsSource","getInternalBlocks","cids","mfsSource","root","get","mh","rootCid","recursive","ref","output","Set","add","base","blocksCount","removedBlocksCount","removeBlock","k","key","utils","blockstore","keyToCid","b32","toV1","toString","has","res","delete","err","Error","message","msg","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst { cidToString } = require('../../../utils/cid')\nconst log = require('debug')('ipfs:repo:gc')\nconst { MFS_ROOT_KEY, withTimeoutOption } = require('../../utils')\nconst Repo = require('ipfs-repo')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst { parallelMerge, transform, map } = require('streaming-iterables')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\n// Perform mark and sweep garbage collection\nmodule.exports = ({ gcLock, pin, pinManager, refs, repo }) => {\n  return withTimeoutOption(async function * gc (options = {}) {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pin, pinManager, refs, repo })\n      // Get all blocks keys from the blockstore\n      const blockKeys = repo.blocks.query({ keysOnly: true })\n\n      // Delete blocks that are not being used\n      yield * deleteUnmarkedBlocks({ repo, refs }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  })\n}\n\n// Get Set of CIDs of blocks to keep\nasync function createMarkedSet ({ pin, pinManager, refs, repo }) {\n  const pinsSource = map(({ cid }) => cid, pin.ls())\n\n  const pinInternalsSource = (async function * () {\n    const cids = await pinManager.getInternalBlocks()\n    yield * cids\n  })()\n\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n      throw err\n    }\n\n    const rootCid = new CID(mh)\n    yield rootCid\n\n    for await (const { ref } of refs(rootCid, { recursive: true })) {\n      yield new CID(ref)\n    }\n  })()\n\n  const output = new Set()\n  for await (const cid of parallelMerge(pinsSource, pinInternalsSource, mfsSource)) {\n    output.add(cidToString(cid, { base: 'base32' }))\n  }\n  return output\n}\n\n// Delete all blocks that are not marked as in use\nasync function * deleteUnmarkedBlocks ({ repo, refs }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  const removeBlock = async ({ key: k }) => {\n    blocksCount++\n\n    try {\n      const cid = Repo.utils.blockstore.keyToCid(k)\n      const b32 = cid.toV1().toString('base32')\n      if (markedSet.has(b32)) return null\n      const res = { cid }\n\n      try {\n        await repo.blocks.delete(cid)\n        removedBlocksCount++\n      } catch (err) {\n        res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n      }\n\n      return res\n    } catch (err) {\n      const msg = `Could not convert block with key '${k}' to CID`\n      log(msg, err)\n      return { err: new Error(msg + `: ${err.message}`) }\n    }\n  }\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res\n  }\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"]},"metadata":{},"sourceType":"script"}