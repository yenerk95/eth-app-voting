{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('idb'),\n    openDB = _require2.openDB,\n    deleteDB = _require2.deleteDB;\n\nvar _require3 = require('interface-datastore'),\n    Key = _require3.Key,\n    Errors = _require3.Errors,\n    utils = _require3.utils,\n    Adapter = _require3.Adapter;\n\nvar filter = utils.filter,\n    sortAll = utils.sortAll;\n\nvar isStrictTypedArray = function isStrictTypedArray(arr) {\n  return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;\n};\n\nvar typedarrayToBuffer = function typedarrayToBuffer(arr) {\n  if (isStrictTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer);\n\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n    }\n\n    return buf;\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr);\n  }\n};\n\nvar str2ab = function str2ab(str) {\n  var buf = new ArrayBuffer(str.length);\n  var bufView = new Uint8Array(buf);\n\n  for (var i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n};\n\nvar queryIt = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(q, store, location) {\n    var range, cursor, limit, key, value;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            range = q.prefix ? self.IDBKeyRange.bound(str2ab(q.prefix), str2ab(q.prefix + '\\xFF'), false, true) : undefined;\n            _context.next = 3;\n            return _awaitAsyncGenerator(store.transaction(location).store.openCursor(range));\n\n          case 3:\n            cursor = _context.sent;\n            limit = 0;\n\n            if (!(cursor && q.offset && q.offset > 0)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 8;\n            return _awaitAsyncGenerator(cursor.advance(q.offset));\n\n          case 8:\n            cursor = _context.sent;\n\n          case 9:\n            if (!cursor) {\n              _context.next = 27;\n              break;\n            }\n\n            if (!(q.limit !== undefined && q.limit === limit)) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 12:\n            limit++;\n            key = new Key(Buffer.from(cursor.key));\n\n            if (!q.keysOnly) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.next = 17;\n            return {\n              key: key\n            };\n\n          case 17:\n            _context.next = 22;\n            break;\n\n          case 19:\n            value = Buffer.from(cursor.value);\n            _context.next = 22;\n            return {\n              key: key,\n              value: value\n            };\n\n          case 22:\n            _context.next = 24;\n            return _awaitAsyncGenerator(cursor.continue());\n\n          case 24:\n            cursor = _context.sent;\n            _context.next = 9;\n            break;\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function queryIt(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar IdbDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(IdbDatastore, _Adapter);\n\n  var _super = _createSuper(IdbDatastore);\n\n  function IdbDatastore(location) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, IdbDatastore);\n\n    _this = _super.call(this);\n    _this.store = null;\n    _this.options = options;\n    _this.location = options.prefix + location;\n    _this.version = options.version || 1;\n    return _this;\n  }\n\n  _createClass(IdbDatastore, [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var location;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.store !== null)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                location = this.location;\n                _context2.prev = 3;\n                _context2.next = 6;\n                return openDB(this.location, this.version, {\n                  upgrade: function upgrade(db) {\n                    db.createObjectStore(location);\n                  }\n                });\n\n              case 6:\n                this.store = _context2.sent;\n                _context2.next = 12;\n                break;\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](3);\n                throw Errors.dbOpenFailedError(_context2.t0);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[3, 9]]);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, val) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.store === null)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('Datastore needs to be opened.');\n\n              case 2:\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this.store.put(this.location, val, key.toBuffer());\n\n              case 5:\n                _context3.next = 10;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](2);\n                throw Errors.dbWriteFailedError(_context3.t0);\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 7]]);\n      }));\n\n      function put(_x4, _x5) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key) {\n        var value;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.store === null)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Datastore needs to be opened.');\n\n              case 2:\n                _context4.prev = 2;\n                _context4.next = 5;\n                return this.store.get(this.location, key.toBuffer());\n\n              case 5:\n                value = _context4.sent;\n                _context4.next = 11;\n                break;\n\n              case 8:\n                _context4.prev = 8;\n                _context4.t0 = _context4[\"catch\"](2);\n                throw Errors.dbWriteFailedError(_context4.t0);\n\n              case 11:\n                if (value) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                throw Errors.notFoundError();\n\n              case 13:\n                return _context4.abrupt(\"return\", typedarrayToBuffer(value));\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[2, 8]]);\n      }));\n\n      function get(_x6) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"has\",\n    value: function () {\n      var _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(this.store === null)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('Datastore needs to be opened.');\n\n              case 2:\n                _context5.prev = 2;\n                _context5.next = 5;\n                return this.get(key);\n\n              case 5:\n                _context5.next = 12;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](2);\n\n                if (!(_context5.t0.code === 'ERR_NOT_FOUND')) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 11:\n                throw _context5.t0;\n\n              case 12:\n                return _context5.abrupt(\"return\", true);\n\n              case 13:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 7]]);\n      }));\n\n      function has(_x7) {\n        return _has.apply(this, arguments);\n      }\n\n      return has;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(key) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this.store === null)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('Datastore needs to be opened.');\n\n              case 2:\n                _context6.prev = 2;\n                _context6.next = 5;\n                return this.store.delete(this.location, key.toBuffer());\n\n              case 5:\n                _context6.next = 10;\n                break;\n\n              case 7:\n                _context6.prev = 7;\n                _context6.t0 = _context6[\"catch\"](2);\n                throw Errors.dbDeleteFailedError(_context6.t0);\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[2, 7]]);\n      }));\n\n      function _delete(_x8) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var _this2 = this;\n\n      var puts = [];\n      var dels = [];\n      return {\n        put: function put(key, value) {\n          puts.push([key.toBuffer(), value]);\n        },\n        delete: function _delete(key) {\n          dels.push(key.toBuffer());\n        },\n        commit: function () {\n          var _commit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n            var tx, store;\n            return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    if (!(_this2.store === null)) {\n                      _context7.next = 2;\n                      break;\n                    }\n\n                    throw new Error('Datastore needs to be opened.');\n\n                  case 2:\n                    tx = _this2.store.transaction(_this2.location, 'readwrite');\n                    store = tx.store;\n                    _context7.next = 6;\n                    return Promise.all(puts.map(function (p) {\n                      return store.put(p[1], p[0]);\n                    }));\n\n                  case 6:\n                    _context7.next = 8;\n                    return Promise.all(dels.map(function (p) {\n                      return store.delete(p);\n                    }));\n\n                  case 8:\n                    _context7.next = 10;\n                    return tx.done;\n\n                  case 10:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _callee7);\n          }));\n\n          function commit() {\n            return _commit.apply(this, arguments);\n          }\n\n          return commit;\n        }()\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q) {\n      if (this.store === null) {\n        throw new Error('Datastore needs to be opened.');\n      }\n\n      var it = queryIt(q, this.store, this.location);\n\n      if (Array.isArray(q.filters)) {\n        it = q.filters.reduce(function (it, f) {\n          return filter(it, f);\n        }, it);\n      }\n\n      if (Array.isArray(q.orders)) {\n        it = q.orders.reduce(function (it, f) {\n          return sortAll(it, f);\n        }, it);\n      }\n\n      return it;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.store === null) {\n        throw new Error('Datastore needs to be opened.');\n      }\n\n      this.store.close();\n      this.store = null;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      return deleteDB(this.location);\n    }\n  }]);\n\n  return IdbDatastore;\n}(Adapter);\n\nmodule.exports = IdbDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-idb/src/index.js"],"names":["require","Buffer","openDB","deleteDB","Key","Errors","utils","Adapter","filter","sortAll","isStrictTypedArray","arr","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Float32Array","Float64Array","typedarrayToBuffer","buf","from","buffer","byteLength","slice","byteOffset","str2ab","str","ArrayBuffer","length","bufView","i","strLen","charCodeAt","queryIt","q","store","location","range","prefix","self","IDBKeyRange","bound","undefined","transaction","openCursor","cursor","limit","offset","advance","key","keysOnly","value","continue","IdbDatastore","options","version","upgrade","db","createObjectStore","dbOpenFailedError","val","Error","put","toBuffer","dbWriteFailedError","get","notFoundError","code","delete","dbDeleteFailedError","puts","dels","push","commit","tx","Promise","all","map","p","done","it","Array","isArray","filters","reduce","f","orders","close","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst { openDB, deleteDB } = require('idb')\nconst { Key, Errors, utils, Adapter } = require('interface-datastore')\nconst { filter, sortAll } = utils\n\nconst isStrictTypedArray = (arr) => {\n  return (\n    arr instanceof Int8Array ||\n    arr instanceof Int16Array ||\n    arr instanceof Int32Array ||\n    arr instanceof Uint8Array ||\n    arr instanceof Uint8ClampedArray ||\n    arr instanceof Uint16Array ||\n    arr instanceof Uint32Array ||\n    arr instanceof Float32Array ||\n    arr instanceof Float64Array\n  )\n}\n\nconst typedarrayToBuffer = (arr) => {\n  if (isStrictTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    let buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n\nconst str2ab = (str) => {\n  const buf = new ArrayBuffer(str.length)\n  const bufView = new Uint8Array(buf)\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i)\n  }\n  return buf\n}\n\nconst queryIt = async function * (q, store, location) {\n  const range = q.prefix ? self.IDBKeyRange.bound(str2ab(q.prefix), str2ab(q.prefix + '\\xFF'), false, true) : undefined\n  let cursor = await store.transaction(location).store.openCursor(range)\n  let limit = 0\n\n  if (cursor && q.offset && q.offset > 0) {\n    cursor = await cursor.advance(q.offset)\n  }\n\n  while (cursor) {\n    // limit\n    if (q.limit !== undefined && q.limit === limit) {\n      return\n    }\n    limit++\n\n    const key = new Key(Buffer.from(cursor.key))\n    if (q.keysOnly) {\n      yield { key }\n    } else {\n      const value = Buffer.from(cursor.value)\n      yield { key, value }\n    }\n    cursor = await cursor.continue()\n  }\n}\n\nclass IdbDatastore extends Adapter {\n  constructor (location, options = {}) {\n    super()\n\n    this.store = null\n    this.options = options\n    this.location = options.prefix + location\n    this.version = options.version || 1\n  }\n\n  async open () {\n    if (this.store !== null) {\n      return\n    }\n\n    const location = this.location\n    try {\n      this.store = await openDB(this.location, this.version, {\n        upgrade (db) {\n          db.createObjectStore(location)\n        }\n      })\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  async put (key, val) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    try {\n      await this.store.put(this.location, val, key.toBuffer())\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  async get (key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    let value\n    try {\n      value = await this.store.get(this.location, key.toBuffer())\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n\n    if (!value) {\n      throw Errors.notFoundError()\n    }\n\n    return typedarrayToBuffer(value)\n  }\n\n  async has (key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    try {\n      await this.get(key)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') return false\n      throw err\n    }\n    return true\n  }\n\n  async delete (key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    try {\n      await this.store.delete(this.location, key.toBuffer())\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  batch () {\n    const puts = []\n    const dels = []\n\n    return {\n      put (key, value) {\n        puts.push([key.toBuffer(), value])\n      },\n      delete (key) {\n        dels.push(key.toBuffer())\n      },\n      commit: async () => {\n        if (this.store === null) {\n          throw new Error('Datastore needs to be opened.')\n        }\n        const tx = this.store.transaction(this.location, 'readwrite')\n        const store = tx.store\n        await Promise.all(puts.map(p => store.put(p[1], p[0])))\n        await Promise.all(dels.map(p => store.delete(p)))\n        await tx.done\n      }\n    }\n  }\n\n  query (q) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    let it = queryIt(q, this.store, this.location)\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    return it\n  }\n\n  close () {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    this.store.close()\n    this.store = null\n  }\n\n  destroy () {\n    return deleteDB(this.location)\n  }\n}\n\nmodule.exports = IdbDatastore\n"]},"metadata":{},"sourceType":"script"}