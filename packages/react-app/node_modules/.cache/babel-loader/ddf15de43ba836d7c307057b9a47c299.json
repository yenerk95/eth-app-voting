{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst {\n  cidToString\n} = require('../../../utils/cid');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  MFS_ROOT_KEY,\n  withTimeoutOption\n} = require('../../utils');\n\nconst Repo = require('ipfs-repo');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst {\n  parallelMerge,\n  transform,\n  map\n} = require('streaming-iterables'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256; // Perform mark and sweep garbage collection\n\nmodule.exports = ({\n  gcLock,\n  pin,\n  pinManager,\n  refs,\n  repo\n}) => {\n  return withTimeoutOption(async function* gc(options = {}) {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pin,\n        pinManager,\n        refs,\n        repo\n      }); // Get all blocks keys from the blockstore\n\n      const blockKeys = repo.blocks.query({\n        keysOnly: true\n      }); // Delete blocks that are not being used\n\n      yield* deleteUnmarkedBlocks({\n        repo,\n        refs\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  });\n}; // Get Set of CIDs of blocks to keep\n\n\nasync function createMarkedSet({\n  pin,\n  pinManager,\n  refs,\n  repo\n}) {\n  const pinsSource = map(({\n    cid\n  }) => cid, pin.ls());\n\n  const pinInternalsSource = async function* () {\n    const cids = await pinManager.getInternalBlocks();\n    yield* cids;\n  }();\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = new CID(mh);\n    yield rootCid;\n\n    for await (const {\n      ref\n    } of refs(rootCid, {\n      recursive: true\n    })) {\n      yield new CID(ref);\n    }\n  }();\n\n  const output = new Set();\n\n  for await (const cid of parallelMerge(pinsSource, pinInternalsSource, mfsSource)) {\n    output.add(cidToString(cid, {\n      base: 'base32'\n    }));\n  }\n\n  return output;\n} // Delete all blocks that are not marked as in use\n\n\nasync function* deleteUnmarkedBlocks({\n  repo,\n  refs\n}, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n\n  const removeBlock = async ({\n    key: k\n  }) => {\n    blocksCount++;\n\n    try {\n      const cid = Repo.utils.blockstore.keyToCid(k);\n      const b32 = cid.toV1().toString('base32');\n      if (markedSet.has(b32)) return null;\n      const res = {\n        cid\n      };\n\n      try {\n        await repo.blocks.delete(cid);\n        removedBlocksCount++;\n      } catch (err) {\n        res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`);\n      }\n\n      return res;\n    } catch (err) {\n      const msg = `Could not convert block with key '${k}' to CID`;\n      log(msg, err);\n      return {\n        err: new Error(msg + `: ${err.message}`)\n      };\n    }\n  };\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res;\n  }\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/repo/gc.js"],"names":["CID","require","cidToString","log","MFS_ROOT_KEY","withTimeoutOption","Repo","Errors","ERR_NOT_FOUND","notFoundError","code","parallelMerge","transform","map","BLOCK_RM_CONCURRENCY","module","exports","gcLock","pin","pinManager","refs","repo","gc","options","start","Date","now","release","writeLock","markedSet","createMarkedSet","blockKeys","blocks","query","keysOnly","deleteUnmarkedBlocks","pinsSource","cid","ls","pinInternalsSource","cids","getInternalBlocks","mfsSource","mh","root","get","err","rootCid","ref","recursive","output","Set","add","base","blocksCount","removedBlocksCount","removeBlock","key","k","utils","blockstore","keyToCid","b32","toV1","toString","has","res","delete","Error","message","msg","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst { cidToString } = require('../../../utils/cid')\nconst log = require('debug')('ipfs:repo:gc')\nconst { MFS_ROOT_KEY, withTimeoutOption } = require('../../utils')\nconst Repo = require('ipfs-repo')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst { parallelMerge, transform, map } = require('streaming-iterables')\n\n// Limit on the number of parallel block remove operations\nconst BLOCK_RM_CONCURRENCY = 256\n\n// Perform mark and sweep garbage collection\nmodule.exports = ({ gcLock, pin, pinManager, refs, repo }) => {\n  return withTimeoutOption(async function * gc (options = {}) {\n    const start = Date.now()\n    log('Creating set of marked blocks')\n\n    const release = await gcLock.writeLock()\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({ pin, pinManager, refs, repo })\n      // Get all blocks keys from the blockstore\n      const blockKeys = repo.blocks.query({ keysOnly: true })\n\n      // Delete blocks that are not being used\n      yield * deleteUnmarkedBlocks({ repo, refs }, markedSet, blockKeys)\n\n      log(`Complete (${Date.now() - start}ms)`)\n    } finally {\n      release()\n    }\n  })\n}\n\n// Get Set of CIDs of blocks to keep\nasync function createMarkedSet ({ pin, pinManager, refs, repo }) {\n  const pinsSource = map(({ cid }) => cid, pin.ls())\n\n  const pinInternalsSource = (async function * () {\n    const cids = await pinManager.getInternalBlocks()\n    yield * cids\n  })()\n\n  const mfsSource = (async function * () {\n    let mh\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS')\n        return\n      }\n      throw err\n    }\n\n    const rootCid = new CID(mh)\n    yield rootCid\n\n    for await (const { ref } of refs(rootCid, { recursive: true })) {\n      yield new CID(ref)\n    }\n  })()\n\n  const output = new Set()\n  for await (const cid of parallelMerge(pinsSource, pinInternalsSource, mfsSource)) {\n    output.add(cidToString(cid, { base: 'base32' }))\n  }\n  return output\n}\n\n// Delete all blocks that are not marked as in use\nasync function * deleteUnmarkedBlocks ({ repo, refs }, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0\n  let removedBlocksCount = 0\n\n  const removeBlock = async ({ key: k }) => {\n    blocksCount++\n\n    try {\n      const cid = Repo.utils.blockstore.keyToCid(k)\n      const b32 = cid.toV1().toString('base32')\n      if (markedSet.has(b32)) return null\n      const res = { cid }\n\n      try {\n        await repo.blocks.delete(cid)\n        removedBlocksCount++\n      } catch (err) {\n        res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`)\n      }\n\n      return res\n    } catch (err) {\n      const msg = `Could not convert block with key '${k}' to CID`\n      log(msg, err)\n      return { err: new Error(msg + `: ${err.message}`) }\n    }\n  }\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res\n  }\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` +\n  `Deleted ${removedBlocksCount} blocks.`)\n}\n"]},"metadata":{},"sourceType":"script"}