{"ast":null,"code":"const getIterator = require('get-iterator');\n\nconst defer = require('p-defer');\n\nmodule.exports = writable => async source => {\n  source = getIterator(source);\n  const errPromise = defer();\n  const closePromise = defer();\n  const endingPromise = defer();\n  const finishPromise = defer();\n  let drainPromise;\n\n  const errorHandler = err => errPromise.reject(err);\n\n  const closeHandler = () => closePromise.resolve({\n    closed: true\n  });\n\n  const finishHandler = () => finishPromise.resolve({\n    finished: true\n  });\n\n  const drainHandler = () => {\n    if (drainPromise) drainPromise.resolve({\n      drained: true\n    });\n  }; // There's no event to determine the start of a call to .end()\n\n\n  const _end = writable.end.bind(writable);\n\n  writable.end = (...args) => {\n    endingPromise.resolve({\n      ending: true\n    });\n    return _end(...args);\n  };\n\n  writable.on('error', errorHandler).on('close', closeHandler).on('finish', finishHandler).on('drain', drainHandler);\n\n  const getNext = async () => {\n    try {\n      return source.next();\n    } catch (err) {\n      writable.destroy(err);\n      return errPromise.promise;\n    }\n  };\n\n  try {\n    while (true) {\n      // Race the iterator and the error, close and finish listener\n      const result = await Promise.race([errPromise.promise, closePromise.promise, endingPromise.promise, finishPromise.promise, getNext()]);\n\n      if (result.closed || result.finished) {\n        break;\n      } // .end() was called, waiting on flush (finish event)\n\n\n      if (result.ending) {\n        await Promise.race([errPromise.promise, // TODO: do we need to wait on close? If slow end and destroy is\n        // called then what is emitted? close or finish?\n        closePromise.promise, finishPromise.promise]);\n        break;\n      } // If destroyed, race err & close to determine reason & then throw/break\n\n\n      if (writable.destroyed) {\n        await Promise.race([errPromise.promise, closePromise.promise]);\n        break;\n      }\n\n      if (result.done) {\n        writable.end();\n        await Promise.race([errPromise.promise, // TODO: do we need to wait on close? If slow end and destroy is\n        // called then what is emitted? close or finish?\n        closePromise.promise, finishPromise.promise]);\n        break;\n      }\n\n      if (!writable.write(result.value)) {\n        drainPromise = defer();\n        await Promise.race([errPromise.promise, closePromise.promise, finishPromise.promise, drainPromise.promise]);\n      }\n    }\n  } finally {\n    writable.removeListener('error', errorHandler).removeListener('close', closeHandler).removeListener('finish', finishHandler).removeListener('drain', drainHandler); // End the iterator if it is a generator\n\n    if (typeof source.return === 'function') {\n      await source.return();\n    }\n  }\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/stream-to-it/sink.js"],"names":["getIterator","require","defer","module","exports","writable","source","errPromise","closePromise","endingPromise","finishPromise","drainPromise","errorHandler","err","reject","closeHandler","resolve","closed","finishHandler","finished","drainHandler","drained","_end","end","bind","args","ending","on","getNext","next","destroy","promise","result","Promise","race","destroyed","done","write","value","removeListener","return"],"mappings":"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","sourcesContent":["const getIterator = require('get-iterator')\nconst defer = require('p-defer')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const errPromise = defer()\n  const closePromise = defer()\n  const endingPromise = defer()\n  const finishPromise = defer()\n  let drainPromise\n\n  const errorHandler = err => errPromise.reject(err)\n  const closeHandler = () => closePromise.resolve({ closed: true })\n  const finishHandler = () => finishPromise.resolve({ finished: true })\n  const drainHandler = () => {\n    if (drainPromise) drainPromise.resolve({ drained: true })\n  }\n\n  // There's no event to determine the start of a call to .end()\n  const _end = writable.end.bind(writable)\n  writable.end = (...args) => {\n    endingPromise.resolve({ ending: true })\n    return _end(...args)\n  }\n\n  writable\n    .on('error', errorHandler)\n    .on('close', closeHandler)\n    .on('finish', finishHandler)\n    .on('drain', drainHandler)\n\n  const getNext = async () => {\n    try {\n      return source.next()\n    } catch (err) {\n      writable.destroy(err)\n      return errPromise.promise\n    }\n  }\n\n  try {\n    while (true) {\n      // Race the iterator and the error, close and finish listener\n      const result = await Promise.race([\n        errPromise.promise,\n        closePromise.promise,\n        endingPromise.promise,\n        finishPromise.promise,\n        getNext()\n      ])\n\n      if (result.closed || result.finished) {\n        break\n      }\n\n      // .end() was called, waiting on flush (finish event)\n      if (result.ending) {\n        await Promise.race([\n          errPromise.promise,\n          // TODO: do we need to wait on close? If slow end and destroy is\n          // called then what is emitted? close or finish?\n          closePromise.promise,\n          finishPromise.promise\n        ])\n        break\n      }\n\n      // If destroyed, race err & close to determine reason & then throw/break\n      if (writable.destroyed) {\n        await Promise.race([\n          errPromise.promise,\n          closePromise.promise\n        ])\n        break\n      }\n\n      if (result.done) {\n        writable.end()\n        await Promise.race([\n          errPromise.promise,\n          // TODO: do we need to wait on close? If slow end and destroy is\n          // called then what is emitted? close or finish?\n          closePromise.promise,\n          finishPromise.promise\n        ])\n        break\n      }\n\n      if (!writable.write(result.value)) {\n        drainPromise = defer()\n        await Promise.race([\n          errPromise.promise,\n          closePromise.promise,\n          finishPromise.promise,\n          drainPromise.promise\n        ])\n      }\n    }\n  } finally {\n    writable\n      .removeListener('error', errorHandler)\n      .removeListener('close', closeHandler)\n      .removeListener('finish', finishHandler)\n      .removeListener('drain', drainHandler)\n\n    // End the iterator if it is a generator\n    if (typeof source.return === 'function') {\n      await source.return()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}