{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar log = require('debug')('mss:select');\n\nvar errCode = require('err-code');\n\nvar multistream = require('./multistream');\n\nvar handshake = require('it-handshake');\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(stream, protocols, protocolId) {\n    var _handshake, reader, writer, rest, shakeStream, protocol, response, _iterator, _step, _protocol, _response;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            protocols = Array.isArray(protocols) ? _toConsumableArray(protocols) : [protocols];\n            _handshake = handshake(stream), reader = _handshake.reader, writer = _handshake.writer, rest = _handshake.rest, shakeStream = _handshake.stream;\n            protocol = protocols.shift();\n\n            if (protocolId) {\n              log('select: write [\"%s\", \"%s\"]', protocolId, protocol);\n              multistream.writeAll(writer, [protocolId, protocol]);\n            } else {\n              log('select: write \"%s\"', protocol);\n              multistream.write(writer, protocol);\n            }\n\n            _context.next = 6;\n            return multistream.read(reader);\n\n          case 6:\n            response = _context.sent.toString();\n            log('select: read \"%s\"', response); // Read the protocol response if we got the protocolId in return\n\n            if (!(response === protocolId)) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.next = 11;\n            return multistream.read(reader);\n\n          case 11:\n            response = _context.sent.toString();\n            log('select: read \"%s\"', response);\n\n          case 13:\n            if (!(response === protocol)) {\n              _context.next = 16;\n              break;\n            }\n\n            rest();\n            return _context.abrupt(\"return\", {\n              stream: shakeStream,\n              protocol: protocol\n            });\n\n          case 16:\n            // We haven't gotten a valid ack, try the other protocols\n            _iterator = _createForOfIteratorHelper(protocols);\n            _context.prev = 17;\n\n            _iterator.s();\n\n          case 19:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 32;\n              break;\n            }\n\n            _protocol = _step.value;\n            log('select: write \"%s\"', _protocol);\n            multistream.write(writer, _protocol);\n            _context.next = 25;\n            return multistream.read(reader);\n\n          case 25:\n            _response = _context.sent.toString();\n            log('select: read \"%s\" for \"%s\"', _response, _protocol);\n\n            if (!(_response === _protocol)) {\n              _context.next = 30;\n              break;\n            }\n\n            rest(); // End our writer so others can start writing to stream\n\n            return _context.abrupt(\"return\", {\n              stream: shakeStream,\n              protocol: _protocol\n            });\n\n          case 30:\n            _context.next = 19;\n            break;\n\n          case 32:\n            _context.next = 37;\n            break;\n\n          case 34:\n            _context.prev = 34;\n            _context.t0 = _context[\"catch\"](17);\n\n            _iterator.e(_context.t0);\n\n          case 37:\n            _context.prev = 37;\n\n            _iterator.f();\n\n            return _context.finish(37);\n\n          case 40:\n            rest();\n            throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL');\n\n          case 42:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[17, 34, 37, 40]]);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/multistream-select/src/select.js"],"names":["log","require","errCode","multistream","handshake","module","exports","stream","protocols","protocolId","Array","isArray","reader","writer","rest","shakeStream","protocol","shift","writeAll","write","read","response","toString","Error"],"mappings":"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","sourcesContent":["'use strict'\n\nconst log = require('debug')('mss:select')\nconst errCode = require('err-code')\nconst multistream = require('./multistream')\nconst handshake = require('it-handshake')\n\nmodule.exports = async (stream, protocols, protocolId) => {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n  const { reader, writer, rest, stream: shakeStream } = handshake(stream)\n\n  const protocol = protocols.shift()\n  if (protocolId) {\n    log('select: write [\"%s\", \"%s\"]', protocolId, protocol)\n    multistream.writeAll(writer, [protocolId, protocol])\n  } else {\n    log('select: write \"%s\"', protocol)\n    multistream.write(writer, protocol)\n  }\n\n  let response = (await multistream.read(reader)).toString()\n  log('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === protocolId) {\n    response = (await multistream.read(reader)).toString()\n    log('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    rest()\n    return { stream: shakeStream, protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    log('select: write \"%s\"', protocol)\n    multistream.write(writer, protocol)\n    const response = (await multistream.read(reader)).toString()\n    log('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      rest() // End our writer so others can start writing to stream\n      return { stream: shakeStream, protocol }\n    }\n  }\n\n  rest()\n  throw errCode(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL')\n}\n"]},"metadata":{},"sourceType":"script"}