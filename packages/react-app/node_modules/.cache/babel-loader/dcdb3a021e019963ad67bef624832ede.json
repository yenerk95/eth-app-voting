{"ast":null,"code":"import _regeneratorRuntime from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nfunction _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _asyncIterator(iterable) {\n  var method;\n\n  if (typeof Symbol !== \"undefined\") {\n    if (Symbol.asyncIterator) {\n      method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      method = iterable[Symbol.iterator];\n      if (method != null) return method.call(iterable);\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nimport { Buffer } from \"buffer\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from \"./constants\"; // Returns generator that encrypts payload from the user\n\nexport function encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, chunkBuffer, i, end, data;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 2;\n              _iterator = _asyncIterator(source);\n\n            case 4:\n              _context.next = 6;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 6:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 10;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 10:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 27;\n                break;\n              }\n\n              chunk = _value;\n              chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n              i = 0;\n\n            case 15:\n              if (!(i < chunkBuffer.length)) {\n                _context.next = 24;\n                break;\n              }\n\n              end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n              if (end > chunkBuffer.length) {\n                end = chunkBuffer.length;\n              }\n\n              data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n              _context.next = 21;\n              return data;\n\n            case 21:\n              i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n              _context.next = 15;\n              break;\n\n            case 24:\n              _iteratorNormalCompletion = true;\n              _context.next = 4;\n              break;\n\n            case 27:\n              _context.next = 33;\n              break;\n\n            case 29:\n              _context.prev = 29;\n              _context.t0 = _context[\"catch\"](2);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 33:\n              _context.prev = 33;\n              _context.prev = 34;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 38;\n                break;\n              }\n\n              _context.next = 38;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 38:\n              _context.prev = 38;\n\n              if (!_didIteratorError) {\n                _context.next = 41;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 41:\n              return _context.finish(38);\n\n            case 42:\n              return _context.finish(33);\n\n            case 43:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 29, 33, 43], [34,, 38, 42]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n} // Decrypt received payload to the user\n\nexport function decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk, chunkBuffer, i, end, _chunk, _yield$_awaitAsyncGen, decrypted, valid;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _context2.prev = 2;\n              _iterator2 = _asyncIterator(source);\n\n            case 4:\n              _context2.next = 6;\n              return _awaitAsyncGenerator(_iterator2.next());\n\n            case 6:\n              _step2 = _context2.sent;\n              _iteratorNormalCompletion2 = _step2.done;\n              _context2.next = 10;\n              return _awaitAsyncGenerator(_step2.value);\n\n            case 10:\n              _value2 = _context2.sent;\n\n              if (_iteratorNormalCompletion2) {\n                _context2.next = 34;\n                break;\n              }\n\n              chunk = _value2;\n              chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n              i = 0;\n\n            case 15:\n              if (!(i < chunkBuffer.length)) {\n                _context2.next = 31;\n                break;\n              }\n\n              end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n\n              if (end > chunkBuffer.length) {\n                end = chunkBuffer.length;\n              }\n\n              _chunk = chunkBuffer.slice(i, end);\n              _context2.next = 21;\n              return _awaitAsyncGenerator(handshake.decrypt(_chunk, handshake.session));\n\n            case 21:\n              _yield$_awaitAsyncGen = _context2.sent;\n              decrypted = _yield$_awaitAsyncGen.plaintext;\n              valid = _yield$_awaitAsyncGen.valid;\n\n              if (valid) {\n                _context2.next = 26;\n                break;\n              }\n\n              throw new Error(\"Failed to validate decrypted chunk\");\n\n            case 26:\n              _context2.next = 28;\n              return decrypted;\n\n            case 28:\n              i += NOISE_MSG_MAX_LENGTH_BYTES;\n              _context2.next = 15;\n              break;\n\n            case 31:\n              _iteratorNormalCompletion2 = true;\n              _context2.next = 4;\n              break;\n\n            case 34:\n              _context2.next = 40;\n              break;\n\n            case 36:\n              _context2.prev = 36;\n              _context2.t0 = _context2[\"catch\"](2);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context2.t0;\n\n            case 40:\n              _context2.prev = 40;\n              _context2.prev = 41;\n\n              if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                _context2.next = 45;\n                break;\n              }\n\n              _context2.next = 45;\n              return _awaitAsyncGenerator(_iterator2.return());\n\n            case 45:\n              _context2.prev = 45;\n\n              if (!_didIteratorError2) {\n                _context2.next = 48;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 48:\n              return _context2.finish(45);\n\n            case 49:\n              return _context2.finish(40);\n\n            case 50:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[2, 36, 40, 50], [41,, 45, 49]]);\n    }));\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"sources":["../src/crypto.ts"],"names":["chunk","chunkBuffer","Buffer","i","end","data","handshake","plaintext","valid"],"mappings":"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","sourcesContent":["import { Buffer } from \"buffer\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG} from \"./constants\";\n\ninterface IReturnEncryptionWrapper {\n  (source: Iterable<Uint8Array>): AsyncIterableIterator<Uint8Array>;\n}\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  }\n}\n\n\n// Decrypt received payload to the user\nexport function decryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n        const {plaintext: decrypted, valid} = await handshake.decrypt(chunk, handshake.session);\n        if(!valid) {\n          throw new Error(\"Failed to validate decrypted chunk\");\n        }\n        yield decrypted;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}