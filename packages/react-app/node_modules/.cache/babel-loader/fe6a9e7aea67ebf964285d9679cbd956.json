{"ast":null,"code":"'use strict';\n\nconst pipe = require('it-pipe');\n\nconst pushable = require('it-pushable');\n\nconst log = require('debug')('libp2p:mplex');\n\nconst abortable = require('abortable-iterator');\n\nconst Coder = require('./coder');\n\nconst restrictSize = require('./restrict-size');\n\nconst {\n  MessageTypes,\n  MessageTypeNames\n} = require('./message-types');\n\nconst createStream = require('./stream');\n\nclass Mplex {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {function(*)} options.onStream Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd Called whenever a stream ends\n   * @param {AbortSignal} options.signal An AbortController signal\n   */\n  constructor(options) {\n    options = options || {};\n    options = typeof options === 'function' ? {\n      onStream: options\n    } : options;\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._options = options;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    this.source = this._createSource();\n    /**\n     * @property {function} onStream\n     */\n\n    this.onStream = options.onStream;\n    /**\n     * @property {function} onStreamEnd\n     */\n\n    this.onStreamEnd = options.onStreamEnd;\n  }\n  /**\n   * Returns a Map of streams and their ids\n   * @returns {Map<number,*>}\n   */\n\n\n  get streams() {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = [];\n\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream);\n    });\n\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream);\n    });\n\n    return streams;\n  }\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   * @param {string} [name] If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n\n\n  newStream(name) {\n    const id = this._streamId++;\n    name = name == null ? id.toString() : String(name);\n    const registry = this._streams.initiators;\n    return this._newStream({\n      id,\n      name,\n      type: 'initiator',\n      registry\n    });\n  }\n  /**\n   * Called whenever an inbound stream is created\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n\n\n  _newReceiverStream({\n    id,\n    name\n  }) {\n    const registry = this._streams.receivers;\n    return this._newStream({\n      id,\n      name,\n      type: 'receiver',\n      registry\n    });\n  }\n  /**\n   * Creates a new stream\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n\n\n  _newStream({\n    id,\n    name,\n    type,\n    registry\n  }) {\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`);\n    }\n\n    log('new %s stream %s %s', type, id, name);\n\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg,\n          type: MessageTypeNames[msg.type],\n          data: msg.data && msg.data.slice()\n        });\n      }\n\n      return this.source.push(msg);\n    };\n\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name);\n      registry.delete(id);\n      this.onStreamEnd && this.onStreamEnd(stream);\n    };\n\n    const stream = createStream({\n      id,\n      name,\n      send,\n      type,\n      onEnd,\n      maxMsgSize: this._options.maxMsgSize\n    });\n    registry.set(id, stream);\n    return stream;\n  }\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n\n\n  _createSink() {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal);\n      }\n\n      try {\n        await pipe(source, Coder.decode, restrictSize(this._options.maxMsgSize), async source => {\n          for await (const msgs of source) {\n            for (const msg of msgs) {\n              this._handleIncoming(msg);\n            }\n          }\n        });\n      } catch (err) {\n        log('error in sink', err);\n        return this.source.end(err); // End the source with an error\n      }\n\n      this.source.end();\n    };\n  }\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   * @private\n   * @returns {*} An iterable source\n   */\n\n\n  _createSource() {\n    const onEnd = err => {\n      const {\n        initiators,\n        receivers\n      } = this._streams; // Abort all the things!\n\n      for (const s of initiators.values()) s.abort(err);\n\n      for (const s of receivers.values()) s.abort(err);\n    };\n\n    const source = pushable({\n      onEnd,\n      writev: true\n    });\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    });\n  }\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Buffer|BufferList} options.data\n   * @returns {void}\n   */\n\n\n  _handleIncoming({\n    id,\n    type,\n    data\n  }) {\n    if (log.enabled) {\n      log('incoming message', {\n        id,\n        type: MessageTypeNames[type],\n        data: data.slice()\n      });\n    } // Create a new stream?\n\n\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({\n        id,\n        name: data.toString()\n      });\n\n      return this.onStream(stream);\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers;\n    const stream = list.get(id);\n    if (!stream) return log('missing stream %s', id);\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data);\n        break;\n\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close();\n        break;\n\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset();\n        break;\n\n      default:\n        log('unknown message type %s', type);\n    }\n  }\n\n}\n\nMplex.multicodec = '/mplex/6.7.0';\nmodule.exports = Mplex;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-mplex/src/mplex.js"],"names":["pipe","require","pushable","log","abortable","Coder","restrictSize","MessageTypes","MessageTypeNames","createStream","Mplex","constructor","options","onStream","_streamId","_streams","initiators","Map","receivers","_options","sink","_createSink","source","_createSource","onStreamEnd","streams","forEach","stream","push","newStream","name","id","toString","String","registry","_newStream","type","_newReceiverStream","has","Error","send","msg","enabled","data","slice","onEnd","delete","maxMsgSize","set","signal","decode","msgs","_handleIncoming","err","end","s","values","abort","writev","Object","assign","encode","return","NEW_STREAM","list","get","MESSAGE_INITIATOR","MESSAGE_RECEIVER","CLOSE_INITIATOR","CLOSE_RECEIVER","close","RESET_INITIATOR","RESET_RECEIVER","reset","multicodec","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pipe = require('it-pipe')\nconst pushable = require('it-pushable')\nconst log = require('debug')('libp2p:mplex')\nconst abortable = require('abortable-iterator')\nconst Coder = require('./coder')\nconst restrictSize = require('./restrict-size')\nconst { MessageTypes, MessageTypeNames } = require('./message-types')\nconst createStream = require('./stream')\n\nclass Mplex {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {function(*)} options.onStream Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd Called whenever a stream ends\n   * @param {AbortSignal} options.signal An AbortController signal\n   */\n  constructor (options) {\n    options = options || {}\n    options = typeof options === 'function' ? { onStream: options } : options\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    }\n    this._options = options\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    this.source = this._createSource()\n\n    /**\n     * @property {function} onStream\n     */\n    this.onStream = options.onStream\n\n    /**\n     * @property {function} onStreamEnd\n     */\n    this.onStreamEnd = options.onStreamEnd\n  }\n\n  /**\n   * Returns a Map of streams and their ids\n   * @returns {Map<number,*>}\n   */\n  get streams () {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = []\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream)\n    })\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream)\n    })\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   * @param {string} [name] If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n  newStream (name) {\n    const id = this._streamId++\n    name = name == null ? id.toString() : String(name)\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n  _newReceiverStream ({ id, name }) {\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  /**\n   * Creates a new stream\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n  _newStream ({ id, name, type, registry }) {\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n    log('new %s stream %s %s', type, id, name)\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() })\n      }\n      return this.source.push(msg)\n    }\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name)\n      registry.delete(id)\n      this.onStreamEnd && this.onStreamEnd(stream)\n    }\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n  _createSink () {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal)\n      }\n\n      try {\n        await pipe(\n          source,\n          Coder.decode,\n          restrictSize(this._options.maxMsgSize),\n          async source => {\n            for await (const msgs of source) {\n              for (const msg of msgs) {\n                this._handleIncoming(msg)\n              }\n            }\n          }\n        )\n      } catch (err) {\n        log('error in sink', err)\n        return this.source.end(err) // End the source with an error\n      }\n\n      this.source.end()\n    }\n  }\n\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   * @private\n   * @returns {*} An iterable source\n   */\n  _createSource () {\n    const onEnd = err => {\n      const { initiators, receivers } = this._streams\n      // Abort all the things!\n      for (const s of initiators.values()) s.abort(err)\n      for (const s of receivers.values()) s.abort(err)\n    }\n    const source = pushable({ onEnd, writev: true })\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    })\n  }\n\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Buffer|BufferList} options.data\n   * @returns {void}\n   */\n  _handleIncoming ({ id, type, data }) {\n    if (log.enabled) {\n      log('incoming message', { id, type: MessageTypeNames[type], data: data.slice() })\n    }\n\n    // Create a new stream?\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({ id, name: data.toString() })\n      return this.onStream(stream)\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (!stream) return log('missing stream %s', id)\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data)\n        break\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close()\n        break\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset()\n        break\n      default:\n        log('unknown message type %s', type)\n    }\n  }\n}\n\nMplex.multicodec = '/mplex/6.7.0'\n\nmodule.exports = Mplex\n"]},"metadata":{},"sourceType":"script"}