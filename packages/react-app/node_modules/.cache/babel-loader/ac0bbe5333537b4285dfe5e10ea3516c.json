{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nmodule.exports = function (_ref) {\n  var libp2p = _ref.libp2p;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _peers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n      var verbose, peers, _iterator, _step, _step$value, peerId, connections, _iterator2, _step2, connection, tupple;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              options = options || {};\n              verbose = options.v || options.verbose;\n              peers = [];\n              _iterator = _createForOfIteratorHelper(libp2p.connections);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _step$value = _slicedToArray(_step.value, 2), peerId = _step$value[0], connections = _step$value[1];\n                  _iterator2 = _createForOfIteratorHelper(connections);\n\n                  try {\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      connection = _step2.value;\n                      tupple = {\n                        addr: connection.remoteAddr,\n                        peer: peerId\n                      };\n\n                      if (verbose || options.direction) {\n                        tupple.direction = connection.stat.direction;\n                      }\n\n                      if (verbose) {\n                        tupple.muxer = connection.stat.multiplexer;\n                        tupple.latency = 'n/a';\n                      }\n\n                      peers.push(tupple);\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              return _context.abrupt(\"return\", peers);\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function peers(_x) {\n      return _peers.apply(this, arguments);\n    }\n\n    return peers;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/swarm/peers.js"],"names":["require","withTimeoutOption","module","exports","libp2p","options","verbose","v","peers","connections","peerId","connection","tupple","addr","remoteAddr","peer","direction","stat","muxer","multiplexer","latency","push"],"mappings":"AAAA;;;;;;;;;;eAE8BA,OAAO,CAAC,aAAD,C;IAA7BC,iB,YAAAA,iB;;AAERC,MAAM,CAACC,OAAP,GAAiB,gBAAgB;AAAA,MAAbC,MAAa,QAAbA,MAAa;AAC/B,SAAOH,iBAAiB;AAAA,0EAAC,iBAAsBI,OAAtB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAiC;AACxDA,cAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEMC,cAAAA,OAHiB,GAGPD,OAAO,CAACE,CAAR,IAAaF,OAAO,CAACC,OAHd;AAIjBE,cAAAA,KAJiB,GAIT,EAJS;AAAA,qDAMaJ,MAAM,CAACK,WANpB;;AAAA;AAMvB,oEAAwD;AAAA,gEAA5CC,MAA4C,mBAApCD,WAAoC;AAAA,0DAC7BA,WAD6B;;AAAA;AACtD,2EAAsC;AAA3BE,sBAAAA,UAA2B;AAC9BC,sBAAAA,MAD8B,GACrB;AACbC,wBAAAA,IAAI,EAAEF,UAAU,CAACG,UADJ;AAEbC,wBAAAA,IAAI,EAAEL;AAFO,uBADqB;;AAMpC,0BAAIJ,OAAO,IAAID,OAAO,CAACW,SAAvB,EAAkC;AAChCJ,wBAAAA,MAAM,CAACI,SAAP,GAAmBL,UAAU,CAACM,IAAX,CAAgBD,SAAnC;AACD;;AAED,0BAAIV,OAAJ,EAAa;AACXM,wBAAAA,MAAM,CAACM,KAAP,GAAeP,UAAU,CAACM,IAAX,CAAgBE,WAA/B;AACAP,wBAAAA,MAAM,CAACQ,OAAP,GAAiB,KAAjB;AACD;;AAEDZ,sBAAAA,KAAK,CAACa,IAAN,CAAWT,MAAX;AACD;AAjBqD;AAAA;AAAA;AAAA;AAAA;AAkBvD;AAxBsB;AAAA;AAAA;AAAA;AAAA;;AAAA,+CA0BhBJ,KA1BgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAD;;AAAA,aAAgBA,KAAhB;AAAA;AAAA;;AAAA,WAAgBA,KAAhB;AAAA,MAAxB;AA4BD,CA7BD","sourcesContent":["'use strict'\n\nconst { withTimeoutOption } = require('../../utils')\n\nmodule.exports = ({ libp2p }) => {\n  return withTimeoutOption(async function peers (options) { // eslint-disable-line require-await\n    options = options || {}\n\n    const verbose = options.v || options.verbose\n    const peers = []\n\n    for (const [peerId, connections] of libp2p.connections) {\n      for (const connection of connections) {\n        const tupple = {\n          addr: connection.remoteAddr,\n          peer: peerId\n        }\n\n        if (verbose || options.direction) {\n          tupple.direction = connection.stat.direction\n        }\n\n        if (verbose) {\n          tupple.muxer = connection.stat.multiplexer\n          tupple.latency = 'n/a'\n        }\n\n        peers.push(tupple)\n      }\n    }\n\n    return peers\n  })\n}\n"]},"metadata":{},"sourceType":"script"}