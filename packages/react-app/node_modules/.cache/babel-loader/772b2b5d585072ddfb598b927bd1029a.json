{"ast":null,"code":"'use strict';\n\nconst mafmt = require('mafmt');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst withIs = require('class-is');\n\nconst {\n  CircuitRelay: CircuitPB\n} = require('./protocol');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit');\nlog.error = debug('libp2p:circuit:error');\n\nconst toConnection = require('libp2p-utils/src/stream-to-ma-conn');\n\nconst {\n  relay: multicodec\n} = require('./multicodec');\n\nconst createListener = require('./listener');\n\nconst {\n  handleCanHop,\n  handleHop,\n  hop\n} = require('./circuit/hop');\n\nconst {\n  handleStop\n} = require('./circuit/stop');\n\nconst StreamHandler = require('./circuit/stream-handler');\n\nclass Circuit {\n  /**\n   * Creates an instance of Circuit.\n   *\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Upgrader} options.upgrader\n   */\n  constructor({\n    libp2p,\n    upgrader\n  }) {\n    this._dialer = libp2p.dialer;\n    this._registrar = libp2p.registrar;\n    this._connectionManager = libp2p.connectionManager;\n    this._upgrader = upgrader;\n    this._options = libp2p._config.relay;\n    this._libp2p = libp2p;\n    this.peerId = libp2p.peerId;\n\n    this._registrar.handle(multicodec, this._onProtocol.bind(this));\n  }\n\n  async _onProtocol({\n    connection,\n    stream,\n    protocol\n  }) {\n    const streamHandler = new StreamHandler({\n      stream\n    });\n    const request = await streamHandler.read();\n    const circuit = this;\n    let virtualConnection;\n\n    switch (request.type) {\n      case CircuitPB.Type.CAN_HOP:\n        {\n          log('received CAN_HOP request from %s', connection.remotePeer.toB58String());\n          await handleCanHop({\n            circuit,\n            connection,\n            streamHandler\n          });\n          break;\n        }\n\n      case CircuitPB.Type.HOP:\n        {\n          log('received HOP request from %s', connection.remotePeer.toB58String());\n          virtualConnection = await handleHop({\n            connection,\n            request,\n            streamHandler,\n            circuit\n          });\n          break;\n        }\n\n      case CircuitPB.Type.STOP:\n        {\n          log('received STOP request from %s', connection.remotePeer.toB58String());\n          virtualConnection = await handleStop({\n            connection,\n            request,\n            streamHandler,\n            circuit\n          });\n          break;\n        }\n\n      default:\n        {\n          log('Request of type %s not supported', request.type);\n        }\n    }\n\n    if (virtualConnection) {\n      const remoteAddr = multiaddr(request.dstPeer.addrs[0]);\n      const localAddr = multiaddr(request.srcPeer.addrs[0]);\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr,\n        localAddr\n      });\n      const type = CircuitPB.Type === CircuitPB.Type.HOP ? 'relay' : 'inbound';\n      log('new %s connection %s', type, maConn.remoteAddr);\n      const conn = await this._upgrader.upgradeInbound(maConn);\n      log('%s connection %s upgraded', type, maConn.remoteAddr);\n      this.handler && this.handler(conn);\n    }\n  }\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {AbortSignal} [options.signal] - An optional abort signal\n   * @returns {Connection} - the connection\n   */\n\n\n  async dial(ma, options) {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit');\n    const relayAddr = multiaddr(addrs[0]);\n    const destinationAddr = multiaddr(addrs[addrs.length - 1]);\n    const relayPeer = PeerId.createFromCID(relayAddr.getPeerId());\n    const destinationPeer = PeerId.createFromCID(destinationAddr.getPeerId());\n    let disconnectOnFailure = false;\n\n    let relayConnection = this._connectionManager.get(relayPeer);\n\n    if (!relayConnection) {\n      relayConnection = await this._dialer.connectToPeer(relayAddr, options);\n      disconnectOnFailure = true;\n    }\n\n    try {\n      const virtualConnection = await hop({\n        connection: relayConnection,\n        circuit: this,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.peerId.toBytes(),\n            addrs: this._libp2p.multiaddrs.map(addr => addr.buffer)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).buffer]\n          }\n        }\n      });\n      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`);\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      });\n      log('new outbound connection %s', maConn.remoteAddr);\n      return this._upgrader.upgradeOutbound(maConn);\n    } catch (err) {\n      log.error('Circuit relay dial failed', err);\n      disconnectOnFailure && (await relayConnection.close());\n      throw err;\n    }\n  }\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @return {listener}\n   */\n\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    } // Called on successful HOP and STOP requests\n\n\n    this.handler = handler;\n    return createListener(this, options);\n  }\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      return mafmt.Circuit.matches(ma);\n    });\n  }\n\n}\n/**\n * @type {Circuit}\n */\n\n\nmodule.exports = withIs(Circuit, {\n  className: 'Circuit',\n  symbolName: '@libp2p/js-libp2p-circuit/circuit'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/circuit/index.js"],"names":["mafmt","require","multiaddr","PeerId","withIs","CircuitRelay","CircuitPB","debug","log","error","toConnection","relay","multicodec","createListener","handleCanHop","handleHop","hop","handleStop","StreamHandler","Circuit","constructor","libp2p","upgrader","_dialer","dialer","_registrar","registrar","_connectionManager","connectionManager","_upgrader","_options","_config","_libp2p","peerId","handle","_onProtocol","bind","connection","stream","protocol","streamHandler","request","read","circuit","virtualConnection","type","Type","CAN_HOP","remotePeer","toB58String","HOP","STOP","remoteAddr","dstPeer","addrs","localAddr","srcPeer","maConn","conn","upgradeInbound","handler","dial","ma","options","toString","split","relayAddr","destinationAddr","length","relayPeer","createFromCID","getPeerId","destinationPeer","disconnectOnFailure","relayConnection","get","connectToPeer","id","toBytes","multiaddrs","map","addr","buffer","encapsulate","upgradeOutbound","err","close","filter","Array","isArray","matches","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mafmt = require('mafmt')\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\nconst withIs = require('class-is')\nconst { CircuitRelay: CircuitPB } = require('./protocol')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit')\nlog.error = debug('libp2p:circuit:error')\nconst toConnection = require('libp2p-utils/src/stream-to-ma-conn')\n\nconst { relay: multicodec } = require('./multicodec')\nconst createListener = require('./listener')\nconst { handleCanHop, handleHop, hop } = require('./circuit/hop')\nconst { handleStop } = require('./circuit/stop')\nconst StreamHandler = require('./circuit/stream-handler')\n\nclass Circuit {\n  /**\n   * Creates an instance of Circuit.\n   *\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Upgrader} options.upgrader\n   */\n  constructor ({ libp2p, upgrader }) {\n    this._dialer = libp2p.dialer\n    this._registrar = libp2p.registrar\n    this._connectionManager = libp2p.connectionManager\n    this._upgrader = upgrader\n    this._options = libp2p._config.relay\n    this._libp2p = libp2p\n    this.peerId = libp2p.peerId\n    this._registrar.handle(multicodec, this._onProtocol.bind(this))\n  }\n\n  async _onProtocol ({ connection, stream, protocol }) {\n    const streamHandler = new StreamHandler({ stream })\n    const request = await streamHandler.read()\n    const circuit = this\n    let virtualConnection\n\n    switch (request.type) {\n      case CircuitPB.Type.CAN_HOP: {\n        log('received CAN_HOP request from %s', connection.remotePeer.toB58String())\n        await handleCanHop({ circuit, connection, streamHandler })\n        break\n      }\n      case CircuitPB.Type.HOP: {\n        log('received HOP request from %s', connection.remotePeer.toB58String())\n        virtualConnection = await handleHop({\n          connection,\n          request,\n          streamHandler,\n          circuit\n        })\n        break\n      }\n      case CircuitPB.Type.STOP: {\n        log('received STOP request from %s', connection.remotePeer.toB58String())\n        virtualConnection = await handleStop({\n          connection,\n          request,\n          streamHandler,\n          circuit\n        })\n        break\n      }\n      default: {\n        log('Request of type %s not supported', request.type)\n      }\n    }\n\n    if (virtualConnection) {\n      const remoteAddr = multiaddr(request.dstPeer.addrs[0])\n      const localAddr = multiaddr(request.srcPeer.addrs[0])\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr,\n        localAddr\n      })\n      const type = CircuitPB.Type === CircuitPB.Type.HOP ? 'relay' : 'inbound'\n      log('new %s connection %s', type, maConn.remoteAddr)\n\n      const conn = await this._upgrader.upgradeInbound(maConn)\n      log('%s connection %s upgraded', type, maConn.remoteAddr)\n      this.handler && this.handler(conn)\n    }\n  }\n\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {AbortSignal} [options.signal] - An optional abort signal\n   * @returns {Connection} - the connection\n   */\n  async dial (ma, options) {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit')\n    const relayAddr = multiaddr(addrs[0])\n    const destinationAddr = multiaddr(addrs[addrs.length - 1])\n    const relayPeer = PeerId.createFromCID(relayAddr.getPeerId())\n    const destinationPeer = PeerId.createFromCID(destinationAddr.getPeerId())\n\n    let disconnectOnFailure = false\n    let relayConnection = this._connectionManager.get(relayPeer)\n    if (!relayConnection) {\n      relayConnection = await this._dialer.connectToPeer(relayAddr, options)\n      disconnectOnFailure = true\n    }\n\n    try {\n      const virtualConnection = await hop({\n        connection: relayConnection,\n        circuit: this,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.peerId.toBytes(),\n            addrs: this._libp2p.multiaddrs.map(addr => addr.buffer)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).buffer]\n          }\n        }\n      })\n\n      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`)\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      })\n      log('new outbound connection %s', maConn.remoteAddr)\n\n      return this._upgrader.upgradeOutbound(maConn)\n    } catch (err) {\n      log.error('Circuit relay dial failed', err)\n      disconnectOnFailure && await relayConnection.close()\n      throw err\n    }\n  }\n\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @return {listener}\n   */\n  createListener (options, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    // Called on successful HOP and STOP requests\n    this.handler = handler\n\n    return createListener(this, options)\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {Array<Multiaddr>}\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n}\n\n/**\n * @type {Circuit}\n */\nmodule.exports = withIs(Circuit, { className: 'Circuit', symbolName: '@libp2p/js-libp2p-circuit/circuit' })\n"]},"metadata":{},"sourceType":"script"}