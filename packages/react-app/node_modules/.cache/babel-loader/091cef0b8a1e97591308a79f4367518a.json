{"ast":null,"code":"import debug from \"debug\";\nimport { DUMP_SESSION_KEYS } from './constants';\nexport var logger = debug('libp2p:noise');\nvar keyLogger;\n\nif (DUMP_SESSION_KEYS) {\n  keyLogger = logger;\n} else {\n  keyLogger = function keyLogger() {\n    /* do nothing */\n  };\n}\n\nexport function logLocalStaticKeys(s) {\n  keyLogger(\"LOCAL_STATIC_PUBLIC_KEY \".concat(s.publicKey.toString('hex')));\n  keyLogger(\"LOCAL_STATIC_PRIVATE_KEY \".concat(s.privateKey.toString('hex')));\n}\nexport function logLocalEphemeralKeys(e) {\n  if (e) {\n    keyLogger(\"LOCAL_PUBLIC_EPHEMERAL_KEY \".concat(e.publicKey.toString('hex')));\n    keyLogger(\"LOCAL_PRIVATE_EPHEMERAL_KEY \".concat(e.privateKey.toString('hex')));\n  } else {\n    keyLogger('Missing local ephemeral keys.');\n  }\n}\nexport function logRemoteStaticKey(rs) {\n  keyLogger(\"REMOTE_STATIC_PUBLIC_KEY \".concat(rs.toString('hex')));\n}\nexport function logRemoteEphemeralKey(re) {\n  keyLogger(\"REMOTE_EPHEMERAL_PUBLIC_KEY \".concat(re.toString('hex')));\n}\nexport function logCipherState(session) {\n  if (session.cs1 && session.cs2) {\n    keyLogger(\"CIPHER_STATE_1 \".concat(session.cs1.n, \" \").concat(session.cs1.k.toString('hex')));\n    keyLogger(\"CIPHER_STATE_2 \".concat(session.cs2.n, \" \").concat(session.cs2.k.toString('hex')));\n  } else {\n    keyLogger('Missing cipher state.');\n  }\n}","map":{"version":3,"sources":["../src/logger.ts"],"names":["logger","debug","keyLogger","s","e","rs","re","session"],"mappings":"AAAA,OAAA,KAAA,MAAA,OAAA;AACA,SAAA,iBAAA,QAAA,aAAA;AAIA,OAAO,IAAMA,MAAM,GAAGC,KAAK,CAApB,cAAoB,CAApB;AAEP,IAAA,SAAA;;AACA,IAAA,iBAAA,EAAqB;AACnBC,EAAAA,SAAS,GAATA,MAAAA;AADF,CAAA,MAGK;AACHA,EAAAA,SAAS,GAAG,qBAAM;AAAE;AAApBA,GAAAA;AACD;;AAED,OAAO,SAAA,kBAAA,CAAA,CAAA,EAA8C;AACnDA,EAAAA,SAAS,CAAA,2BAAA,MAAA,CAA4BC,CAAC,CAADA,SAAAA,CAAAA,QAAAA,CAArCD,KAAqCC,CAA5B,CAAA,CAATD;AACAA,EAAAA,SAAS,CAAA,4BAAA,MAAA,CAA6BC,CAAC,CAADA,UAAAA,CAAAA,QAAAA,CAAtCD,KAAsCC,CAA7B,CAAA,CAATD;AACD;AAED,OAAO,SAAA,qBAAA,CAAA,CAAA,EAA2D;AAChE,MAAA,CAAA,EAAK;AACHA,IAAAA,SAAS,CAAA,8BAAA,MAAA,CAA+BE,CAAC,CAADA,SAAAA,CAAAA,QAAAA,CAAxCF,KAAwCE,CAA/B,CAAA,CAATF;AACAA,IAAAA,SAAS,CAAA,+BAAA,MAAA,CAAgCE,CAAC,CAADA,UAAAA,CAAAA,QAAAA,CAAzCF,KAAyCE,CAAhC,CAAA,CAATF;AAFF,GAAA,MAII;AACFA,IAAAA,SAAS,CAATA,+BAAS,CAATA;AACD;AACF;AAED,OAAO,SAAA,kBAAA,CAAA,EAAA,EAA8C;AACnDA,EAAAA,SAAS,CAAA,4BAAA,MAAA,CAA6BG,EAAE,CAAFA,QAAAA,CAAtCH,KAAsCG,CAA7B,CAAA,CAATH;AACD;AAED,OAAO,SAAA,qBAAA,CAAA,EAAA,EAAiD;AACtDA,EAAAA,SAAS,CAAA,+BAAA,MAAA,CAAgCI,EAAE,CAAFA,QAAAA,CAAzCJ,KAAyCI,CAAhC,CAAA,CAATJ;AACD;AAED,OAAO,SAAA,cAAA,CAAA,OAAA,EAAqD;AAC1D,MAAGK,OAAO,CAAPA,GAAAA,IAAeA,OAAO,CAAzB,GAAA,EAA8B;AAC5BL,IAAAA,SAAS,CAAA,kBAAA,MAAA,CAAmBK,OAAO,CAAPA,GAAAA,CAAnB,CAAA,EAAA,GAAA,EAAA,MAAA,CAAoCA,OAAO,CAAPA,GAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAA7CL,KAA6CK,CAApC,CAAA,CAATL;AACAA,IAAAA,SAAS,CAAA,kBAAA,MAAA,CAAmBK,OAAO,CAAPA,GAAAA,CAAnB,CAAA,EAAA,GAAA,EAAA,MAAA,CAAoCA,OAAO,CAAPA,GAAAA,CAAAA,CAAAA,CAAAA,QAAAA,CAA7CL,KAA6CK,CAApC,CAAA,CAATL;AAFF,GAAA,MAII;AACFA,IAAAA,SAAS,CAATA,uBAAS,CAATA;AACD;AACF","sourcesContent":["import debug from \"debug\";\nimport {DUMP_SESSION_KEYS} from './constants';\nimport { KeyPair } from \"./@types/libp2p\";\nimport { NoiseSession, SymmetricState } from \"./@types/handshake\";\n\nexport const logger = debug('libp2p:noise');\n\nlet keyLogger;\nif(DUMP_SESSION_KEYS){\n  keyLogger = logger\n}\nelse {\n  keyLogger = () => { /* do nothing */ }\n}\n\nexport function logLocalStaticKeys(s: KeyPair): void {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`)\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`)\n}\n\nexport function logLocalEphemeralKeys(e: KeyPair|undefined): void {\n  if(e){\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`)\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`)\n  }\n  else{\n    keyLogger('Missing local ephemeral keys.')\n  }\n}\n\nexport function logRemoteStaticKey(rs: Buffer): void {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`)\n}\n\nexport function logRemoteEphemeralKey(re: Buffer): void {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`)\n}\n\nexport function logCipherState(session: NoiseSession): void {\n  if(session.cs1 && session.cs2){\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`)\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`)\n  }\n  else{\n    keyLogger('Missing cipher state.')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}