{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require('debug');\n\nvar parseDuration = require('parse-duration');\n\nvar crypto = require('libp2p-crypto');\n\nvar errcode = require('err-code');\n\nvar log = debug('ipfs:name:publish');\nlog.error = debug('ipfs:name:publish:error');\n\nvar _require = require('../../utils'),\n    OFFLINE_ERROR = _require.OFFLINE_ERROR,\n    normalizePath = _require.normalizePath,\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar _require2 = require('./utils'),\n    resolvePath = _require2.resolvePath;\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = function (_ref) {\n  var ipns = _ref.ipns,\n      dag = _ref.dag,\n      peerId = _ref.peerId,\n      isOnline = _ref.isOnline,\n      keychain = _ref.keychain,\n      constructorOptions = _ref.options;\n\n  var lookupKey = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(keyName) {\n      var pass, pem, privateKey;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(keyName === 'self')) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\", peerId.privKey);\n\n            case 2:\n              _context.prev = 2;\n              pass = constructorOptions.pass;\n              _context.next = 6;\n              return keychain.exportKey(keyName, pass);\n\n            case 6:\n              pem = _context.sent;\n              _context.next = 9;\n              return crypto.keys.import(pem, pass);\n\n            case 9:\n              privateKey = _context.sent;\n              return _context.abrupt(\"return\", privateKey);\n\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](2);\n              log.error(_context.t0);\n              throw errcode(_context.t0, 'ERR_CANNOT_GET_KEY');\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 13]]);\n    }));\n\n    return function lookupKey(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * IPNS is a PKI namespace, where names are the hashes of public keys, and\n   * the private key enables publishing new (signed) values. In both publish\n   * and resolve, the default name used is the node's own PeerID,\n   * which is the hash of its public key.\n   *\n   * @param {String} value ipfs path of the object to be published.\n   * @param {Object} options ipfs publish options.\n   * @param {boolean} options.resolve resolve given path before publishing.\n   * @param {String} options.lifetime time duration that the record will be valid for.\n  This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n  \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n    * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n    * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n    * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n    * @param {function(Error)} [callback]\n    * @returns {Promise|void}\n    */\n\n\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(value, options) {\n      var resolve, lifetime, key, pubLifetime, results;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = options || {};\n              resolve = !(options.resolve === false);\n              lifetime = options.lifetime || '24h';\n              key = options.key || 'self';\n\n              if (isOnline()) {\n                _context2.next = 6;\n                break;\n              }\n\n              throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n\n            case 6:\n              _context2.prev = 6;\n              value = normalizePath(value);\n              _context2.next = 14;\n              break;\n\n            case 10:\n              _context2.prev = 10;\n              _context2.t0 = _context2[\"catch\"](6);\n              log.error(_context2.t0);\n              throw _context2.t0;\n\n            case 14:\n              _context2.prev = 14;\n              pubLifetime = parseDuration(lifetime); // Calculate lifetime with nanoseconds precision\n\n              pubLifetime = pubLifetime.toFixed(6);\n              _context2.next = 23;\n              break;\n\n            case 19:\n              _context2.prev = 19;\n              _context2.t1 = _context2[\"catch\"](14);\n              log.error(_context2.t1);\n              throw _context2.t1;\n\n            case 23:\n              _context2.next = 25;\n              return Promise.all([// verify if the path exists, if not, an error will stop the execution\n              lookupKey(key), resolve ? resolvePath({\n                ipns: ipns,\n                dag: dag\n              }, value) : Promise.resolve()]);\n\n            case 25:\n              results = _context2.sent;\n              return _context2.abrupt(\"return\", ipns.publish(results[0], value, pubLifetime));\n\n            case 27:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[6, 10], [14, 19]]);\n    }));\n\n    function publish(_x2, _x3) {\n      return _publish.apply(this, arguments);\n    }\n\n    return publish;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/name/publish.js"],"names":["debug","require","parseDuration","crypto","errcode","log","error","OFFLINE_ERROR","normalizePath","withTimeoutOption","resolvePath","module","exports","ipns","dag","peerId","isOnline","keychain","constructorOptions","options","lookupKey","keyName","privKey","pass","exportKey","pem","keys","import","privateKey","value","resolve","lifetime","key","Error","pubLifetime","toFixed","Promise","all","results","publish"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst parseDuration = require('parse-duration')\nconst crypto = require('libp2p-crypto')\nconst errcode = require('err-code')\n\nconst log = debug('ipfs:name:publish')\nlog.error = debug('ipfs:name:publish:error')\n\nconst { OFFLINE_ERROR, normalizePath, withTimeoutOption } = require('../../utils')\nconst { resolvePath } = require('./utils')\n\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\nmodule.exports = ({ ipns, dag, peerId, isOnline, keychain, options: constructorOptions }) => {\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey\n    }\n\n    try {\n      const pass = constructorOptions.pass\n      const pem = await keychain.exportKey(keyName, pass)\n      const privateKey = await crypto.keys.import(pem, pass)\n      return privateKey\n    } catch (err) {\n      log.error(err)\n      throw errcode(err, 'ERR_CANNOT_GET_KEY')\n    }\n  }\n\n  /**\n   * IPNS is a PKI namespace, where names are the hashes of public keys, and\n   * the private key enables publishing new (signed) values. In both publish\n   * and resolve, the default name used is the node's own PeerID,\n   * which is the hash of its public key.\n   *\n   * @param {String} value ipfs path of the object to be published.\n   * @param {Object} options ipfs publish options.\n   * @param {boolean} options.resolve resolve given path before publishing.\n   * @param {String} options.lifetime time duration that the record will be valid for.\n  This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n  \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n    * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n    * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n    * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n    * @param {function(Error)} [callback]\n    * @returns {Promise|void}\n    */\n  return withTimeoutOption(async function publish (value, options) {\n    options = options || {}\n\n    const resolve = !(options.resolve === false)\n    const lifetime = options.lifetime || '24h'\n    const key = options.key || 'self'\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: params related logic should be in the core implementation\n\n    // Normalize path value\n    try {\n      value = normalizePath(value)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    let pubLifetime\n    try {\n      pubLifetime = parseDuration(lifetime)\n\n      // Calculate lifetime with nanoseconds precision\n      pubLifetime = pubLifetime.toFixed(6)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    // TODO: ttl human for cache\n    const results = await Promise.all([\n      // verify if the path exists, if not, an error will stop the execution\n      lookupKey(key),\n      resolve ? resolvePath({ ipns, dag }, value) : Promise.resolve()\n    ])\n\n    // Start publishing process\n    return ipns.publish(results[0], value, pubLifetime)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}