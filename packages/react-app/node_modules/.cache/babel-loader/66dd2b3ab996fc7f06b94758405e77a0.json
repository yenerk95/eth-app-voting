{"ast":null,"code":"import { Buffer } from \"buffer\";\nexport const uint16BEEncode = (value, target, offset) => {\n  target = target || Buffer.allocUnsafe(2);\n  target.writeUInt16BE(value, offset);\n  return target;\n};\nuint16BEEncode.bytes = 2;\nexport const uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n  return data.readUInt16BE(0);\n};\nuint16BEDecode.bytes = 2; // Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0(message) {\n  return Buffer.concat([message.ne, message.ciphertext]);\n}\nexport function encode1(message) {\n  return Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\nexport function encode2(message) {\n  return Buffer.concat([message.ns, message.ciphertext]);\n}\nexport function decode0(input) {\n  if (input.length < 32) {\n    throw new Error(\"Cannot decode stage 0 MessageBuffer: length less than 32 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: Buffer.alloc(0)\n  };\n}\nexport function decode1(input) {\n  if (input.length < 80) {\n    throw new Error(\"Cannot decode stage 1 MessageBuffer: length less than 80 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length)\n  };\n}\nexport function decode2(input) {\n  if (input.length < 48) {\n    throw new Error(\"Cannot decode stage 2 MessageBuffer: length less than 48 bytes.\");\n  }\n\n  return {\n    ne: Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length)\n  };\n}","map":{"version":3,"sources":["../src/encoder.ts"],"names":["uint16BEEncode","target","Buffer","uint16BEDecode","data","RangeError","message","input","ne","ciphertext","ns"],"mappings":"AAAA,SAAA,MAAA,QAAA,QAAA;AAIA,OAAO,MAAMA,cAAc,GAAG,CAAA,KAAA,EAAA,MAAA,EAAA,MAAA,KAA2B;AACvDC,EAAAA,MAAM,GAAGA,MAAM,IAAIC,MAAM,CAANA,WAAAA,CAAnBD,CAAmBC,CAAnBD;AACAA,EAAAA,MAAM,CAANA,aAAAA,CAAAA,KAAAA,EAAAA,MAAAA;AACA,SAAA,MAAA;AAHK,CAAA;AAKPD,cAAc,CAAdA,KAAAA,GAAAA,CAAAA;AAEA,OAAO,MAAMG,cAAc,GAAGC,IAAI,IAAI;AACpC,MAAIA,IAAI,CAAJA,MAAAA,GAAJ,CAAA,EAAqB,MAAMC,UAAU,CAAhB,0BAAgB,CAAhB;AACrB,SAAOD,IAAI,CAAJA,YAAAA,CAAP,CAAOA,CAAP;AAFK,CAAA;AAIPD,cAAc,CAAdA,KAAAA,GAAAA,CAAAA,C,CAEA;;AAEA,OAAO,SAAA,OAAA,CAAA,OAAA,EAAgD;AACrD,SAAOD,MAAM,CAANA,MAAAA,CAAc,CAACI,OAAO,CAAR,EAAA,EAAaA,OAAO,CAAzC,UAAqB,CAAdJ,CAAP;AACD;AAED,OAAO,SAAA,OAAA,CAAA,OAAA,EAAgD;AACrD,SAAOA,MAAM,CAANA,MAAAA,CAAc,CAACI,OAAO,CAAR,EAAA,EAAaA,OAAO,CAApB,EAAA,EAAyBA,OAAO,CAArD,UAAqB,CAAdJ,CAAP;AACD;AAED,OAAO,SAAA,OAAA,CAAA,OAAA,EAAgD;AACrD,SAAOA,MAAM,CAANA,MAAAA,CAAc,CAACI,OAAO,CAAR,EAAA,EAAaA,OAAO,CAAzC,UAAqB,CAAdJ,CAAP;AACD;AAED,OAAO,SAAA,OAAA,CAAA,KAAA,EAA8C;AACnD,MAAIK,KAAK,CAALA,MAAAA,GAAJ,EAAA,EAAuB;AACrB,UAAM,IAAA,KAAA,CAAN,iEAAM,CAAN;AACD;;AAED,SAAO;AACLC,IAAAA,EAAE,EAAED,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EADC,EACDA,CADC;AAELE,IAAAA,UAAU,EAAEF,KAAK,CAALA,KAAAA,CAAAA,EAAAA,EAAgBA,KAAK,CAF5B,MAEOA,CAFP;AAGLG,IAAAA,EAAE,EAAER,MAAM,CAANA,KAAAA,CAAAA,CAAAA;AAHC,GAAP;AAKD;AAED,OAAO,SAAA,OAAA,CAAA,KAAA,EAA8C;AACnD,MAAIK,KAAK,CAALA,MAAAA,GAAJ,EAAA,EAAuB;AACrB,UAAM,IAAA,KAAA,CAAN,iEAAM,CAAN;AACD;;AAED,SAAO;AACLC,IAAAA,EAAE,EAAED,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EADC,EACDA,CADC;AAELG,IAAAA,EAAE,EAAEH,KAAK,CAALA,KAAAA,CAAAA,EAAAA,EAFC,EAEDA,CAFC;AAGLE,IAAAA,UAAU,EAAEF,KAAK,CAALA,KAAAA,CAAAA,EAAAA,EAAgBA,KAAK,CAArBA,MAAAA;AAHP,GAAP;AAKD;AAED,OAAO,SAAA,OAAA,CAAA,KAAA,EAA8C;AACnD,MAAIA,KAAK,CAALA,MAAAA,GAAJ,EAAA,EAAuB;AACrB,UAAM,IAAA,KAAA,CAAN,iEAAM,CAAN;AACD;;AAED,SAAO;AACLC,IAAAA,EAAE,EAAEN,MAAM,CAANA,KAAAA,CADC,CACDA,CADC;AAELQ,IAAAA,EAAE,EAAEH,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAFC,EAEDA,CAFC;AAGLE,IAAAA,UAAU,EAAEF,KAAK,CAALA,KAAAA,CAAAA,EAAAA,EAAgBA,KAAK,CAArBA,MAAAA;AAHP,GAAP;AAKD","sourcesContent":["import {Buffer} from \"buffer\";\nimport {bytes} from \"./@types/basic\";\nimport {MessageBuffer} from \"./@types/handshake\";\n\nexport const uint16BEEncode = (value, target, offset) => {\n  target = target || Buffer.allocUnsafe(2);\n  target.writeUInt16BE(value, offset);\n  return target;\n};\nuint16BEEncode.bytes = 2;\n\nexport const uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n  return data.readUInt16BE(0);\n};\nuint16BEDecode.bytes = 2;\n\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0(message: MessageBuffer): bytes {\n  return Buffer.concat([message.ne, message.ciphertext]);\n}\n\nexport function encode1(message: MessageBuffer): bytes {\n  return Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\n\nexport function encode2(message: MessageBuffer): bytes {\n  return Buffer.concat([message.ns, message.ciphertext]);\n}\n\nexport function decode0(input: bytes): MessageBuffer {\n  if (input.length < 32) {\n    throw new Error(\"Cannot decode stage 0 MessageBuffer: length less than 32 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: Buffer.alloc(0),\n  }\n}\n\nexport function decode1(input: bytes): MessageBuffer {\n  if (input.length < 80) {\n    throw new Error(\"Cannot decode stage 1 MessageBuffer: length less than 80 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length),\n  }\n}\n\nexport function decode2(input: bytes): MessageBuffer {\n  if (input.length < 48) {\n    throw new Error(\"Cannot decode stage 2 MessageBuffer: length less than 48 bytes.\");\n  }\n\n  return {\n    ne: Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length),\n  }\n}\n"]},"metadata":{},"sourceType":"module"}