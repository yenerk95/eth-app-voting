{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst log = require('debug')('ipfs:mfs:mkdir');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst createNode = require('./utils/create-node');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst updateTree = require('./utils/update-tree');\n\nconst addLink = require('./utils/add-link');\n\nconst withMfsRoot = require('./utils/with-mfs-root');\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null,\n  signal: undefined\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsMkdir(path, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === '/') {\n      if (options.parents) {\n        return;\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n\n    const root = await withMfsRoot(context, options);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', options); // make sure the containing folder exists, creating it if necessary\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n      try {\n        parent = await exporter(subPath, context.ipld);\n        log(`${subPath} existed`);\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`);\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return;\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          } // add the intermediate directory\n\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options);\n        } else {\n          throw err;\n        }\n      }\n    } // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n    // update the tree from the leaf to the root\n\n\n    const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, options);\n  });\n};\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/mkdir.js"],"names":["errCode","require","log","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","applyDefaultOptions","withTimeoutOption","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","mode","mtime","signal","undefined","module","exports","context","mfsMkdir","path","options","Error","trim","substring","pathComponents","root","parent","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","ipld","node","Links","map","link","Name","push","name","cid","err","code","addEmptyDir","newRootCid","childName","result","parentCid","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst log = require('debug')('ipfs:mfs:mkdir')\nconst exporter = require('ipfs-unixfs-exporter')\nconst createNode = require('./utils/create-node')\nconst toPathComponents = require('./utils/to-path-components')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst updateTree = require('./utils/update-tree')\nconst addLink = require('./utils/add-link')\nconst withMfsRoot = require('./utils/with-mfs-root')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsMkdir (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (options.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await withMfsRoot(context, options)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', options)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.ipld)\n        log(`${subPath} existed`)\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`)\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })\n}\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"]},"metadata":{},"sourceType":"script"}