{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar withIs = require('class-is');\n\nvar Topology = require('./index');\n\nvar MulticodecTopology = /*#__PURE__*/function (_Topology) {\n  _inherits(MulticodecTopology, _Topology);\n\n  var _super = _createSuper(MulticodecTopology);\n\n  /**\n   * @param {Object} props\n   * @param {number} props.min minimum needed connections (default: 0)\n   * @param {number} props.max maximum needed connections (default: Infinity)\n   * @param {Array<string>} props.multicodecs protocol multicodecs\n   * @param {Object} props.handlers\n   * @param {function} props.handlers.onConnect protocol \"onConnect\" handler\n   * @param {function} props.handlers.onDisconnect protocol \"onDisconnect\" handler\n   * @constructor\n   */\n  function MulticodecTopology(_ref) {\n    var _this;\n\n    var min = _ref.min,\n        max = _ref.max,\n        multicodecs = _ref.multicodecs,\n        handlers = _ref.handlers;\n\n    _classCallCheck(this, MulticodecTopology);\n\n    _this = _super.call(this, {\n      min: min,\n      max: max,\n      handlers: handlers\n    });\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided');\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided');\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided');\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided');\n    }\n\n    _this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];\n    _this._registrar = undefined;\n    _this._onProtocolChange = _this._onProtocolChange.bind(_assertThisInitialized(_this));\n    _this._onPeerConnect = _this._onPeerConnect.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(MulticodecTopology, [{\n    key: \"_updatePeers\",\n\n    /**\n     * Update topology.\n     * @param {Array<{id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string>}>} peerDataIterable\n     * @returns {void}\n     */\n    value: function _updatePeers(peerDataIterable) {\n      var _this2 = this;\n\n      var _iterator = _createForOfIteratorHelper(peerDataIterable),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var _step$value = _step.value,\n              id = _step$value.id,\n              protocols = _step$value.protocols;\n\n          if (_this2.multicodecs.filter(function (multicodec) {\n            return protocols.includes(multicodec);\n          }).length) {\n            // Add the peer regardless of whether or not there is currently a connection\n            _this2.peers.add(id.toB58String()); // If there is a connection, call _onConnect\n\n\n            var connection = _this2._registrar.getConnection(id);\n\n            connection && _this2._onConnect(id, connection);\n          } else {\n            // Remove any peers we might be tracking that are no longer of value to us\n            _this2.peers.delete(id.toB58String());\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Check if a new peer support the multicodecs for this topology.\n     * @param {Object} props\n     * @param {PeerId} props.peerId\n     * @param {Array<string>} props.protocols\n     */\n\n  }, {\n    key: \"_onProtocolChange\",\n    value: function _onProtocolChange(_ref2) {\n      var _this3 = this;\n\n      var peerId = _ref2.peerId,\n          protocols = _ref2.protocols;\n      var hadPeer = this.peers.has(peerId.toB58String());\n      var hasProtocol = protocols.filter(function (protocol) {\n        return _this3.multicodecs.includes(protocol);\n      }); // Not supporting the protocol anymore?\n\n      if (hadPeer && hasProtocol.length === 0) {\n        this._onDisconnect(peerId);\n      } // New to protocol support\n\n\n      var _iterator2 = _createForOfIteratorHelper(protocols),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var protocol = _step2.value;\n\n          if (this.multicodecs.includes(protocol)) {\n            var peerData = this._registrar.peerStore.get(peerId);\n\n            this._updatePeers([peerData]);\n\n            return;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Verify if a new connected peer has a topology multicodec and call _onConnect.\n     * @param {Connection} connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(connection) {\n      var peerId = connection.remotePeer;\n\n      var protocols = this._registrar.peerStore.protoBook.get(peerId);\n\n      if (!protocols) {\n        return;\n      }\n\n      if (this.multicodecs.find(function (multicodec) {\n        return protocols.includes(multicodec);\n      })) {\n        this.peers.add(peerId.toB58String());\n\n        this._onConnect(peerId, connection);\n      }\n    }\n  }, {\n    key: \"registrar\",\n    set: function set(registrar) {\n      this._registrar = registrar;\n\n      this._registrar.peerStore.on('change:protocols', this._onProtocolChange);\n\n      this._registrar.connectionManager.on('peer:connect', this._onPeerConnect); // Update topology peers\n\n\n      this._updatePeers(this._registrar.peerStore.peers.values());\n    }\n  }]);\n\n  return MulticodecTopology;\n}(Topology);\n\nmodule.exports = withIs(MulticodecTopology, {\n  className: 'MulticodecTopology',\n  symbolName: '@libp2p/js-interfaces/topology/multicodec-topology'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-interfaces/src/topology/multicodec-topology.js"],"names":["withIs","require","Topology","MulticodecTopology","min","max","multicodecs","handlers","Error","onConnect","onDisconnect","Array","isArray","_registrar","undefined","_onProtocolChange","bind","_onPeerConnect","peerDataIterable","id","protocols","filter","multicodec","includes","length","peers","add","toB58String","connection","getConnection","_onConnect","delete","peerId","hadPeer","has","hasProtocol","protocol","_onDisconnect","peerData","peerStore","get","_updatePeers","remotePeer","protoBook","find","registrar","on","connectionManager","values","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst withIs = require('class-is')\n\nconst Topology = require('./index')\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {Object} props\n   * @param {number} props.min minimum needed connections (default: 0)\n   * @param {number} props.max maximum needed connections (default: Infinity)\n   * @param {Array<string>} props.multicodecs protocol multicodecs\n   * @param {Object} props.handlers\n   * @param {function} props.handlers.onConnect protocol \"onConnect\" handler\n   * @param {function} props.handlers.onDisconnect protocol \"onDisconnect\" handler\n   * @constructor\n   */\n  constructor ({\n    min,\n    max,\n    multicodecs,\n    handlers\n  }) {\n    super({ min, max, handlers })\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided')\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided')\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided')\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided')\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs]\n    this._registrar = undefined\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n  }\n\n  set registrar (registrar) {\n    this._registrar = registrar\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange)\n    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect)\n\n    // Update topology peers\n    this._updatePeers(this._registrar.peerStore.peers.values())\n  }\n\n  /**\n   * Update topology.\n   * @param {Array<{id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string>}>} peerDataIterable\n   * @returns {void}\n   */\n  _updatePeers (peerDataIterable) {\n    for (const { id, protocols } of peerDataIterable) {\n      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.add(id.toB58String())\n        // If there is a connection, call _onConnect\n        const connection = this._registrar.getConnection(id)\n        connection && this._onConnect(id, connection)\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(id.toB58String())\n      }\n    }\n  }\n\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {Array<string>} props.protocols\n   */\n  _onProtocolChange ({ peerId, protocols }) {\n    const hadPeer = this.peers.has(peerId.toB58String())\n    const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol))\n\n    // Not supporting the protocol anymore?\n    if (hadPeer && hasProtocol.length === 0) {\n      this._onDisconnect(peerId)\n    }\n\n    // New to protocol support\n    for (const protocol of protocols) {\n      if (this.multicodecs.includes(protocol)) {\n        const peerData = this._registrar.peerStore.get(peerId)\n        this._updatePeers([peerData])\n        return\n      }\n    }\n  }\n\n  /**\n   * Verify if a new connected peer has a topology multicodec and call _onConnect.\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  _onPeerConnect (connection) {\n    const peerId = connection.remotePeer\n    const protocols = this._registrar.peerStore.protoBook.get(peerId)\n\n    if (!protocols) {\n      return\n    }\n\n    if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {\n      this.peers.add(peerId.toB58String())\n      this._onConnect(peerId, connection)\n    }\n  }\n}\n\nmodule.exports = withIs(MulticodecTopology, { className: 'MulticodecTopology', symbolName: '@libp2p/js-interfaces/topology/multicodec-topology' })\n"]},"metadata":{},"sourceType":"script"}