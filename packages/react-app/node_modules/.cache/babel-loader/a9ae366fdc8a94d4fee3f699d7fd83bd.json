{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass EventIterator {\n  constructor(listen, remove, options = {}) {\n    this.listen = listen;\n    this.remove = remove;\n    this.options = Object.assign({\n      highWaterMark: 100\n    }, options);\n    Object.freeze(this);\n  }\n\n  [Symbol.asyncIterator]() {\n    let placeholder;\n    const queue = [];\n    const listen = this.listen;\n    const remove = this.remove;\n\n    const push = value => {\n      const resolution = {\n        value,\n        done: false\n      };\n\n      if (placeholder) {\n        placeholder.resolve(resolution);\n        placeholder = undefined;\n      } else {\n        queue.push(Promise.resolve(resolution));\n        const {\n          highWaterMark\n        } = this.options;\n\n        if (highWaterMark !== undefined && queue.length >= highWaterMark && console) {\n          console.warn(`EventIterator queue reached ${queue.length} items`);\n        }\n      }\n    };\n\n    const stop = () => {\n      if (remove) {\n        remove(push, stop, fail);\n      }\n\n      const resolution = {\n        done: true\n      };\n\n      if (placeholder) {\n        placeholder.resolve(resolution);\n        placeholder = undefined;\n      } else {\n        queue.push(Promise.resolve(resolution));\n      }\n    };\n\n    const fail = error => {\n      if (remove) {\n        remove(push, stop, fail);\n      }\n\n      if (placeholder) {\n        placeholder.reject(error);\n        placeholder = undefined;\n      } else {\n        const rejection = Promise.reject(error);\n        /* Attach error handler to avoid leaking an unhandled promise rejection. */\n\n        rejection.catch(() => {});\n        queue.push(rejection);\n      }\n    };\n\n    listen(push, stop, fail);\n    return {\n      next(value) {\n        if (queue.length) {\n          return queue.shift();\n        } else {\n          return new Promise((resolve, reject) => {\n            placeholder = {\n              resolve,\n              reject\n            };\n          });\n        }\n      },\n\n      return() {\n        if (remove) {\n          remove(push, stop, fail);\n        }\n\n        return Promise.resolve({\n          done: true\n        });\n      }\n\n    };\n  }\n\n}\n\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/event-iterator/lib/event-iterator.js"],"names":["Object","defineProperty","exports","value","EventIterator","constructor","listen","remove","options","assign","highWaterMark","freeze","Symbol","asyncIterator","placeholder","queue","push","resolution","done","resolve","undefined","Promise","length","console","warn","stop","fail","error","reject","rejection","catch","next","shift","return","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventIterator {\n    constructor(listen, remove, options = {}) {\n        this.listen = listen;\n        this.remove = remove;\n        this.options = Object.assign({ highWaterMark: 100 }, options);\n        Object.freeze(this);\n    }\n    [Symbol.asyncIterator]() {\n        let placeholder;\n        const queue = [];\n        const listen = this.listen;\n        const remove = this.remove;\n        const push = (value) => {\n            const resolution = { value, done: false };\n            if (placeholder) {\n                placeholder.resolve(resolution);\n                placeholder = undefined;\n            }\n            else {\n                queue.push(Promise.resolve(resolution));\n                const { highWaterMark } = this.options;\n                if (highWaterMark !== undefined && queue.length >= highWaterMark && console) {\n                    console.warn(`EventIterator queue reached ${queue.length} items`);\n                }\n            }\n        };\n        const stop = () => {\n            if (remove) {\n                remove(push, stop, fail);\n            }\n            const resolution = { done: true };\n            if (placeholder) {\n                placeholder.resolve(resolution);\n                placeholder = undefined;\n            }\n            else {\n                queue.push(Promise.resolve(resolution));\n            }\n        };\n        const fail = (error) => {\n            if (remove) {\n                remove(push, stop, fail);\n            }\n            if (placeholder) {\n                placeholder.reject(error);\n                placeholder = undefined;\n            }\n            else {\n                const rejection = Promise.reject(error);\n                /* Attach error handler to avoid leaking an unhandled promise rejection. */\n                rejection.catch(() => { });\n                queue.push(rejection);\n            }\n        };\n        listen(push, stop, fail);\n        return {\n            next(value) {\n                if (queue.length) {\n                    return queue.shift();\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        placeholder = { resolve, reject };\n                    });\n                }\n            },\n            return() {\n                if (remove) {\n                    remove(push, stop, fail);\n                }\n                return Promise.resolve({ done: true });\n            },\n        };\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n"]},"metadata":{},"sourceType":"script"}