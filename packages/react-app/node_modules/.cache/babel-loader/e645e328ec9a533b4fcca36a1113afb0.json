{"ast":null,"code":"'use strict';\n\nconst WantManager = require('./want-manager');\n\nconst Network = require('./network');\n\nconst DecisionEngine = require('./decision-engine');\n\nconst Notifications = require('./notifications');\n\nconst logger = require('./utils').logger;\n\nconst Stats = require('./stats');\n\nconst AbortController = require('abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\n\nclass Bitswap {\n  constructor(libp2p, blockstore, options) {\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerId, this.network, this._stats);\n    this.notifications = new Notifications(this.peerId);\n  }\n\n  get peerId() {\n    return this._libp2p.peerId;\n  } // handle messages received through the network\n\n\n  async _receiveMessage(peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming);\n    }\n\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n\n    const blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n    const wanted = blocks.filter(b => this.wm.wantlist.contains(b.cid)).map(b => b.cid);\n    this.wm.cancelWants(wanted);\n    await Promise.all(blocks.map(async b => {\n      const wasWanted = wanted.includes(b.cid);\n      await this._handleReceivedBlock(peerId, b, wasWanted);\n    }));\n  }\n\n  async _handleReceivedBlock(peerId, block, wasWanted) {\n    this._log('received block');\n\n    const has = await this.blockstore.has(block.cid);\n\n    this._updateReceiveCounters(peerId.toB58String(), block, has);\n\n    if (!wasWanted) {\n      return;\n    }\n\n    await this.put(block);\n  }\n\n  _updateReceiveCounters(peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1);\n\n    this._stats.push(peerId, 'dataReceived', block.data.length);\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1);\n\n      this._stats.push(peerId, 'dupDataReceived', block.data.length);\n    }\n  } // handle errors on the receiving channel\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  } // handle new peers\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  } // handle peers being disconnected\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  enableStats() {\n    this._stats.enable();\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Map}\n   */\n\n\n  wantlistForPeer(peerId) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Object}\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Block>}\n   */\n\n\n  async get(cid, options = {}) {\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n\n    let promptedNetwork = false;\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid).catch(err => this._log.error(err));\n        } // we don't have the block locally so fetch it from the network\n\n\n        return fetchFromNetwork(cid, options);\n      }\n    }; // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n\n\n    const controller = new AbortController();\n    const signal = anySignal([options.signal, controller.signal]);\n    const block = await Promise.race([this.notifications.wantBlock(cid, {\n      signal\n    }), loadOrFetchFromNetwork(cid, {\n      signal\n    })]); // since we have the block we can now remove our listener\n\n    controller.abort();\n    return block;\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<AsyncIterator<Block>>}\n   */\n\n\n  async *getMany(cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n\n\n  unwant(cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    this.wm.unwantBlocks(cids);\n    cids.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n\n\n  cancelWants(cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    this.wm.cancelWants(cids);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @returns {Promise<void>}\n   */\n\n\n  async put(block) {\n    await this.blockstore.put(block);\n\n    this._sendHaveBlockNotifications(block);\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {AsyncIterable<Block>} blocks\n   * @returns {AsyncIterable<Block>}\n   */\n\n\n  async *putMany(blocks) {\n    for await (const block of this.blockstore.putMany(blocks)) {\n      this._sendHaveBlockNotifications(block);\n\n      yield block;\n    }\n  }\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @param {Block} block\n   */\n\n\n  _sendHaveBlockNotifications(block) {\n    this.notifications.hasBlock(block);\n    this.engine.receivedBlocks([block]); // Note: Don't wait for provide to finish before returning\n\n    this.network.provide(block.cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Iterator<PeerId>}\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    this.wm.start();\n    this.network.start();\n    this.engine.start();\n  }\n  /**\n   * Stop the bitswap node.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    this.network.stop();\n    this.engine.stop();\n  }\n\n}\n\nmodule.exports = Bitswap;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/index.js"],"names":["WantManager","require","Network","DecisionEngine","Notifications","logger","Stats","AbortController","anySignal","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","constructor","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","engine","wm","notifications","_receiveMessage","incoming","messageReceived","err","blocks","size","Array","from","values","wanted","filter","b","wantlist","contains","cid","map","cancelWants","Promise","all","wasWanted","includes","_handleReceivedBlock","block","has","_updateReceiveCounters","toB58String","put","exists","push","data","length","_receiveError","error","message","_onPeerConnected","connected","_onPeerDisconnected","disconnected","peerDisconnected","enableStats","enable","disableStats","disable","wantlistForPeer","ledgerForPeer","get","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","code","findAndConnect","catch","controller","signal","race","abort","getMany","cids","unwant","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","hasBlock","receivedBlocks","provide","getWantlist","entries","peers","stat","start","stop","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,WAAW,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA7B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAD,CAAP,CAAmBI,MAAlC;;AACA,MAAMC,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMM,eAAe,GAAGN,OAAO,CAAC,kBAAD,CAA/B;;AACA,MAAMO,SAAS,GAAGP,OAAO,CAAC,YAAD,CAAzB;;AAEA,MAAMQ,cAAc,GAAG;AACrBC,EAAAA,YAAY,EAAE,KADO;AAErBC,EAAAA,2BAA2B,EAAE,IAFR;AAGrBC,EAAAA,gCAAgC,EAAE;AAHb,CAAvB;AAKA,MAAMC,SAAS,GAAG,CAChB,gBADgB,EAEhB,cAFgB,EAGhB,iBAHgB,EAIhB,iBAJgB,EAKhB,YALgB,EAMhB,UANgB,EAOhB,sBAPgB,EAQhB,gBARgB,EAShB,WATgB,CAAlB;AAYA;;;;;;;;;AAQA,MAAMC,OAAN,CAAc;AACZC,EAAAA,WAAW,CAAEC,MAAF,EAAUC,UAAV,EAAsBC,OAAtB,EAA+B;AACxC,SAAKC,OAAL,GAAeH,MAAf;AACA,SAAKI,IAAL,GAAYf,MAAM,CAAC,KAAKgB,MAAN,CAAlB;AAEA,SAAKC,QAAL,GAAgBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,cAAlB,EAAkCS,OAAlC,CAAhB,CAJwC,CAMxC;;AACA,SAAKO,MAAL,GAAc,IAAInB,KAAJ,CAAUO,SAAV,EAAqB;AACjCa,MAAAA,OAAO,EAAE,KAAKJ,QAAL,CAAcZ,YADU;AAEjCiB,MAAAA,sBAAsB,EAAE,KAAKL,QAAL,CAAcX,2BAFL;AAGjCiB,MAAAA,2BAA2B,EAAE,KAAKN,QAAL,CAAcV;AAHV,KAArB,CAAd,CAPwC,CAaxC;;AACA,SAAKiB,OAAL,GAAe,IAAI3B,OAAJ,CAAYc,MAAZ,EAAoB,IAApB,EAA0B,EAA1B,EAA8B,KAAKS,MAAnC,CAAf,CAdwC,CAgBxC;;AACA,SAAKR,UAAL,GAAkBA,UAAlB;AAEA,SAAKa,MAAL,GAAc,IAAI3B,cAAJ,CAAmB,KAAKkB,MAAxB,EAAgCJ,UAAhC,EAA4C,KAAKY,OAAjD,EAA0D,KAAKJ,MAA/D,CAAd,CAnBwC,CAqBxC;;AACA,SAAKM,EAAL,GAAU,IAAI/B,WAAJ,CAAgB,KAAKqB,MAArB,EAA6B,KAAKQ,OAAlC,EAA2C,KAAKJ,MAAhD,CAAV;AAEA,SAAKO,aAAL,GAAqB,IAAI5B,aAAJ,CAAkB,KAAKiB,MAAvB,CAArB;AACD;;AAED,MAAIA,MAAJ,GAAc;AACZ,WAAO,KAAKF,OAAL,CAAaE,MAApB;AACD,GA9BW,CAgCZ;;;AACA,QAAMY,eAAN,CAAuBZ,MAAvB,EAA+Ba,QAA/B,EAAyC;AACvC,QAAI;AACF;AACA;AACA;AACA,YAAM,KAAKJ,MAAL,CAAYK,eAAZ,CAA4Bd,MAA5B,EAAoCa,QAApC,CAAN;AACD,KALD,CAKE,OAAOE,GAAP,EAAY;AACZ;AACA;AACA;AACA,WAAKhB,IAAL,CAAU,2BAAV,EAAuCc,QAAvC;AACD;;AAED,QAAIA,QAAQ,CAACG,MAAT,CAAgBC,IAAhB,KAAyB,CAA7B,EAAgC;AAC9B;AACD;;AAED,UAAMD,MAAM,GAAGE,KAAK,CAACC,IAAN,CAAWN,QAAQ,CAACG,MAAT,CAAgBI,MAAhB,EAAX,CAAf,CAjBuC,CAmBvC;;AACA,UAAMC,MAAM,GAAGL,MAAM,CAClBM,MADY,CACJC,CAAD,IAAO,KAAKb,EAAL,CAAQc,QAAR,CAAiBC,QAAjB,CAA0BF,CAAC,CAACG,GAA5B,CADF,EAEZC,GAFY,CAEPJ,CAAD,IAAOA,CAAC,CAACG,GAFD,CAAf;AAIA,SAAKhB,EAAL,CAAQkB,WAAR,CAAoBP,MAApB;AAEA,UAAMQ,OAAO,CAACC,GAAR,CAAYd,MAAM,CAACW,GAAP,CAAW,MAAOJ,CAAP,IAAa;AACxC,YAAMQ,SAAS,GAAGV,MAAM,CAACW,QAAP,CAAgBT,CAAC,CAACG,GAAlB,CAAlB;AACA,YAAM,KAAKO,oBAAL,CAA0BjC,MAA1B,EAAkCuB,CAAlC,EAAqCQ,SAArC,CAAN;AACD,KAHiB,CAAZ,CAAN;AAID;;AAED,QAAME,oBAAN,CAA4BjC,MAA5B,EAAoCkC,KAApC,EAA2CH,SAA3C,EAAsD;AACpD,SAAKhC,IAAL,CAAU,gBAAV;;AAEA,UAAMoC,GAAG,GAAG,MAAM,KAAKvC,UAAL,CAAgBuC,GAAhB,CAAoBD,KAAK,CAACR,GAA1B,CAAlB;;AAEA,SAAKU,sBAAL,CAA4BpC,MAAM,CAACqC,WAAP,EAA5B,EAAkDH,KAAlD,EAAyDC,GAAzD;;AAEA,QAAI,CAACJ,SAAL,EAAgB;AACd;AACD;;AAED,UAAM,KAAKO,GAAL,CAASJ,KAAT,CAAN;AACD;;AAEDE,EAAAA,sBAAsB,CAAEpC,MAAF,EAAUkC,KAAV,EAAiBK,MAAjB,EAAyB;AAC7C,SAAKnC,MAAL,CAAYoC,IAAZ,CAAiBxC,MAAjB,EAAyB,gBAAzB,EAA2C,CAA3C;;AACA,SAAKI,MAAL,CAAYoC,IAAZ,CAAiBxC,MAAjB,EAAyB,cAAzB,EAAyCkC,KAAK,CAACO,IAAN,CAAWC,MAApD;;AAEA,QAAIH,MAAJ,EAAY;AACV,WAAKnC,MAAL,CAAYoC,IAAZ,CAAiBxC,MAAjB,EAAyB,iBAAzB,EAA4C,CAA5C;;AACA,WAAKI,MAAL,CAAYoC,IAAZ,CAAiBxC,MAAjB,EAAyB,iBAAzB,EAA4CkC,KAAK,CAACO,IAAN,CAAWC,MAAvD;AACD;AACF,GAvFW,CAyFZ;;;AACAC,EAAAA,aAAa,CAAE5B,GAAF,EAAO;AAClB,SAAKhB,IAAL,CAAU6C,KAAV,CAAgB,kBAAhB,EAAoC7B,GAAG,CAAC8B,OAAxC;AACD,GA5FW,CA8FZ;;;AACAC,EAAAA,gBAAgB,CAAE9C,MAAF,EAAU;AACxB,SAAKU,EAAL,CAAQqC,SAAR,CAAkB/C,MAAlB;AACD,GAjGW,CAmGZ;;;AACAgD,EAAAA,mBAAmB,CAAEhD,MAAF,EAAU;AAC3B,SAAKU,EAAL,CAAQuC,YAAR,CAAqBjD,MAArB;AACA,SAAKS,MAAL,CAAYyC,gBAAZ,CAA6BlD,MAA7B;;AACA,SAAKI,MAAL,CAAY6C,YAAZ,CAAyBjD,MAAzB;AACD;AAED;;;;;AAGAmD,EAAAA,WAAW,GAAI;AACb,SAAK/C,MAAL,CAAYgD,MAAZ;AACD;AAED;;;;;AAGAC,EAAAA,YAAY,GAAI;AACd,SAAKjD,MAAL,CAAYkD,OAAZ;AACD;AAED;;;;;;;;AAMAC,EAAAA,eAAe,CAAEvD,MAAF,EAAU;AACvB,WAAO,KAAKS,MAAL,CAAY8C,eAAZ,CAA4BvD,MAA5B,CAAP;AACD;AAED;;;;;;;;AAMAwD,EAAAA,aAAa,CAAExD,MAAF,EAAU;AACrB,WAAO,KAAKS,MAAL,CAAY+C,aAAZ,CAA0BxD,MAA1B,CAAP;AACD;AAED;;;;;;;;;;;AASA,QAAMyD,GAAN,CAAW/B,GAAX,EAAgB7B,OAAO,GAAG,EAA1B,EAA8B;AAC5B,UAAM6D,gBAAgB,GAAG,CAAChC,GAAD,EAAM7B,OAAN,KAAkB;AACzC;AACA;AACA,WAAKa,EAAL,CAAQiD,UAAR,CAAmB,CAACjC,GAAD,CAAnB,EAA0B7B,OAA1B;AAEA,aAAO,KAAKc,aAAL,CAAmBiD,SAAnB,CAA6BlC,GAA7B,EAAkC7B,OAAlC,CAAP;AACD,KAND;;AAQA,QAAIgE,eAAe,GAAG,KAAtB;;AAEA,UAAMC,sBAAsB,GAAG,OAAOpC,GAAP,EAAY7B,OAAZ,KAAwB;AACrD,UAAI;AACF;AACA,cAAMqC,KAAK,GAAG,MAAM,KAAKtC,UAAL,CAAgB6D,GAAhB,CAAoB/B,GAApB,EAAyB7B,OAAzB,CAApB;AAEA,eAAOqC,KAAP;AACD,OALD,CAKE,OAAOnB,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACgD,IAAJ,KAAa,eAAjB,EAAkC;AAChC,gBAAMhD,GAAN;AACD;;AAED,YAAI,CAAC8C,eAAL,EAAsB;AACpBA,UAAAA,eAAe,GAAG,IAAlB;AAEA,eAAKrD,OAAL,CAAawD,cAAb,CAA4BtC,GAA5B,EACGuC,KADH,CACUlD,GAAD,IAAS,KAAKhB,IAAL,CAAU6C,KAAV,CAAgB7B,GAAhB,CADlB;AAED,SAVW,CAYZ;;;AACA,eAAO2C,gBAAgB,CAAChC,GAAD,EAAM7B,OAAN,CAAvB;AACD;AACF,KArBD,CAX4B,CAkC5B;AACA;AACA;AACA;;;AACA,UAAMqE,UAAU,GAAG,IAAIhF,eAAJ,EAAnB;AACA,UAAMiF,MAAM,GAAGhF,SAAS,CAAC,CAACU,OAAO,CAACsE,MAAT,EAAiBD,UAAU,CAACC,MAA5B,CAAD,CAAxB;AAEA,UAAMjC,KAAK,GAAG,MAAML,OAAO,CAACuC,IAAR,CAAa,CAC/B,KAAKzD,aAAL,CAAmBiD,SAAnB,CAA6BlC,GAA7B,EAAkC;AAChCyC,MAAAA;AADgC,KAAlC,CAD+B,EAI/BL,sBAAsB,CAACpC,GAAD,EAAM;AAC1ByC,MAAAA;AAD0B,KAAN,CAJS,CAAb,CAApB,CAzC4B,CAkD5B;;AACAD,IAAAA,UAAU,CAACG,KAAX;AAEA,WAAOnC,KAAP;AACD;AAED;;;;;;;;;;;AASA,SAAQoC,OAAR,CAAiBC,IAAjB,EAAuB1E,OAAO,GAAG,EAAjC,EAAqC;AACnC,eAAW,MAAM6B,GAAjB,IAAwB6C,IAAxB,EAA8B;AAC5B,YAAM,KAAKd,GAAL,CAAS/B,GAAT,EAAc7B,OAAd,CAAN;AACD;AACF;AAED;;;;;;;;;;;;;AAWA2E,EAAAA,MAAM,CAAED,IAAF,EAAQ;AACZ,QAAI,CAACrD,KAAK,CAACuD,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxBA,MAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD;;AAED,SAAK7D,EAAL,CAAQgE,YAAR,CAAqBH,IAArB;AACAA,IAAAA,IAAI,CAACI,OAAL,CAAcjD,GAAD,IAAS,KAAKf,aAAL,CAAmBiE,WAAnB,CAA+BlD,GAA/B,CAAtB;AACD;AAED;;;;;;;;;;AAQAE,EAAAA,WAAW,CAAE2C,IAAF,EAAQ;AACjB,QAAI,CAACrD,KAAK,CAACuD,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxBA,MAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD;;AACD,SAAK7D,EAAL,CAAQkB,WAAR,CAAoB2C,IAApB;AACD;AAED;;;;;;;;;AAOA,QAAMjC,GAAN,CAAWJ,KAAX,EAAkB;AAChB,UAAM,KAAKtC,UAAL,CAAgB0C,GAAhB,CAAoBJ,KAApB,CAAN;;AACA,SAAK2C,2BAAL,CAAiC3C,KAAjC;AACD;AAED;;;;;;;;;AAOA,SAAQ4C,OAAR,CAAiB9D,MAAjB,EAAyB;AACvB,eAAW,MAAMkB,KAAjB,IAA0B,KAAKtC,UAAL,CAAgBkF,OAAhB,CAAwB9D,MAAxB,CAA1B,EAA2D;AACzD,WAAK6D,2BAAL,CAAiC3C,KAAjC;;AAEA,YAAMA,KAAN;AACD;AACF;AAED;;;;;;;AAKA2C,EAAAA,2BAA2B,CAAE3C,KAAF,EAAS;AAClC,SAAKvB,aAAL,CAAmBoE,QAAnB,CAA4B7C,KAA5B;AACA,SAAKzB,MAAL,CAAYuE,cAAZ,CAA2B,CAAC9C,KAAD,CAA3B,EAFkC,CAGlC;;AACA,SAAK1B,OAAL,CAAayE,OAAb,CAAqB/C,KAAK,CAACR,GAA3B,EAAgCuC,KAAhC,CAAuClD,GAAD,IAAS;AAC7C,WAAKhB,IAAL,CAAU6C,KAAV,CAAgB,uBAAhB,EAAyC7B,GAAG,CAAC8B,OAA7C;AACD,KAFD;AAGD;AAED;;;;;;;AAKAqC,EAAAA,WAAW,GAAI;AACb,WAAO,KAAKxE,EAAL,CAAQc,QAAR,CAAiB2D,OAAjB,EAAP;AACD;AAED;;;;;;;AAKAC,EAAAA,KAAK,GAAI;AACP,WAAO,KAAK3E,MAAL,CAAY2E,KAAZ,EAAP;AACD;AAED;;;;;;;AAKAC,EAAAA,IAAI,GAAI;AACN,WAAO,KAAKjF,MAAZ;AACD;AAED;;;;;;;AAKAkF,EAAAA,KAAK,GAAI;AACP,SAAK5E,EAAL,CAAQ4E,KAAR;AACA,SAAK9E,OAAL,CAAa8E,KAAb;AACA,SAAK7E,MAAL,CAAY6E,KAAZ;AACD;AAED;;;;;;;AAKAC,EAAAA,IAAI,GAAI;AACN,SAAKnF,MAAL,CAAYmF,IAAZ;;AACA,SAAK7E,EAAL,CAAQ6E,IAAR;AACA,SAAK/E,OAAL,CAAa+E,IAAb;AACA,SAAK9E,MAAL,CAAY8E,IAAZ;AACD;;AAxVW;;AA2VdC,MAAM,CAACC,OAAP,GAAiBhG,OAAjB","sourcesContent":["'use strict'\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\nconst AbortController = require('abort-controller')\nconst anySignal = require('any-signal')\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\nclass Bitswap {\n  constructor (libp2p, blockstore, options) {\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, {}, this._stats)\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerId)\n  }\n\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  // handle messages received through the network\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    const blocks = Array.from(incoming.blocks.values())\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    const wanted = blocks\n      .filter((b) => this.wm.wantlist.contains(b.cid))\n      .map((b) => b.cid)\n\n    this.wm.cancelWants(wanted)\n\n    await Promise.all(blocks.map(async (b) => {\n      const wasWanted = wanted.includes(b.cid)\n      await this._handleReceivedBlock(peerId, b, wasWanted)\n    }))\n  }\n\n  async _handleReceivedBlock (peerId, block, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(block.cid)\n\n    this._updateReceiveCounters(peerId.toB58String(), block, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(block)\n  }\n\n  _updateReceiveCounters (peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1)\n    this._stats.push(peerId, 'dataReceived', block.data.length)\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1)\n      this._stats.push(peerId, 'dupDataReceived', block.data.length)\n    }\n  }\n\n  // handle errors on the receiving channel\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  // handle new peers\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  // handle peers being disconnected\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  /**\n   * @returns {void}\n   */\n  enableStats () {\n    this._stats.enable()\n  }\n\n  /**\n   * @returns {void}\n   */\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Map}\n   */\n  wantlistForPeer (peerId) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Object}\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Block>}\n   */\n  async get (cid, options = {}) {\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = anySignal([options.signal, controller.signal])\n\n    const block = await Promise.race([\n      this.notifications.wantBlock(cid, {\n        signal\n      }),\n      loadOrFetchFromNetwork(cid, {\n        signal\n      })\n    ])\n\n    // since we have the block we can now remove our listener\n    controller.abort()\n\n    return block\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<AsyncIterator<Block>>}\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n  unwant (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    this.wm.unwantBlocks(cids)\n    cids.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n  cancelWants (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n    this.wm.cancelWants(cids)\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @returns {Promise<void>}\n   */\n  async put (block) {\n    await this.blockstore.put(block)\n    this._sendHaveBlockNotifications(block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {AsyncIterable<Block>} blocks\n   * @returns {AsyncIterable<Block>}\n   */\n  async * putMany (blocks) {\n    for await (const block of this.blockstore.putMany(blocks)) {\n      this._sendHaveBlockNotifications(block)\n\n      yield block\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @param {Block} block\n   */\n  _sendHaveBlockNotifications (block) {\n    this.notifications.hasBlock(block)\n    this.engine.receivedBlocks([block])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(block.cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Iterator<PeerId>}\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node.\n   *\n   * @returns {void}\n   */\n  start () {\n    this.wm.start()\n    this.network.start()\n    this.engine.start()\n  }\n\n  /**\n   * Stop the bitswap node.\n   *\n   * @returns {void}\n   */\n  stop () {\n    this._stats.stop()\n    this.wm.stop()\n    this.network.stop()\n    this.engine.stop()\n  }\n}\n\nmodule.exports = Bitswap\n"]},"metadata":{},"sourceType":"script"}