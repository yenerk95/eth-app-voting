{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nvar DuplexPair = require('it-pair/duplex');\n\nvar pipe = require('it-pipe');\n\nvar lp = require('it-length-prefixed');\n\nvar Wrap = require('it-pb-rpc');\n\nvar int32BEEncode = lp.int32BEEncode,\n    int32BEDecode = lp.int32BEDecode; // Maximum length of the data section of the message\n// 8MB, https://github.com/libp2p/specs/blob/94ad1bd/secio/README.md#message-framing\n\nvar MAX_DATA_LENGTH = 0x800000;\n\nvar etm = require('../etm');\n\nvar crypto = require('./crypto'); // step 3. Finish\n// -- send expected message to verify encryption works (send local nonce)\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _finish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(state, wrapped) {\n    var proto, _DuplexPair, _DuplexPair2, secure, user, network, shake, nonceBack;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            log('3. finish - start');\n            proto = state.protocols;\n            _DuplexPair = DuplexPair(), _DuplexPair2 = _slicedToArray(_DuplexPair, 2), secure = _DuplexPair2[0], user = _DuplexPair2[1];\n            network = wrapped.unwrap();\n            pipe(secure, // this is FROM the user\n            etm.createBoxStream(proto.local.cipher, proto.local.mac), lp.encode({\n              lengthEncoder: int32BEEncode\n            }), network, // and gets piped INTO and FROM the network\n            lp.decode({\n              lengthDecoder: int32BEDecode,\n              maxDataLength: MAX_DATA_LENGTH\n            }), etm.createUnboxStream(proto.remote.cipher, proto.remote.mac), secure // and gets piped TO the user\n            ).catch(function (err) {\n              log.error('an error occurred in the crypto stream', err);\n            }); // Exchange nonces over the encrypted stream for final verification\n\n            shake = Wrap(user);\n            shake.write(state.proposal.in.rand);\n            _context.next = 9;\n            return shake.read(state.proposal.in.rand.length);\n\n          case 9:\n            nonceBack = _context.sent;\n            crypto.verifyNonce(state, nonceBack.slice());\n            log('3. finish - finish'); // Awesome that's all folks.\n\n            state.secure = shake.unwrap();\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  function finish(_x, _x2) {\n    return _finish.apply(this, arguments);\n  }\n\n  return finish;\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-secio/src/handshake/finish.js"],"names":["debug","require","log","error","DuplexPair","pipe","lp","Wrap","int32BEEncode","int32BEDecode","MAX_DATA_LENGTH","etm","crypto","module","exports","state","wrapped","proto","protocols","secure","user","network","unwrap","createBoxStream","local","cipher","mac","encode","lengthEncoder","decode","lengthDecoder","maxDataLength","createUnboxStream","remote","catch","err","shake","write","proposal","in","rand","read","length","nonceBack","verifyNonce","slice","finish"],"mappings":"AAAA;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMC,GAAG,GAAGF,KAAK,CAAC,cAAD,CAAjB;AACAE,GAAG,CAACC,KAAJ,GAAYH,KAAK,CAAC,oBAAD,CAAjB;;AAEA,IAAMI,UAAU,GAAGH,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAMI,IAAI,GAAGJ,OAAO,CAAC,SAAD,CAApB;;AACA,IAAMK,EAAE,GAAGL,OAAO,CAAC,oBAAD,CAAlB;;AACA,IAAMM,IAAI,GAAGN,OAAO,CAAC,WAAD,CAApB;;IACQO,a,GAAiCF,E,CAAjCE,a;IAAeC,a,GAAkBH,E,CAAlBG,a,EAEvB;AACA;;AACA,IAAMC,eAAe,GAAG,QAAxB;;AAEA,IAAMC,GAAG,GAAGV,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAMW,MAAM,GAAGX,OAAO,CAAC,UAAD,CAAtB,C,CAEA;AACA;;;AACAY,MAAM,CAACC,OAAP;AAAA,yEAAiB,iBAAuBC,KAAvB,EAA8BC,OAA9B;AAAA;;AAAA;AAAA;AAAA;AAAA;AACfd,YAAAA,GAAG,CAAC,mBAAD,CAAH;AAEMe,YAAAA,KAHS,GAGDF,KAAK,CAACG,SAHL;AAAA,0BAKQd,UAAU,EALlB,iDAKRe,MALQ,oBAKAC,IALA;AAMTC,YAAAA,OANS,GAMCL,OAAO,CAACM,MAAR,EAND;AAQfjB,YAAAA,IAAI,CACFc,MADE,EACM;AACRR,YAAAA,GAAG,CAACY,eAAJ,CAAoBN,KAAK,CAACO,KAAN,CAAYC,MAAhC,EAAwCR,KAAK,CAACO,KAAN,CAAYE,GAApD,CAFE,EAGFpB,EAAE,CAACqB,MAAH,CAAU;AAAEC,cAAAA,aAAa,EAAEpB;AAAjB,aAAV,CAHE,EAIFa,OAJE,EAIO;AACTf,YAAAA,EAAE,CAACuB,MAAH,CAAU;AAAEC,cAAAA,aAAa,EAAErB,aAAjB;AAAgCsB,cAAAA,aAAa,EAAErB;AAA/C,aAAV,CALE,EAMFC,GAAG,CAACqB,iBAAJ,CAAsBf,KAAK,CAACgB,MAAN,CAAaR,MAAnC,EAA2CR,KAAK,CAACgB,MAAN,CAAaP,GAAxD,CANE,EAOFP,MAPE,CAOK;AAPL,aAAJ,CAQEe,KARF,CAQQ,UAAAC,GAAG,EAAI;AACbjC,cAAAA,GAAG,CAACC,KAAJ,CAAU,wCAAV,EAAoDgC,GAApD;AACD,aAVD,EARe,CAoBf;;AACMC,YAAAA,KArBS,GAqBD7B,IAAI,CAACa,IAAD,CArBH;AAsBfgB,YAAAA,KAAK,CAACC,KAAN,CAAYtB,KAAK,CAACuB,QAAN,CAAeC,EAAf,CAAkBC,IAA9B;AAtBe;AAAA,mBAuBSJ,KAAK,CAACK,IAAN,CAAW1B,KAAK,CAACuB,QAAN,CAAeC,EAAf,CAAkBC,IAAlB,CAAuBE,MAAlC,CAvBT;;AAAA;AAuBTC,YAAAA,SAvBS;AAwBf/B,YAAAA,MAAM,CAACgC,WAAP,CAAmB7B,KAAnB,EAA0B4B,SAAS,CAACE,KAAV,EAA1B;AAEA3C,YAAAA,GAAG,CAAC,oBAAD,CAAH,CA1Be,CA4Bf;;AACAa,YAAAA,KAAK,CAACI,MAAN,GAAeiB,KAAK,CAACd,MAAN,EAAf;;AA7Be;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAjB;;AAAA,WAAgCwB,MAAhC;AAAA;AAAA;;AAAA,SAAgCA,MAAhC;AAAA","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:secio')\nlog.error = debug('libp2p:secio:error')\n\nconst DuplexPair = require('it-pair/duplex')\nconst pipe = require('it-pipe')\nconst lp = require('it-length-prefixed')\nconst Wrap = require('it-pb-rpc')\nconst { int32BEEncode, int32BEDecode } = lp\n\n// Maximum length of the data section of the message\n// 8MB, https://github.com/libp2p/specs/blob/94ad1bd/secio/README.md#message-framing\nconst MAX_DATA_LENGTH = 0x800000\n\nconst etm = require('../etm')\nconst crypto = require('./crypto')\n\n// step 3. Finish\n// -- send expected message to verify encryption works (send local nonce)\nmodule.exports = async function finish (state, wrapped) {\n  log('3. finish - start')\n\n  const proto = state.protocols\n\n  const [secure, user] = DuplexPair()\n  const network = wrapped.unwrap()\n\n  pipe(\n    secure, // this is FROM the user\n    etm.createBoxStream(proto.local.cipher, proto.local.mac),\n    lp.encode({ lengthEncoder: int32BEEncode }),\n    network, // and gets piped INTO and FROM the network\n    lp.decode({ lengthDecoder: int32BEDecode, maxDataLength: MAX_DATA_LENGTH }),\n    etm.createUnboxStream(proto.remote.cipher, proto.remote.mac),\n    secure // and gets piped TO the user\n  ).catch(err => {\n    log.error('an error occurred in the crypto stream', err)\n  })\n\n  // Exchange nonces over the encrypted stream for final verification\n  const shake = Wrap(user)\n  shake.write(state.proposal.in.rand)\n  const nonceBack = await shake.read(state.proposal.in.rand.length)\n  crypto.verifyNonce(state, nonceBack.slice())\n\n  log('3. finish - finish')\n\n  // Awesome that's all folks.\n  state.secure = shake.unwrap()\n}\n"]},"metadata":{},"sourceType":"script"}