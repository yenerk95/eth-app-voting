{"ast":null,"code":"import _regeneratorRuntime from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { IK } from \"./handshakes/ik\";\nimport { Buffer } from \"buffer\";\nimport { decode0, decode1, encode0, encode1 } from \"./encoder\";\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from \"./utils\";\nimport { FailedIKError } from \"./errors\";\nimport { logger, logLocalStaticKeys, logRemoteStaticKey, logLocalEphemeralKeys, logRemoteEphemeralKey, logCipherState } from \"./logger\";\nexport var IKHandshake = /*#__PURE__*/function () {\n  function IKHandshake(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n    _classCallCheck(this, IKHandshake);\n\n    _defineProperty(this, \"isInitiator\", void 0);\n\n    _defineProperty(this, \"session\", void 0);\n\n    _defineProperty(this, \"remotePeer\", void 0);\n\n    _defineProperty(this, \"remoteEarlyData\", void 0);\n\n    _defineProperty(this, \"payload\", void 0);\n\n    _defineProperty(this, \"prologue\", void 0);\n\n    _defineProperty(this, \"staticKeypair\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"ik\", void 0);\n\n    this.isInitiator = isInitiator;\n    this.payload = Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.ik = handshake || new IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = Buffer.alloc(0);\n  }\n\n  _createClass(IKHandshake, [{\n    key: \"stage0\",\n    value: function () {\n      var _stage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var messageBuffer, receivedMsg, receivedMessageBuffer, _this$ik$recvMessage, plaintext, valid, decodedPayload;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logLocalStaticKeys(this.session.hs.s);\n                logRemoteStaticKey(this.session.hs.rs);\n\n                if (!this.isInitiator) {\n                  _context.next = 10;\n                  break;\n                }\n\n                logger(\"IK Stage 0 - Initiator sending message...\");\n                messageBuffer = this.ik.sendMessage(this.session, this.payload);\n                this.connection.writeLP(encode1(messageBuffer));\n                logger(\"IK Stage 0 - Initiator sent message.\");\n                logLocalEphemeralKeys(this.session.hs.e);\n                _context.next = 40;\n                break;\n\n              case 10:\n                logger(\"IK Stage 0 - Responder receiving message...\");\n                _context.next = 13;\n                return this.connection.readLP();\n\n              case 13:\n                receivedMsg = _context.sent;\n                _context.prev = 14;\n                receivedMessageBuffer = decode1(receivedMsg.slice());\n                _this$ik$recvMessage = this.ik.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$ik$recvMessage.plaintext, valid = _this$ik$recvMessage.valid;\n\n                if (valid) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw new Error(\"ik handshake stage 0 decryption validation fail\");\n\n              case 19:\n                logger(\"IK Stage 0 - Responder got message, going to verify payload.\");\n                _context.next = 22;\n                return decodePayload(plaintext);\n\n              case 22:\n                decodedPayload = _context.sent;\n                _context.t0 = this.remotePeer;\n\n                if (_context.t0) {\n                  _context.next = 28;\n                  break;\n                }\n\n                _context.next = 27;\n                return getPeerIdFromPayload(decodedPayload);\n\n              case 27:\n                _context.t0 = _context.sent;\n\n              case 28:\n                this.remotePeer = _context.t0;\n                _context.next = 31;\n                return verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n\n              case 31:\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger(\"IK Stage 0 - Responder successfully verified payload!\");\n                logRemoteEphemeralKey(this.session.hs.re);\n                _context.next = 40;\n                break;\n\n              case 36:\n                _context.prev = 36;\n                _context.t1 = _context[\"catch\"](14);\n                logger(\"Responder breaking up with IK handshake in stage 0.\");\n                throw new FailedIKError(receivedMsg, \"Error occurred while verifying initiator's signed payload: \".concat(_context.t1.message));\n\n              case 40:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[14, 36]]);\n      }));\n\n      function stage0() {\n        return _stage.apply(this, arguments);\n      }\n\n      return stage0;\n    }()\n  }, {\n    key: \"stage1\",\n    value: function () {\n      var _stage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var receivedMsg, receivedMessageBuffer, _this$ik$recvMessage2, plaintext, valid, decodedPayload, messageBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.isInitiator) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                logger(\"IK Stage 1 - Initiator receiving message...\");\n                _context2.next = 4;\n                return this.connection.readLP();\n\n              case 4:\n                receivedMsg = _context2.sent.slice();\n                receivedMessageBuffer = decode0(Buffer.from(receivedMsg));\n                _this$ik$recvMessage2 = this.ik.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$ik$recvMessage2.plaintext, valid = _this$ik$recvMessage2.valid;\n                logger(\"IK Stage 1 - Initiator got message, going to verify payload.\");\n                _context2.prev = 8;\n\n                if (valid) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw new Error(\"ik stage 1 decryption validation fail\");\n\n              case 11:\n                _context2.next = 13;\n                return decodePayload(plaintext);\n\n              case 13:\n                decodedPayload = _context2.sent;\n                _context2.t0 = this.remotePeer;\n\n                if (_context2.t0) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                _context2.next = 18;\n                return getPeerIdFromPayload(decodedPayload);\n\n              case 18:\n                _context2.t0 = _context2.sent;\n\n              case 19:\n                this.remotePeer = _context2.t0;\n                _context2.next = 22;\n                return verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n\n              case 22:\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger(\"IK Stage 1 - Initiator successfully verified payload!\");\n                logRemoteEphemeralKey(this.session.hs.re);\n                _context2.next = 31;\n                break;\n\n              case 27:\n                _context2.prev = 27;\n                _context2.t1 = _context2[\"catch\"](8);\n                logger(\"Initiator breaking up with IK handshake in stage 1.\");\n                throw new FailedIKError(receivedMsg, \"Error occurred while verifying responder's signed payload: \".concat(_context2.t1.message));\n\n              case 31:\n                _context2.next = 38;\n                break;\n\n              case 33:\n                logger(\"IK Stage 1 - Responder sending message...\");\n                messageBuffer = this.ik.sendMessage(this.session, this.payload);\n                this.connection.writeLP(encode0(messageBuffer));\n                logger(\"IK Stage 1 - Responder sent message...\");\n                logLocalEphemeralKeys(this.session.hs.e);\n\n              case 38:\n                logCipherState(this.session);\n\n              case 39:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 27]]);\n      }));\n\n      function stage1() {\n        return _stage2.apply(this, arguments);\n      }\n\n      return stage1;\n    }()\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(ciphertext, session) {\n      var cs = this.getCS(session, false);\n      return this.ik.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(plaintext, session) {\n      var cs = this.getCS(session);\n      return this.ik.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n    }\n  }, {\n    key: \"getLocalEphemeralKeys\",\n    value: function getLocalEphemeralKeys() {\n      if (!this.session.hs.e) {\n        throw new Error(\"Ephemeral keys do not exist.\");\n      }\n\n      return this.session.hs.e;\n    }\n  }, {\n    key: \"getCS\",\n    value: function getCS(session) {\n      var encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!session.cs1 || !session.cs2) {\n        throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n      }\n\n      if (this.isInitiator) {\n        return encryption ? session.cs1 : session.cs2;\n      } else {\n        return encryption ? session.cs2 : session.cs1;\n      }\n    }\n  }, {\n    key: \"setRemoteEarlyData\",\n    value: function setRemoteEarlyData(data) {\n      if (data) {\n        this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n      }\n    }\n  }]);\n\n  return IKHandshake;\n}();","map":{"version":3,"sources":["../src/handshake-ik.ts"],"names":["constructor","Buffer","handshake","logLocalStaticKeys","logRemoteStaticKey","logger","messageBuffer","encode1","logLocalEphemeralKeys","receivedMsg","receivedMessageBuffer","decode1","valid","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","logRemoteEphemeralKey","e","decode0","encode0","logCipherState","cs","encryption","session","data"],"mappings":"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","sourcesContent":["import {WrappedConnection} from \"./noise\";\nimport {IK} from \"./handshakes/ik\";\nimport {NoiseSession} from \"./@types/handshake\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {KeyPair} from \"./@types/libp2p\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {Buffer} from \"buffer\";\nimport {decode0, decode1, encode0, encode1} from \"./encoder\";\nimport {decodePayload, getPeerIdFromPayload, verifySignedPayload} from \"./utils\";\nimport {FailedIKError} from \"./errors\";\nimport {\n  logger, \n  logLocalStaticKeys,\n  logRemoteStaticKey, \n  logLocalEphemeralKeys, \n  logRemoteEphemeralKey, \n  logCipherState\n} from \"./logger\";\nimport PeerId from \"peer-id\";\n\nexport class IKHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  private payload: bytes;\n  private prologue: bytes32;\n  private staticKeypair: KeyPair;\n  private connection: WrappedConnection;\n  private ik: IK;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remoteStaticKey: bytes,\n    remotePeer?: PeerId,\n    handshake?: IK,\n  ) {\n    this.isInitiator = isInitiator;\n    this.payload = Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if(remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.ik = handshake || new IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  public async stage0(): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    logRemoteStaticKey(this.session.hs.rs)\n    if (this.isInitiator) {\n      logger(\"IK Stage 0 - Initiator sending message...\");\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger(\"IK Stage 0 - Initiator sent message.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"IK Stage 0 - Responder receiving message...\");\n      const receivedMsg = await this.connection.readLP();\n      try {\n        const receivedMessageBuffer = decode1(receivedMsg.slice());\n        const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);\n        if(!valid) {\n          throw new Error(\"ik handshake stage 0 decryption validation fail\");\n        }\n        logger(\"IK Stage 0 - Responder got message, going to verify payload.\");\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger(\"IK Stage 0 - Responder successfully verified payload!\");\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger(\"Responder breaking up with IK handshake in stage 0.\");\n\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`);\n      }\n    }\n  }\n\n  public async stage1(): Promise<void> {\n    if (this.isInitiator) {\n      logger(\"IK Stage 1 - Initiator receiving message...\");\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = decode0(Buffer.from(receivedMsg));\n      const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);\n      logger(\"IK Stage 1 - Initiator got message, going to verify payload.\");\n      try {\n        if(!valid) {\n          throw new Error(\"ik stage 1 decryption validation fail\");\n        }\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger(\"IK Stage 1 - Initiator successfully verified payload!\");\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger(\"Initiator breaking up with IK handshake in stage 1.\");\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`);\n      }\n    } else {\n      logger(\"IK Stage 1 - Responder sending message...\");\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"IK Stage 1 - Responder sent message...\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n    logCipherState(this.session)\n  }\n\n  public decrypt(ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  public encrypt(plaintext: Buffer, session: NoiseSession): Buffer {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  public getLocalEphemeralKeys(): KeyPair {\n    if (!this.session.hs.e) {\n      throw new Error(\"Ephemeral keys do not exist.\");\n    }\n\n    return this.session.hs.e;\n  }\n\n  private getCS(session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  private setRemoteEarlyData(data: Uint8Array|null|undefined): void {\n    if(data){\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}