{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('streaming-iterables'),\n    map = _require.map;\n\nvar errcode = require('err-code');\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\n\n\nvar BlockService = /*#__PURE__*/function () {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  function BlockService(ipfsRepo) {\n    _classCallCheck(this, BlockService);\n\n    this._repo = ipfsRepo;\n    this._bitswap = null;\n  }\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n\n\n  _createClass(BlockService, [{\n    key: \"setExchange\",\n    value: function setExchange(bitswap) {\n      this._bitswap = bitswap;\n    }\n    /**\n     * Go offline, i.e. drop the reference to bitswap.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsetExchange\",\n    value: function unsetExchange() {\n      this._bitswap = null;\n    }\n    /**\n     * Is the blockservice online, i.e. is bitswap present.\n     *\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"hasExchange\",\n    value: function hasExchange() {\n      return this._bitswap != null;\n    }\n    /**\n     * Put a block to the underlying datastore.\n     *\n     * @param {Block} block\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(block, options) {\n      if (this.hasExchange()) {\n        return this._bitswap.put(block, options);\n      } else {\n        return this._repo.blocks.put(block, options);\n      }\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore.\n     *\n     * @param {AsyncIterator<Block>} blocks\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks, options) {\n      if (this.hasExchange()) {\n        return this._bitswap.putMany(blocks, options);\n      } else {\n        return this._repo.blocks.putMany(blocks, options);\n      }\n    }\n    /**\n     * Get a block by cid.\n     *\n     * @param {CID} cid\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise<Block>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(cid, options) {\n      if (this.hasExchange()) {\n        return this._bitswap.get(cid, options);\n      } else {\n        return this._repo.blocks.get(cid, options);\n      }\n    }\n    /**\n     * Get multiple blocks back from an array of cids.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {AsyncIterator<Block>}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, options) {\n      var _this = this;\n\n      if (!Array.isArray(cids)) {\n        throw new Error('first arg must be an array of cids');\n      }\n\n      if (this.hasExchange()) {\n        return this._bitswap.getMany(cids, options);\n      } else {\n        var getRepoBlocks = map(function (cid) {\n          return _this._repo.blocks.get(cid, options);\n        });\n        return getRepoBlocks(cids);\n      }\n    }\n    /**\n     * Delete a block from the blockstore.\n     *\n     * @param {CID} cid\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._repo.blocks.has(cid);\n\n              case 2:\n                if (_context.sent) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n\n              case 4:\n                return _context.abrupt(\"return\", this._repo.blocks.delete(cid, options));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _delete(_x, _x2) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Delete multiple blocks from the blockstore.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"deleteMany\",\n    value: function deleteMany(cids, options) {\n      var repo = this._repo;\n      return this._repo.blocks.deleteMany(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context2.prev = 2;\n                _iterator = _asyncIterator(cids);\n\n              case 4:\n                _context2.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context2.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context2.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context2.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                cid = _value;\n                _context2.next = 15;\n                return _awaitAsyncGenerator(repo.blocks.has(cid));\n\n              case 15:\n                if (_context2.sent) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n\n              case 17:\n                _context2.next = 19;\n                return cid;\n\n              case 19:\n                _iteratorNormalCompletion = true;\n                _context2.next = 4;\n                break;\n\n              case 22:\n                _context2.next = 28;\n                break;\n\n              case 24:\n                _context2.prev = 24;\n                _context2.t0 = _context2[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context2.t0;\n\n              case 28:\n                _context2.prev = 28;\n                _context2.prev = 29;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                _context2.next = 33;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 33:\n                _context2.prev = 33;\n\n                if (!_didIteratorError) {\n                  _context2.next = 36;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 36:\n                return _context2.finish(33);\n\n              case 37:\n                return _context2.finish(28);\n\n              case 38:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[2, 24, 28, 38], [29,, 33, 37]]);\n      }))(), options);\n    }\n  }]);\n\n  return BlockService;\n}();\n\nmodule.exports = BlockService;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-block-service/src/index.js"],"names":["require","map","errcode","BlockService","ipfsRepo","_repo","_bitswap","bitswap","block","options","hasExchange","put","blocks","putMany","cid","get","cids","Array","isArray","Error","getMany","getRepoBlocks","has","delete","repo","deleteMany","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;eAEgBA,OAAO,CAAC,qBAAD,C;IAAfC,G,YAAAA,G;;AACR,IAAMC,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;AAEA;;;;;;;IAKMG,Y;AACJ;;;;;AAKA,wBAAaC,QAAb,EAAuB;AAAA;;AACrB,SAAKC,KAAL,GAAaD,QAAb;AACA,SAAKE,QAAL,GAAgB,IAAhB;AACD;AAED;;;;;;;;;;;;;;gCAUaC,O,EAAS;AACpB,WAAKD,QAAL,GAAgBC,OAAhB;AACD;AAED;;;;;;;;oCAKiB;AACf,WAAKD,QAAL,GAAgB,IAAhB;AACD;AAED;;;;;;;;kCAKe;AACb,aAAO,KAAKA,QAAL,IAAiB,IAAxB;AACD;AAED;;;;;;;;;;;wBAQKE,K,EAAOC,O,EAAS;AACnB,UAAI,KAAKC,WAAL,EAAJ,EAAwB;AACtB,eAAO,KAAKJ,QAAL,CAAcK,GAAd,CAAkBH,KAAlB,EAAyBC,OAAzB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKJ,KAAL,CAAWO,MAAX,CAAkBD,GAAlB,CAAsBH,KAAtB,EAA6BC,OAA7B,CAAP;AACD;AACF;AAED;;;;;;;;;;;4BAQSG,M,EAAQH,O,EAAS;AACxB,UAAI,KAAKC,WAAL,EAAJ,EAAwB;AACtB,eAAO,KAAKJ,QAAL,CAAcO,OAAd,CAAsBD,MAAtB,EAA8BH,OAA9B,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKJ,KAAL,CAAWO,MAAX,CAAkBC,OAAlB,CAA0BD,MAA1B,EAAkCH,OAAlC,CAAP;AACD;AACF;AAED;;;;;;;;;;;wBAQKK,G,EAAKL,O,EAAS;AACjB,UAAI,KAAKC,WAAL,EAAJ,EAAwB;AACtB,eAAO,KAAKJ,QAAL,CAAcS,GAAd,CAAkBD,GAAlB,EAAuBL,OAAvB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKJ,KAAL,CAAWO,MAAX,CAAkBG,GAAlB,CAAsBD,GAAtB,EAA2BL,OAA3B,CAAP;AACD;AACF;AAED;;;;;;;;;;;4BAQSO,I,EAAMP,O,EAAS;AAAA;;AACtB,UAAI,CAACQ,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0B;AACxB,cAAM,IAAIG,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,UAAI,KAAKT,WAAL,EAAJ,EAAwB;AACtB,eAAO,KAAKJ,QAAL,CAAcc,OAAd,CAAsBJ,IAAtB,EAA4BP,OAA5B,CAAP;AACD,OAFD,MAEO;AACL,YAAMY,aAAa,GAAGpB,GAAG,CAAC,UAACa,GAAD;AAAA,iBAAS,KAAI,CAACT,KAAL,CAAWO,MAAX,CAAkBG,GAAlB,CAAsBD,GAAtB,EAA2BL,OAA3B,CAAT;AAAA,SAAD,CAAzB;AACA,eAAOY,aAAa,CAACL,IAAD,CAApB;AACD;AACF;AAED;;;;;;;;;;;;+FAQcF,G,EAAKL,O;;;;;;uBACN,KAAKJ,KAAL,CAAWO,MAAX,CAAkBU,GAAlB,CAAsBR,GAAtB,C;;;;;;;;sBACHZ,OAAO,CAAC,IAAIiB,KAAJ,CAAU,6BAAV,CAAD,EAA2C,qBAA3C,C;;;iDAGR,KAAKd,KAAL,CAAWO,MAAX,CAAkBW,MAAlB,CAAyBT,GAAzB,EAA8BL,OAA9B,C;;;;;;;;;;;;;;;;AAGT;;;;;;;;;;;+BAQYO,I,EAAMP,O,EAAS;AACzB,UAAMe,IAAI,GAAG,KAAKnB,KAAlB;AAEA,aAAO,KAAKA,KAAL,CAAWO,MAAX,CAAkBa,UAAlB,CAA8B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACXT,IADW;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAClBF,gBAAAA,GADkB;AAAA;AAAA,4CAEtBU,IAAI,CAACZ,MAAL,CAAYU,GAAZ,CAAgBR,GAAhB,CAFsB;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,sBAGzBZ,OAAO,CAAC,IAAIiB,KAAJ,CAAU,6BAAV,CAAD,EAA2C,qBAA3C,CAHkB;;AAAA;AAAA;AAMjC,uBAAML,GAAN;;AANiC;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAA9B,EAQDL,OARC,CAAP;AASD;;;;;;AAGHiB,MAAM,CAACC,OAAP,GAAiBxB,YAAjB","sourcesContent":["'use strict'\n\nconst { map } = require('streaming-iterables')\nconst errcode = require('err-code')\n\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor (ipfsRepo) {\n    this._repo = ipfsRepo\n    this._bitswap = null\n  }\n\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n  setExchange (bitswap) {\n    this._bitswap = bitswap\n  }\n\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n  unsetExchange () {\n    this._bitswap = null\n  }\n\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n  hasExchange () {\n    return this._bitswap != null\n  }\n\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  put (block, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block, options)\n    } else {\n      return this._repo.blocks.put(block, options)\n    }\n  }\n\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {AsyncIterator<Block>} blocks\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  putMany (blocks, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks, options)\n    } else {\n      return this._repo.blocks.putMany(blocks, options)\n    }\n  }\n\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise<Block>}\n   */\n  get (cid, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid, options)\n    } else {\n      return this._repo.blocks.get(cid, options)\n    }\n  }\n\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {AsyncIterator<Block>}\n   */\n  getMany (cids, options) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids')\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids, options)\n    } else {\n      const getRepoBlocks = map((cid) => this._repo.blocks.get(cid, options))\n      return getRepoBlocks(cids)\n    }\n  }\n\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  async delete (cid, options) {\n    if (!await this._repo.blocks.has(cid)) {\n      throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND')\n    }\n\n    return this._repo.blocks.delete(cid, options)\n  }\n\n  /**\n   * Delete multiple blocks from the blockstore.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  deleteMany (cids, options) {\n    const repo = this._repo\n\n    return this._repo.blocks.deleteMany((async function * () {\n      for await (const cid of cids) {\n        if (!await repo.blocks.has(cid)) {\n          throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND')\n        }\n\n        yield cid\n      }\n    }()), options)\n  }\n}\n\nmodule.exports = BlockService\n"]},"metadata":{},"sourceType":"script"}