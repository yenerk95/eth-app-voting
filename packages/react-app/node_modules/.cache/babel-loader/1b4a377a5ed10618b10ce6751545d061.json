{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst parseDuration = require('parse-duration');\n\nconst Key = require('interface-datastore').Key;\n\nconst {\n  TimeoutError\n} = require('./errors');\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n};\nexports.MFS_ROOT_KEY = new Key('/local/filesroot');\nexports.MFS_MAX_CHUNK_SIZE = 262144;\nexports.MFS_MAX_LINKS = 174;\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw new Error('invalid ipfs ref path');\n  }\n\n  const [hash, ...links] = matched[1].split('/'); // check that a CID can be constructed with the hash\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash,\n      links\n    };\n  } else {\n    throw new Error('invalid ipfs ref path');\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nconst normalizePath = pathStr => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${new CID(pathStr)}`;\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(`invalid path: ${pathStr}`), {\n      code: ERR_BAD_PATH\n    });\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n\n\nconst normalizeCidPath = path => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param {Dag} dag The IPFS dag api\n * @param {Array<CID|string>} ipfsPaths A single or collection of ipfs-paths\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {Promise<Array<CID>>}\n */\n\n\nconst resolvePath = async function (dag, ipfsPaths, options) {\n  options = options || {};\n\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths];\n  }\n\n  const cids = [];\n\n  for (const path of ipfsPaths) {\n    if (isIpfs.cid(path)) {\n      cids.push(new CID(path));\n      continue;\n    }\n\n    const {\n      hash,\n      links\n    } = parseIpfsPath(path);\n\n    if (!links.length) {\n      cids.push(new CID(hash));\n      continue;\n    }\n\n    let cid = new CID(hash);\n\n    try {\n      for await (const {\n        value\n      } of dag.resolve(path, options)) {\n        if (CID.isCID(value)) {\n          cid = value;\n        }\n      }\n    } catch (err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        const linkName = err.message.replace('Object has no property \\'', '').slice(0, -1);\n        err.message = `no link named \"${linkName}\" under ${cid}`;\n        err.code = 'ERR_NO_LINK';\n      }\n\n      throw err;\n    }\n\n    cids.push(cid);\n  }\n\n  return cids;\n};\n\nconst mapFile = (file, options) => {\n  options = options || {};\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'dir'\n  };\n\n  if (file.unixfs) {\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize();\n      output.type = 'file';\n\n      if (options.includeContent) {\n        output.content = file.content();\n      }\n    }\n\n    output.mode = file.unixfs.mode;\n    output.mtime = file.unixfs.mtime;\n  }\n\n  return output;\n};\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  return (...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n    if (!options || !options.timeout) return fn(...args);\n    const timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n    const controller = new TimeoutController(timeout);\n    options.signal = anySignal([options.signal, controller.signal]);\n    const fnRes = fn(...args);\n    const timeoutPromise = new Promise((resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError());\n      });\n    });\n    const start = Date.now();\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError();\n      }\n\n      const timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n\n      if (timeTaken > timeout) {\n        controller.abort();\n        throw new TimeoutError();\n      }\n    };\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return async function* () {\n        const it = fnRes[Symbol.asyncIterator]();\n\n        try {\n          while (true) {\n            const {\n              value,\n              done\n            } = await Promise.race([it.next(), timeoutPromise]);\n\n            if (done) {\n              break;\n            }\n\n            maybeThrowTimeoutError();\n            yield value;\n          }\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n\n          if (it.return) {\n            it.return();\n          }\n        }\n      }();\n    }\n\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise]);\n        maybeThrowTimeoutError();\n        return res;\n      } catch (err) {\n        maybeThrowTimeoutError();\n        throw err;\n      } finally {\n        controller.clear();\n      }\n    })();\n  };\n}\n\nexports.normalizePath = normalizePath;\nexports.normalizeCidPath = normalizeCidPath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;\nexports.mapFile = mapFile;\nexports.withTimeoutOption = withTimeoutOption;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/utils.js"],"names":["isIpfs","require","CID","Buffer","TimeoutController","anySignal","parseDuration","Key","TimeoutError","ERR_BAD_PATH","exports","OFFLINE_ERROR","MFS_FILE_TYPES","file","directory","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","parseIpfsPath","ipfsPath","replace","matched","match","Error","hash","links","split","cid","normalizePath","pathStr","path","Object","assign","code","normalizeCidPath","isBuffer","toString","isCID","indexOf","substring","length","charAt","resolvePath","dag","ipfsPaths","options","Array","isArray","cids","push","value","resolve","err","message","startsWith","linkName","slice","mapFile","output","name","depth","size","type","unixfs","fileSize","includeContent","content","mode","mtime","withTimeoutOption","fn","optionsArgIndex","args","timeout","controller","signal","fnRes","timeoutPromise","Promise","reject","addEventListener","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","done","race","next","clear","return","res"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAaF,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,0BAAD,CAAjC;;AACA,MAAMI,SAAS,GAAGJ,OAAO,CAAC,YAAD,CAAzB;;AACA,MAAMK,aAAa,GAAGL,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,qBAAD,CAAP,CAA+BM,GAA3C;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAmBP,OAAO,CAAC,UAAD,CAAhC;;AAEA,MAAMQ,YAAY,GAAG,cAArB;AACAC,OAAO,CAACC,aAAR,GAAwB,6EAAxB;AAEAD,OAAO,CAACE,cAAR,GAAyB;AACvBC,EAAAA,IAAI,EAAE,CADiB;AAEvBC,EAAAA,SAAS,EAAE,CAFY;AAGvB,4BAA0B;AAHH,CAAzB;AAKAJ,OAAO,CAACK,YAAR,GAAuB,IAAIR,GAAJ,CAAQ,kBAAR,CAAvB;AACAG,OAAO,CAACM,kBAAR,GAA6B,MAA7B;AACAN,OAAO,CAACO,aAAR,GAAwB,GAAxB;AAEA;;;;;;;;;;;;;AAYA,SAASC,aAAT,CAAwBC,QAAxB,EAAkC;AAChCA,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,OAAT,CAAiB,WAAjB,EAA8B,EAA9B,CAAX;AACA,QAAMC,OAAO,GAAGF,QAAQ,CAACG,KAAT,CAAe,yBAAf,CAAhB;;AACA,MAAI,CAACD,OAAL,EAAc;AACZ,UAAM,IAAIE,KAAJ,CAAU,uBAAV,CAAN;AACD;;AAED,QAAM,CAACC,IAAD,EAAO,GAAGC,KAAV,IAAmBJ,OAAO,CAAC,CAAD,CAAP,CAAWK,KAAX,CAAiB,GAAjB,CAAzB,CAPgC,CAShC;;AACA,MAAI1B,MAAM,CAAC2B,GAAP,CAAWH,IAAX,CAAJ,EAAsB;AACpB,WAAO;AAAEA,MAAAA,IAAF;AAAQC,MAAAA;AAAR,KAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAIF,KAAJ,CAAU,uBAAV,CAAN;AACD;AACF;AAED;;;;;;;;;;AAQA,MAAMK,aAAa,GAAIC,OAAD,IAAa;AACjC,MAAI7B,MAAM,CAAC2B,GAAP,CAAWE,OAAX,CAAJ,EAAyB;AACvB,WAAQ,SAAQ,IAAI3B,GAAJ,CAAQ2B,OAAR,CAAiB,EAAjC;AACD,GAFD,MAEO,IAAI7B,MAAM,CAAC8B,IAAP,CAAYD,OAAZ,CAAJ,EAA0B;AAC/B,WAAOA,OAAP;AACD,GAFM,MAEA;AACL,UAAME,MAAM,CAACC,MAAP,CAAc,IAAIT,KAAJ,CAAW,iBAAgBM,OAAQ,EAAnC,CAAd,EAAqD;AAAEI,MAAAA,IAAI,EAAExB;AAAR,KAArD,CAAN;AACD;AACF,CARD,C,CAUA;;;AACA,MAAMyB,gBAAgB,GAAIJ,IAAD,IAAU;AACjC,MAAI3B,MAAM,CAACgC,QAAP,CAAgBL,IAAhB,CAAJ,EAA2B;AACzB,WAAO,IAAI5B,GAAJ,CAAQ4B,IAAR,EAAcM,QAAd,EAAP;AACD;;AACD,MAAIlC,GAAG,CAACmC,KAAJ,CAAUP,IAAV,CAAJ,EAAqB;AACnB,WAAOA,IAAI,CAACM,QAAL,EAAP;AACD;;AACD,MAAIN,IAAI,CAACQ,OAAL,CAAa,QAAb,MAA2B,CAA/B,EAAkC;AAChCR,IAAAA,IAAI,GAAGA,IAAI,CAACS,SAAL,CAAe,SAASC,MAAxB,CAAP;AACD;;AACD,MAAIV,IAAI,CAACW,MAAL,CAAYX,IAAI,CAACU,MAAL,GAAc,CAA1B,MAAiC,GAArC,EAA0C;AACxCV,IAAAA,IAAI,GAAGA,IAAI,CAACS,SAAL,CAAe,CAAf,EAAkBT,IAAI,CAACU,MAAL,GAAc,CAAhC,CAAP;AACD;;AACD,SAAOV,IAAP;AACD,CAdD;AAgBA;;;;;;;;;;;;;;;;;;AAgBA,MAAMY,WAAW,GAAG,gBAAgBC,GAAhB,EAAqBC,SAArB,EAAgCC,OAAhC,EAAyC;AAC3DA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,SAAd,CAAL,EAA+B;AAC7BA,IAAAA,SAAS,GAAG,CAACA,SAAD,CAAZ;AACD;;AAED,QAAMI,IAAI,GAAG,EAAb;;AAEA,OAAK,MAAMlB,IAAX,IAAmBc,SAAnB,EAA8B;AAC5B,QAAI5C,MAAM,CAAC2B,GAAP,CAAWG,IAAX,CAAJ,EAAsB;AACpBkB,MAAAA,IAAI,CAACC,IAAL,CAAU,IAAI/C,GAAJ,CAAQ4B,IAAR,CAAV;AACA;AACD;;AAED,UAAM;AAAEN,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAkBP,aAAa,CAACY,IAAD,CAArC;;AAEA,QAAI,CAACL,KAAK,CAACe,MAAX,EAAmB;AACjBQ,MAAAA,IAAI,CAACC,IAAL,CAAU,IAAI/C,GAAJ,CAAQsB,IAAR,CAAV;AACA;AACD;;AAED,QAAIG,GAAG,GAAG,IAAIzB,GAAJ,CAAQsB,IAAR,CAAV;;AACA,QAAI;AACF,iBAAW,MAAM;AAAE0B,QAAAA;AAAF,OAAjB,IAA8BP,GAAG,CAACQ,OAAJ,CAAYrB,IAAZ,EAAkBe,OAAlB,CAA9B,EAA0D;AACxD,YAAI3C,GAAG,CAACmC,KAAJ,CAAUa,KAAV,CAAJ,EAAsB;AACpBvB,UAAAA,GAAG,GAAGuB,KAAN;AACD;AACF;AACF,KAND,CAME,OAAOE,GAAP,EAAY;AACZ;AACA,UAAIA,GAAG,CAACC,OAAJ,CAAYC,UAAZ,CAAuB,wBAAvB,CAAJ,EAAsD;AACpD,cAAMC,QAAQ,GAAGH,GAAG,CAACC,OAAJ,CAAYjC,OAAZ,CAAoB,2BAApB,EAAiD,EAAjD,EAAqDoC,KAArD,CAA2D,CAA3D,EAA8D,CAAC,CAA/D,CAAjB;AACAJ,QAAAA,GAAG,CAACC,OAAJ,GAAe,kBAAiBE,QAAS,WAAU5B,GAAI,EAAvD;AACAyB,QAAAA,GAAG,CAACnB,IAAJ,GAAW,aAAX;AACD;;AACD,YAAMmB,GAAN;AACD;;AACDJ,IAAAA,IAAI,CAACC,IAAL,CAAUtB,GAAV;AACD;;AAED,SAAOqB,IAAP;AACD,CA1CD;;AA4CA,MAAMS,OAAO,GAAG,CAAC5C,IAAD,EAAOgC,OAAP,KAAmB;AACjCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAMa,MAAM,GAAG;AACb/B,IAAAA,GAAG,EAAEd,IAAI,CAACc,GADG;AAEbG,IAAAA,IAAI,EAAEjB,IAAI,CAACiB,IAFE;AAGb6B,IAAAA,IAAI,EAAE9C,IAAI,CAAC8C,IAHE;AAIbC,IAAAA,KAAK,EAAE/C,IAAI,CAACiB,IAAL,CAAUJ,KAAV,CAAgB,GAAhB,EAAqBc,MAJf;AAKbqB,IAAAA,IAAI,EAAE,CALO;AAMbC,IAAAA,IAAI,EAAE;AANO,GAAf;;AASA,MAAIjD,IAAI,CAACkD,MAAT,EAAiB;AACf,QAAIlD,IAAI,CAACkD,MAAL,CAAYD,IAAZ,KAAqB,MAAzB,EAAiC;AAC/BJ,MAAAA,MAAM,CAACG,IAAP,GAAchD,IAAI,CAACkD,MAAL,CAAYC,QAAZ,EAAd;AACAN,MAAAA,MAAM,CAACI,IAAP,GAAc,MAAd;;AAEA,UAAIjB,OAAO,CAACoB,cAAZ,EAA4B;AAC1BP,QAAAA,MAAM,CAACQ,OAAP,GAAiBrD,IAAI,CAACqD,OAAL,EAAjB;AACD;AACF;;AAEDR,IAAAA,MAAM,CAACS,IAAP,GAActD,IAAI,CAACkD,MAAL,CAAYI,IAA1B;AACAT,IAAAA,MAAM,CAACU,KAAP,GAAevD,IAAI,CAACkD,MAAL,CAAYK,KAA3B;AACD;;AAED,SAAOV,MAAP;AACD,CA3BD;;AA6BA,SAASW,iBAAT,CAA4BC,EAA5B,EAAgCC,eAAhC,EAAiD;AAC/C,SAAO,CAAC,GAAGC,IAAJ,KAAa;AAClB,UAAM3B,OAAO,GAAG2B,IAAI,CAACD,eAAe,IAAI,IAAnB,GAA0BC,IAAI,CAAChC,MAAL,GAAc,CAAxC,GAA4C+B,eAA7C,CAApB;AACA,QAAI,CAAC1B,OAAD,IAAY,CAACA,OAAO,CAAC4B,OAAzB,EAAkC,OAAOH,EAAE,CAAC,GAAGE,IAAJ,CAAT;AAElC,UAAMC,OAAO,GAAG,OAAO5B,OAAO,CAAC4B,OAAf,KAA2B,QAA3B,GACZnE,aAAa,CAACuC,OAAO,CAAC4B,OAAT,CADD,GAEZ5B,OAAO,CAAC4B,OAFZ;AAIA,UAAMC,UAAU,GAAG,IAAItE,iBAAJ,CAAsBqE,OAAtB,CAAnB;AAEA5B,IAAAA,OAAO,CAAC8B,MAAR,GAAiBtE,SAAS,CAAC,CAACwC,OAAO,CAAC8B,MAAT,EAAiBD,UAAU,CAACC,MAA5B,CAAD,CAA1B;AAEA,UAAMC,KAAK,GAAGN,EAAE,CAAC,GAAGE,IAAJ,CAAhB;AACA,UAAMK,cAAc,GAAG,IAAIC,OAAJ,CAAY,CAAC3B,OAAD,EAAU4B,MAAV,KAAqB;AACtDL,MAAAA,UAAU,CAACC,MAAX,CAAkBK,gBAAlB,CAAmC,OAAnC,EAA4C,MAAM;AAChDD,QAAAA,MAAM,CAAC,IAAIvE,YAAJ,EAAD,CAAN;AACD,OAFD;AAGD,KAJsB,CAAvB;AAMA,UAAMyE,KAAK,GAAGC,IAAI,CAACC,GAAL,EAAd;;AAEA,UAAMC,sBAAsB,GAAG,MAAM;AACnC,UAAIV,UAAU,CAACC,MAAX,CAAkBU,OAAtB,EAA+B;AAC7B,cAAM,IAAI7E,YAAJ,EAAN;AACD;;AAED,YAAM8E,SAAS,GAAGJ,IAAI,CAACC,GAAL,KAAaF,KAA/B,CALmC,CAOnC;AACA;AACA;;AACA,UAAIK,SAAS,GAAGb,OAAhB,EAAyB;AACvBC,QAAAA,UAAU,CAACa,KAAX;AACA,cAAM,IAAI/E,YAAJ,EAAN;AACD;AACF,KAdD;;AAgBA,QAAIoE,KAAK,CAACY,MAAM,CAACC,aAAR,CAAT,EAAiC;AAC/B,aAAQ,mBAAoB;AAC1B,cAAMC,EAAE,GAAGd,KAAK,CAACY,MAAM,CAACC,aAAR,CAAL,EAAX;;AAEA,YAAI;AACF,iBAAO,IAAP,EAAa;AACX,kBAAM;AAAEvC,cAAAA,KAAF;AAASyC,cAAAA;AAAT,gBAAkB,MAAMb,OAAO,CAACc,IAAR,CAAa,CAACF,EAAE,CAACG,IAAH,EAAD,EAAYhB,cAAZ,CAAb,CAA9B;;AAEA,gBAAIc,IAAJ,EAAU;AACR;AACD;;AAEDP,YAAAA,sBAAsB;AAEtB,kBAAMlC,KAAN;AACD;AACF,SAZD,CAYE,OAAOE,GAAP,EAAY;AACZgC,UAAAA,sBAAsB;AAEtB,gBAAMhC,GAAN;AACD,SAhBD,SAgBU;AACRsB,UAAAA,UAAU,CAACoB,KAAX;;AAEA,cAAIJ,EAAE,CAACK,MAAP,EAAe;AACbL,YAAAA,EAAE,CAACK,MAAH;AACD;AACF;AACF,OA1BM,EAAP;AA2BD;;AAED,WAAO,CAAC,YAAY;AAClB,UAAI;AACF,cAAMC,GAAG,GAAG,MAAMlB,OAAO,CAACc,IAAR,CAAa,CAAChB,KAAD,EAAQC,cAAR,CAAb,CAAlB;AAEAO,QAAAA,sBAAsB;AAEtB,eAAOY,GAAP;AACD,OAND,CAME,OAAO5C,GAAP,EAAY;AACZgC,QAAAA,sBAAsB;AAEtB,cAAMhC,GAAN;AACD,OAVD,SAUU;AACRsB,QAAAA,UAAU,CAACoB,KAAX;AACD;AACF,KAdM,GAAP;AAeD,GAlFD;AAmFD;;AAEDpF,OAAO,CAACkB,aAAR,GAAwBA,aAAxB;AACAlB,OAAO,CAACwB,gBAAR,GAA2BA,gBAA3B;AACAxB,OAAO,CAACQ,aAAR,GAAwBA,aAAxB;AACAR,OAAO,CAACgC,WAAR,GAAsBA,WAAtB;AACAhC,OAAO,CAAC+C,OAAR,GAAkBA,OAAlB;AACA/C,OAAO,CAAC2D,iBAAR,GAA4BA,iBAA5B","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst { Buffer } = require('buffer')\nconst TimeoutController = require('timeout-abort-controller')\nconst anySignal = require('any-signal')\nconst parseDuration = require('parse-duration')\nconst Key = require('interface-datastore').Key\nconst { TimeoutError } = require('./errors')\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\n\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n}\nexports.MFS_ROOT_KEY = new Key('/local/filesroot')\nexports.MFS_MAX_CHUNK_SIZE = 262144\nexports.MFS_MAX_LINKS = 174\n\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\nfunction parseIpfsPath (ipfsPath) {\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '')\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/)\n  if (!matched) {\n    throw new Error('invalid ipfs ref path')\n  }\n\n  const [hash, ...links] = matched[1].split('/')\n\n  // check that a CID can be constructed with the hash\n  if (isIpfs.cid(hash)) {\n    return { hash, links }\n  } else {\n    throw new Error('invalid ipfs ref path')\n  }\n}\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\nconst normalizePath = (pathStr) => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${new CID(pathStr)}`\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr\n  } else {\n    throw Object.assign(new Error(`invalid path: ${pathStr}`), { code: ERR_BAD_PATH })\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\nconst normalizeCidPath = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString()\n  }\n  if (CID.isCID(path)) {\n    return path.toString()\n  }\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param {Dag} dag The IPFS dag api\n * @param {Array<CID|string>} ipfsPaths A single or collection of ipfs-paths\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {Promise<Array<CID>>}\n */\nconst resolvePath = async function (dag, ipfsPaths, options) {\n  options = options || {}\n\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths]\n  }\n\n  const cids = []\n\n  for (const path of ipfsPaths) {\n    if (isIpfs.cid(path)) {\n      cids.push(new CID(path))\n      continue\n    }\n\n    const { hash, links } = parseIpfsPath(path)\n\n    if (!links.length) {\n      cids.push(new CID(hash))\n      continue\n    }\n\n    let cid = new CID(hash)\n    try {\n      for await (const { value } of dag.resolve(path, options)) {\n        if (CID.isCID(value)) {\n          cid = value\n        }\n      }\n    } catch (err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        const linkName = err.message.replace('Object has no property \\'', '').slice(0, -1)\n        err.message = `no link named \"${linkName}\" under ${cid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n    cids.push(cid)\n  }\n\n  return cids\n}\n\nconst mapFile = (file, options) => {\n  options = options || {}\n\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'dir'\n  }\n\n  if (file.unixfs) {\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize()\n      output.type = 'file'\n\n      if (options.includeContent) {\n        output.content = file.content()\n      }\n    }\n\n    output.mode = file.unixfs.mode\n    output.mtime = file.unixfs.mtime\n  }\n\n  return output\n}\n\nfunction withTimeoutOption (fn, optionsArgIndex) {\n  return (...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex]\n    if (!options || !options.timeout) return fn(...args)\n\n    const timeout = typeof options.timeout === 'string'\n      ? parseDuration(options.timeout)\n      : options.timeout\n\n    const controller = new TimeoutController(timeout)\n\n    options.signal = anySignal([options.signal, controller.signal])\n\n    const fnRes = fn(...args)\n    const timeoutPromise = new Promise((resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError())\n      })\n    })\n\n    const start = Date.now()\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError()\n      }\n\n      const timeTaken = Date.now() - start\n\n      // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n      if (timeTaken > timeout) {\n        controller.abort()\n        throw new TimeoutError()\n      }\n    }\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return (async function * () {\n        const it = fnRes[Symbol.asyncIterator]()\n\n        try {\n          while (true) {\n            const { value, done } = await Promise.race([it.next(), timeoutPromise])\n\n            if (done) {\n              break\n            }\n\n            maybeThrowTimeoutError()\n\n            yield value\n          }\n        } catch (err) {\n          maybeThrowTimeoutError()\n\n          throw err\n        } finally {\n          controller.clear()\n\n          if (it.return) {\n            it.return()\n          }\n        }\n      })()\n    }\n\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise])\n\n        maybeThrowTimeoutError()\n\n        return res\n      } catch (err) {\n        maybeThrowTimeoutError()\n\n        throw err\n      } finally {\n        controller.clear()\n      }\n    })()\n  }\n}\n\nexports.normalizePath = normalizePath\nexports.normalizeCidPath = normalizeCidPath\nexports.parseIpfsPath = parseIpfsPath\nexports.resolvePath = resolvePath\nexports.mapFile = mapFile\nexports.withTimeoutOption = withTimeoutOption\n"]},"metadata":{},"sourceType":"script"}