{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  resolvePath,\n  withTimeoutOption\n} = require('../../utils');\n\nmodule.exports = ({\n  pinManager,\n  gcLock,\n  dag\n}) => {\n  return withTimeoutOption(async function add(paths, options) {\n    options = options || {};\n    const recursive = options.recursive !== false;\n    const cids = await resolvePath(dag, paths, {\n      signal: options.signal\n    });\n\n    const pinAdd = async () => {\n      const results = []; // verify that each hash can be pinned\n\n      for (const cid of cids) {\n        const key = cid.toBaseEncodedString();\n\n        if (recursive) {\n          if (pinManager.recursivePins.has(key)) {\n            // it's already pinned recursively\n            results.push(cid);\n            continue;\n          } // entire graph of nested links should be pinned,\n          // so make sure we have all the objects\n\n\n          await pinManager.fetchCompleteDag(key, {\n            preload: options.preload,\n            signal: options.signal\n          }); // found all objects, we can add the pin\n\n          results.push(cid);\n        } else {\n          if (pinManager.recursivePins.has(key)) {\n            // recursive supersedes direct, can't have both\n            throw new Error(`${key} already pinned recursively`);\n          }\n\n          if (!pinManager.directPins.has(key)) {\n            // make sure we have the object\n            await dag.get(cid, {\n              preload: options.preload\n            });\n          }\n\n          results.push(cid);\n        }\n      } // update the pin sets in memory\n\n\n      const pinset = recursive ? pinManager.recursivePins : pinManager.directPins;\n      results.forEach(cid => pinset.add(cid.toString())); // persist updated pin sets to datastore\n\n      await pinManager.flushPins();\n      return results.map(cid => ({\n        cid\n      }));\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      return pinAdd();\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      await pinAdd();\n    } finally {\n      release();\n    }\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/add.js"],"names":["resolvePath","withTimeoutOption","require","module","exports","pinManager","gcLock","dag","add","paths","options","recursive","cids","signal","pinAdd","results","cid","key","toBaseEncodedString","recursivePins","has","push","fetchCompleteDag","preload","Error","directPins","get","pinset","forEach","toString","flushPins","map","lock","Boolean","release","readLock"],"mappings":"AAAA;AACA;;AAEA,MAAM;AAAEA,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAAqCC,OAAO,CAAC,aAAD,CAAlD;;AAEAC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,MAAd;AAAsBC,EAAAA;AAAtB,CAAD,KAAiC;AAChD,SAAON,iBAAiB,CAAC,eAAeO,GAAf,CAAoBC,KAApB,EAA2BC,OAA3B,EAAoC;AAC3DA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAMC,SAAS,GAAGD,OAAO,CAACC,SAAR,KAAsB,KAAxC;AACA,UAAMC,IAAI,GAAG,MAAMZ,WAAW,CAACO,GAAD,EAAME,KAAN,EAAa;AAAEI,MAAAA,MAAM,EAAEH,OAAO,CAACG;AAAlB,KAAb,CAA9B;;AACA,UAAMC,MAAM,GAAG,YAAY;AACzB,YAAMC,OAAO,GAAG,EAAhB,CADyB,CAGzB;;AACA,WAAK,MAAMC,GAAX,IAAkBJ,IAAlB,EAAwB;AACtB,cAAMK,GAAG,GAAGD,GAAG,CAACE,mBAAJ,EAAZ;;AAEA,YAAIP,SAAJ,EAAe;AACb,cAAIN,UAAU,CAACc,aAAX,CAAyBC,GAAzB,CAA6BH,GAA7B,CAAJ,EAAuC;AACrC;AACAF,YAAAA,OAAO,CAACM,IAAR,CAAaL,GAAb;AAEA;AACD,WANY,CAQb;AACA;;;AACA,gBAAMX,UAAU,CAACiB,gBAAX,CAA4BL,GAA5B,EAAiC;AAAEM,YAAAA,OAAO,EAAEb,OAAO,CAACa,OAAnB;AAA4BV,YAAAA,MAAM,EAAEH,OAAO,CAACG;AAA5C,WAAjC,CAAN,CAVa,CAYb;;AACAE,UAAAA,OAAO,CAACM,IAAR,CAAaL,GAAb;AACD,SAdD,MAcO;AACL,cAAIX,UAAU,CAACc,aAAX,CAAyBC,GAAzB,CAA6BH,GAA7B,CAAJ,EAAuC;AACrC;AACA,kBAAM,IAAIO,KAAJ,CAAW,GAAEP,GAAI,6BAAjB,CAAN;AACD;;AAED,cAAI,CAACZ,UAAU,CAACoB,UAAX,CAAsBL,GAAtB,CAA0BH,GAA1B,CAAL,EAAqC;AACnC;AACA,kBAAMV,GAAG,CAACmB,GAAJ,CAAQV,GAAR,EAAa;AAAEO,cAAAA,OAAO,EAAEb,OAAO,CAACa;AAAnB,aAAb,CAAN;AACD;;AAEDR,UAAAA,OAAO,CAACM,IAAR,CAAaL,GAAb;AACD;AACF,OAlCwB,CAoCzB;;;AACA,YAAMW,MAAM,GAAGhB,SAAS,GAAGN,UAAU,CAACc,aAAd,GAA8Bd,UAAU,CAACoB,UAAjE;AACAV,MAAAA,OAAO,CAACa,OAAR,CAAgBZ,GAAG,IAAIW,MAAM,CAACnB,GAAP,CAAWQ,GAAG,CAACa,QAAJ,EAAX,CAAvB,EAtCyB,CAwCzB;;AACA,YAAMxB,UAAU,CAACyB,SAAX,EAAN;AAEA,aAAOf,OAAO,CAACgB,GAAR,CAAYf,GAAG,KAAK;AAAEA,QAAAA;AAAF,OAAL,CAAf,CAAP;AACD,KA5CD,CAL2D,CAmD3D;AACA;;;AACA,UAAMgB,IAAI,GAAGC,OAAO,CAACvB,OAAO,CAACsB,IAAT,CAApB;;AAEA,QAAI,CAACA,IAAL,EAAW;AACT,aAAOlB,MAAM,EAAb;AACD;;AAED,UAAMoB,OAAO,GAAG,MAAM5B,MAAM,CAAC6B,QAAP,EAAtB;;AAEA,QAAI;AACF,YAAMrB,MAAM,EAAZ;AACD,KAFD,SAEU;AACRoB,MAAAA,OAAO;AACR;AACF,GAlEuB,CAAxB;AAmED,CApED","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { resolvePath, withTimeoutOption } = require('../../utils')\n\nmodule.exports = ({ pinManager, gcLock, dag }) => {\n  return withTimeoutOption(async function add (paths, options) {\n    options = options || {}\n\n    const recursive = options.recursive !== false\n    const cids = await resolvePath(dag, paths, { signal: options.signal })\n    const pinAdd = async () => {\n      const results = []\n\n      // verify that each hash can be pinned\n      for (const cid of cids) {\n        const key = cid.toBaseEncodedString()\n\n        if (recursive) {\n          if (pinManager.recursivePins.has(key)) {\n            // it's already pinned recursively\n            results.push(cid)\n\n            continue\n          }\n\n          // entire graph of nested links should be pinned,\n          // so make sure we have all the objects\n          await pinManager.fetchCompleteDag(key, { preload: options.preload, signal: options.signal })\n\n          // found all objects, we can add the pin\n          results.push(cid)\n        } else {\n          if (pinManager.recursivePins.has(key)) {\n            // recursive supersedes direct, can't have both\n            throw new Error(`${key} already pinned recursively`)\n          }\n\n          if (!pinManager.directPins.has(key)) {\n            // make sure we have the object\n            await dag.get(cid, { preload: options.preload })\n          }\n\n          results.push(cid)\n        }\n      }\n\n      // update the pin sets in memory\n      const pinset = recursive ? pinManager.recursivePins : pinManager.directPins\n      results.forEach(cid => pinset.add(cid.toString()))\n\n      // persist updated pin sets to datastore\n      await pinManager.flushPins()\n\n      return results.map(cid => ({ cid }))\n    }\n\n    // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n    const lock = Boolean(options.lock)\n\n    if (!lock) {\n      return pinAdd()\n    }\n\n    const release = await gcLock.readLock()\n\n    try {\n      await pinAdd()\n    } finally {\n      release()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}