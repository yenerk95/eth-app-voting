{"ast":null,"code":"'use strict';\n\nconst Block = require('ipld-block');\n\nconst CID = require('cids');\n\nconst {\n  getName\n} = require('multicodec');\n\nconst vd = require('varint-decoder');\n\nconst multihashing = require('multihashing-async');\n\nconst {\n  isMapEqual\n} = require('../../utils');\n\nconst {\n  Message\n} = require('./message.proto');\n\nconst Entry = require('./entry');\n\nclass BitswapMessage {\n  constructor(full) {\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n\n    const cidStr = cid.toString('base58btc');\n    const entry = this.wantlist.get(cidStr);\n\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority;\n      } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n      if (cancel) {\n        entry.cancel = Boolean(cancel);\n      } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave);\n      } // want-block overrides existing want-have\n\n\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n\n  addBlock(block) {\n    const cidStr = block.cid.toString('base58btc');\n    this.blocks.set(cidStr, block);\n  }\n\n  addHave(cid) {\n    const cidStr = cid.toString('base58btc');\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n\n  addDontHave(cid) {\n    const cidStr = cid.toString('base58btc');\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n\n  cancel(cid) {\n    const cidStr = cid.toString('base58btc');\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   */\n\n\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.buffer,\n            // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        })\n      },\n      blocks: Array.from(this.blocks.values()).map(block => block.data)\n    };\n\n    if (this.full) {\n      msg.wantlist.full = true;\n    }\n\n    return Message.encode(msg);\n  }\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   */\n\n\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.buffer,\n            // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        })\n      },\n      blockPresences: [],\n      payload: []\n    };\n\n    if (this.full) {\n      msg.wantlist.full = true;\n    }\n\n    this.blocks.forEach(block => {\n      msg.payload.push({\n        prefix: block.cid.prefix,\n        data: block.data\n      });\n    });\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push({\n        cid: new CID(cidStr).buffer,\n        type: bpType\n      });\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n\n    return Message.encode(msg);\n  }\n\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n\n}\n\nBitswapMessage.deserialize = async raw => {\n  const decoded = Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n\n  if (decoded.wantlist) {\n    decoded.wantlist.entries.forEach(entry => {\n      // note: entry.block is the CID here\n      const cid = new CID(entry.block);\n      msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave);\n    });\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      const cid = new CID(blockPresence.cid);\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid);\n      } else {\n        msg.addDontHave(cid);\n      }\n    });\n  } // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n\n\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await multihashing(b, 'sha2-256');\n      const cid = new CID(hash);\n      msg.addBlock(new Block(b, cid));\n    }));\n    return msg;\n  } // Bitswap 1.1.0\n\n\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n\n      const values = vd(p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2]; // const hashLen = values[3] // We haven't need to use this so far\n\n      const hash = await multihashing(p.data, hashAlg);\n      const cid = new CID(cidVersion, getName(multicodec), hash);\n      msg.addBlock(new Block(p.data, cid));\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n\n  return msg;\n};\n\nBitswapMessage.blockPresenceSize = cid => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.buffer.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/types/message/index.js"],"names":["Block","require","CID","getName","vd","multihashing","isMapEqual","Message","Entry","BitswapMessage","constructor","full","wantlist","Map","blocks","blockPresences","pendingBytes","empty","size","addEntry","cid","priority","wantType","cancel","sendDontHave","WantType","cidStr","toString","entry","get","Boolean","Have","set","addBlock","block","addHave","has","BlockPresenceType","addDontHave","DontHave","delete","setPendingBytes","serializeToBitswap100","msg","entries","Array","from","values","map","buffer","Number","data","encode","serializeToBitswap110","payload","forEach","push","prefix","bpType","type","equals","other","Symbol","toStringTag","list","keys","deserialize","raw","decoded","decode","isFull","blockPresence","length","Promise","all","b","hash","p","cidVersion","multicodec","hashAlg","blockPresenceSize","Wantlist","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,YAAD,CAArB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAcF,OAAO,CAAC,YAAD,CAA3B;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,gBAAD,CAAlB;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAiBL,OAAO,CAAC,aAAD,CAA9B;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAcN,OAAO,CAAC,iBAAD,CAA3B;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,SAAD,CAArB;;AAEA,MAAMQ,cAAN,CAAqB;AACnBC,EAAAA,WAAW,CAAEC,IAAF,EAAQ;AACjB,SAAKA,IAAL,GAAYA,IAAZ;AACA,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACA,SAAKC,MAAL,GAAc,IAAID,GAAJ,EAAd;AACA,SAAKE,cAAL,GAAsB,IAAIF,GAAJ,EAAtB;AACA,SAAKG,YAAL,GAAoB,CAApB;AACD;;AAED,MAAIC,KAAJ,GAAa;AACX,WAAO,KAAKH,MAAL,CAAYI,IAAZ,KAAqB,CAArB,IACA,KAAKN,QAAL,CAAcM,IAAd,KAAuB,CADvB,IAEA,KAAKH,cAAL,CAAoBG,IAApB,KAA6B,CAFpC;AAGD;;AAEDC,EAAAA,QAAQ,CAAEC,GAAF,EAAOC,QAAP,EAAiBC,QAAjB,EAA2BC,MAA3B,EAAmCC,YAAnC,EAAiD;AACvD,QAAIF,QAAQ,IAAI,IAAhB,EAAsB;AACpBA,MAAAA,QAAQ,GAAGb,cAAc,CAACgB,QAAf,CAAwBzB,KAAnC;AACD;;AAED,UAAM0B,MAAM,GAAGN,GAAG,CAACO,QAAJ,CAAa,WAAb,CAAf;AACA,UAAMC,KAAK,GAAG,KAAKhB,QAAL,CAAciB,GAAd,CAAkBH,MAAlB,CAAd;;AACA,QAAIE,KAAJ,EAAW;AACT;AACA,UAAIA,KAAK,CAACN,QAAN,KAAmBA,QAAvB,EAAiC;AAC/BM,QAAAA,KAAK,CAACP,QAAN,GAAiBA,QAAjB;AACD,OAJQ,CAKT;;;AACA,UAAIE,MAAJ,EAAY;AACVK,QAAAA,KAAK,CAACL,MAAN,GAAeO,OAAO,CAACP,MAAD,CAAtB;AACD,OARQ,CAST;;;AACA,UAAIC,YAAJ,EAAkB;AAChBI,QAAAA,KAAK,CAACJ,YAAN,GAAqBM,OAAO,CAACN,YAAD,CAA5B;AACD,OAZQ,CAaT;;;AACA,UAAIF,QAAQ,KAAKb,cAAc,CAACgB,QAAf,CAAwBzB,KAArC,IAA8C4B,KAAK,CAACN,QAAN,KAAmBb,cAAc,CAACgB,QAAf,CAAwBM,IAA7F,EAAmG;AACjGH,QAAAA,KAAK,CAACN,QAAN,GAAiBA,QAAjB;AACD;AACF,KAjBD,MAiBO;AACL,WAAKV,QAAL,CAAcoB,GAAd,CAAkBN,MAAlB,EAA0B,IAAIlB,KAAJ,CAAUY,GAAV,EAAeC,QAAf,EAAyBC,QAAzB,EAAmCC,MAAnC,EAA2CC,YAA3C,CAA1B;AACD;AACF;;AAEDS,EAAAA,QAAQ,CAAEC,KAAF,EAAS;AACf,UAAMR,MAAM,GAAGQ,KAAK,CAACd,GAAN,CAAUO,QAAV,CAAmB,WAAnB,CAAf;AACA,SAAKb,MAAL,CAAYkB,GAAZ,CAAgBN,MAAhB,EAAwBQ,KAAxB;AACD;;AAEDC,EAAAA,OAAO,CAAEf,GAAF,EAAO;AACZ,UAAMM,MAAM,GAAGN,GAAG,CAACO,QAAJ,CAAa,WAAb,CAAf;;AACA,QAAI,CAAC,KAAKZ,cAAL,CAAoBqB,GAApB,CAAwBV,MAAxB,CAAL,EAAsC;AACpC,WAAKX,cAAL,CAAoBiB,GAApB,CAAwBN,MAAxB,EAAgCjB,cAAc,CAAC4B,iBAAf,CAAiCN,IAAjE;AACD;AACF;;AAEDO,EAAAA,WAAW,CAAElB,GAAF,EAAO;AAChB,UAAMM,MAAM,GAAGN,GAAG,CAACO,QAAJ,CAAa,WAAb,CAAf;;AACA,QAAI,CAAC,KAAKZ,cAAL,CAAoBqB,GAApB,CAAwBV,MAAxB,CAAL,EAAsC;AACpC,WAAKX,cAAL,CAAoBiB,GAApB,CAAwBN,MAAxB,EAAgCjB,cAAc,CAAC4B,iBAAf,CAAiCE,QAAjE;AACD;AACF;;AAEDhB,EAAAA,MAAM,CAAEH,GAAF,EAAO;AACX,UAAMM,MAAM,GAAGN,GAAG,CAACO,QAAJ,CAAa,WAAb,CAAf;AACA,SAAKf,QAAL,CAAc4B,MAAd,CAAqBd,MAArB;AACA,SAAKP,QAAL,CAAcC,GAAd,EAAmB,CAAnB,EAAsBX,cAAc,CAACgB,QAAf,CAAwBzB,KAA9C,EAAqD,IAArD,EAA2D,KAA3D;AACD;;AAEDyC,EAAAA,eAAe,CAAEvB,IAAF,EAAQ;AACrB,SAAKF,YAAL,GAAoBE,IAApB;AACD;AAED;;;;;;AAIAwB,EAAAA,qBAAqB,GAAI;AACvB,UAAMC,GAAG,GAAG;AACV/B,MAAAA,QAAQ,EAAE;AACRgC,QAAAA,OAAO,EAAEC,KAAK,CAACC,IAAN,CAAW,KAAKlC,QAAL,CAAcmC,MAAd,EAAX,EAAmCC,GAAnC,CAAwCpB,KAAD,IAAW;AACzD,iBAAO;AACLM,YAAAA,KAAK,EAAEN,KAAK,CAACR,GAAN,CAAU6B,MADZ;AACoB;AACzB5B,YAAAA,QAAQ,EAAE6B,MAAM,CAACtB,KAAK,CAACP,QAAP,CAFX;AAGLE,YAAAA,MAAM,EAAEO,OAAO,CAACF,KAAK,CAACL,MAAP;AAHV,WAAP;AAKD,SANQ;AADD,OADA;AAUVT,MAAAA,MAAM,EAAE+B,KAAK,CAACC,IAAN,CAAW,KAAKhC,MAAL,CAAYiC,MAAZ,EAAX,EACLC,GADK,CACAd,KAAD,IAAWA,KAAK,CAACiB,IADhB;AAVE,KAAZ;;AAcA,QAAI,KAAKxC,IAAT,EAAe;AACbgC,MAAAA,GAAG,CAAC/B,QAAJ,CAAaD,IAAb,GAAoB,IAApB;AACD;;AAED,WAAOJ,OAAO,CAAC6C,MAAR,CAAeT,GAAf,CAAP;AACD;AAED;;;;;;AAIAU,EAAAA,qBAAqB,GAAI;AACvB,UAAMV,GAAG,GAAG;AACV/B,MAAAA,QAAQ,EAAE;AACRgC,QAAAA,OAAO,EAAEC,KAAK,CAACC,IAAN,CAAW,KAAKlC,QAAL,CAAcmC,MAAd,EAAX,EAAmCC,GAAnC,CAAwCpB,KAAD,IAAW;AACzD,iBAAO;AACLM,YAAAA,KAAK,EAAEN,KAAK,CAACR,GAAN,CAAU6B,MADZ;AACoB;AACzB5B,YAAAA,QAAQ,EAAE6B,MAAM,CAACtB,KAAK,CAACP,QAAP,CAFX;AAGLC,YAAAA,QAAQ,EAAEM,KAAK,CAACN,QAHX;AAILC,YAAAA,MAAM,EAAEO,OAAO,CAACF,KAAK,CAACL,MAAP,CAJV;AAKLC,YAAAA,YAAY,EAAEM,OAAO,CAACF,KAAK,CAACJ,YAAP;AALhB,WAAP;AAOD,SARQ;AADD,OADA;AAYVT,MAAAA,cAAc,EAAE,EAZN;AAaVuC,MAAAA,OAAO,EAAE;AAbC,KAAZ;;AAgBA,QAAI,KAAK3C,IAAT,EAAe;AACbgC,MAAAA,GAAG,CAAC/B,QAAJ,CAAaD,IAAb,GAAoB,IAApB;AACD;;AAED,SAAKG,MAAL,CAAYyC,OAAZ,CAAqBrB,KAAD,IAAW;AAC7BS,MAAAA,GAAG,CAACW,OAAJ,CAAYE,IAAZ,CAAiB;AACfC,QAAAA,MAAM,EAAEvB,KAAK,CAACd,GAAN,CAAUqC,MADH;AAEfN,QAAAA,IAAI,EAAEjB,KAAK,CAACiB;AAFG,OAAjB;AAID,KALD;;AAOA,SAAK,MAAM,CAACzB,MAAD,EAASgC,MAAT,CAAX,IAA+B,KAAK3C,cAApC,EAAoD;AAClD4B,MAAAA,GAAG,CAAC5B,cAAJ,CAAmByC,IAAnB,CAAwB;AACtBpC,QAAAA,GAAG,EAAE,IAAIlB,GAAJ,CAAQwB,MAAR,EAAgBuB,MADC;AAEtBU,QAAAA,IAAI,EAAED;AAFgB,OAAxB;AAID;;AAED,QAAI,KAAK1C,YAAL,GAAoB,CAAxB,EAA2B;AACzB2B,MAAAA,GAAG,CAAC3B,YAAJ,GAAmB,KAAKA,YAAxB;AACD;;AAED,WAAOT,OAAO,CAAC6C,MAAR,CAAeT,GAAf,CAAP;AACD;;AAEDiB,EAAAA,MAAM,CAAEC,KAAF,EAAS;AACb,QAAI,KAAKlD,IAAL,KAAckD,KAAK,CAAClD,IAApB,IACA,KAAKK,YAAL,KAAsB6C,KAAK,CAAC7C,YAD5B,IAEA,CAACV,UAAU,CAAC,KAAKM,QAAN,EAAgBiD,KAAK,CAACjD,QAAtB,CAFX,IAGA,CAACN,UAAU,CAAC,KAAKQ,MAAN,EAAc+C,KAAK,CAAC/C,MAApB,CAHX,IAIA,CAACR,UAAU,CAAC,KAAKS,cAAN,EAAsB8C,KAAK,CAAC9C,cAA5B,CAJf,EAKE;AACA,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD;;AAED,OAAK+C,MAAM,CAACC,WAAZ,IAA4B;AAC1B,UAAMC,IAAI,GAAGnB,KAAK,CAACC,IAAN,CAAW,KAAKlC,QAAL,CAAcqD,IAAd,EAAX,CAAb;AACA,UAAMnD,MAAM,GAAG+B,KAAK,CAACC,IAAN,CAAW,KAAKhC,MAAL,CAAYmD,IAAZ,EAAX,CAAf;AACA,WAAQ,yBAAwB,KAAKtD,IAAK,WAAUqD,IAAK,aAAYlD,MAAO,GAA5E;AACD;;AAlKkB;;AAqKrBL,cAAc,CAACyD,WAAf,GAA6B,MAAOC,GAAP,IAAe;AAC1C,QAAMC,OAAO,GAAG7D,OAAO,CAAC8D,MAAR,CAAeF,GAAf,CAAhB;AAEA,QAAMG,MAAM,GAAIF,OAAO,CAACxD,QAAR,IAAoBwD,OAAO,CAACxD,QAAR,CAAiBD,IAAtC,IAA+C,KAA9D;AACA,QAAMgC,GAAG,GAAG,IAAIlC,cAAJ,CAAmB6D,MAAnB,CAAZ;;AAEA,MAAIF,OAAO,CAACxD,QAAZ,EAAsB;AACpBwD,IAAAA,OAAO,CAACxD,QAAR,CAAiBgC,OAAjB,CAAyBW,OAAzB,CAAkC3B,KAAD,IAAW;AAC1C;AACA,YAAMR,GAAG,GAAG,IAAIlB,GAAJ,CAAQ0B,KAAK,CAACM,KAAd,CAAZ;AACAS,MAAAA,GAAG,CAACxB,QAAJ,CAAaC,GAAb,EAAkBQ,KAAK,CAACP,QAAxB,EAAkCO,KAAK,CAACN,QAAxC,EAAkDM,KAAK,CAACL,MAAxD,EAAgEK,KAAK,CAACJ,YAAtE;AACD,KAJD;AAKD;;AAED,MAAI4C,OAAO,CAACrD,cAAZ,EAA4B;AAC1BqD,IAAAA,OAAO,CAACrD,cAAR,CAAuBwC,OAAvB,CAAgCgB,aAAD,IAAmB;AAChD,YAAMnD,GAAG,GAAG,IAAIlB,GAAJ,CAAQqE,aAAa,CAACnD,GAAtB,CAAZ;;AACA,UAAImD,aAAa,CAACZ,IAAd,KAAuBlD,cAAc,CAAC4B,iBAAf,CAAiCN,IAA5D,EAAkE;AAChEY,QAAAA,GAAG,CAACR,OAAJ,CAAYf,GAAZ;AACD,OAFD,MAEO;AACLuB,QAAAA,GAAG,CAACL,WAAJ,CAAgBlB,GAAhB;AACD;AACF,KAPD;AAQD,GAvByC,CAyB1C;AACA;;;AACA,MAAIgD,OAAO,CAACtD,MAAR,CAAe0D,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,UAAMC,OAAO,CAACC,GAAR,CAAYN,OAAO,CAACtD,MAAR,CAAekC,GAAf,CAAmB,MAAO2B,CAAP,IAAa;AAChD,YAAMC,IAAI,GAAG,MAAMvE,YAAY,CAACsE,CAAD,EAAI,UAAJ,CAA/B;AACA,YAAMvD,GAAG,GAAG,IAAIlB,GAAJ,CAAQ0E,IAAR,CAAZ;AACAjC,MAAAA,GAAG,CAACV,QAAJ,CAAa,IAAIjC,KAAJ,CAAU2E,CAAV,EAAavD,GAAb,CAAb;AACD,KAJiB,CAAZ,CAAN;AAKA,WAAOuB,GAAP;AACD,GAlCyC,CAoC1C;;;AACA,MAAIyB,OAAO,CAACd,OAAR,CAAgBkB,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,UAAMC,OAAO,CAACC,GAAR,CAAYN,OAAO,CAACd,OAAR,CAAgBN,GAAhB,CAAoB,MAAO6B,CAAP,IAAa;AACjD,UAAI,CAACA,CAAC,CAACpB,MAAH,IAAa,CAACoB,CAAC,CAAC1B,IAApB,EAA0B;AACxB;AACD;;AACD,YAAMJ,MAAM,GAAG3C,EAAE,CAACyE,CAAC,CAACpB,MAAH,CAAjB;AACA,YAAMqB,UAAU,GAAG/B,MAAM,CAAC,CAAD,CAAzB;AACA,YAAMgC,UAAU,GAAGhC,MAAM,CAAC,CAAD,CAAzB;AACA,YAAMiC,OAAO,GAAGjC,MAAM,CAAC,CAAD,CAAtB,CAPiD,CAQjD;;AACA,YAAM6B,IAAI,GAAG,MAAMvE,YAAY,CAACwE,CAAC,CAAC1B,IAAH,EAAS6B,OAAT,CAA/B;AACA,YAAM5D,GAAG,GAAG,IAAIlB,GAAJ,CAAQ4E,UAAR,EAAoB3E,OAAO,CAAC4E,UAAD,CAA3B,EAAyCH,IAAzC,CAAZ;AACAjC,MAAAA,GAAG,CAACV,QAAJ,CAAa,IAAIjC,KAAJ,CAAU6E,CAAC,CAAC1B,IAAZ,EAAkB/B,GAAlB,CAAb;AACD,KAZiB,CAAZ,CAAN;AAaAuB,IAAAA,GAAG,CAACF,eAAJ,CAAoB2B,OAAO,CAACpD,YAA5B;AACA,WAAO2B,GAAP;AACD;;AAED,SAAOA,GAAP;AACD,CAxDD;;AA0DAlC,cAAc,CAACwE,iBAAf,GAAoC7D,GAAD,IAAS;AAC1C;AACA;AACA;AACA;AACA,SAAOA,GAAG,CAAC6B,MAAJ,CAAWuB,MAAX,GAAoB,CAA3B;AACD,CAND;;AAQA/D,cAAc,CAACD,KAAf,GAAuBA,KAAvB;AACAC,cAAc,CAACgB,QAAf,GAA0B;AACxBzB,EAAAA,KAAK,EAAEO,OAAO,CAAC2E,QAAR,CAAiBzD,QAAjB,CAA0BzB,KADT;AAExB+B,EAAAA,IAAI,EAAExB,OAAO,CAAC2E,QAAR,CAAiBzD,QAAjB,CAA0BM;AAFR,CAA1B;AAIAtB,cAAc,CAAC4B,iBAAf,GAAmC;AACjCN,EAAAA,IAAI,EAAExB,OAAO,CAAC8B,iBAAR,CAA0BN,IADC;AAEjCQ,EAAAA,QAAQ,EAAEhC,OAAO,CAAC8B,iBAAR,CAA0BE;AAFH,CAAnC;AAIA4C,MAAM,CAACC,OAAP,GAAiB3E,cAAjB","sourcesContent":["'use strict'\n\nconst Block = require('ipld-block')\nconst CID = require('cids')\nconst { getName } = require('multicodec')\nconst vd = require('varint-decoder')\nconst multihashing = require('multihashing-async')\nconst { isMapEqual } = require('../../utils')\nconst { Message } = require('./message.proto')\nconst Entry = require('./entry')\n\nclass BitswapMessage {\n  constructor (full) {\n    this.full = full\n    this.wantlist = new Map()\n    this.blocks = new Map()\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString('base58btc')\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  addBlock (block) {\n    const cidStr = block.cid.toString('base58btc')\n    this.blocks.set(cidStr, block)\n  }\n\n  addHave (cid) {\n    const cidStr = cid.toString('base58btc')\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  addDontHave (cid) {\n    const cidStr = cid.toString('base58btc')\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  cancel (cid) {\n    const cidStr = cid.toString('base58btc')\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.buffer, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        })\n      },\n      blocks: Array.from(this.blocks.values())\n        .map((block) => block.data)\n    }\n\n    if (this.full) {\n      msg.wantlist.full = true\n    }\n\n    return Message.encode(msg)\n  }\n\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.buffer, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        })\n      },\n      blockPresences: [],\n      payload: []\n    }\n\n    if (this.full) {\n      msg.wantlist.full = true\n    }\n\n    this.blocks.forEach((block) => {\n      msg.payload.push({\n        prefix: block.cid.prefix,\n        data: block.data\n      })\n    })\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push({\n        cid: new CID(cidStr).buffer,\n        type: bpType\n      })\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg)\n  }\n\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\nBitswapMessage.deserialize = async (raw) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist) {\n    decoded.wantlist.entries.forEach((entry) => {\n      // note: entry.block is the CID here\n      const cid = new CID(entry.block)\n      msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave)\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      const cid = new CID(blockPresence.cid)\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await multihashing(b, 'sha2-256')\n      const cid = new CID(hash)\n      msg.addBlock(new Block(b, cid))\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await multihashing(p.data, hashAlg)\n      const cid = new CID(cidVersion, getName(multicodec), hash)\n      msg.addBlock(new Block(p.data, cid))\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.buffer.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\nmodule.exports = BitswapMessage\n"]},"metadata":{},"sourceType":"script"}