{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nconst errCode = require('err-code');\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:dialer');\nlog.error = debug('libp2p:dialer:error');\n\nconst {\n  DialRequest\n} = require('./dial-request');\n\nconst getPeer = require('../get-peer');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS\n} = require('../constants');\n\nclass Dialer {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {TransportManager} options.transportManager\n   * @param {Peerstore} peerStore\n   * @param {number} options.concurrency Number of max concurrent dials. Defaults to `MAX_PARALLEL_DIALS`\n   * @param {number} options.timeout How long a dial attempt is allowed to take. Defaults to `DIAL_TIMEOUT`\n   */\n  constructor({\n    transportManager,\n    peerStore,\n    concurrency = MAX_PARALLEL_DIALS,\n    timeout = DIAL_TIMEOUT,\n    perPeerLimit = MAX_PER_PEER_DIALS\n  }) {\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.concurrency = concurrency;\n    this.timeout = timeout;\n    this.perPeerLimit = perPeerLimit;\n    this.tokens = [...new Array(concurrency)].map((_, index) => index);\n    this._pendingDials = new Map();\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectToPeer(peer, options = {}) {\n    const dialTarget = this._createDialTarget(peer);\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * @typedef DialTarget\n   * @property {string} id\n   * @property {Multiaddr[]} addrs\n   */\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * @private\n   * @param {PeerId|Multiaddr|string} peer A PeerId or Multiaddr\n   * @returns {DialTarget}\n   */\n\n\n  _createDialTarget(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    let addrs = this.peerStore.addressBook.getMultiaddrsForPeer(id); // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n\n    if (multiaddr.isMultiaddr(peer)) {\n      addrs = addrs.filter(addr => !peer.equals(addr));\n      addrs.unshift(peer);\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs\n    };\n  }\n  /**\n   * @typedef PendingDial\n   * @property {DialRequest} dialRequest\n   * @property {TimeoutController} controller\n   * @property {Promise} promise\n   * @property {function():void} destroy\n   */\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget, options) {\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals);\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n\n  getTokens(num) {\n    const total = Math.min(num, this.perPeerLimit, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n\n}\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/dialer/index.js"],"names":["multiaddr","require","errCode","TimeoutController","anySignal","debug","log","error","DialRequest","getPeer","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","Dialer","constructor","transportManager","peerStore","concurrency","timeout","perPeerLimit","tokens","Array","map","_","index","_pendingDials","Map","destroy","dial","values","controller","abort","err","clear","connectToPeer","peer","options","dialTarget","_createDialTarget","addrs","length","Error","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","connection","promise","signal","aborted","code","ERR_TIMEOUT","multiaddrs","addressBook","add","getMultiaddrsForPeer","isMultiaddr","filter","addr","equals","unshift","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","push","run","delete","set","getTokens","num","total","Math","min","splice","releaseToken","token","indexOf","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAME,iBAAiB,GAAGF,OAAO,CAAC,0BAAD,CAAjC;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,YAAD,CAAzB;;AACA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMK,GAAG,GAAGD,KAAK,CAAC,eAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,qBAAD,CAAjB;;AAEA,MAAM;AAAEG,EAAAA;AAAF,IAAkBP,OAAO,CAAC,gBAAD,CAA/B;;AACA,MAAMQ,OAAO,GAAGR,OAAO,CAAC,aAAD,CAAvB;;AAEA,MAAM;AAAES,EAAAA;AAAF,IAAYT,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAM;AACJU,EAAAA,YADI;AAEJC,EAAAA,kBAFI;AAGJC,EAAAA;AAHI,IAIFZ,OAAO,CAAC,cAAD,CAJX;;AAMA,MAAMa,MAAN,CAAa;AACX;;;;;;;;AAQAC,EAAAA,WAAW,CAAE;AACXC,IAAAA,gBADW;AAEXC,IAAAA,SAFW;AAGXC,IAAAA,WAAW,GAAGN,kBAHH;AAIXO,IAAAA,OAAO,GAAGR,YAJC;AAKXS,IAAAA,YAAY,GAAGP;AALJ,GAAF,EAMR;AACD,SAAKG,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,MAAL,GAAc,CAAC,GAAG,IAAIC,KAAJ,CAAUJ,WAAV,CAAJ,EAA4BK,GAA5B,CAAgC,CAACC,CAAD,EAAIC,KAAJ,KAAcA,KAA9C,CAAd;AACA,SAAKC,aAAL,GAAqB,IAAIC,GAAJ,EAArB;AACD;AAED;;;;;AAGAC,EAAAA,OAAO,GAAI;AACT,SAAK,MAAMC,IAAX,IAAmB,KAAKH,aAAL,CAAmBI,MAAnB,EAAnB,EAAgD;AAC9C,UAAI;AACFD,QAAAA,IAAI,CAACE,UAAL,CAAgBC,KAAhB;AACD,OAFD,CAEE,OAAOC,GAAP,EAAY;AACZ3B,QAAAA,GAAG,CAACC,KAAJ,CAAU0B,GAAV;AACD;AACF;;AACD,SAAKP,aAAL,CAAmBQ,KAAnB;AACD;AAED;;;;;;;;;;;;AAUA,QAAMC,aAAN,CAAqBC,IAArB,EAA2BC,OAAO,GAAG,EAArC,EAAyC;AACvC,UAAMC,UAAU,GAAG,KAAKC,iBAAL,CAAuBH,IAAvB,CAAnB;;AAEA,QAAI,CAACE,UAAU,CAACE,KAAX,CAAiBC,MAAtB,EAA8B;AAC5B,YAAMvC,OAAO,CAAC,IAAIwC,KAAJ,CAAU,mCAAV,CAAD,EAAiDhC,KAAK,CAACiC,sBAAvD,CAAb;AACD;;AACD,UAAMC,WAAW,GAAG,KAAKlB,aAAL,CAAmBmB,GAAnB,CAAuBP,UAAU,CAACQ,EAAlC,KAAyC,KAAKC,kBAAL,CAAwBT,UAAxB,EAAoCD,OAApC,CAA7D;;AAEA,QAAI;AACF,YAAMW,UAAU,GAAG,MAAMJ,WAAW,CAACK,OAArC;AACA3C,MAAAA,GAAG,CAAC,sBAAD,EAAyBgC,UAAU,CAACQ,EAApC,CAAH;AACA,aAAOE,UAAP;AACD,KAJD,CAIE,OAAOf,GAAP,EAAY;AACZ;AACA,UAAIW,WAAW,CAACb,UAAZ,CAAuBmB,MAAvB,CAA8BC,OAAlC,EAA2C;AACzClB,QAAAA,GAAG,CAACmB,IAAJ,GAAW1C,KAAK,CAAC2C,WAAjB;AACD;;AACD/C,MAAAA,GAAG,CAACC,KAAJ,CAAU0B,GAAV;AACA,YAAMA,GAAN;AACD,KAXD,SAWU;AACRW,MAAAA,WAAW,CAAChB,OAAZ;AACD;AACF;AAED;;;;;;AAMA;;;;;;;;;;AAQAW,EAAAA,iBAAiB,CAAEH,IAAF,EAAQ;AACvB,UAAM;AAAEU,MAAAA,EAAF;AAAMQ,MAAAA;AAAN,QAAqB7C,OAAO,CAAC2B,IAAD,CAAlC;;AAEA,QAAIkB,UAAJ,EAAgB;AACd,WAAKrC,SAAL,CAAesC,WAAf,CAA2BC,GAA3B,CAA+BV,EAA/B,EAAmCQ,UAAnC;AACD;;AAED,QAAId,KAAK,GAAG,KAAKvB,SAAL,CAAesC,WAAf,CAA2BE,oBAA3B,CAAgDX,EAAhD,CAAZ,CAPuB,CASvB;AACA;;AACA,QAAI9C,SAAS,CAAC0D,WAAV,CAAsBtB,IAAtB,CAAJ,EAAiC;AAC/BI,MAAAA,KAAK,GAAGA,KAAK,CAACmB,MAAN,CAAcC,IAAD,IAAU,CAACxB,IAAI,CAACyB,MAAL,CAAYD,IAAZ,CAAxB,CAAR;AACApB,MAAAA,KAAK,CAACsB,OAAN,CAAc1B,IAAd;AACD;;AAED,WAAO;AACLU,MAAAA,EAAE,EAAEA,EAAE,CAACiB,WAAH,EADC;AAELvB,MAAAA;AAFK,KAAP;AAID;AAED;;;;;;;;AAQA;;;;;;;;;;AAQAO,EAAAA,kBAAkB,CAAET,UAAF,EAAcD,OAAd,EAAuB;AACvC,UAAM2B,UAAU,GAAG,CAACJ,IAAD,EAAOvB,OAAP,KAAmB;AACpC,UAAIA,OAAO,CAACa,MAAR,CAAeC,OAAnB,EAA4B,MAAMjD,OAAO,CAAC,IAAIwC,KAAJ,CAAU,iBAAV,CAAD,EAA+BhC,KAAK,CAACuD,mBAArC,CAAb;AAC5B,aAAO,KAAKjD,gBAAL,CAAsBa,IAAtB,CAA2B+B,IAA3B,EAAiCvB,OAAjC,CAAP;AACD,KAHD;;AAKA,UAAM6B,WAAW,GAAG,IAAI1D,WAAJ,CAAgB;AAClCgC,MAAAA,KAAK,EAAEF,UAAU,CAACE,KADgB;AAElCwB,MAAAA,UAFkC;AAGlCG,MAAAA,MAAM,EAAE;AAH0B,KAAhB,CAApB,CANuC,CAYvC;;AACA,UAAMC,iBAAiB,GAAG,IAAIjE,iBAAJ,CAAsB,KAAKgB,OAA3B,CAA1B;AACA,UAAMkD,OAAO,GAAG,CAACD,iBAAiB,CAAClB,MAAnB,CAAhB;AACAb,IAAAA,OAAO,CAACa,MAAR,IAAkBmB,OAAO,CAACC,IAAR,CAAajC,OAAO,CAACa,MAArB,CAAlB;AACA,UAAMA,MAAM,GAAG9C,SAAS,CAACiE,OAAD,CAAxB;AAEA,UAAMzB,WAAW,GAAG;AAClBsB,MAAAA,WADkB;AAElBnC,MAAAA,UAAU,EAAEqC,iBAFM;AAGlBnB,MAAAA,OAAO,EAAEiB,WAAW,CAACK,GAAZ,CAAgB,EAAE,GAAGlC,OAAL;AAAca,QAAAA;AAAd,OAAhB,CAHS;AAIlBtB,MAAAA,OAAO,EAAE,MAAM;AACbwC,QAAAA,iBAAiB,CAAClC,KAAlB;;AACA,aAAKR,aAAL,CAAmB8C,MAAnB,CAA0BlC,UAAU,CAACQ,EAArC;AACD;AAPiB,KAApB;;AASA,SAAKpB,aAAL,CAAmB+C,GAAnB,CAAuBnC,UAAU,CAACQ,EAAlC,EAAsCF,WAAtC;;AACA,WAAOA,WAAP;AACD;;AAED8B,EAAAA,SAAS,CAAEC,GAAF,EAAO;AACd,UAAMC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASH,GAAT,EAAc,KAAKvD,YAAnB,EAAiC,KAAKC,MAAL,CAAYoB,MAA7C,CAAd;AACA,UAAMpB,MAAM,GAAG,KAAKA,MAAL,CAAY0D,MAAZ,CAAmB,CAAnB,EAAsBH,KAAtB,CAAf;AACAtE,IAAAA,GAAG,CAAC,+CAAD,EAAkDqE,GAAlD,EAAuDC,KAAvD,EAA8D,KAAKvD,MAAL,CAAYoB,MAA1E,CAAH;AACA,WAAOpB,MAAP;AACD;;AAED2D,EAAAA,YAAY,CAAEC,KAAF,EAAS;AACnB;AACA,QAAI,KAAK5D,MAAL,CAAY6D,OAAZ,CAAoBD,KAApB,IAA6B,CAAC,CAAlC,EAAqC;AACrC3E,IAAAA,GAAG,CAAC,mBAAD,EAAsB2E,KAAtB,CAAH;AACA,SAAK5D,MAAL,CAAYiD,IAAZ,CAAiBW,KAAjB;AACD;;AAxKU;;AA2KbE,MAAM,CAACC,OAAP,GAAiBtE,MAAjB","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\nconst errCode = require('err-code')\nconst TimeoutController = require('timeout-abort-controller')\nconst anySignal = require('any-signal')\nconst debug = require('debug')\nconst log = debug('libp2p:dialer')\nlog.error = debug('libp2p:dialer:error')\n\nconst { DialRequest } = require('./dial-request')\nconst getPeer = require('../get-peer')\n\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS\n} = require('../constants')\n\nclass Dialer {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {TransportManager} options.transportManager\n   * @param {Peerstore} peerStore\n   * @param {number} options.concurrency Number of max concurrent dials. Defaults to `MAX_PARALLEL_DIALS`\n   * @param {number} options.timeout How long a dial attempt is allowed to take. Defaults to `DIAL_TIMEOUT`\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    concurrency = MAX_PARALLEL_DIALS,\n    timeout = DIAL_TIMEOUT,\n    perPeerLimit = MAX_PER_PEER_DIALS\n  }) {\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.concurrency = concurrency\n    this.timeout = timeout\n    this.perPeerLimit = perPeerLimit\n    this.tokens = [...new Array(concurrency)].map((_, index) => index)\n    this._pendingDials = new Map()\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const dialTarget = this._createDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * @typedef DialTarget\n   * @property {string} id\n   * @property {Multiaddr[]} addrs\n   */\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * @private\n   * @param {PeerId|Multiaddr|string} peer A PeerId or Multiaddr\n   * @returns {DialTarget}\n   */\n  _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let addrs = this.peerStore.addressBook.getMultiaddrsForPeer(id)\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (multiaddr.isMultiaddr(peer)) {\n      addrs = addrs.filter((addr) => !peer.equals(addr))\n      addrs.unshift(peer)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs\n    }\n  }\n\n  /**\n   * @typedef PendingDial\n   * @property {DialRequest} dialRequest\n   * @property {TimeoutController} controller\n   * @property {Promise} promise\n   * @property {function():void} destroy\n   */\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options) {\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n    return pendingDial\n  }\n\n  getTokens (num) {\n    const total = Math.min(num, this.perPeerLimit, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}