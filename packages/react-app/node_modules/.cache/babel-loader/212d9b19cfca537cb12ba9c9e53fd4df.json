{"ast":null,"code":"'use strict';\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar multihash = require('multihashes');\n\nvar multibase = require('multibase');\n\nvar Multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar CID = require('cids');\n\nvar _require2 = require('iso-url'),\n    URL = _require2.URL;\n\nvar pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nvar pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nvar defaultProtocolMatch = 1;\nvar defaultHashMath = 2; // CID, libp2p-key or DNSLink\n\nvar subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nvar subdomainIdMatch = 1;\nvar subdomainProtocolMatch = 2; // Fully qualified domain name (FQDN) that has an explicit .tld suffix\n\nvar fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\n\nfunction isMultihash(hash) {\n  var formatted = convertToString(hash);\n\n  try {\n    multihash.decode(multibase.decode('z' + formatted));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultibase(hash) {\n  try {\n    return multibase.isEncoded(hash);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isCID(hash) {\n  try {\n    new CID(hash); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultiaddr(input) {\n  if (!input) return false;\n  if (Multiaddr.isMultiaddr(input)) return true;\n\n  try {\n    new Multiaddr(input); // eslint-disable-line no-new\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.IPFS.matches(input);\n}\n\nfunction isIpfs(input, pattern) {\n  var protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  var hashMatch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultHashMath;\n  var formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  var match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  var hash = match[hashMatch];\n\n  if (hash && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n\nfunction isIpns(input, pattern) {\n  var protocolMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultProtocolMatch;\n  var hashMatch = arguments.length > 3 ? arguments[3] : undefined;\n  var formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  var match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  var ipnsId = match[hashMatch];\n\n  if (ipnsId && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase(); // Check if it is cidv1\n\n    if (isCID(ipnsId)) return true; // Check if it looks like FQDN\n\n    try {\n      // URL implementation in web browsers forces lowercase of the hostname\n      var _URL = new URL(\"http://\".concat(ipnsId)),\n          hostname = _URL.hostname; // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n\n\n      return fqdnWithTld.test(hostname);\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isString(input) {\n  return typeof input === 'string';\n}\n\nfunction convertToString(input) {\n  if (Buffer.isBuffer(input)) {\n    return multibase.encode('base58btc', input).toString().slice(1);\n  }\n\n  if (isString(input)) {\n    return input;\n  }\n\n  return false;\n}\n\nvar ipfsSubdomain = function ipfsSubdomain(url) {\n  return isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n};\n\nvar ipnsSubdomain = function ipnsSubdomain(url) {\n  return isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n};\n\nvar subdomain = function subdomain(url) {\n  return ipfsSubdomain(url) || ipnsSubdomain(url);\n};\n\nvar ipfsUrl = function ipfsUrl(url) {\n  return isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\n};\n\nvar ipnsUrl = function ipnsUrl(url) {\n  return isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\n};\n\nvar url = function url(_url) {\n  return ipfsUrl(_url) || ipnsUrl(_url) || subdomain(_url);\n};\n\nvar path = function path(_path) {\n  return isIpfs(_path, pathPattern) || isIpns(_path, pathPattern);\n};\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  base32cid: function base32cid(cid) {\n    return isMultibase(cid) === 'base32' && isCID(cid);\n  },\n  ipfsSubdomain: ipfsSubdomain,\n  ipnsSubdomain: ipnsSubdomain,\n  subdomain: subdomain,\n  subdomainGatewayPattern: subdomainGatewayPattern,\n  ipfsUrl: ipfsUrl,\n  ipnsUrl: ipnsUrl,\n  url: url,\n  pathGatewayPattern: pathGatewayPattern,\n  ipfsPath: function ipfsPath(path) {\n    return isIpfs(path, pathPattern);\n  },\n  ipnsPath: function ipnsPath(path) {\n    return isIpns(path, pathPattern);\n  },\n  path: path,\n  pathPattern: pathPattern,\n  urlOrPath: function urlOrPath(x) {\n    return url(x) || path(x);\n  },\n  cidPath: function cidPath(path) {\n    return isString(path) && !isCID(path) && isIpfs(\"/ipfs/\".concat(path), pathPattern);\n  }\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/is-ipfs/src/index.js"],"names":["require","Buffer","multihash","multibase","Multiaddr","mafmt","CID","URL","pathGatewayPattern","pathPattern","defaultProtocolMatch","defaultHashMath","subdomainGatewayPattern","subdomainIdMatch","subdomainProtocolMatch","fqdnWithTld","isMultihash","hash","formatted","convertToString","decode","e","isMultibase","isEncoded","isCID","isMultiaddr","input","isPeerMultiaddr","IPFS","matches","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","hostname","test","isString","isBuffer","encode","toString","slice","ipfsSubdomain","url","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","path","module","exports","multiaddr","peerMultiaddr","cid","base32cid","ipfsPath","ipnsPath","urlOrPath","x","cidPath"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst multihash = require('multihashes')\nconst multibase = require('multibase')\nconst Multiaddr = require('multiaddr')\nconst mafmt = require('mafmt')\nconst CID = require('cids')\nconst { URL } = require('iso-url')\n\nconst pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nconst pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nconst subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\nfunction isMultihash (hash) {\n  const formatted = convertToString(hash)\n  try {\n    multihash.decode(multibase.decode('z' + formatted))\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isMultibase (hash) {\n  try {\n    return multibase.isEncoded(hash)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isCID (hash) {\n  try {\n    new CID(hash) // eslint-disable-line no-new\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isMultiaddr (input) {\n  if (!input) return false\n  if (Multiaddr.isMultiaddr(input)) return true\n  try {\n    new Multiaddr(input) // eslint-disable-line no-new\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nfunction isPeerMultiaddr (input) {\n  return isMultiaddr(input) && mafmt.IPFS.matches(input)\n}\n\nfunction isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\nfunction isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isString (input) {\n  return typeof input === 'string'\n}\n\nfunction convertToString (input) {\n  if (Buffer.isBuffer(input)) {\n    return multibase.encode('base58btc', input).toString().slice(1)\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\nconst ipfsSubdomain = (url) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\nconst ipnsSubdomain = (url) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\nconst subdomain = (url) => ipfsSubdomain(url) || ipnsSubdomain(url)\n\nconst ipfsUrl = (url) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\nconst ipnsUrl = (url) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\nconst url = (url) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\n\nconst path = (path) => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  base32cid: (cid) => (isMultibase(cid) === 'base32' && isCID(cid)),\n  ipfsSubdomain,\n  ipnsSubdomain,\n  subdomain,\n  subdomainGatewayPattern,\n  ipfsUrl,\n  ipnsUrl,\n  url,\n  pathGatewayPattern: pathGatewayPattern,\n  ipfsPath: (path) => isIpfs(path, pathPattern),\n  ipnsPath: (path) => isIpns(path, pathPattern),\n  path,\n  pathPattern,\n  urlOrPath: (x) => url(x) || path(x),\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n}\n"]},"metadata":{},"sourceType":"script"}