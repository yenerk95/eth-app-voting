{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:peer-store:address-book');\nlog.error = debug('libp2p:peer-store:address-book:error');\n\nvar multiaddr = require('multiaddr');\n\nvar PeerId = require('peer-id');\n\nvar Book = require('./book');\n\nvar _require = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;\n/**\n * The AddressBook is responsible for keeping the known multiaddrs\n * of a peer.\n */\n\n\nvar AddressBook = /*#__PURE__*/function (_Book) {\n  _inherits(AddressBook, _Book);\n\n  var _super = _createSuper(AddressBook);\n\n  /**\n   * Address object\n   * @typedef {Object} Address\n   * @property {Multiaddr} multiaddr peer multiaddr.\n   */\n\n  /**\n  * @constructor\n  * @param {PeerStore} peerStore\n  */\n  function AddressBook(peerStore) {\n    var _this;\n\n    _classCallCheck(this, AddressBook);\n\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    _this = _super.call(this, {\n      peerStore: peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: function eventTransformer(data) {\n        return data.map(function (address) {\n          return address.multiaddr;\n        });\n      }\n    });\n    /**\n     * Map known peers to their known Addresses.\n     * @type {Map<string, Array<Address>>}\n     */\n\n    _this.data = new Map();\n    return _this;\n  }\n  /**\n   * Set known multiaddrs of a provided peer.\n   * @override\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  _createClass(AddressBook, [{\n    key: \"set\",\n    value: function set(peerId, multiaddrs) {\n      if (!PeerId.isPeerId(peerId)) {\n        log.error('peerId must be an instance of peer-id to store data');\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var addresses = this._toAddresses(multiaddrs);\n\n      var id = peerId.toB58String();\n      var rec = this.data.get(id); // Not replace multiaddrs\n\n      if (!addresses.length) {\n        return this;\n      } // Already knows the peer\n\n\n      if (rec && rec.length === addresses.length) {\n        var intersection = rec.filter(function (mi) {\n          return addresses.some(function (newMi) {\n            return mi.multiaddr.equals(newMi.multiaddr);\n          });\n        }); // Are new addresses equal to the old ones?\n        // If yes, no changes needed!\n\n        if (intersection.length === rec.length) {\n          log(\"the addresses provided to store are equal to the already stored for \".concat(id));\n          return this;\n        }\n      }\n\n      this._setData(peerId, addresses);\n\n      log(\"stored provided multiaddrs for \".concat(id)); // Notify the existance of a new peer\n\n      if (!rec) {\n        this._ps.emit('peer', peerId);\n      }\n\n      return this;\n    }\n    /**\n     * Add known addresses of a provided peer.\n     * If the peer is not known, it is set with the given addresses.\n     * @param {PeerId} peerId\n     * @param {Array<Multiaddr>} multiaddrs\n     * @returns {AddressBook}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(peerId, multiaddrs) {\n      if (!PeerId.isPeerId(peerId)) {\n        log.error('peerId must be an instance of peer-id to store data');\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var addresses = this._toAddresses(multiaddrs);\n\n      var id = peerId.toB58String();\n      var rec = this.data.get(id); // Add recorded uniquely to the new array (Union)\n\n      rec && rec.forEach(function (mi) {\n        if (!addresses.find(function (r) {\n          return r.multiaddr.equals(mi.multiaddr);\n        })) {\n          addresses.push(mi);\n        }\n      }); // If the recorded length is equal to the new after the unique union\n      // The content is the same, no need to update.\n\n      if (rec && rec.length === addresses.length) {\n        log(\"the addresses provided to store are already stored for \".concat(id));\n        return this;\n      }\n\n      this._setData(peerId, addresses);\n\n      log(\"added provided multiaddrs for \".concat(id)); // Notify the existance of a new peer\n\n      if (!rec) {\n        this._ps.emit('peer', peerId);\n      }\n\n      return this;\n    }\n    /**\n     * Transforms received multiaddrs into Address.\n     * @private\n     * @param {Array<Multiaddr>} multiaddrs\n     * @returns {Array<Address>}\n     */\n\n  }, {\n    key: \"_toAddresses\",\n    value: function _toAddresses(multiaddrs) {\n      if (!multiaddrs) {\n        log.error('multiaddrs must be provided to store data');\n        throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);\n      } // create Address for each address\n\n\n      var addresses = [];\n      multiaddrs.forEach(function (addr) {\n        if (!multiaddr.isMultiaddr(addr)) {\n          log.error(\"multiaddr \".concat(addr, \" must be an instance of multiaddr\"));\n          throw errcode(new Error(\"multiaddr \".concat(addr, \" must be an instance of multiaddr\")), ERR_INVALID_PARAMETERS);\n        }\n\n        addresses.push({\n          multiaddr: addr\n        });\n      });\n      return addresses;\n    }\n    /**\n     * Get the known multiaddrs for a given peer. All returned multiaddrs\n     * will include the encapsulated `PeerId` of the peer.\n     * @param {PeerId} peerId\n     * @returns {Array<Multiaddr>}\n     */\n\n  }, {\n    key: \"getMultiaddrsForPeer\",\n    value: function getMultiaddrsForPeer(peerId) {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var record = this.data.get(peerId.toB58String());\n\n      if (!record) {\n        return undefined;\n      }\n\n      return record.map(function (address) {\n        var multiaddr = address.multiaddr;\n        var idString = multiaddr.getPeerId();\n        if (idString && idString === peerId.toB58String()) return multiaddr;\n        return multiaddr.encapsulate(\"/p2p/\".concat(peerId.toB58String()));\n      });\n    }\n  }]);\n\n  return AddressBook;\n}(Book);\n\nmodule.exports = AddressBook;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/peer-store/address-book.js"],"names":["errcode","require","debug","log","error","multiaddr","PeerId","Book","ERR_INVALID_PARAMETERS","codes","AddressBook","peerStore","eventName","eventProperty","eventTransformer","data","map","address","Map","peerId","multiaddrs","isPeerId","Error","addresses","_toAddresses","id","toB58String","rec","get","length","intersection","filter","mi","some","newMi","equals","_setData","_ps","emit","forEach","find","r","push","addr","isMultiaddr","record","undefined","idString","getPeerId","encapsulate","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('libp2p:peer-store:address-book')\nlog.error = debug('libp2p:peer-store:address-book:error')\n\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst Book = require('./book')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\n\n/**\n * The AddressBook is responsible for keeping the known multiaddrs\n * of a peer.\n */\nclass AddressBook extends Book {\n  /**\n   * Address object\n   * @typedef {Object} Address\n   * @property {Multiaddr} multiaddr peer multiaddr.\n   */\n\n  /**\n  * @constructor\n  * @param {PeerStore} peerStore\n  */\n  constructor (peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: (data) => data.map((address) => address.multiaddr)\n    })\n\n    /**\n     * Map known peers to their known Addresses.\n     * @type {Map<string, Array<Address>>}\n     */\n    this.data = new Map()\n  }\n\n  /**\n   * Set known multiaddrs of a provided peer.\n   * @override\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n  set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n    const rec = this.data.get(id)\n\n    // Not replace multiaddrs\n    if (!addresses.length) {\n      return this\n    }\n\n    // Already knows the peer\n    if (rec && rec.length === addresses.length) {\n      const intersection = rec.filter((mi) => addresses.some((newMi) => mi.multiaddr.equals(newMi.multiaddr)))\n\n      // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n      if (intersection.length === rec.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, addresses)\n    log(`stored provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!rec) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n  add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n    const rec = this.data.get(id)\n\n    // Add recorded uniquely to the new array (Union)\n    rec && rec.forEach((mi) => {\n      if (!addresses.find(r => r.multiaddr.equals(mi.multiaddr))) {\n        addresses.push(mi)\n      }\n    })\n\n    // If the recorded length is equal to the new after the unique union\n    // The content is the same, no need to update.\n    if (rec && rec.length === addresses.length) {\n      log(`the addresses provided to store are already stored for ${id}`)\n      return this\n    }\n\n    this._setData(peerId, addresses)\n\n    log(`added provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!rec) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Transforms received multiaddrs into Address.\n   * @private\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {Array<Address>}\n   */\n  _toAddresses (multiaddrs) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data')\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS)\n    }\n\n    // create Address for each address\n    const addresses = []\n    multiaddrs.forEach((addr) => {\n      if (!multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`)\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS)\n      }\n\n      addresses.push({\n        multiaddr: addr\n      })\n    })\n\n    return addresses\n  }\n\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Multiaddr>}\n   */\n  getMultiaddrsForPeer (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const record = this.data.get(peerId.toB58String())\n\n    if (!record) {\n      return undefined\n    }\n\n    return record.map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\nmodule.exports = AddressBook\n"]},"metadata":{},"sourceType":"script"}