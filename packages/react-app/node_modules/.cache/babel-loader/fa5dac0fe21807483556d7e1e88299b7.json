{"ast":null,"code":"'use strict';\n\nconst withIs = require('class-is');\n\nconst Topology = require('./index');\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {Object} props\n   * @param {number} props.min minimum needed connections (default: 0)\n   * @param {number} props.max maximum needed connections (default: Infinity)\n   * @param {Array<string>} props.multicodecs protocol multicodecs\n   * @param {Object} props.handlers\n   * @param {function} props.handlers.onConnect protocol \"onConnect\" handler\n   * @param {function} props.handlers.onDisconnect protocol \"onDisconnect\" handler\n   * @constructor\n   */\n  constructor({\n    min,\n    max,\n    multicodecs,\n    handlers\n  }) {\n    super({\n      min,\n      max,\n      handlers\n    });\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided');\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided');\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided');\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided');\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];\n    this._registrar = undefined;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n  }\n\n  set registrar(registrar) {\n    this._registrar = registrar;\n\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect); // Update topology peers\n\n\n    this._updatePeers(this._registrar.peerStore.peers.values());\n  }\n  /**\n   * Update topology.\n   * @param {Array<{id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string>}>} peerDataIterable\n   * @returns {void}\n   */\n\n\n  _updatePeers(peerDataIterable) {\n    for (const {\n      id,\n      protocols\n    } of peerDataIterable) {\n      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.add(id.toB58String()); // If there is a connection, call _onConnect\n\n        const connection = this._registrar.getConnection(id);\n\n        connection && this._onConnect(id, connection);\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(id.toB58String());\n      }\n    }\n  }\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {Array<string>} props.protocols\n   */\n\n\n  _onProtocolChange({\n    peerId,\n    protocols\n  }) {\n    const hadPeer = this.peers.has(peerId.toB58String());\n    const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol)); // Not supporting the protocol anymore?\n\n    if (hadPeer && hasProtocol.length === 0) {\n      this._onDisconnect(peerId);\n    } // New to protocol support\n\n\n    for (const protocol of protocols) {\n      if (this.multicodecs.includes(protocol)) {\n        const peerData = this._registrar.peerStore.get(peerId);\n\n        this._updatePeers([peerData]);\n\n        return;\n      }\n    }\n  }\n  /**\n   * Verify if a new connected peer has a topology multicodec and call _onConnect.\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  _onPeerConnect(connection) {\n    const peerId = connection.remotePeer;\n\n    const protocols = this._registrar.peerStore.protoBook.get(peerId);\n\n    if (!protocols) {\n      return;\n    }\n\n    if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {\n      this.peers.add(peerId.toB58String());\n\n      this._onConnect(peerId, connection);\n    }\n  }\n\n}\n\nmodule.exports = withIs(MulticodecTopology, {\n  className: 'MulticodecTopology',\n  symbolName: '@libp2p/js-interfaces/topology/multicodec-topology'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-interfaces/src/topology/multicodec-topology.js"],"names":["withIs","require","Topology","MulticodecTopology","constructor","min","max","multicodecs","handlers","Error","onConnect","onDisconnect","Array","isArray","_registrar","undefined","_onProtocolChange","bind","_onPeerConnect","registrar","peerStore","on","connectionManager","_updatePeers","peers","values","peerDataIterable","id","protocols","filter","multicodec","includes","length","add","toB58String","connection","getConnection","_onConnect","delete","peerId","hadPeer","has","hasProtocol","protocol","_onDisconnect","peerData","get","remotePeer","protoBook","find","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst withIs = require('class-is')\n\nconst Topology = require('./index')\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {Object} props\n   * @param {number} props.min minimum needed connections (default: 0)\n   * @param {number} props.max maximum needed connections (default: Infinity)\n   * @param {Array<string>} props.multicodecs protocol multicodecs\n   * @param {Object} props.handlers\n   * @param {function} props.handlers.onConnect protocol \"onConnect\" handler\n   * @param {function} props.handlers.onDisconnect protocol \"onDisconnect\" handler\n   * @constructor\n   */\n  constructor ({\n    min,\n    max,\n    multicodecs,\n    handlers\n  }) {\n    super({ min, max, handlers })\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided')\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided')\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided')\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided')\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs]\n    this._registrar = undefined\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n  }\n\n  set registrar (registrar) {\n    this._registrar = registrar\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange)\n    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect)\n\n    // Update topology peers\n    this._updatePeers(this._registrar.peerStore.peers.values())\n  }\n\n  /**\n   * Update topology.\n   * @param {Array<{id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string>}>} peerDataIterable\n   * @returns {void}\n   */\n  _updatePeers (peerDataIterable) {\n    for (const { id, protocols } of peerDataIterable) {\n      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.add(id.toB58String())\n        // If there is a connection, call _onConnect\n        const connection = this._registrar.getConnection(id)\n        connection && this._onConnect(id, connection)\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(id.toB58String())\n      }\n    }\n  }\n\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {Array<string>} props.protocols\n   */\n  _onProtocolChange ({ peerId, protocols }) {\n    const hadPeer = this.peers.has(peerId.toB58String())\n    const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol))\n\n    // Not supporting the protocol anymore?\n    if (hadPeer && hasProtocol.length === 0) {\n      this._onDisconnect(peerId)\n    }\n\n    // New to protocol support\n    for (const protocol of protocols) {\n      if (this.multicodecs.includes(protocol)) {\n        const peerData = this._registrar.peerStore.get(peerId)\n        this._updatePeers([peerData])\n        return\n      }\n    }\n  }\n\n  /**\n   * Verify if a new connected peer has a topology multicodec and call _onConnect.\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  _onPeerConnect (connection) {\n    const peerId = connection.remotePeer\n    const protocols = this._registrar.peerStore.protoBook.get(peerId)\n\n    if (!protocols) {\n      return\n    }\n\n    if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {\n      this.peers.add(peerId.toB58String())\n      this._onConnect(peerId, connection)\n    }\n  }\n}\n\nmodule.exports = withIs(MulticodecTopology, { className: 'MulticodecTopology', symbolName: '@libp2p/js-interfaces/topology/multicodec-topology' })\n"]},"metadata":{},"sourceType":"script"}