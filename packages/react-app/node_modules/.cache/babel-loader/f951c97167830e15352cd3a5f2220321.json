{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('interface-datastore'),\n    Adapter = _require2.Adapter,\n    Key = _require2.Key;\n\nvar sh = require('./shard');\n\nvar KeytransformStore = require('./keytransform');\n\nvar shardKey = new Key(sh.SHARDING_FN);\nvar shardReadmeKey = new Key(sh.README_FN);\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nvar ShardingDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(ShardingDatastore, _Adapter);\n\n  var _super = _createSuper(ShardingDatastore);\n\n  function ShardingDatastore(store, shard) {\n    var _this;\n\n    _classCallCheck(this, ShardingDatastore);\n\n    _this = _super.call(this);\n    _this.child = new KeytransformStore(store, {\n      convert: _this._convertKey.bind(_assertThisInitialized(_this)),\n      invert: _this._invertKey.bind(_assertThisInitialized(_this))\n    });\n    _this.shard = shard;\n    return _this;\n  }\n\n  _createClass(ShardingDatastore, [{\n    key: \"open\",\n    value: function open() {\n      return this.child.open();\n    }\n  }, {\n    key: \"_convertKey\",\n    value: function _convertKey(key) {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      var parent = new Key(this.shard.fun(s));\n      return parent.child(key);\n    }\n  }, {\n    key: \"_invertKey\",\n    value: function _invertKey(key) {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      return Key.withNamespaces(key.list().slice(1));\n    }\n  }, {\n    key: \"put\",\n    value: function put(key, val, options) {\n      return this.child.put(key, val, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      return this.child.get(key, options);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, options) {\n      return this.child.has(key, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, options) {\n      return this.child.delete(key, options);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      return this.child.batch();\n    }\n  }, {\n    key: \"query\",\n    value: function query(q, options) {\n      var _this2 = this;\n\n      var tq = {\n        keysOnly: q.keysOnly,\n        offset: q.offset,\n        limit: q.limit,\n        filters: [function (e) {\n          return e.key.toString() !== shardKey.toString();\n        }, function (e) {\n          return e.key.toString() !== shardReadmeKey.toString();\n        }]\n      };\n\n      if (q.prefix != null) {\n        tq.filters.push(function (e) {\n          return _this2._invertKey(e.key).toString().startsWith(q.prefix);\n        });\n      }\n\n      if (q.filters != null) {\n        var filters = q.filters.map(function (f) {\n          return function (e) {\n            return f(Object.assign({}, e, {\n              key: _this2._invertKey(e.key)\n            }));\n          };\n        });\n        tq.filters = tq.filters.concat(filters);\n      }\n\n      if (q.orders != null) {\n        tq.orders = q.orders.map(function (o) {\n          return /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(res) {\n              var ordered;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      res.forEach(function (e) {\n                        e.key = _this2._invertKey(e.key);\n                      });\n                      _context.next = 3;\n                      return o(res);\n\n                    case 3:\n                      ordered = _context.sent;\n                      ordered.forEach(function (e) {\n                        e.key = _this2._convertKey(e.key);\n                      });\n                      return _context.abrupt(\"return\", ordered);\n\n                    case 6:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }();\n        });\n      }\n\n      return this.child.query(tq, options);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.child.close();\n    }\n  }], [{\n    key: \"createOrOpen\",\n    value: function () {\n      var _createOrOpen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(store, shard) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return ShardingDatastore.create(store, shard);\n\n              case 3:\n                _context2.next = 9;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (!(_context2.t0 && _context2.t0.message !== 'datastore exists')) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw _context2.t0;\n\n              case 9:\n                return _context2.abrupt(\"return\", ShardingDatastore.open(store));\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 5]]);\n      }));\n\n      function createOrOpen(_x2, _x3) {\n        return _createOrOpen.apply(this, arguments);\n      }\n\n      return createOrOpen;\n    }()\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(store) {\n        var shard;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return sh.readShardFun('/', store);\n\n              case 2:\n                shard = _context3.sent;\n                return _context3.abrupt(\"return\", new ShardingDatastore(store, shard));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function open(_x4) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(store, shard) {\n        var exists, put, diskShard, a, b;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return store.has(shardKey);\n\n              case 2:\n                exists = _context4.sent;\n\n                if (exists) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n                return _context4.abrupt(\"return\", Promise.all([put(shardKey, Buffer.from(shard.toString() + '\\n')), put(shardReadmeKey, Buffer.from(sh.readme))]));\n\n              case 6:\n                _context4.next = 8;\n                return sh.readShardFun('/', store);\n\n              case 8:\n                diskShard = _context4.sent;\n                a = (diskShard || '').toString();\n                b = shard.toString();\n\n                if (!(a !== b)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                throw new Error(\"specified fun \".concat(b, \" does not match repo shard fun \").concat(a));\n\n              case 13:\n                throw new Error('datastore exists');\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function create(_x5, _x6) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return ShardingDatastore;\n}(Adapter);\n\nmodule.exports = ShardingDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-core/src/sharding.js"],"names":["require","Buffer","Adapter","Key","sh","KeytransformStore","shardKey","SHARDING_FN","shardReadmeKey","README_FN","ShardingDatastore","store","shard","child","convert","_convertKey","bind","invert","_invertKey","open","key","s","toString","parent","fun","withNamespaces","list","slice","val","options","put","get","has","delete","batch","q","tq","keysOnly","offset","limit","filters","e","prefix","push","startsWith","map","f","Object","assign","concat","orders","o","res","forEach","ordered","query","close","create","message","readShardFun","exists","putRaw","Promise","all","from","readme","diskShard","a","b","Error","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst { Adapter, Key } = require('interface-datastore')\nconst sh = require('./shard')\nconst KeytransformStore = require('./keytransform')\n\nconst shardKey = new Key(sh.SHARDING_FN)\nconst shardReadmeKey = new Key(sh.README_FN)\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\nclass ShardingDatastore extends Adapter {\n  constructor (store, shard) {\n    super()\n\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    })\n    this.shard = shard\n  }\n\n  open () {\n    return this.child.open()\n  }\n\n  _convertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n\n    const parent = new Key(this.shard.fun(s))\n    return parent.child(key)\n  }\n\n  _invertKey (key) {\n    const s = key.toString()\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key\n    }\n    return Key.withNamespaces(key.list().slice(1))\n  }\n\n  static async createOrOpen (store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard)\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err\n    }\n    return ShardingDatastore.open(store)\n  }\n\n  static async open (store) {\n    const shard = await sh.readShardFun('/', store)\n    return new ShardingDatastore(store, shard)\n  }\n\n  static async create (store, shard) {\n    const exists = await store.has(shardKey)\n    if (!exists) {\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store)\n      return Promise.all([put(shardKey, Buffer.from(shard.toString() + '\\n')),\n        put(shardReadmeKey, Buffer.from(sh.readme))])\n    }\n\n    const diskShard = await sh.readShardFun('/', store)\n    const a = (diskShard || '').toString()\n    const b = shard.toString()\n    if (a !== b) throw new Error(`specified fun ${b} does not match repo shard fun ${a}`)\n    throw new Error('datastore exists')\n  }\n\n  put (key, val, options) {\n    return this.child.put(key, val, options)\n  }\n\n  get (key, options) {\n    return this.child.get(key, options)\n  }\n\n  has (key, options) {\n    return this.child.has(key, options)\n  }\n\n  delete (key, options) {\n    return this.child.delete(key, options)\n  }\n\n  batch () {\n    return this.child.batch()\n  }\n\n  query (q, options) {\n    const tq = {\n      keysOnly: q.keysOnly,\n      offset: q.offset,\n      limit: q.limit,\n      filters: [\n        e => e.key.toString() !== shardKey.toString(),\n        e => e.key.toString() !== shardReadmeKey.toString()\n      ]\n    }\n\n    if (q.prefix != null) {\n      tq.filters.push((e) => {\n        return this._invertKey(e.key).toString().startsWith(q.prefix)\n      })\n    }\n\n    if (q.filters != null) {\n      const filters = q.filters.map((f) => (e) => {\n        return f(Object.assign({}, e, {\n          key: this._invertKey(e.key)\n        }))\n      })\n      tq.filters = tq.filters.concat(filters)\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map((o) => async (res) => {\n        res.forEach((e) => { e.key = this._invertKey(e.key) })\n        const ordered = await o(res)\n        ordered.forEach((e) => { e.key = this._convertKey(e.key) })\n        return ordered\n      })\n    }\n\n    return this.child.query(tq, options)\n  }\n\n  close () {\n    return this.child.close()\n  }\n}\n\nmodule.exports = ShardingDatastore\n"]},"metadata":{},"sourceType":"script"}