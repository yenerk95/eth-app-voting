{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar debug = require('debug');\n\nvar globalThis = require('ipfs-utils/src/globalthis');\n\nvar log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nvar PeerId = require('peer-id');\n\nvar peerRouting = require('./peer-routing');\n\nvar contentRouting = require('./content-routing');\n\nvar pubsub = require('./pubsub');\n\nvar getPeer = require('./get-peer');\n\nvar _require2 = require('./config'),\n    validateConfig = _require2.validate;\n\nvar _require3 = require('./errors'),\n    codes = _require3.codes;\n\nvar AddressManager = require('./address-manager');\n\nvar ConnectionManager = require('./connection-manager');\n\nvar Circuit = require('./circuit');\n\nvar Dialer = require('./dialer');\n\nvar Keychain = require('./keychain');\n\nvar Metrics = require('./metrics');\n\nvar TransportManager = require('./transport-manager');\n\nvar Upgrader = require('./upgrader');\n\nvar PeerStore = require('./peer-store');\n\nvar PersistentPeerStore = require('./peer-store/persistent');\n\nvar Registrar = require('./registrar');\n\nvar _ping = require('./ping');\n\nvar _require4 = require('./identify'),\n    IdentifyService = _require4.IdentifyService,\n    IDENTIFY_PROTOCOLS = _require4.multicodecs;\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nvar Libp2p = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Libp2p, _EventEmitter);\n\n  var _super = _createSuper(Libp2p);\n\n  function Libp2p(_options) {\n    var _this;\n\n    _classCallCheck(this, Libp2p);\n\n    _this = _super.call(this); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    _this._options = validateConfig(_options);\n    _this.peerId = _this._options.peerId;\n    _this.datastore = _this._options.datastore;\n    _this.peerStore = _this.datastore && _this._options.peerStore.persistence ? new PersistentPeerStore(_objectSpread({\n      datastore: _this.datastore\n    }, _this._options.peerStore)) : new PeerStore(); // Addresses {listen, announce, noAnnounce}\n\n    _this.addresses = _this._options.addresses;\n    _this.addressManager = new AddressManager(_this._options.addresses);\n    _this._modules = _this._options.modules;\n    _this._config = _this._options.config;\n    _this._transport = []; // Transport instances/references\n\n    _this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_this), _this._options.connectionManager); // Create Metrics\n\n    if (_this._options.metrics.enabled) {\n      _this.metrics = new Metrics(_objectSpread(_objectSpread({}, _this._options.metrics), {}, {\n        connectionManager: _this.connectionManager\n      }));\n    } // Create keychain\n\n\n    if (_this._options.keychain && _this._options.keychain.pass && _this._options.keychain.datastore) {\n      log('creating keychain');\n      var keychainOpts = Keychain.generateOptions();\n      _this.keychain = new Keychain(_this._options.keychain.datastore, _objectSpread(_objectSpread({\n        passPhrase: _this._options.keychain.pass\n      }, keychainOpts), _this._options.keychain));\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    _this.upgrader = new Upgrader({\n      localPeer: _this.peerId,\n      metrics: _this.metrics,\n      onConnection: function onConnection(connection) {\n        return _this.connectionManager.onConnect(connection);\n      },\n      onConnectionEnd: function onConnectionEnd(connection) {\n        return _this.connectionManager.onDisconnect(connection);\n      }\n    }); // Setup the transport manager\n\n    _this.transportManager = new TransportManager({\n      libp2p: _assertThisInitialized(_this),\n      upgrader: _this.upgrader,\n      faultTolerance: _this._options.transportManager.faultTolerance\n    }); // Create the Registrar\n\n    _this.registrar = new Registrar({\n      peerStore: _this.peerStore,\n      connectionManager: _this.connectionManager\n    });\n    _this.handle = _this.handle.bind(_assertThisInitialized(_this));\n    _this.registrar.handle = _this.handle; // Attach crypto channels\n\n    if (_this._modules.connEncryption) {\n      var cryptos = _this._modules.connEncryption;\n      cryptos.forEach(function (crypto) {\n        _this.upgrader.cryptos.set(crypto.protocol, crypto);\n      });\n    }\n\n    _this.dialer = new Dialer({\n      transportManager: _this.transportManager,\n      peerStore: _this.peerStore,\n      concurrency: _this._options.dialer.maxParallelDials,\n      perPeerLimit: _this._options.dialer.maxDialsPerPeer,\n      timeout: _this._options.dialer.dialTimeout\n    });\n\n    _this._modules.transport.forEach(function (Transport) {\n      var key = Transport.prototype[Symbol.toStringTag];\n      var transportOptions = _this._config.transport[key];\n\n      _this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (_this._config.relay.enabled) {\n      _this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n    } // Attach stream multiplexers\n\n\n    if (_this._modules.streamMuxer) {\n      var muxers = _this._modules.streamMuxer;\n      muxers.forEach(function (muxer) {\n        _this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      _this.identifyService = new IdentifyService({\n        libp2p: _assertThisInitialized(_this),\n        protocols: _this.upgrader.protocols\n      });\n\n      _this.handle(Object.values(IDENTIFY_PROTOCOLS), _this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (_this._modules.connProtector) {\n      _this.upgrader.protector = _this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (_this._modules.dht) {\n      var DHT = _this._modules.dht;\n      _this._dht = new DHT(_objectSpread({\n        libp2p: _assertThisInitialized(_this),\n        dialer: _this.dialer,\n        peerId: _this.peerId,\n        peerStore: _this.peerStore,\n        registrar: _this.registrar,\n        datastore: _this.datastore\n      }, _this._config.dht));\n    } // start pubsub\n\n\n    if (_this._modules.pubsub) {\n      _this.pubsub = pubsub(_assertThisInitialized(_this), _this._modules.pubsub, _this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    _this.peerRouting = peerRouting(_assertThisInitialized(_this));\n    _this.contentRouting = contentRouting(_assertThisInitialized(_this)); // Mount default protocols\n\n    _ping.mount(_assertThisInitialized(_this));\n\n    _this._onDiscoveryPeer = _this._onDiscoveryPeer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  _createClass(Libp2p, [{\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        log.error.apply(log, args);\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(Libp2p.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Starts the libp2p node and all its subsystems\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('libp2p is starting');\n                _context.prev = 1;\n                _context.next = 4;\n                return this._onStarting();\n\n              case 4:\n                _context.next = 6;\n                return this._onDidStart();\n\n              case 6:\n                log('libp2p has started');\n                _context.next = 16;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](1);\n                this.emit('error', _context.t0);\n                log.error('An error occurred starting libp2p', _context.t0);\n                _context.next = 15;\n                return this.stop();\n\n              case 15:\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 9]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     * @async\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _iterator, _step, service;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                log('libp2p is stopping');\n                _context2.prev = 1;\n                _iterator = _createForOfIteratorHelper(this._discovery.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    service = _step.value;\n                    service.removeListener('peer', this._onDiscoveryPeer);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context2.next = 6;\n                return Promise.all(Array.from(this._discovery.values(), function (s) {\n                  return s.stop();\n                }));\n\n              case 6:\n                this._discovery = new Map();\n                _context2.next = 9;\n                return this.peerStore.stop();\n\n              case 9:\n                _context2.next = 11;\n                return this.connectionManager.stop();\n\n              case 11:\n                _context2.next = 13;\n                return Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n\n              case 13:\n                _context2.next = 15;\n                return this.transportManager.close();\n\n              case 15:\n                _ping.unmount(this);\n\n                this.dialer.destroy();\n                _context2.next = 22;\n                break;\n\n              case 19:\n                _context2.prev = 19;\n                _context2.t0 = _context2[\"catch\"](1);\n\n                if (_context2.t0) {\n                  log.error(_context2.t0);\n                  this.emit('error', _context2.t0);\n                }\n\n              case 22:\n                this._isStarted = false;\n                log('libp2p has stopped');\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 19]]);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Load keychain keys from the datastore.\n     * Imports the private key as 'self', if needed.\n     * @async\n     * @returns {void}\n     */\n\n  }, {\n    key: \"loadKeychain\",\n    value: function () {\n      var _loadKeychain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.keychain.findKeyByName('self');\n\n              case 3:\n                _context3.next = 9;\n                break;\n\n              case 5:\n                _context3.prev = 5;\n                _context3.t0 = _context3[\"catch\"](0);\n                _context3.next = 9;\n                return this.keychain.importPeer('self', this.peerId);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 5]]);\n      }));\n\n      function loadKeychain() {\n        return _loadKeychain.apply(this, arguments);\n      }\n\n      return loadKeychain;\n    }()\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this._isStarted;\n    }\n    /**\n     * Gets a Map of the current connections. The keys are the stringified\n     * `PeerId` of the peer. The value is an array of Connections to that peer.\n     * @returns {Map<string, Connection[]>}\n     */\n\n  }, {\n    key: \"dial\",\n\n    /**\n     * Dials to the provided peer. If successful, the known metadata of the\n     * peer will be added to the nodes `peerStore`\n     * @param {PeerId|Multiaddr|string} peer The peer to dial\n     * @param {object} options\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection>}\n     */\n    value: function dial(peer, options) {\n      return this.dialProtocol(peer, null, options);\n    }\n    /**\n     * Dials to the provided peer and handshakes with the given protocol.\n     * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n     * and the `Connection` will be returned\n     * @async\n     * @param {PeerId|Multiaddr|string} peer The peer to dial\n     * @param {string[]|string} protocols\n     * @param {object} options\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection|*>}\n     */\n\n  }, {\n    key: \"dialProtocol\",\n    value: function () {\n      var _dialProtocol = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peer, protocols, options) {\n        var _getPeer, id, multiaddrs, connection;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _getPeer = getPeer(peer, this.peerStore), id = _getPeer.id, multiaddrs = _getPeer.multiaddrs;\n                connection = this.connectionManager.get(id);\n\n                if (connection) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                _context4.next = 5;\n                return this.dialer.connectToPeer(peer, options);\n\n              case 5:\n                connection = _context4.sent;\n                _context4.next = 9;\n                break;\n\n              case 8:\n                if (multiaddrs) {\n                  this.peerStore.addressBook.add(id, multiaddrs);\n                }\n\n              case 9:\n                if (!protocols) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", connection.newStream(protocols));\n\n              case 11:\n                return _context4.abrupt(\"return\", connection);\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function dialProtocol(_x, _x2, _x3) {\n        return _dialProtocol.apply(this, arguments);\n      }\n\n      return dialProtocol;\n    }()\n    /**\n     * Get peer advertising multiaddrs by concating the addresses used\n     * by transports to listen with the announce addresses.\n     * Duplicated addresses and noAnnounce addresses are filtered out.\n     * @return {Array<Multiaddr>}\n     */\n\n  }, {\n    key: \"hangUp\",\n\n    /**\n     * Disconnects all connections to the given `peer`\n     * @param {PeerId|multiaddr|string} peer the peer to close connections to\n     * @returns {Promise<void>}\n     */\n    value: function () {\n      var _hangUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(peer) {\n        var _getPeer2, id, connections;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _getPeer2 = getPeer(peer), id = _getPeer2.id;\n                connections = this.connectionManager.connections.get(id.toB58String());\n\n                if (connections) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 4:\n                _context5.next = 6;\n                return Promise.all(connections.map(function (connection) {\n                  return connection.close();\n                }));\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function hangUp(_x4) {\n        return _hangUp.apply(this, arguments);\n      }\n\n      return hangUp;\n    }()\n    /**\n     * Pings the given peer in order to obtain the operation latency.\n     * @param {PeerId|Multiaddr|string} peer The peer to ping\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"ping\",\n    value: function ping(peer) {\n      var _getPeer3 = getPeer(peer),\n          id = _getPeer3.id;\n\n      return _ping(this, id);\n    }\n    /**\n     * Registers the `handler` for each protocol\n     * @param {string[]|string} protocols\n     * @param {function({ connection:*, stream:*, protocol:string })} handler\n     */\n\n  }, {\n    key: \"handle\",\n    value: function handle(protocols, handler) {\n      var _this2 = this;\n\n      protocols = Array.isArray(protocols) ? protocols : [protocols];\n      protocols.forEach(function (protocol) {\n        _this2.upgrader.protocols.set(protocol, handler);\n      }); // Only push if libp2p is running\n\n      if (this.isStarted() && this.identifyService) {\n        this.identifyService.pushToPeerStore(this.peerStore);\n      }\n    }\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     * @param {string[]|string} protocols\n     */\n\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocols) {\n      var _this3 = this;\n\n      protocols = Array.isArray(protocols) ? protocols : [protocols];\n      protocols.forEach(function (protocol) {\n        _this3.upgrader.protocols.delete(protocol);\n      }); // Only push if libp2p is running\n\n      if (this.isStarted() && this.identifyService) {\n        this.identifyService.pushToPeerStore(this.peerStore);\n      }\n    }\n  }, {\n    key: \"_onStarting\",\n    value: function () {\n      var _onStarting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.transportManager.listen();\n\n              case 2:\n                _context6.next = 4;\n                return this.peerStore.start();\n\n              case 4:\n                if (this._config.pubsub.enabled) {\n                  this.pubsub && this.pubsub.start();\n                } // DHT subsystem\n\n\n                if (this._config.dht.enabled) {\n                  this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n                  // the other discovery modules\n\n                  this._dht.on('peer', this._onDiscoveryPeer);\n                } // Start metrics if present\n\n\n                this.metrics && this.metrics.start();\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _onStarting() {\n        return _onStarting2.apply(this, arguments);\n      }\n\n      return _onStarting;\n    }()\n    /**\n     * Called when libp2p has started and before it returns\n     * @private\n     */\n\n  }, {\n    key: \"_onDidStart\",\n    value: function () {\n      var _onDidStart2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this4 = this;\n\n        var _iterator2, _step2, peer;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._isStarted = true;\n                this.connectionManager.start();\n                this.peerStore.on('peer', function (peerId) {\n                  _this4.emit('peer:discovery', peerId);\n\n                  _this4._maybeConnect(peerId);\n                }); // Once we start, emit and dial any peers we may have already discovered\n\n                _iterator2 = _createForOfIteratorHelper(this.peerStore.peers.values());\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    peer = _step2.value;\n                    this.emit('peer:discovery', peer.id);\n\n                    this._maybeConnect(peer.id);\n                  } // Peer discovery\n\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                _context7.next = 7;\n                return this._setupPeerDiscovery();\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _onDidStart() {\n        return _onDidStart2.apply(this, arguments);\n      }\n\n      return _onDidStart;\n    }()\n    /**\n     * Called whenever peer discovery services emit `peer` events.\n     * Known peers may be emitted.\n     * @private\n     * @param {{ id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string> }} peer\n     */\n\n  }, {\n    key: \"_onDiscoveryPeer\",\n    value: function _onDiscoveryPeer(peer) {\n      if (peer.id.toB58String() === this.peerId.toB58String()) {\n        log.error(new Error(codes.ERR_DISCOVERED_SELF));\n        return;\n      }\n\n      peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n      peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n    }\n    /**\n     * Will dial to the given `peerId` if the current number of\n     * connected peers is less than the configured `ConnectionManager`\n     * minPeers.\n     * @private\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"_maybeConnect\",\n    value: function () {\n      var _maybeConnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(peerId) {\n        var minPeers;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId))) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                minPeers = this._options.connectionManager.minPeers || 0;\n\n                if (!(minPeers > this.connectionManager.size)) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                log('connecting to discovered peer %s', peerId.toB58String());\n                _context8.prev = 4;\n                _context8.next = 7;\n                return this.dialer.connectToPeer(peerId);\n\n              case 7:\n                _context8.next = 12;\n                break;\n\n              case 9:\n                _context8.prev = 9;\n                _context8.t0 = _context8[\"catch\"](4);\n                log.error('could not connect to discovered peer', _context8.t0);\n\n              case 12:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[4, 9]]);\n      }));\n\n      function _maybeConnect(_x5) {\n        return _maybeConnect2.apply(this, arguments);\n      }\n\n      return _maybeConnect;\n    }()\n    /**\n     * Initializes and starts peer discovery services\n     *\n     * @async\n     * @private\n     */\n\n  }, {\n    key: \"_setupPeerDiscovery\",\n    value: function () {\n      var _setupPeerDiscovery2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this5 = this;\n\n        var setupService, _iterator3, _step3, DiscoveryService, _iterator4, _step4, Transport;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                setupService = function setupService(DiscoveryService) {\n                  var config = {\n                    enabled: true // on by default\n\n                  };\n\n                  if (DiscoveryService.tag && _this5._config.peerDiscovery && _this5._config.peerDiscovery[DiscoveryService.tag]) {\n                    config = _objectSpread(_objectSpread({}, config), _this5._config.peerDiscovery[DiscoveryService.tag]);\n                  }\n\n                  if (config.enabled && !_this5._discovery.has(DiscoveryService.tag)) {\n                    // not already added\n                    var discoveryService;\n\n                    if (typeof DiscoveryService === 'function') {\n                      discoveryService = new DiscoveryService(Object.assign({}, config, {\n                        peerId: _this5.peerId,\n                        libp2p: _this5\n                      }));\n                    } else {\n                      discoveryService = DiscoveryService;\n                    }\n\n                    discoveryService.on('peer', _this5._onDiscoveryPeer);\n\n                    _this5._discovery.set(DiscoveryService.tag, discoveryService);\n                  }\n                }; // Discovery modules\n\n\n                _iterator3 = _createForOfIteratorHelper(this._modules.peerDiscovery || []);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    DiscoveryService = _step3.value;\n                    setupService(DiscoveryService);\n                  } // Transport modules with discovery\n\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _iterator4 = _createForOfIteratorHelper(this.transportManager.getTransports());\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    Transport = _step4.value;\n\n                    if (Transport.discovery) {\n                      setupService(Transport.discovery);\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n\n                _context9.next = 7;\n                return Promise.all(Array.from(this._discovery.values(), function (d) {\n                  return d.start();\n                }));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _setupPeerDiscovery() {\n        return _setupPeerDiscovery2.apply(this, arguments);\n      }\n\n      return _setupPeerDiscovery;\n    }()\n  }, {\n    key: \"connections\",\n    get: function get() {\n      return this.connectionManager.connections;\n    }\n  }, {\n    key: \"multiaddrs\",\n    get: function get() {\n      // Filter noAnnounce multiaddrs\n      var filterMa = this.addressManager.getNoAnnounceAddrs(); // Create advertising list\n\n      return this.transportManager.getAddrs().concat(this.addressManager.getAnnounceAddrs()).filter(function (ma, index, array) {\n        // Filter out if repeated\n        if (array.findIndex(function (otherMa) {\n          return otherMa.equals(ma);\n        }) !== index) {\n          return false;\n        } // Filter out if in noAnnounceMultiaddrs\n\n\n        if (filterMa.find(function (fm) {\n          return fm.equals(ma);\n        })) {\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }]);\n\n  return Libp2p;\n}(EventEmitter);\n/**\n * Like `new Libp2p(options)` except it will create a `PeerId`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\n\n\nLibp2p.create = /*#__PURE__*/function () {\n  var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n    var options,\n        peerId,\n        _args10 = arguments;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            options = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {};\n\n            if (!options.peerId) {\n              _context10.next = 3;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", new Libp2p(options));\n\n          case 3:\n            _context10.next = 5;\n            return PeerId.create();\n\n          case 5:\n            peerId = _context10.sent;\n            options.peerId = peerId;\n            return _context10.abrupt(\"return\", new Libp2p(options));\n\n          case 8:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n\n  function create() {\n    return _create.apply(this, arguments);\n  }\n\n  return create;\n}();\n\nmodule.exports = Libp2p;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/index.js"],"names":["require","EventEmitter","debug","globalThis","log","error","PeerId","peerRouting","contentRouting","pubsub","getPeer","validateConfig","validate","codes","AddressManager","ConnectionManager","Circuit","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PersistentPeerStore","Registrar","ping","IdentifyService","IDENTIFY_PROTOCOLS","multicodecs","Libp2p","_options","peerId","datastore","peerStore","persistence","addresses","addressManager","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","metrics","enabled","keychain","pass","keychainOpts","generateOptions","passPhrase","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","registrar","handle","bind","connEncryption","cryptos","forEach","crypto","set","protocol","dialer","concurrency","maxParallelDials","perPeerLimit","maxDialsPerPeer","timeout","dialTimeout","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","protocols","Object","values","handleMessage","connProtector","protector","process","undefined","env","LIBP2P_FORCE_PNET","Error","dht","DHT","_dht","mount","_onDiscoveryPeer","eventName","args","_events","_onStarting","_onDidStart","emit","stop","service","removeListener","Promise","all","Array","from","s","close","unmount","destroy","_isStarted","findKeyByName","importPeer","peer","options","dialProtocol","id","multiaddrs","get","connectToPeer","addressBook","newStream","connections","toB58String","map","handler","isArray","isStarted","pushToPeerStore","delete","listen","start","on","_maybeConnect","peers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","protoBook","peerDiscovery","autoDial","minPeers","size","setupService","DiscoveryService","tag","has","discoveryService","assign","getTransports","discovery","d","filterMa","getNoAnnounceAddrs","getAddrs","concat","getAnnounceAddrs","filter","ma","index","array","findIndex","otherMa","equals","find","fm","create","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst debug = require('debug')\nconst globalThis = require('ipfs-utils/src/globalthis')\nconst log = debug('libp2p')\nlog.error = debug('libp2p:error')\n\nconst PeerId = require('peer-id')\n\nconst peerRouting = require('./peer-routing')\nconst contentRouting = require('./content-routing')\nconst pubsub = require('./pubsub')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst Circuit = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PersistentPeerStore = require('./peer-store/persistent')\nconst Registrar = require('./registrar')\nconst ping = require('./ping')\nconst {\n  IdentifyService,\n  multicodecs: IDENTIFY_PROTOCOLS\n} = require('./identify')\n\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    this.peerStore = (this.datastore && this._options.peerStore.persistence)\n      ? new PersistentPeerStore({\n        datastore: this.datastore,\n        ...this._options.peerStore\n      })\n      : new PeerStore()\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this._options.addresses)\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager)\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({\n        ...this._options.metrics,\n        connectionManager: this.connectionManager\n      })\n    }\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.pass && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        passPhrase: this._options.keychain.pass,\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (this._modules.connEncryption) {\n      const cryptos = this._modules.connEncryption\n      cryptos.forEach((crypto) => {\n        this.upgrader.cryptos.set(crypto.protocol, crypto)\n      })\n    }\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      concurrency: this._options.dialer.maxParallelDials,\n      perPeerLimit: this._options.dialer.maxDialsPerPeer,\n      timeout: this._options.dialer.dialTimeout\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({\n        libp2p: this,\n        protocols: this.upgrader.protocols\n      })\n      this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage)\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // start pubsub\n    if (this._modules.pubsub) {\n      this.pubsub = pubsub(this, this._modules.pubsub, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = peerRouting(this)\n    this.contentRouting = contentRouting(this)\n\n    // Mount default protocols\n    ping.mount(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   * @async\n   * @returns {void}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.peerStore.stop()\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this._dht && this._dht.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.transportManager.close()\n\n      ping.unmount(this)\n      this.dialer.destroy()\n    } catch (err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    this._isStarted = false\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   * @async\n   * @returns {void}\n   */\n  async loadKeychain () {\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this.dialProtocol(peer, null, options)\n  }\n\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `Connection` will be returned\n   * @async\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection|*>}\n   */\n  async dialProtocol (peer, protocols, options) {\n    const { id, multiaddrs } = getPeer(peer, this.peerStore)\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    // If a protocol was provided, create a new stream\n    if (protocols) {\n      return connection.newStream(protocols)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get peer advertising multiaddrs by concating the addresses used\n   * by transports to listen with the announce addresses.\n   * Duplicated addresses and noAnnounce addresses are filtered out.\n   * @return {Array<Multiaddr>}\n   */\n  get multiaddrs () {\n    // Filter noAnnounce multiaddrs\n    const filterMa = this.addressManager.getNoAnnounceAddrs()\n\n    // Create advertising list\n    return this.transportManager.getAddrs()\n      .concat(this.addressManager.getAnnounceAddrs())\n      .filter((ma, index, array) => {\n        // Filter out if repeated\n        if (array.findIndex((otherMa) => otherMa.equals(ma)) !== index) {\n          return false\n        }\n\n        // Filter out if in noAnnounceMultiaddrs\n        if (filterMa.find((fm) => fm.equals(ma))) {\n          return false\n        }\n\n        return true\n      })\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   * @param {PeerId|multiaddr|string} peer the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   * @param {PeerId|Multiaddr|string} peer The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id } = getPeer(peer)\n\n    return ping(this, id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   * @param {string[]|string} protocols\n   * @param {function({ connection:*, stream:*, protocol:string })} handler\n   */\n  handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Only push if libp2p is running\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore)\n    }\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   * @param {string[]|string} protocols\n   */\n  unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Only push if libp2p is running\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore)\n    }\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports\n    await this.transportManager.listen()\n\n    // Start PeerStore\n    await this.peerStore.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.connectionManager.start()\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId)\n    })\n\n    // Once we start, emit and dial any peers we may have already discovered\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id)\n      this._maybeConnect(peer.id)\n    }\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string> }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs)\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols)\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minPeers = this._options.connectionManager.minPeers || 0\n      if (minPeers > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (err) {\n          log.error('could not connect to discovered peer', err)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      if (Transport.discovery) {\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\n/**\n * Like `new Libp2p(options)` except it will create a `PeerId`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\nLibp2p.create = async function create (options = {}) {\n  if (options.peerId) {\n    return new Libp2p(options)\n  }\n\n  const peerId = await PeerId.create()\n\n  options.peerId = peerId\n  return new Libp2p(options)\n}\n\nmodule.exports = Libp2p\n"]},"metadata":{},"sourceType":"script"}