{"ast":null,"code":"'use strict';\n\nconst core = require('datastore-core');\n\nconst ShardingStore = core.ShardingDatastore;\n\nconst Block = require('ipld-block');\n\nconst {\n  cidToKey,\n  keyToCid\n} = require('./blockstore-utils');\n\nconst map = require('it-map');\n\nconst pipe = require('it-pipe');\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options);\n  return createBaseStore(store);\n};\n\nfunction maybeWithSharding(filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2);\n    return ShardingStore.createOrOpen(filestore, shard);\n  }\n\n  return filestore;\n}\n\nfunction createBaseStore(store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {Object} query\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async *query(query, options) {\n      // eslint-disable-line require-await\n      yield* store.query(query, options);\n    },\n\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async get(cid, options) {\n      const key = cidToKey(cid);\n      let blockData;\n\n      try {\n        blockData = await store.get(key, options);\n        return new Block(blockData, cid);\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          const otherCid = cidToOtherVersion(cid);\n\n          if (!otherCid) {\n            throw err;\n          }\n\n          const otherKey = cidToKey(otherCid);\n          const blockData = await store.get(otherKey, options);\n          await store.put(key, blockData);\n          return new Block(blockData, cid);\n        }\n\n        throw err;\n      }\n    },\n\n    /**\n     * Like get, but for more.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    /**\n     * Write a single block to the store.\n     *\n     * @param {Block} block\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async put(block, options) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block');\n      }\n\n      const exists = await this.has(block.cid);\n\n      if (exists) {\n        return this.get(block.cid, options);\n      }\n\n      await store.put(cidToKey(block.cid), block.data, options);\n      return block;\n    },\n\n    /**\n     * Like put, but for more.\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @param {Object} options\n     * @returns {AsyncIterable<Block>}\n     */\n    async *putMany(blocks, options) {\n      // eslint-disable-line require-await\n      yield* pipe(blocks, source => {\n        // turn them into a key/value pair\n        return map(source, block => {\n          return {\n            key: cidToKey(block.cid),\n            value: block.data\n          };\n        });\n      }, source => {\n        // put them into the datastore\n        return store.putMany(source, options);\n      }, source => {\n        // map the returned key/value back into a block\n        return map(source, ({\n          key,\n          value\n        }) => {\n          return new Block(value, keyToCid(key));\n        });\n      });\n    },\n\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<bool>}\n     */\n    async has(cid, options) {\n      const exists = await store.has(cidToKey(cid), options);\n      if (exists) return exists;\n      const otherCid = cidToOtherVersion(cid);\n      if (!otherCid) return false;\n      return store.has(cidToKey(otherCid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async delete(cid, options) {\n      // eslint-disable-line require-await\n      return store.delete(cidToKey(cid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {AsyncIterable<CID>} cids\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async *deleteMany(cids, options) {\n      // eslint-disable-line require-await\n      yield* store.deleteMany(async function* () {\n        for await (const cid of cids) {\n          yield cidToKey(cid);\n        }\n      }(), options);\n    },\n\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close() {\n      // eslint-disable-line require-await\n      return store.close();\n    }\n\n  };\n}\n\nfunction cidToOtherVersion(cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0();\n  } catch (err) {\n    return null;\n  }\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo/src/blockstore.js"],"names":["core","require","ShardingStore","ShardingDatastore","Block","cidToKey","keyToCid","map","pipe","module","exports","filestore","options","store","maybeWithSharding","createBaseStore","sharding","shard","NextToLast","createOrOpen","query","get","cid","key","blockData","err","code","otherCid","cidToOtherVersion","otherKey","put","getMany","cids","block","isBlock","Error","exists","has","data","putMany","blocks","source","value","delete","deleteMany","close","version","toV1","toV0"],"mappings":"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","sourcesContent":["'use strict'\n\nconst core = require('datastore-core')\nconst ShardingStore = core.ShardingDatastore\nconst Block = require('ipld-block')\nconst { cidToKey, keyToCid } = require('./blockstore-utils')\nconst map = require('it-map')\nconst pipe = require('it-pipe')\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options)\n  return createBaseStore(store)\n}\n\nfunction maybeWithSharding (filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2)\n    return ShardingStore.createOrOpen(filestore, shard)\n  }\n  return filestore\n}\n\nfunction createBaseStore (store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {Object} query\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async * query (query, options) { // eslint-disable-line require-await\n      yield * store.query(query, options)\n    },\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async get (cid, options) {\n      const key = cidToKey(cid)\n      let blockData\n      try {\n        blockData = await store.get(key, options)\n        return new Block(blockData, cid)\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          const otherCid = cidToOtherVersion(cid)\n\n          if (!otherCid) {\n            throw err\n          }\n\n          const otherKey = cidToKey(otherCid)\n          const blockData = await store.get(otherKey, options)\n          await store.put(key, blockData)\n          return new Block(blockData, cid)\n        }\n\n        throw err\n      }\n    },\n    /**\n     * Like get, but for more.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async * getMany (cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    },\n    /**\n     * Write a single block to the store.\n     *\n     * @param {Block} block\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async put (block, options) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block')\n      }\n\n      const exists = await this.has(block.cid)\n\n      if (exists) {\n        return this.get(block.cid, options)\n      }\n\n      await store.put(cidToKey(block.cid), block.data, options)\n\n      return block\n    },\n\n    /**\n     * Like put, but for more.\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @param {Object} options\n     * @returns {AsyncIterable<Block>}\n     */\n    async * putMany (blocks, options) { // eslint-disable-line require-await\n      yield * pipe(\n        blocks,\n        (source) => {\n          // turn them into a key/value pair\n          return map(source, (block) => {\n            return { key: cidToKey(block.cid), value: block.data }\n          })\n        },\n        (source) => {\n          // put them into the datastore\n          return store.putMany(source, options)\n        },\n        (source) => {\n          // map the returned key/value back into a block\n          return map(source, ({ key, value }) => {\n            return new Block(value, keyToCid(key))\n          })\n        }\n      )\n    },\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<bool>}\n     */\n    async has (cid, options) {\n      const exists = await store.has(cidToKey(cid), options)\n      if (exists) return exists\n      const otherCid = cidToOtherVersion(cid)\n      if (!otherCid) return false\n      return store.has(cidToKey(otherCid), options)\n    },\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async delete (cid, options) { // eslint-disable-line require-await\n      return store.delete(cidToKey(cid), options)\n    },\n    /**\n     * Delete a block from the store\n     *\n     * @param {AsyncIterable<CID>} cids\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async * deleteMany (cids, options) { // eslint-disable-line require-await\n      yield * store.deleteMany((async function * () {\n        for await (const cid of cids) {\n          yield cidToKey(cid)\n        }\n      }()), options)\n    },\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close () { // eslint-disable-line require-await\n      return store.close()\n    }\n  }\n}\n\nfunction cidToOtherVersion (cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0()\n  } catch (err) {\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"script"}