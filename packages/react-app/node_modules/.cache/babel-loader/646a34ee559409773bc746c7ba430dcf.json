{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar log = require('debug')('ipfs:mfs:write');\n\nvar importer = require('ipfs-unixfs-importer');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar stat = require('./stat');\n\nvar mkdir = require('./mkdir');\n\nvar addLink = require('./utils/add-link');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar createLock = require('./utils/create-lock');\n\nvar toAsyncIterator = require('./utils/to-async-iterator');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar toTrail = require('./utils/to-trail');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar errCode = require('err-code');\n\nvar _require2 = require('../../utils'),\n    MFS_MAX_CHUNK_SIZE = _require2.MFS_MAX_CHUNK_SIZE;\n\nvar last = require('it-last');\n\nvar _require3 = require('../../utils'),\n    withTimeoutOption = _require3.withTimeoutOption;\n\nvar defaultOptions = {\n  offset: 0,\n  // the offset in the file to begin writing\n  length: undefined,\n  // how many bytes from the incoming buffer to write\n  create: false,\n  // whether to create the file if it does not exist\n  truncate: false,\n  // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false,\n  // whether to create intermediate directories if they do not exist\n  progress: function progress() {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000,\n  mode: undefined,\n  mtime: undefined,\n  signal: undefined\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, content, options) {\n      var source, destination, parent;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n              log('Reading source, destination and parent');\n              _context2.next = 4;\n              return createLock().readLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return toAsyncIterator(content, options);\n\n                      case 2:\n                        source = _context.sent;\n                        _context.next = 5;\n                        return toMfsPath(context, path, options);\n\n                      case 5:\n                        destination = _context.sent;\n                        _context.next = 8;\n                        return toMfsPath(context, destination.mfsDirectory, options);\n\n                      case 8:\n                        parent = _context.sent;\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })))();\n\n            case 4:\n              log('Read source, destination and parent');\n\n              if (!(!options.parents && !parent.exists)) {\n                _context2.next = 7;\n                break;\n              }\n\n              throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n\n            case 7:\n              if (!(!options.create && !destination.exists)) {\n                _context2.next = 9;\n                break;\n              }\n\n              throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST');\n\n            case 9:\n              return _context2.abrupt(\"return\", updateOrImport(context, path, source, destination, options));\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function mfsWrite(_x4, _x5, _x6) {\n      return _mfsWrite.apply(this, arguments);\n    }\n\n    return mfsWrite;\n  }());\n};\n\nvar updateOrImport = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, path, source, destination, options) {\n    var child;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return write(context, source, destination, options);\n\n          case 2:\n            child = _context4.sent;\n            _context4.next = 5;\n            return createLock().writeLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n              var pathComponents, fileName, parentExists, updatedPath, trail, parent, parentNode, result, newRootCid;\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      pathComponents = toPathComponents(path);\n                      fileName = pathComponents.pop();\n                      parentExists = false;\n                      _context3.prev = 3;\n                      _context3.next = 6;\n                      return stat(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 6:\n                      parentExists = true;\n                      _context3.next = 13;\n                      break;\n\n                    case 9:\n                      _context3.prev = 9;\n                      _context3.t0 = _context3[\"catch\"](3);\n\n                      if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                        _context3.next = 13;\n                        break;\n                      }\n\n                      throw _context3.t0;\n\n                    case 13:\n                      if (parentExists) {\n                        _context3.next = 16;\n                        break;\n                      }\n\n                      _context3.next = 16;\n                      return mkdir(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 16:\n                      _context3.next = 18;\n                      return toMfsPath(context, path, options);\n\n                    case 18:\n                      updatedPath = _context3.sent;\n                      _context3.next = 21;\n                      return toTrail(context, updatedPath.mfsDirectory, options);\n\n                    case 21:\n                      trail = _context3.sent;\n                      parent = trail[trail.length - 1];\n\n                      if (parent.type.includes('directory')) {\n                        _context3.next = 25;\n                        break;\n                      }\n\n                      throw errCode(new Error(\"cannot write to \".concat(parent.name, \": Not a directory\")), 'ERR_NOT_A_DIRECTORY');\n\n                    case 25:\n                      _context3.next = 27;\n                      return context.ipld.get(parent.cid);\n\n                    case 27:\n                      parentNode = _context3.sent;\n                      _context3.next = 30;\n                      return addLink(context, {\n                        parent: parentNode,\n                        name: fileName,\n                        cid: child.cid,\n                        size: child.size,\n                        flush: options.flush,\n                        shardSplitThreshold: options.shardSplitThreshold,\n                        hashAlg: options.hashAlg,\n                        cidVersion: options.cidVersion\n                      });\n\n                    case 30:\n                      result = _context3.sent;\n                      parent.cid = result.cid; // update the tree with the new child\n\n                      _context3.next = 34;\n                      return updateTree(context, trail, options);\n\n                    case 34:\n                      newRootCid = _context3.sent;\n                      _context3.next = 37;\n                      return updateMfsRoot(context, newRootCid, options);\n\n                    case 37:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[3, 9]]);\n            })))();\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateOrImport(_x7, _x8, _x9, _x10, _x11) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar write = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(context, source, destination, options) {\n    var sources, extra, content, mode, mtime, result;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (destination.exists) {\n              log(\"Overwriting file \".concat(destination.cid, \" offset \").concat(options.offset, \" length \").concat(options.length));\n            } else {\n              log(\"Writing file offset \".concat(options.offset, \" length \").concat(options.length));\n            }\n\n            sources = []; // pad start of file if necessary\n\n            if (options.offset > 0) {\n              if (destination.unixfs) {\n                log(\"Writing first \".concat(options.offset, \" bytes of original file\"));\n                sources.push(function () {\n                  return destination.content({\n                    offset: 0,\n                    length: options.offset\n                  });\n                });\n\n                if (destination.unixfs.fileSize() < options.offset) {\n                  extra = options.offset - destination.unixfs.fileSize();\n                  log(\"Writing zeros for extra \".concat(extra, \" bytes\"));\n                  sources.push(asyncZeroes(extra));\n                }\n              } else {\n                log(\"Writing zeros for first \".concat(options.offset, \" bytes\"));\n                sources.push(asyncZeroes(options.offset));\n              }\n            }\n\n            sources.push(limitAsyncStreamBytes(source, options.length));\n            content = countBytesStreamed(catAsyncIterators(sources), function (bytesWritten) {\n              if (destination.unixfs && !options.truncate) {\n                // if we've done reading from the new source and we are not going\n                // to truncate the file, add the end of the existing file to the output\n                var fileSize = destination.unixfs.fileSize();\n\n                if (fileSize > bytesWritten) {\n                  log(\"Writing last \".concat(fileSize - bytesWritten, \" of \").concat(fileSize, \" bytes from original file starting at offset \").concat(bytesWritten));\n                  return destination.content({\n                    offset: bytesWritten\n                  });\n                } else {\n                  log('Not writing last bytes from original file');\n                }\n              }\n\n              return _defineProperty({}, Symbol.asyncIterator, _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              })));\n            });\n\n            if (options.mode !== undefined && options.mode !== null) {\n              mode = options.mode;\n            } else if (destination && destination.unixfs) {\n              mode = destination.unixfs.mode;\n            }\n\n            if (options.mtime !== undefined && options.mtine !== null) {\n              mtime = options.mtime;\n            } else if (destination && destination.unixfs) {\n              mtime = destination.unixfs.mtime;\n            }\n\n            _context6.next = 9;\n            return last(importer([{\n              content: content,\n              // persist mode & mtime if set previously\n              mode: mode,\n              mtime: mtime\n            }], context.block, {\n              progress: options.progress,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              strategy: options.strategy,\n              rawLeaves: options.rawLeaves,\n              reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n              leafType: options.leafType,\n              pin: false\n            }));\n\n          case 9:\n            result = _context6.sent;\n            log(\"Wrote \".concat(result.cid));\n            return _context6.abrupt(\"return\", {\n              cid: result.cid,\n              size: result.size\n            });\n\n          case 12:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function write(_x12, _x13, _x14, _x15) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar limitAsyncStreamBytes = function limitAsyncStreamBytes(stream, limit) {\n  return /*#__PURE__*/function () {\n    var _limitAsyncStreamBytes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var emitted, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, buf;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              emitted = 0;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context7.prev = 3;\n              _iterator = _asyncIterator(stream);\n\n            case 5:\n              _context7.next = 7;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 7:\n              _step = _context7.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context7.next = 11;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 11:\n              _value = _context7.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context7.next = 24;\n                break;\n              }\n\n              buf = _value;\n              emitted += buf.length;\n\n              if (!(emitted > limit)) {\n                _context7.next = 19;\n                break;\n              }\n\n              _context7.next = 18;\n              return buf.slice(0, limit - emitted);\n\n            case 18:\n              return _context7.abrupt(\"return\");\n\n            case 19:\n              _context7.next = 21;\n              return buf;\n\n            case 21:\n              _iteratorNormalCompletion = true;\n              _context7.next = 5;\n              break;\n\n            case 24:\n              _context7.next = 30;\n              break;\n\n            case 26:\n              _context7.prev = 26;\n              _context7.t0 = _context7[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context7.t0;\n\n            case 30:\n              _context7.prev = 30;\n              _context7.prev = 31;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context7.next = 35;\n                break;\n              }\n\n              _context7.next = 35;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 35:\n              _context7.prev = 35;\n\n              if (!_didIteratorError) {\n                _context7.next = 38;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 38:\n              return _context7.finish(35);\n\n            case 39:\n              return _context7.finish(30);\n\n            case 40:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[3, 26, 30, 40], [31,, 35, 39]]);\n    }));\n\n    function _limitAsyncStreamBytes() {\n      return _limitAsyncStreamBytes2.apply(this, arguments);\n    }\n\n    return _limitAsyncStreamBytes;\n  }();\n};\n\nvar asyncZeroes = function asyncZeroes(count) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MFS_MAX_CHUNK_SIZE;\n  var buf = Buffer.alloc(chunkSize, 0);\n\n  var stream = _defineProperty({}, Symbol.asyncIterator, /*#__PURE__*/_regeneratorRuntime.mark(function _asyncZeroes() {\n    return _regeneratorRuntime.wrap(function _asyncZeroes$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!true) {\n              _context8.next = 5;\n              break;\n            }\n\n            _context8.next = 3;\n            return buf.slice();\n\n          case 3:\n            _context8.next = 0;\n            break;\n\n          case 5:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _asyncZeroes);\n  }));\n\n  return limitAsyncStreamBytes(stream, count);\n};\n\nvar catAsyncIterators = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(sources) {\n    var i;\n    return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context9.next = 6;\n              break;\n            }\n\n            return _context9.delegateYield(_asyncGeneratorDelegate(_asyncIterator(sources[i]()), _awaitAsyncGenerator), \"t0\", 3);\n\n          case 3:\n            i++;\n            _context9.next = 1;\n            break;\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function catAsyncIterators(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar countBytesStreamed = /*#__PURE__*/function () {\n  var _ref3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(source, notify) {\n    var wrote, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, buf, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, _buf;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            wrote = 0;\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context10.prev = 3;\n            _iterator2 = _asyncIterator(source);\n\n          case 5:\n            _context10.next = 7;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 7:\n            _step2 = _context10.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context10.next = 11;\n            return _awaitAsyncGenerator(_step2.value);\n\n          case 11:\n            _value2 = _context10.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context10.next = 20;\n              break;\n            }\n\n            buf = _value2;\n            wrote += buf.length;\n            _context10.next = 17;\n            return buf;\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context10.next = 5;\n            break;\n\n          case 20:\n            _context10.next = 26;\n            break;\n\n          case 22:\n            _context10.prev = 22;\n            _context10.t0 = _context10[\"catch\"](3);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context10.t0;\n\n          case 26:\n            _context10.prev = 26;\n            _context10.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context10.next = 31;\n              break;\n            }\n\n            _context10.next = 31;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 31:\n            _context10.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context10.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context10.finish(31);\n\n          case 35:\n            return _context10.finish(26);\n\n          case 36:\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context10.prev = 38;\n            _iterator3 = _asyncIterator(notify(wrote));\n\n          case 40:\n            _context10.next = 42;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 42:\n            _step3 = _context10.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context10.next = 46;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 46:\n            _value3 = _context10.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context10.next = 55;\n              break;\n            }\n\n            _buf = _value3;\n            wrote += _buf.length;\n            _context10.next = 52;\n            return _buf;\n\n          case 52:\n            _iteratorNormalCompletion3 = true;\n            _context10.next = 40;\n            break;\n\n          case 55:\n            _context10.next = 61;\n            break;\n\n          case 57:\n            _context10.prev = 57;\n            _context10.t1 = _context10[\"catch\"](38);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context10.t1;\n\n          case 61:\n            _context10.prev = 61;\n            _context10.prev = 62;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context10.next = 66;\n              break;\n            }\n\n            _context10.next = 66;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 66:\n            _context10.prev = 66;\n\n            if (!_didIteratorError3) {\n              _context10.next = 69;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 69:\n            return _context10.finish(66);\n\n          case 70:\n            return _context10.finish(61);\n\n          case 71:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee9, null, [[3, 22, 26, 36], [27,, 31, 35], [38, 57, 61, 71], [62,, 66, 70]]);\n  }));\n\n  return function countBytesStreamed(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/write.js"],"names":["log","require","importer","Buffer","stat","mkdir","addLink","applyDefaultOptions","createLock","toAsyncIterator","toMfsPath","toPathComponents","toTrail","updateTree","updateMfsRoot","errCode","MFS_MAX_CHUNK_SIZE","last","withTimeoutOption","defaultOptions","offset","length","undefined","create","truncate","rawLeaves","reduceSingleLeafToSelf","cidVersion","hashAlg","parents","progress","strategy","flush","leafType","shardSplitThreshold","mode","mtime","signal","module","exports","context","path","content","options","readLock","source","destination","mfsDirectory","parent","exists","Error","updateOrImport","mfsWrite","write","child","writeLock","pathComponents","fileName","pop","parentExists","join","code","updatedPath","trail","type","includes","name","ipld","get","cid","parentNode","size","result","newRootCid","sources","unixfs","push","fileSize","extra","asyncZeroes","limitAsyncStreamBytes","countBytesStreamed","catAsyncIterators","bytesWritten","Symbol","asyncIterator","mtine","block","pin","stream","limit","emitted","buf","slice","_limitAsyncStreamBytes","count","chunkSize","alloc","_asyncZeroes","i","notify","wrote"],"mappings":"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","sourcesContent":["'use strict'\n\nconst log = require('debug')('ipfs:mfs:write')\nconst importer = require('ipfs-unixfs-importer')\nconst { Buffer } = require('buffer')\nconst stat = require('./stat')\nconst mkdir = require('./mkdir')\nconst addLink = require('./utils/add-link')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst createLock = require('./utils/create-lock')\nconst toAsyncIterator = require('./utils/to-async-iterator')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toPathComponents = require('./utils/to-path-components')\nconst toTrail = require('./utils/to-trail')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst errCode = require('err-code')\nconst {\n  MFS_MAX_CHUNK_SIZE\n} = require('../../utils')\nconst last = require('it-last')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  offset: 0, // the offset in the file to begin writing\n  length: undefined, // how many bytes from the incoming buffer to write\n  create: false, // whether to create the file if it does not exist\n  truncate: false, // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false, // whether to create intermediate directories if they do not exist\n  progress: () => {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000,\n  mode: undefined,\n  mtime: undefined,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsWrite (path, content, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    let source, destination, parent\n    log('Reading source, destination and parent')\n    await createLock().readLock(async () => {\n      source = await toAsyncIterator(content, options)\n      destination = await toMfsPath(context, path, options)\n      parent = await toMfsPath(context, destination.mfsDirectory, options)\n    })()\n    log('Read source, destination and parent')\n    if (!options.parents && !parent.exists) {\n      throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST')\n    }\n\n    if (!options.create && !destination.exists) {\n      throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST')\n    }\n\n    return updateOrImport(context, path, source, destination, options)\n  })\n}\n\nconst updateOrImport = async (context, path, source, destination, options) => {\n  const child = await write(context, source, destination, options)\n\n  // The slow bit is done, now add or replace the DAGLink in the containing directory\n  // re-reading the path to the containing folder in case it has changed in the interim\n  await createLock().writeLock(async () => {\n    const pathComponents = toPathComponents(path)\n    const fileName = pathComponents.pop()\n    let parentExists = false\n\n    try {\n      await stat(context)(`/${pathComponents.join('/')}`, options)\n      parentExists = true\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    if (!parentExists) {\n      await mkdir(context)(`/${pathComponents.join('/')}`, options)\n    }\n\n    // get an updated mfs path in case the root changed while we were writing\n    const updatedPath = await toMfsPath(context, path, options)\n    const trail = await toTrail(context, updatedPath.mfsDirectory, options)\n    const parent = trail[trail.length - 1]\n\n    if (!parent.type.includes('directory')) {\n      throw errCode(new Error(`cannot write to ${parent.name}: Not a directory`), 'ERR_NOT_A_DIRECTORY')\n    }\n\n    const parentNode = await context.ipld.get(parent.cid)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: fileName,\n      cid: child.cid,\n      size: child.size,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      hashAlg: options.hashAlg,\n      cidVersion: options.cidVersion\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })()\n}\n\nconst write = async (context, source, destination, options) => {\n  if (destination.exists) {\n    log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`)\n  } else {\n    log(`Writing file offset ${options.offset} length ${options.length}`)\n  }\n\n  const sources = []\n\n  // pad start of file if necessary\n  if (options.offset > 0) {\n    if (destination.unixfs) {\n      log(`Writing first ${options.offset} bytes of original file`)\n\n      sources.push(\n        () => {\n          return destination.content({\n            offset: 0,\n            length: options.offset\n          })\n        }\n      )\n\n      if (destination.unixfs.fileSize() < options.offset) {\n        const extra = options.offset - destination.unixfs.fileSize()\n\n        log(`Writing zeros for extra ${extra} bytes`)\n        sources.push(\n          asyncZeroes(extra)\n        )\n      }\n    } else {\n      log(`Writing zeros for first ${options.offset} bytes`)\n      sources.push(\n        asyncZeroes(options.offset)\n      )\n    }\n  }\n\n  sources.push(\n    limitAsyncStreamBytes(source, options.length)\n  )\n\n  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {\n    if (destination.unixfs && !options.truncate) {\n      // if we've done reading from the new source and we are not going\n      // to truncate the file, add the end of the existing file to the output\n      const fileSize = destination.unixfs.fileSize()\n\n      if (fileSize > bytesWritten) {\n        log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`)\n\n        return destination.content({\n          offset: bytesWritten\n        })\n      } else {\n        log('Not writing last bytes from original file')\n      }\n    }\n\n    return {\n      [Symbol.asyncIterator]: async function * () {}\n    }\n  })\n\n  let mode\n\n  if (options.mode !== undefined && options.mode !== null) {\n    mode = options.mode\n  } else if (destination && destination.unixfs) {\n    mode = destination.unixfs.mode\n  }\n\n  let mtime\n\n  if (options.mtime !== undefined && options.mtine !== null) {\n    mtime = options.mtime\n  } else if (destination && destination.unixfs) {\n    mtime = destination.unixfs.mtime\n  }\n\n  const result = await last(importer([{\n    content: content,\n\n    // persist mode & mtime if set previously\n    mode,\n    mtime\n  }], context.block, {\n    progress: options.progress,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    strategy: options.strategy,\n    rawLeaves: options.rawLeaves,\n    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n    leafType: options.leafType,\n    pin: false\n  }))\n\n  log(`Wrote ${result.cid}`)\n\n  return {\n    cid: result.cid,\n    size: result.size\n  }\n}\n\nconst limitAsyncStreamBytes = (stream, limit) => {\n  return async function * _limitAsyncStreamBytes () {\n    let emitted = 0\n\n    for await (const buf of stream) {\n      emitted += buf.length\n\n      if (emitted > limit) {\n        yield buf.slice(0, limit - emitted)\n\n        return\n      }\n\n      yield buf\n    }\n  }\n}\n\nconst asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {\n  const buf = Buffer.alloc(chunkSize, 0)\n\n  const stream = {\n    [Symbol.asyncIterator]: function * _asyncZeroes () {\n      while (true) {\n        yield buf.slice()\n      }\n    }\n  }\n\n  return limitAsyncStreamBytes(stream, count)\n}\n\nconst catAsyncIterators = async function * (sources) { // eslint-disable-line require-await\n  for (let i = 0; i < sources.length; i++) {\n    yield * sources[i]()\n  }\n}\n\nconst countBytesStreamed = async function * (source, notify) {\n  let wrote = 0\n\n  for await (const buf of source) {\n    wrote += buf.length\n\n    yield buf\n  }\n\n  for await (const buf of notify(wrote)) {\n    wrote += buf.length\n\n    yield buf\n  }\n}\n"]},"metadata":{},"sourceType":"script"}