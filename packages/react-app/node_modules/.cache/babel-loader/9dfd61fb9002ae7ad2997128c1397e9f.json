{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar log = require('debug')('ipfs:mfs:touch');\n\nvar errCode = require('err-code');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar toTrail = require('./utils/to-trail');\n\nvar addLink = require('./utils/add-link');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode;\n\nvar mc = require('multicodec');\n\nvar mh = require('multihashing-async').multihash;\n\nvar pipe = require('it-pipe');\n\nvar importer = require('ipfs-unixfs-importer');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar last = require('it-last');\n\nvar cp = require('./cp');\n\nvar rm = require('./rm');\n\nvar persist = require('ipfs-unixfs-importer/src/utils/persist');\n\nvar _require2 = require('../../utils'),\n    withTimeoutOption = _require2.withTimeoutOption;\n\nvar defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false,\n  signal: undefined\n};\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  var modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 1 || originalMode & 8 || originalMode & 64)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n\nfunction calculateUGO(references, modification) {\n  var ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n} // https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  var match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(\"Invalid file mode: \".concat(input));\n  }\n\n  var _match = _slicedToArray(match, 4),\n      _ = _match[0],\n      // eslint-disable-line no-unused-vars\n  references = _match[1],\n      operator = _match[2],\n      mode = _match[3];\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  var modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n}\n\nfunction calculateMode(mode, metadata) {\n  if (typeof mode === 'string' || mode instanceof String) {\n    if (mode.match(/^\\d+$/g)) {\n      mode = parseInt(mode, 8);\n    } else {\n      mode = mode.split(',').reduce(function (curr, acc) {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode);\n    }\n  }\n\n  return mode;\n}\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsChmod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path, mode, options) {\n      var _yield$toMfsPath, cid, mfsDirectory, name, root, node, metadata, updatedCid, trail, parent, parentNode, result, newRootCid;\n\n      return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n              log(\"Fetching stats for \".concat(path));\n              _context5.next = 4;\n              return toMfsPath(context, path, options);\n\n            case 4:\n              _yield$toMfsPath = _context5.sent;\n              cid = _yield$toMfsPath.cid;\n              mfsDirectory = _yield$toMfsPath.mfsDirectory;\n              name = _yield$toMfsPath.name;\n\n              if (!(cid.codec !== 'dag-pb')) {\n                _context5.next = 10;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n\n            case 10:\n              if (!options.recursive) {\n                _context5.next = 19;\n                break;\n              }\n\n              _context5.next = 13;\n              return pipe( /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, entry, _node;\n\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _iteratorNormalCompletion = true;\n                        _didIteratorError = false;\n                        _context.prev = 2;\n                        _iterator = _asyncIterator(exporter.recursive(cid, context.ipld));\n\n                      case 4:\n                        _context.next = 6;\n                        return _awaitAsyncGenerator(_iterator.next());\n\n                      case 6:\n                        _step = _context.sent;\n                        _iteratorNormalCompletion = _step.done;\n                        _context.next = 10;\n                        return _awaitAsyncGenerator(_step.value);\n\n                      case 10:\n                        _value = _context.sent;\n\n                        if (_iteratorNormalCompletion) {\n                          _context.next = 23;\n                          break;\n                        }\n\n                        entry = _value;\n                        _context.next = 15;\n                        return _awaitAsyncGenerator(context.ipld.get(entry.cid));\n\n                      case 15:\n                        _node = _context.sent;\n                        entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n                        _node = new DAGNode(entry.unixfs.marshal(), _node.Links);\n                        _context.next = 20;\n                        return {\n                          path: entry.path,\n                          content: _node\n                        };\n\n                      case 20:\n                        _iteratorNormalCompletion = true;\n                        _context.next = 4;\n                        break;\n\n                      case 23:\n                        _context.next = 29;\n                        break;\n\n                      case 25:\n                        _context.prev = 25;\n                        _context.t0 = _context[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context.t0;\n\n                      case 29:\n                        _context.prev = 29;\n                        _context.prev = 30;\n\n                        if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                          _context.next = 34;\n                          break;\n                        }\n\n                        _context.next = 34;\n                        return _awaitAsyncGenerator(_iterator.return());\n\n                      case 34:\n                        _context.prev = 34;\n\n                        if (!_didIteratorError) {\n                          _context.next = 37;\n                          break;\n                        }\n\n                        throw _iteratorError;\n\n                      case 37:\n                        return _context.finish(34);\n\n                      case 38:\n                        return _context.finish(29);\n\n                      case 39:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[2, 25, 29, 39], [30,, 34, 38]]);\n              })), function (source) {\n                return importer(source, context.block, _objectSpread(_objectSpread({}, options), {}, {\n                  pin: false,\n                  dagBuilder: function () {\n                    var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(source, block, options) {\n                      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _loop, _iterator2, _step2, _value2;\n\n                      return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              _iteratorNormalCompletion2 = true;\n                              _didIteratorError2 = false;\n                              _context4.prev = 2;\n                              _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                                var entry;\n                                return _regeneratorRuntime.wrap(function _loop$(_context3) {\n                                  while (1) {\n                                    switch (_context3.prev = _context3.next) {\n                                      case 0:\n                                        entry = _value2;\n                                        _context3.next = 3;\n                                        return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                                          var cid;\n                                          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                            while (1) {\n                                              switch (_context2.prev = _context2.next) {\n                                                case 0:\n                                                  _context2.next = 2;\n                                                  return persist(entry.content.serialize(), block, options);\n\n                                                case 2:\n                                                  cid = _context2.sent;\n                                                  return _context2.abrupt(\"return\", {\n                                                    cid: cid,\n                                                    path: entry.path,\n                                                    unixfs: UnixFS.unmarshal(entry.content.Data),\n                                                    node: entry.content\n                                                  });\n\n                                                case 4:\n                                                case \"end\":\n                                                  return _context2.stop();\n                                              }\n                                            }\n                                          }, _callee2);\n                                        }));\n\n                                      case 3:\n                                      case \"end\":\n                                        return _context3.stop();\n                                    }\n                                  }\n                                }, _loop);\n                              });\n                              _iterator2 = _asyncIterator(source);\n\n                            case 5:\n                              _context4.next = 7;\n                              return _awaitAsyncGenerator(_iterator2.next());\n\n                            case 7:\n                              _step2 = _context4.sent;\n                              _iteratorNormalCompletion2 = _step2.done;\n                              _context4.next = 11;\n                              return _awaitAsyncGenerator(_step2.value);\n\n                            case 11:\n                              _value2 = _context4.sent;\n\n                              if (_iteratorNormalCompletion2) {\n                                _context4.next = 17;\n                                break;\n                              }\n\n                              return _context4.delegateYield(_loop(), \"t0\", 14);\n\n                            case 14:\n                              _iteratorNormalCompletion2 = true;\n                              _context4.next = 5;\n                              break;\n\n                            case 17:\n                              _context4.next = 23;\n                              break;\n\n                            case 19:\n                              _context4.prev = 19;\n                              _context4.t1 = _context4[\"catch\"](2);\n                              _didIteratorError2 = true;\n                              _iteratorError2 = _context4.t1;\n\n                            case 23:\n                              _context4.prev = 23;\n                              _context4.prev = 24;\n\n                              if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                                _context4.next = 28;\n                                break;\n                              }\n\n                              _context4.next = 28;\n                              return _awaitAsyncGenerator(_iterator2.return());\n\n                            case 28:\n                              _context4.prev = 28;\n\n                              if (!_didIteratorError2) {\n                                _context4.next = 31;\n                                break;\n                              }\n\n                              throw _iteratorError2;\n\n                            case 31:\n                              return _context4.finish(28);\n\n                            case 32:\n                              return _context4.finish(23);\n\n                            case 33:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee3, null, [[2, 19, 23, 33], [24,, 28, 32]]);\n                    }));\n\n                    return function dagBuilder(_x, _x2, _x3) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }()\n                }));\n              }, function (nodes) {\n                return last(nodes);\n              });\n\n            case 13:\n              root = _context5.sent;\n              _context5.next = 16;\n              return rm(context)(path, options);\n\n            case 16:\n              _context5.next = 18;\n              return cp(context)(\"/ipfs/\".concat(root.cid), path, options);\n\n            case 18:\n              return _context5.abrupt(\"return\");\n\n            case 19:\n              _context5.next = 21;\n              return context.ipld.get(cid);\n\n            case 21:\n              node = _context5.sent;\n              metadata = UnixFS.unmarshal(node.Data);\n              metadata.mode = calculateMode(mode, metadata);\n              node = new DAGNode(metadata.marshal(), node.Links);\n              _context5.next = 27;\n              return context.ipld.put(node, mc.DAG_PB, {\n                cidVersion: cid.version,\n                hashAlg: mh.names[options.hashAlg],\n                onlyHash: !options.flush\n              });\n\n            case 27:\n              updatedCid = _context5.sent;\n              _context5.next = 30;\n              return toTrail(context, mfsDirectory, options);\n\n            case 30:\n              trail = _context5.sent;\n              parent = trail[trail.length - 1];\n              _context5.next = 34;\n              return context.ipld.get(parent.cid);\n\n            case 34:\n              parentNode = _context5.sent;\n              _context5.next = 37;\n              return addLink(context, {\n                parent: parentNode,\n                name: name,\n                cid: updatedCid,\n                size: node.serialize().length,\n                flush: options.flush,\n                hashAlg: options.hashAlg,\n                cidVersion: cid.version\n              });\n\n            case 37:\n              result = _context5.sent;\n              parent.cid = result.cid; // update the tree with the new child\n\n              _context5.next = 41;\n              return updateTree(context, trail, options);\n\n            case 41:\n              newRootCid = _context5.sent;\n              _context5.next = 44;\n              return updateMfsRoot(context, newRootCid, options);\n\n            case 44:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    function mfsChmod(_x4, _x5, _x6) {\n      return _mfsChmod.apply(this, arguments);\n    }\n\n    return mfsChmod;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/chmod.js"],"names":["applyDefaultOptions","require","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","DAGNode","mc","mh","multihash","pipe","importer","exporter","last","cp","rm","persist","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","recursive","signal","undefined","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","_","operator","calculateMode","metadata","String","split","reduce","curr","acc","module","exports","context","path","options","cid","mfsDirectory","name","codec","ipld","entry","get","node","unixfs","marshal","Links","content","source","block","pin","dagBuilder","serialize","unmarshal","Data","nodes","root","put","DAG_PB","version","names","onlyHash","updatedCid","trail","parent","length","parentNode","size","result","newRootCid","mfsChmod"],"mappings":"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","sourcesContent":["'use strict'\n\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst UnixFS = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst { DAGNode } = require('ipld-dag-pb')\nconst mc = require('multicodec')\nconst mh = require('multihashing-async').multihash\nconst pipe = require('it-pipe')\nconst importer = require('ipfs-unixfs-importer')\nconst exporter = require('ipfs-unixfs-exporter')\nconst last = require('it-last')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst persist = require('ipfs-unixfs-importer/src/utils/persist')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false,\n  signal: undefined\n}\n\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n// https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    _, // eslint-disable-line no-unused-vars\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n}\n\nfunction calculateMode (mode, metadata) {\n  if (typeof mode === 'string' || mode instanceof String) {\n    if (mode.match(/^\\d+$/g)) {\n      mode = parseInt(mode, 8)\n    } else {\n      mode = mode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode)\n    }\n  }\n\n  return mode\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsChmod (path, mode, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, options)\n\n    if (cid.codec !== 'dag-pb') {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (options.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of exporter.recursive(cid, context.ipld)) {\n            let node = await context.ipld.get(entry.cid)\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n            node = new DAGNode(entry.unixfs.marshal(), node.Links)\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        (source) => importer(source, context.block, {\n          ...options,\n          pin: false,\n          dagBuilder: async function * (source, block, options) {\n            for await (const entry of source) {\n              yield async function () {\n                const cid = await persist(entry.content.serialize(), block, options)\n\n                return {\n                  cid,\n                  path: entry.path,\n                  unixfs: UnixFS.unmarshal(entry.content.Data),\n                  node: entry.content\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      // remove old path from mfs\n      await rm(context)(path, options)\n\n      // add newly created tree to mfs at path\n      await cp(context)(`/ipfs/${root.cid}`, path, options)\n\n      return\n    }\n\n    let node = await context.ipld.get(cid)\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    node = new DAGNode(metadata.marshal(), node.Links)\n\n    const updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n      cidVersion: cid.version,\n      hashAlg: mh.names[options.hashAlg],\n      onlyHash: !options.flush\n    })\n\n    const trail = await toTrail(context, mfsDirectory, options)\n    const parent = trail[trail.length - 1]\n    const parentNode = await context.ipld.get(parent.cid)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: node.serialize().length,\n      flush: options.flush,\n      hashAlg: options.hashAlg,\n      cidVersion: cid.version\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}