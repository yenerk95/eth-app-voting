{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar abortable = require('abortable-iterator');\n\nvar log = require('debug')('libp2p:stream:converter'); // Convert a duplex iterable into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\n\n\nmodule.exports = function (_ref) {\n  var stream = _ref.stream,\n      remoteAddr = _ref.remoteAddr,\n      localAddr = _ref.localAddr;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _sink = stream.sink,\n      source = stream.source;\n  var maConn = {\n    sink: function sink(source) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (options.signal) {\n                  source = abortable(source, options.signal);\n                }\n\n                _context.prev = 1;\n                _context.next = 4;\n                return _sink(source);\n\n              case 4:\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](1);\n\n                // If aborted we can safely ignore\n                if (_context.t0.type !== 'aborted') {\n                  // If the source errored the socket will already have been destroyed by\n                  // toIterable.duplex(). If the socket errored it will already be\n                  // destroyed. There's nothing to do here except log the error & return.\n                  log(_context.t0);\n                }\n\n              case 9:\n                _close();\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 6]]);\n      }))();\n    },\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr: localAddr,\n    remoteAddr: remoteAddr,\n    timeline: {\n      open: Date.now()\n    },\n    close: function close() {\n      _sink([]);\n\n      _close();\n    }\n  };\n\n  function _close() {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now();\n    }\n  }\n\n  return maConn;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-utils/src/stream-to-ma-conn.js"],"names":["abortable","require","log","module","exports","stream","remoteAddr","localAddr","options","sink","source","maConn","signal","type","close","conn","timeline","open","Date","now"],"mappings":"AAAA;;;;;;AAEA,IAAMA,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAP,CAAiB,yBAAjB,CAAZ,C,CAEA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,gBAAqD;AAAA,MAAlDC,MAAkD,QAAlDA,MAAkD;AAAA,MAA1CC,UAA0C,QAA1CA,UAA0C;AAAA,MAA9BC,SAA8B,QAA9BA,SAA8B;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;AAAA,MAC5DC,KAD4D,GAC3CJ,MAD2C,CAC5DI,IAD4D;AAAA,MACtDC,MADsD,GAC3CL,MAD2C,CACtDK,MADsD;AAEpE,MAAMC,MAAM,GAAG;AACPF,IAAAA,IADO,gBACDC,MADC,EACO;AAAA;AAAA;AAAA;AAAA;AAAA;AAClB,oBAAIF,OAAO,CAACI,MAAZ,EAAoB;AAClBF,kBAAAA,MAAM,GAAGV,SAAS,CAACU,MAAD,EAASF,OAAO,CAACI,MAAjB,CAAlB;AACD;;AAHiB;AAAA;AAAA,uBAMVH,KAAI,CAACC,MAAD,CANM;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAQhB;AACA,oBAAI,YAAIG,IAAJ,KAAa,SAAjB,EAA4B;AAC1B;AACA;AACA;AACAX,kBAAAA,GAAG,aAAH;AACD;;AAde;AAgBlBY,gBAAAA,MAAK;;AAhBa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBnB,KAlBY;AAoBbJ,IAAAA,MAAM,EAAEF,OAAO,CAACI,MAAR,GAAiBZ,SAAS,CAACU,MAAD,EAASF,OAAO,CAACI,MAAjB,CAA1B,GAAqDF,MApBhD;AAqBbK,IAAAA,IAAI,EAAEV,MArBO;AAsBbE,IAAAA,SAAS,EAATA,SAtBa;AAuBbD,IAAAA,UAAU,EAAVA,UAvBa;AAwBbU,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,IAAI,EAAEC,IAAI,CAACC,GAAL;AAAR,KAxBG;AA0BbL,IAAAA,KA1Ba,mBA0BJ;AACPL,MAAAA,KAAI,CAAC,EAAD,CAAJ;;AACAK,MAAAA,MAAK;AACN;AA7BY,GAAf;;AAgCA,WAASA,MAAT,GAAkB;AAChB,QAAI,CAACH,MAAM,CAACK,QAAP,CAAgBF,KAArB,EAA4B;AAC1BH,MAAAA,MAAM,CAACK,QAAP,CAAgBF,KAAhB,GAAwBI,IAAI,CAACC,GAAL,EAAxB;AACD;AACF;;AAED,SAAOR,MAAP;AACD,CAzCD","sourcesContent":["'use strict'\n\nconst abortable = require('abortable-iterator')\nconst log = require('debug')('libp2p:stream:converter')\n\n// Convert a duplex iterable into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nmodule.exports = ({ stream, remoteAddr, localAddr }, options = {}) => {\n  const { sink, source } = stream\n  const maConn = {\n    async sink (source) {\n      if (options.signal) {\n        source = abortable(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err)\n        }\n      }\n      close()\n    },\n\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr,\n    remoteAddr,\n    timeline: { open: Date.now() },\n\n    close () {\n      sink([])\n      close()\n    }\n  }\n\n  function close () {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now()\n    }\n  }\n\n  return maConn\n}\n"]},"metadata":{},"sourceType":"script"}