{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar createLock = require('./utils/create-lock');\n\nvar isIpfs = require('is-ipfs'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nvar readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nvar writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}; // These operations are asynchronous and manage their own locking\n\nvar unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nvar wrap = function wrap(_ref2) {\n  var options = _ref2.options,\n      mfs = _ref2.mfs,\n      operations = _ref2.operations,\n      lock = _ref2.lock;\n  Object.keys(operations).forEach(function (key) {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nvar defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nfunction createMfs(options) {\n  var _Object$assign = Object.assign({}, defaultOptions || {}, options),\n      repoOwner = _Object$assign.repoOwner;\n\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  };\n  var lock = createLock(repoOwner);\n\n  var readLock = function readLock(operation) {\n    return lock.readLock(operation);\n  };\n\n  var writeLock = function writeLock(operation) {\n    return lock.writeLock(operation);\n  };\n\n  var mfs = {};\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(function (key) {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n\nmodule.exports = function (_ref3) {\n  var ipld = _ref3.ipld,\n      block = _ref3.block,\n      blockService = _ref3.blockService,\n      repo = _ref3.repo,\n      preload = _ref3.preload,\n      constructorOptions = _ref3.options;\n  var methods = createMfs({\n    ipld: ipld,\n    block: block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  });\n\n  var withPreload = function withPreload(fn) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var paths = args.filter(function (arg) {\n        return isIpfs.ipfsPath(arg) || isIpfs.cid(arg);\n      });\n\n      if (paths.length) {\n        var options = args[args.length - 1];\n\n        if (options && options.preload !== false) {\n          paths.forEach(function (path) {\n            return preload(path);\n          });\n        }\n      }\n\n      return fn.apply(void 0, args);\n    };\n  };\n\n  return _objectSpread(_objectSpread({}, methods), {}, {\n    /**\n     * Change file mode\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {Object} mode - The mode to set the path\n     * @param {Object} [opts] - Options for modification.\n     * @param {boolean} [opts.recursive=false] - Whether to change modes recursively. (default: false)\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    chmod: methods.chmod,\n\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<string>}\n     */\n    cp: withPreload(methods.cp),\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<void>}\n     */\n    mkdir: methods.mkdir,\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @returns {Promise<StatOutput>}\n     */\n    stat: withPreload(methods.stat),\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @returns {Promise<void>}\n     */\n    rm: methods.rm,\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {AsyncIterable<Buffer>}\n     */\n    read: withPreload(methods.read),\n\n    /**\n     * Update modification time\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {number} mtime - Time to use as the new modification time in seconds since (+ve) or before (-ve) the Unix Epoch\n     * @param {Object} [opts] - Options for touch.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.cidVersion=0] - CID version to use with the newly updated node\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    touch: methods.touch,\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @returns {Promise<void>}\n     */\n    write: methods.write,\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @returns {Promise<void>}\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: withPreload(methods.mv),\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @returns {Promise<void>}\n     */\n    flush: methods.flush,\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {AsyncIterable<ListOutputFile>}\n     */\n    ls: withPreload( /*#__PURE__*/function () {\n      var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _iteratorNormalCompletion,\n            _didIteratorError,\n            _iteratorError,\n            _iterator,\n            _step,\n            _value,\n            file,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 2;\n                _iterator = _asyncIterator(methods.ls.apply(methods, _args));\n\n              case 4:\n                _context.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 18;\n                  break;\n                }\n\n                file = _value;\n                _context.next = 15;\n                return _objectSpread(_objectSpread({}, file), {}, {\n                  size: file.size || 0\n                });\n\n              case 15:\n                _iteratorNormalCompletion = true;\n                _context.next = 4;\n                break;\n\n              case 18:\n                _context.next = 24;\n                break;\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 24:\n                _context.prev = 24;\n                _context.prev = 25;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 29;\n                  break;\n                }\n\n                _context.next = 29;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 29:\n                _context.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context.finish(29);\n\n              case 33:\n                return _context.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n      }));\n\n      return function () {\n        return _ref.apply(this, arguments);\n      };\n    }())\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/index.js"],"names":["createLock","require","isIpfs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","ipld","repo","createMfs","assign","blocks","datastore","readLock","operation","writeLock","module","exports","block","blockService","preload","constructorOptions","methods","root","withPreload","fn","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst createLock = require('./utils/create-lock')\nconst isIpfs = require('is-ipfs')\n\n// These operations are read-locked at the function level and will execute simultaneously\nconst readOperations = {\n  stat: require('./stat')\n}\n\n// These operations are locked at the function level and will execute in series\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}\n\n// These operations are asynchronous and manage their own locking\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n}\n\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  }\n\n  const lock = createLock(repoOwner)\n\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\nmodule.exports = ({ ipld, block, blockService, repo, preload, options: constructorOptions }) => {\n  const methods = createMfs({\n    ipld,\n    block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  })\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n    if (paths.length) {\n      const options = args[args.length - 1]\n      if (options && options.preload !== false) {\n        paths.forEach(path => preload(path))\n      }\n    }\n\n    return fn(...args)\n  }\n\n  return {\n    ...methods,\n\n    /**\n     * Change file mode\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {Object} mode - The mode to set the path\n     * @param {Object} [opts] - Options for modification.\n     * @param {boolean} [opts.recursive=false] - Whether to change modes recursively. (default: false)\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    chmod: methods.chmod,\n\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<string>}\n     */\n    cp: withPreload(methods.cp),\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<void>}\n     */\n    mkdir: methods.mkdir,\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @returns {Promise<StatOutput>}\n     */\n    stat: withPreload(methods.stat),\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @returns {Promise<void>}\n     */\n    rm: methods.rm,\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {AsyncIterable<Buffer>}\n     */\n    read: withPreload(methods.read),\n\n    /**\n     * Update modification time\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {number} mtime - Time to use as the new modification time in seconds since (+ve) or before (-ve) the Unix Epoch\n     * @param {Object} [opts] - Options for touch.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.cidVersion=0] - CID version to use with the newly updated node\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    touch: methods.touch,\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @returns {Promise<void>}\n     */\n    write: methods.write,\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @returns {Promise<void>}\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: withPreload(methods.mv),\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @returns {Promise<void>}\n     */\n    flush: methods.flush,\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {AsyncIterable<ListOutputFile>}\n     */\n    ls: withPreload(async function * (...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}