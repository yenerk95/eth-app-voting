{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar isBuffer = require('is-buffer');\n\nvar Shake = require('it-handshake');\n\nvar lp = require('it-length-prefixed');\n\nmodule.exports = function (duplex) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var shake = Shake(duplex);\n  var lpReader = lp.decode.fromReader(shake.reader, opts);\n  var isDone = false;\n  var W = {\n    read: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bytes) {\n        var _yield$shake$reader$n, value, done;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return shake.reader.next(bytes);\n\n              case 2:\n                _yield$shake$reader$n = _context.sent;\n                value = _yield$shake$reader$n.value;\n                done = _yield$shake$reader$n.done;\n\n                if (!(done && value.length < bytes)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error('Couldn\\'t read enough bytes');\n\n              case 7:\n                isDone = done;\n\n                if (value) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 10:\n                return _context.abrupt(\"return\", value);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }(),\n    readLP: function () {\n      var _readLP = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$lpReader$next, value, done;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return lpReader.next();\n\n              case 2:\n                _yield$lpReader$next = _context2.sent;\n                value = _yield$lpReader$next.value;\n                done = _yield$lpReader$next.done;\n                isDone = done;\n\n                if (value) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 8:\n                return _context2.abrupt(\"return\", value);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function readLP() {\n        return _readLP.apply(this, arguments);\n      }\n\n      return readLP;\n    }(),\n    readPB: function () {\n      var _readPB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(proto) {\n        var value, buf;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return W.readLP();\n\n              case 2:\n                value = _context3.sent;\n\n                if (value) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 5:\n                // Is this a buffer?\n                buf = isBuffer(value) ? value : value.slice();\n                return _context3.abrupt(\"return\", proto.decode(buf));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function readPB(_x2) {\n        return _readPB.apply(this, arguments);\n      }\n\n      return readPB;\n    }(),\n    write: function write(data) {\n      // just write\n      shake.writer.push(data);\n    },\n    writeLP: function writeLP(data) {\n      // encode, write\n      W.write(lp.encode.single(data, opts));\n    },\n    writePB: function writePB(data, proto) {\n      // encode, writeLP\n      W.writeLP(proto.encode(data));\n    },\n    pb: function pb(proto) {\n      return {\n        read: function read() {\n          return W.readPB(proto);\n        },\n        write: function write(d) {\n          return W.writePB(d, proto);\n        }\n      };\n    },\n    unwrap: function unwrap() {\n      // returns vanilla duplex again, terminates all reads/writes from this object\n      shake.rest();\n      return shake.stream;\n    }\n  };\n  return W;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/it-pb-rpc/src/index.js"],"names":["isBuffer","require","Shake","lp","module","exports","duplex","opts","shake","lpReader","decode","fromReader","reader","isDone","W","read","bytes","next","value","done","length","Error","readLP","readPB","proto","buf","slice","write","data","writer","push","writeLP","encode","single","writePB","pb","d","unwrap","rest","stream"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isBuffer = require('is-buffer')\nconst Shake = require('it-handshake')\nconst lp = require('it-length-prefixed')\n\nmodule.exports = (duplex, opts = {}) => {\n  const shake = Shake(duplex)\n  const lpReader = lp.decode.fromReader(\n      shake.reader,\n      opts\n  )\n\n  let isDone = false\n\n  const W = {\n    read: async (bytes) => {\n      // just read\n\n      const { value, done } = await shake.reader.next(bytes)\n\n      if (done && value.length < bytes) {\n        throw new Error('Couldn\\'t read enough bytes')\n      }\n\n      isDone = done\n\n      if (!value) { throw new Error('Value is null') }\n      return value\n    },\n    readLP: async () => {\n      // read, decode\n      const { value, done } = await lpReader.next()\n\n      isDone = done\n\n      if (!value) { throw new Error('Value is null') }\n      return value\n    },\n    readPB: async (proto) => {\n      // readLP, decode\n      const value = await W.readLP()\n\n      if (!value) { throw new Error('Value is null') }\n\n      // Is this a buffer?\n      const buf = isBuffer(value) ? value : value.slice()\n\n      return proto.decode(buf)\n    },\n    write: (data) => {\n      // just write\n      shake.writer.push(data)\n    },\n    writeLP: (data) => {\n      // encode, write\n      W.write(lp.encode.single(data, opts))\n    },\n    writePB: (data, proto) => {\n      // encode, writeLP\n      W.writeLP(proto.encode(data))\n    },\n\n    pb: (proto) => {\n      return {\n        read: () => W.readPB(proto),\n        write: (d) => W.writePB(d, proto)\n      }\n    },\n\n    unwrap: () => {\n      // returns vanilla duplex again, terminates all reads/writes from this object\n      shake.rest()\n      return shake.stream\n    }\n  }\n\n  return W\n}\n"]},"metadata":{},"sourceType":"script"}