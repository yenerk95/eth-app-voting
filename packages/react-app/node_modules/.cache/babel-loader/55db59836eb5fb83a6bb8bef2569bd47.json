{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar getIterator = require('get-iterator');\n\nvar defer = require('p-defer');\n\nmodule.exports = function (writable) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n      var errPromise, closePromise, endingPromise, finishPromise, drainPromise, errorHandler, closeHandler, finishHandler, drainHandler, _end, getNext, result;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              source = getIterator(source);\n              errPromise = defer();\n              closePromise = defer();\n              endingPromise = defer();\n              finishPromise = defer();\n\n              errorHandler = function errorHandler(err) {\n                return errPromise.reject(err);\n              };\n\n              closeHandler = function closeHandler() {\n                return closePromise.resolve({\n                  closed: true\n                });\n              };\n\n              finishHandler = function finishHandler() {\n                return finishPromise.resolve({\n                  finished: true\n                });\n              };\n\n              drainHandler = function drainHandler() {\n                if (drainPromise) drainPromise.resolve({\n                  drained: true\n                });\n              }; // There's no event to determine the start of a call to .end()\n\n\n              _end = writable.end.bind(writable);\n\n              writable.end = function () {\n                endingPromise.resolve({\n                  ending: true\n                });\n                return _end.apply(void 0, arguments);\n              };\n\n              writable.on('error', errorHandler).on('close', closeHandler).on('finish', finishHandler).on('drain', drainHandler);\n\n              getNext = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.prev = 0;\n                          return _context.abrupt(\"return\", source.next());\n\n                        case 4:\n                          _context.prev = 4;\n                          _context.t0 = _context[\"catch\"](0);\n                          writable.destroy(_context.t0);\n                          return _context.abrupt(\"return\", errPromise.promise);\n\n                        case 8:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[0, 4]]);\n                }));\n\n                return function getNext() {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n\n              _context2.prev = 13;\n\n            case 14:\n              if (!true) {\n                _context2.next = 39;\n                break;\n              }\n\n              _context2.next = 17;\n              return Promise.race([errPromise.promise, closePromise.promise, endingPromise.promise, finishPromise.promise, getNext()]);\n\n            case 17:\n              result = _context2.sent;\n\n              if (!(result.closed || result.finished)) {\n                _context2.next = 20;\n                break;\n              }\n\n              return _context2.abrupt(\"break\", 39);\n\n            case 20:\n              if (!result.ending) {\n                _context2.next = 24;\n                break;\n              }\n\n              _context2.next = 23;\n              return Promise.race([errPromise.promise, // TODO: do we need to wait on close? If slow end and destroy is\n              // called then what is emitted? close or finish?\n              closePromise.promise, finishPromise.promise]);\n\n            case 23:\n              return _context2.abrupt(\"break\", 39);\n\n            case 24:\n              if (!writable.destroyed) {\n                _context2.next = 28;\n                break;\n              }\n\n              _context2.next = 27;\n              return Promise.race([errPromise.promise, closePromise.promise]);\n\n            case 27:\n              return _context2.abrupt(\"break\", 39);\n\n            case 28:\n              if (!result.done) {\n                _context2.next = 33;\n                break;\n              }\n\n              writable.end();\n              _context2.next = 32;\n              return Promise.race([errPromise.promise, // TODO: do we need to wait on close? If slow end and destroy is\n              // called then what is emitted? close or finish?\n              closePromise.promise, finishPromise.promise]);\n\n            case 32:\n              return _context2.abrupt(\"break\", 39);\n\n            case 33:\n              if (writable.write(result.value)) {\n                _context2.next = 37;\n                break;\n              }\n\n              drainPromise = defer();\n              _context2.next = 37;\n              return Promise.race([errPromise.promise, closePromise.promise, finishPromise.promise, drainPromise.promise]);\n\n            case 37:\n              _context2.next = 14;\n              break;\n\n            case 39:\n              _context2.prev = 39;\n              writable.removeListener('error', errorHandler).removeListener('close', closeHandler).removeListener('finish', finishHandler).removeListener('drain', drainHandler); // End the iterator if it is a generator\n\n              if (!(typeof source.return === 'function')) {\n                _context2.next = 44;\n                break;\n              }\n\n              _context2.next = 44;\n              return source.return();\n\n            case 44:\n              return _context2.finish(39);\n\n            case 45:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[13,, 39, 45]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/stream-to-it/sink.js"],"names":["getIterator","require","defer","module","exports","writable","source","errPromise","closePromise","endingPromise","finishPromise","errorHandler","err","reject","closeHandler","resolve","closed","finishHandler","finished","drainHandler","drainPromise","drained","_end","end","bind","ending","on","getNext","next","destroy","promise","Promise","race","result","destroyed","done","write","value","removeListener","return"],"mappings":"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","sourcesContent":["const getIterator = require('get-iterator')\nconst defer = require('p-defer')\n\nmodule.exports = writable => async source => {\n  source = getIterator(source)\n\n  const errPromise = defer()\n  const closePromise = defer()\n  const endingPromise = defer()\n  const finishPromise = defer()\n  let drainPromise\n\n  const errorHandler = err => errPromise.reject(err)\n  const closeHandler = () => closePromise.resolve({ closed: true })\n  const finishHandler = () => finishPromise.resolve({ finished: true })\n  const drainHandler = () => {\n    if (drainPromise) drainPromise.resolve({ drained: true })\n  }\n\n  // There's no event to determine the start of a call to .end()\n  const _end = writable.end.bind(writable)\n  writable.end = (...args) => {\n    endingPromise.resolve({ ending: true })\n    return _end(...args)\n  }\n\n  writable\n    .on('error', errorHandler)\n    .on('close', closeHandler)\n    .on('finish', finishHandler)\n    .on('drain', drainHandler)\n\n  const getNext = async () => {\n    try {\n      return source.next()\n    } catch (err) {\n      writable.destroy(err)\n      return errPromise.promise\n    }\n  }\n\n  try {\n    while (true) {\n      // Race the iterator and the error, close and finish listener\n      const result = await Promise.race([\n        errPromise.promise,\n        closePromise.promise,\n        endingPromise.promise,\n        finishPromise.promise,\n        getNext()\n      ])\n\n      if (result.closed || result.finished) {\n        break\n      }\n\n      // .end() was called, waiting on flush (finish event)\n      if (result.ending) {\n        await Promise.race([\n          errPromise.promise,\n          // TODO: do we need to wait on close? If slow end and destroy is\n          // called then what is emitted? close or finish?\n          closePromise.promise,\n          finishPromise.promise\n        ])\n        break\n      }\n\n      // If destroyed, race err & close to determine reason & then throw/break\n      if (writable.destroyed) {\n        await Promise.race([\n          errPromise.promise,\n          closePromise.promise\n        ])\n        break\n      }\n\n      if (result.done) {\n        writable.end()\n        await Promise.race([\n          errPromise.promise,\n          // TODO: do we need to wait on close? If slow end and destroy is\n          // called then what is emitted? close or finish?\n          closePromise.promise,\n          finishPromise.promise\n        ])\n        break\n      }\n\n      if (!writable.write(result.value)) {\n        drainPromise = defer()\n        await Promise.race([\n          errPromise.promise,\n          closePromise.promise,\n          finishPromise.promise,\n          drainPromise.promise\n        ])\n      }\n    }\n  } finally {\n    writable\n      .removeListener('error', errorHandler)\n      .removeListener('close', closeHandler)\n      .removeListener('finish', finishHandler)\n      .removeListener('drain', drainHandler)\n\n    // End the iterator if it is a generator\n    if (typeof source.return === 'function') {\n      await source.return()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}