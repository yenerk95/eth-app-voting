{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst debug = require('debug');\n\nconst globalThis = require('ipfs-utils/src/globalthis');\n\nconst log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nconst PeerId = require('peer-id');\n\nconst peerRouting = require('./peer-routing');\n\nconst contentRouting = require('./content-routing');\n\nconst pubsub = require('./pubsub');\n\nconst getPeer = require('./get-peer');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes\n} = require('./errors');\n\nconst AddressManager = require('./address-manager');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst Circuit = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Keychain = require('./keychain');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst PersistentPeerStore = require('./peer-store/persistent');\n\nconst Registrar = require('./registrar');\n\nconst ping = require('./ping');\n\nconst {\n  IdentifyService,\n  multicodecs: IDENTIFY_PROTOCOLS\n} = require('./identify');\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    this.peerId = this._options.peerId;\n    this.datastore = this._options.datastore;\n    this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({\n      datastore: this.datastore,\n      ...this._options.peerStore\n    }) : new PeerStore(); // Addresses {listen, announce, noAnnounce}\n\n    this.addresses = this._options.addresses;\n    this.addressManager = new AddressManager(this._options.addresses);\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager); // Create Metrics\n\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({ ...this._options.metrics,\n        connectionManager: this.connectionManager\n      });\n    } // Create keychain\n\n\n    if (this._options.keychain && this._options.keychain.pass && this._options.keychain.datastore) {\n      log('creating keychain');\n      const keychainOpts = Keychain.generateOptions();\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        passPhrase: this._options.keychain.pass,\n        ...keychainOpts,\n        ...this._options.keychain\n      });\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: connection => this.connectionManager.onConnect(connection),\n      onConnectionEnd: connection => this.connectionManager.onDisconnect(connection)\n    }); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Attach crypto channels\n\n    if (this._modules.connEncryption) {\n      const cryptos = this._modules.connEncryption;\n      cryptos.forEach(crypto => {\n        this.upgrader.cryptos.set(crypto.protocol, crypto);\n      });\n    }\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      concurrency: this._options.dialer.maxParallelDials,\n      perPeerLimit: this._options.dialer.maxDialsPerPeer,\n      timeout: this._options.dialer.dialTimeout\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        libp2p: this,\n        protocols: this.upgrader.protocols\n      });\n      this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht;\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // start pubsub\n\n\n    if (this._modules.pubsub) {\n      this.pubsub = pubsub(this, this._modules.pubsub, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = peerRouting(this);\n    this.contentRouting = contentRouting(this); // Mount default protocols\n\n    ping.mount(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  emit(eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args);\n    } else {\n      super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('libp2p is starting');\n\n    try {\n      await this._onStarting();\n      await this._onDidStart();\n      log('libp2p has started');\n    } catch (err) {\n      this.emit('error', err);\n      log.error('An error occurred starting libp2p', err);\n      await this.stop();\n      throw err;\n    }\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   * @async\n   * @returns {void}\n   */\n\n\n  async stop() {\n    log('libp2p is stopping');\n\n    try {\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer);\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()));\n      this._discovery = new Map();\n      await this.peerStore.stop();\n      await this.connectionManager.stop();\n      await Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n      await this.transportManager.close();\n      ping.unmount(this);\n      this.dialer.destroy();\n    } catch (err) {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n      }\n    }\n\n    this._isStarted = false;\n    log('libp2p has stopped');\n  }\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   * @async\n   * @returns {void}\n   */\n\n\n  async loadKeychain() {\n    try {\n      await this.keychain.findKeyByName('self');\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId);\n    }\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.connectionManager.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this.dialProtocol(peer, null, options);\n  }\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `Connection` will be returned\n   * @async\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection|*>}\n   */\n\n\n  async dialProtocol(peer, protocols, options) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer, this.peerStore);\n    let connection = this.connectionManager.get(id);\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options);\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs);\n    } // If a protocol was provided, create a new stream\n\n\n    if (protocols) {\n      return connection.newStream(protocols);\n    }\n\n    return connection;\n  }\n  /**\n   * Get peer advertising multiaddrs by concating the addresses used\n   * by transports to listen with the announce addresses.\n   * Duplicated addresses and noAnnounce addresses are filtered out.\n   * @return {Array<Multiaddr>}\n   */\n\n\n  get multiaddrs() {\n    // Filter noAnnounce multiaddrs\n    const filterMa = this.addressManager.getNoAnnounceAddrs(); // Create advertising list\n\n    return this.transportManager.getAddrs().concat(this.addressManager.getAnnounceAddrs()).filter((ma, index, array) => {\n      // Filter out if repeated\n      if (array.findIndex(otherMa => otherMa.equals(ma)) !== index) {\n        return false;\n      } // Filter out if in noAnnounceMultiaddrs\n\n\n      if (filterMa.find(fm => fm.equals(ma))) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   * @param {PeerId|multiaddr|string} peer the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  async hangUp(peer) {\n    const {\n      id\n    } = getPeer(peer);\n    const connections = this.connectionManager.connections.get(id.toB58String());\n\n    if (!connections) {\n      return;\n    }\n\n    await Promise.all(connections.map(connection => {\n      return connection.close();\n    }));\n  }\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   * @param {PeerId|Multiaddr|string} peer The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  ping(peer) {\n    const {\n      id\n    } = getPeer(peer);\n    return ping(this, id);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   * @param {string[]|string} protocols\n   * @param {function({ connection:*, stream:*, protocol:string })} handler\n   */\n\n\n  handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Only push if libp2p is running\n\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore);\n    }\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   * @param {string[]|string} protocols\n   */\n\n\n  unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Only push if libp2p is running\n\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore);\n    }\n  }\n\n  async _onStarting() {\n    // Listen on the provided transports\n    await this.transportManager.listen(); // Start PeerStore\n\n    await this.peerStore.start();\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start();\n    } // DHT subsystem\n\n\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n\n      this._dht.on('peer', this._onDiscoveryPeer);\n    } // Start metrics if present\n\n\n    this.metrics && this.metrics.start();\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   * @private\n   */\n\n\n  async _onDidStart() {\n    this._isStarted = true;\n    this.connectionManager.start();\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId);\n\n      this._maybeConnect(peerId);\n    }); // Once we start, emit and dial any peers we may have already discovered\n\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id);\n\n      this._maybeConnect(peer.id);\n    } // Peer discovery\n\n\n    await this._setupPeerDiscovery();\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string> }} peer\n   */\n\n\n  _onDiscoveryPeer(peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);\n  }\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  async _maybeConnect(peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minPeers = this._options.connectionManager.minPeers || 0;\n\n      if (minPeers > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String());\n\n        try {\n          await this.dialer.connectToPeer(peerId);\n        } catch (err) {\n          log.error('could not connect to discovered peer', err);\n        }\n      }\n    }\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  async _setupPeerDiscovery() {\n    const setupService = DiscoveryService => {\n      let config = {\n        enabled: true // on by default\n\n      };\n\n      if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config,\n          ...this._config.peerDiscovery[DiscoveryService.tag]\n        };\n      }\n\n      if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {\n        // not already added\n        let discoveryService;\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }));\n        } else {\n          discoveryService = DiscoveryService;\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer);\n\n        this._discovery.set(DiscoveryService.tag, discoveryService);\n      }\n    }; // Discovery modules\n\n\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService);\n    } // Transport modules with discovery\n\n\n    for (const Transport of this.transportManager.getTransports()) {\n      if (Transport.discovery) {\n        setupService(Transport.discovery);\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()));\n  }\n\n}\n/**\n * Like `new Libp2p(options)` except it will create a `PeerId`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\n\n\nLibp2p.create = async function create(options = {}) {\n  if (options.peerId) {\n    return new Libp2p(options);\n  }\n\n  const peerId = await PeerId.create();\n  options.peerId = peerId;\n  return new Libp2p(options);\n};\n\nmodule.exports = Libp2p;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/index.js"],"names":["EventEmitter","require","debug","globalThis","log","error","PeerId","peerRouting","contentRouting","pubsub","getPeer","validate","validateConfig","codes","AddressManager","ConnectionManager","Circuit","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PersistentPeerStore","Registrar","ping","IdentifyService","multicodecs","IDENTIFY_PROTOCOLS","Libp2p","constructor","_options","peerId","datastore","peerStore","persistence","addresses","addressManager","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","metrics","enabled","keychain","pass","keychainOpts","generateOptions","passPhrase","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","registrar","handle","bind","connEncryption","cryptos","forEach","crypto","set","protocol","dialer","concurrency","maxParallelDials","perPeerLimit","maxDialsPerPeer","timeout","dialTimeout","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","protocols","Object","values","handleMessage","connProtector","protector","process","undefined","env","LIBP2P_FORCE_PNET","Error","dht","DHT","_dht","mount","_onDiscoveryPeer","emit","eventName","args","_events","start","_onStarting","_onDidStart","err","stop","service","removeListener","Promise","all","Array","from","s","close","unmount","destroy","_isStarted","loadKeychain","findKeyByName","importPeer","isStarted","connections","dial","peer","options","dialProtocol","id","multiaddrs","get","connectToPeer","addressBook","newStream","filterMa","getNoAnnounceAddrs","getAddrs","concat","getAnnounceAddrs","filter","ma","index","array","findIndex","otherMa","equals","find","fm","hangUp","toB58String","map","handler","isArray","pushToPeerStore","unhandle","delete","listen","on","_maybeConnect","peers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","protoBook","peerDiscovery","autoDial","minPeers","size","setupService","DiscoveryService","tag","has","discoveryService","assign","getTransports","discovery","d","create","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst debug = require('debug')\nconst globalThis = require('ipfs-utils/src/globalthis')\nconst log = debug('libp2p')\nlog.error = debug('libp2p:error')\n\nconst PeerId = require('peer-id')\n\nconst peerRouting = require('./peer-routing')\nconst contentRouting = require('./content-routing')\nconst pubsub = require('./pubsub')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst Circuit = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PersistentPeerStore = require('./peer-store/persistent')\nconst Registrar = require('./registrar')\nconst ping = require('./ping')\nconst {\n  IdentifyService,\n  multicodecs: IDENTIFY_PROTOCOLS\n} = require('./identify')\n\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    this.peerStore = (this.datastore && this._options.peerStore.persistence)\n      ? new PersistentPeerStore({\n        datastore: this.datastore,\n        ...this._options.peerStore\n      })\n      : new PeerStore()\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this._options.addresses)\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager)\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics({\n        ...this._options.metrics,\n        connectionManager: this.connectionManager\n      })\n    }\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.pass && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        passPhrase: this._options.keychain.pass,\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (this._modules.connEncryption) {\n      const cryptos = this._modules.connEncryption\n      cryptos.forEach((crypto) => {\n        this.upgrader.cryptos.set(crypto.protocol, crypto)\n      })\n    }\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      concurrency: this._options.dialer.maxParallelDials,\n      perPeerLimit: this._options.dialer.maxDialsPerPeer,\n      timeout: this._options.dialer.dialTimeout\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({\n        libp2p: this,\n        protocols: this.upgrader.protocols\n      })\n      this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage)\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      this._dht = new DHT({\n        libp2p: this,\n        dialer: this.dialer,\n        peerId: this.peerId,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      })\n    }\n\n    // start pubsub\n    if (this._modules.pubsub) {\n      this.pubsub = pubsub(this, this._modules.pubsub, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = peerRouting(this)\n    this.contentRouting = contentRouting(this)\n\n    // Mount default protocols\n    ping.mount(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n  emit (eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args)\n    } else {\n      super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   * @async\n   * @returns {void}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.peerStore.stop()\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this._dht && this._dht.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.transportManager.close()\n\n      ping.unmount(this)\n      this.dialer.destroy()\n    } catch (err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    this._isStarted = false\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   * @async\n   * @returns {void}\n   */\n  async loadKeychain () {\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this.dialProtocol(peer, null, options)\n  }\n\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `Connection` will be returned\n   * @async\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection|*>}\n   */\n  async dialProtocol (peer, protocols, options) {\n    const { id, multiaddrs } = getPeer(peer, this.peerStore)\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    // If a protocol was provided, create a new stream\n    if (protocols) {\n      return connection.newStream(protocols)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get peer advertising multiaddrs by concating the addresses used\n   * by transports to listen with the announce addresses.\n   * Duplicated addresses and noAnnounce addresses are filtered out.\n   * @return {Array<Multiaddr>}\n   */\n  get multiaddrs () {\n    // Filter noAnnounce multiaddrs\n    const filterMa = this.addressManager.getNoAnnounceAddrs()\n\n    // Create advertising list\n    return this.transportManager.getAddrs()\n      .concat(this.addressManager.getAnnounceAddrs())\n      .filter((ma, index, array) => {\n        // Filter out if repeated\n        if (array.findIndex((otherMa) => otherMa.equals(ma)) !== index) {\n          return false\n        }\n\n        // Filter out if in noAnnounceMultiaddrs\n        if (filterMa.find((fm) => fm.equals(ma))) {\n          return false\n        }\n\n        return true\n      })\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   * @param {PeerId|multiaddr|string} peer the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   * @param {PeerId|Multiaddr|string} peer The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id } = getPeer(peer)\n\n    return ping(this, id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   * @param {string[]|string} protocols\n   * @param {function({ connection:*, stream:*, protocol:string })} handler\n   */\n  handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Only push if libp2p is running\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore)\n    }\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   * @param {string[]|string} protocols\n   */\n  unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Only push if libp2p is running\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore)\n    }\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports\n    await this.transportManager.listen()\n\n    // Start PeerStore\n    await this.peerStore.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.connectionManager.start()\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId)\n    })\n\n    // Once we start, emit and dial any peers we may have already discovered\n    for (const peer of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peer.id)\n      this._maybeConnect(peer.id)\n    }\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string> }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs)\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols)\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minPeers = this._options.connectionManager.minPeers || 0\n      if (minPeers > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (err) {\n          log.error('could not connect to discovered peer', err)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      if (Transport.discovery) {\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\n/**\n * Like `new Libp2p(options)` except it will create a `PeerId`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\nLibp2p.create = async function create (options = {}) {\n  if (options.peerId) {\n    return new Libp2p(options)\n  }\n\n  const peerId = await PeerId.create()\n\n  options.peerId = peerId\n  return new Libp2p(options)\n}\n\nmodule.exports = Libp2p\n"]},"metadata":{},"sourceType":"script"}