{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require$multihash = require('multihashing-async').multihash,\n    fromB58String = _require$multihash.fromB58String,\n    toB58String = _require$multihash.toB58String;\n\nvar PubsubDatastore = require('datastore-pubsub');\n\nvar withIs = require('class-is');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:pubsub');\nlog.error = debug('ipfs:ipns:pubsub:error'); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nvar IpnsPubsubDatastore = /*#__PURE__*/function () {\n  function IpnsPubsubDatastore(pubsub, localDatastore, peerId) {\n    _classCallCheck(this, IpnsPubsubDatastore);\n\n    this._pubsub = pubsub;\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(IpnsPubsubDatastore, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, value) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this._pubsubDs.put(key, value));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Get a value from the pubsub datastore indexed by the received key properly encoded.\n     * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n     * updated once new publishes occur.\n     * @param {Buffer} key identifier of the value to be obtained.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n        var res, err, ns, stringifiedTopic, id;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._pubsubDs.get(key);\n\n              case 3:\n                res = _context2.sent;\n                _context2.next = 9;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](0);\n                err = _context2.t0;\n\n              case 9:\n                // Add topic subscribed\n                ns = key.slice(0, ipns.namespaceLength);\n\n                if (ns.toString() === ipns.namespace) {\n                  stringifiedTopic = toB58String(key);\n                  id = toB58String(key.slice(ipns.namespaceLength));\n                  this._subscriptions[stringifiedTopic] = id;\n                  log(\"subscribed to pubsub topic \".concat(stringifiedTopic, \", id \").concat(id));\n                } // If no data was obtained, after storing the subscription, return the error.\n\n\n                if (!err) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                throw err;\n\n              case 13:\n                return _context2.abrupt(\"return\", res);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }() // Modify subscription key to have a proper encoding\n\n  }, {\n    key: \"_handleSubscriptionKey\",\n    value: function _handleSubscriptionKey(key) {\n      if (Buffer.isBuffer(key)) {\n        key = toB58String(key);\n      }\n\n      var subscriber = this._subscriptions[key];\n\n      if (!subscriber) {\n        throw errcode(new Error(\"key \".concat(key, \" does not correspond to a subscription\")), 'ERR_INVALID_KEY');\n      }\n\n      var keys;\n\n      try {\n        keys = ipns.getIdKeys(fromB58String(subscriber));\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n\n      return keys.routingKey.toBuffer();\n    }\n    /**\n     * Get pubsub subscriptions related to ipns.\n     * @param {function(Error, Object)} callback\n     * @returns {Array<Object>}\n     */\n\n  }, {\n    key: \"getSubscriptions\",\n    value: function getSubscriptions() {\n      var subscriptions = Object.values(this._subscriptions).filter(Boolean);\n      return subscriptions.map(function (sub) {\n        return \"\".concat(ipns.namespace).concat(sub);\n      });\n    }\n    /**\n     * Cancel pubsub subscriptions related to ipns.\n     * @param {String} name ipns path to cancel the pubsub subscription.\n     * @param {function(Error, Object)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {\n        var _this = this;\n\n        var stringifiedTopic, bufTopic;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(typeof name !== 'string')) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n\n              case 2:\n                // Trim /ipns/ prefix from the name\n                if (name.startsWith(ipns.namespace)) {\n                  name = name.substring(ipns.namespaceLength);\n                }\n\n                stringifiedTopic = Object.keys(this._subscriptions).find(function (key) {\n                  return _this._subscriptions[key] === name;\n                }); // Not found topic\n\n                if (stringifiedTopic) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  canceled: false\n                });\n\n              case 6:\n                // Unsubscribe topic\n                bufTopic = Buffer.from(stringifiedTopic);\n\n                this._pubsubDs.unsubscribe(bufTopic);\n\n                this._subscriptions[stringifiedTopic] = undefined;\n                log(\"unsubscribed pubsub \".concat(stringifiedTopic, \": \").concat(name));\n                return _context3.abrupt(\"return\", {\n                  canceled: true\n                });\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function cancel(_x4) {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }]);\n\n  return IpnsPubsubDatastore;\n}();\n\nexports = module.exports = withIs(IpnsPubsubDatastore, {\n  className: 'IpnsPubsubDatastore',\n  symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/ipns/routing/pubsub-datastore.js"],"names":["ipns","require","Buffer","multihash","fromB58String","toB58String","PubsubDatastore","withIs","errcode","debug","log","error","IpnsPubsubDatastore","pubsub","localDatastore","peerId","_pubsub","_subscriptions","_handleSubscriptionKey","bind","_pubsubDs","validator","key","value","put","get","res","err","ns","slice","namespaceLength","toString","namespace","stringifiedTopic","id","isBuffer","subscriber","Error","keys","getIdKeys","routingKey","toBuffer","subscriptions","Object","values","filter","Boolean","map","sub","name","startsWith","substring","find","canceled","bufTopic","from","unsubscribe","undefined","exports","module","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ipns = require('ipns')\nconst { Buffer } = require('buffer')\nconst { fromB58String, toB58String } = require('multihashing-async').multihash\nconst PubsubDatastore = require('datastore-pubsub')\n\nconst withIs = require('class-is')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:pubsub')\nlog.error = debug('ipfs:ipns:pubsub:error')\n\n// Pubsub datastore aims to manage the pubsub subscriptions for IPNS\nclass IpnsPubsubDatastore {\n  constructor (pubsub, localDatastore, peerId) {\n    this._pubsub = pubsub\n    this._subscriptions = {}\n\n    // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this)\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey)\n  }\n\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n  async put (key, value) { // eslint-disable-line require-await\n    return this._pubsubDs.put(key, value)\n  }\n\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   * @param {Buffer} key identifier of the value to be obtained.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n  async get (key) {\n    let res\n    let err\n\n    try {\n      res = await this._pubsubDs.get(key)\n    } catch (e) {\n      err = e\n    }\n\n    // Add topic subscribed\n    const ns = key.slice(0, ipns.namespaceLength)\n\n    if (ns.toString() === ipns.namespace) {\n      const stringifiedTopic = toB58String(key)\n      const id = toB58String(key.slice(ipns.namespaceLength))\n\n      this._subscriptions[stringifiedTopic] = id\n\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`)\n    }\n\n    // If no data was obtained, after storing the subscription, return the error.\n    if (err) {\n      throw err\n    }\n\n    return res\n  }\n\n  // Modify subscription key to have a proper encoding\n  _handleSubscriptionKey (key) {\n    if (Buffer.isBuffer(key)) {\n      key = toB58String(key)\n    }\n\n    const subscriber = this._subscriptions[key]\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY')\n    }\n\n    let keys\n    try {\n      keys = ipns.getIdKeys(fromB58String(subscriber))\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n\n    return keys.routingKey.toBuffer()\n  }\n\n  /**\n   * Get pubsub subscriptions related to ipns.\n   * @param {function(Error, Object)} callback\n   * @returns {Array<Object>}\n   */\n  getSubscriptions () {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean)\n\n    return subscriptions.map((sub) => `${ipns.namespace}${sub}`)\n  }\n\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   * @param {String} name ipns path to cancel the pubsub subscription.\n   * @param {function(Error, Object)} callback\n   * @returns {void}\n   */\n  async cancel (name) { // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME')\n    }\n\n    // Trim /ipns/ prefix from the name\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength)\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name)\n\n    // Not found topic\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      }\n    }\n\n    // Unsubscribe topic\n    const bufTopic = Buffer.from(stringifiedTopic)\n\n    this._pubsubDs.unsubscribe(bufTopic)\n\n    this._subscriptions[stringifiedTopic] = undefined\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`)\n\n    return {\n      canceled: true\n    }\n  }\n}\n\nexports = module.exports = withIs(IpnsPubsubDatastore, { className: 'IpnsPubsubDatastore', symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore' })\n"]},"metadata":{},"sourceType":"script"}