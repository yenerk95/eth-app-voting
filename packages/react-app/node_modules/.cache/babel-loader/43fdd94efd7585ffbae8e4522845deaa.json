{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ConsumableBuffer = require('./consumable-buffer');\n\nmodule.exports = function wrapHash(hashFn) {\n  return function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  };\n};\n\nvar InfiniteHash = /*#__PURE__*/function () {\n  function InfiniteHash(value, hashFn) {\n    _classCallCheck(this, InfiniteHash);\n\n    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n      throw new Error('can only hash strings or buffers');\n    }\n\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n    this._buffers = [];\n  }\n\n  _createClass(InfiniteHash, [{\n    key: \"take\",\n    value: function () {\n      var _take = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bits) {\n        var pendingBits, result, hash, available, took;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                pendingBits = bits;\n\n              case 1:\n                if (!(this._availableBits < pendingBits)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 4;\n                return this._produceMoreBits();\n\n              case 4:\n                _context.next = 1;\n                break;\n\n              case 6:\n                result = 0;\n\n                while (pendingBits > 0) {\n                  hash = this._buffers[this._currentBufferIndex];\n                  available = Math.min(hash.availableBits(), pendingBits);\n                  took = hash.take(available);\n                  result = (result << available) + took;\n                  pendingBits -= available;\n                  this._availableBits -= available;\n\n                  if (hash.availableBits() === 0) {\n                    this._currentBufferIndex++;\n                  }\n                }\n\n                return _context.abrupt(\"return\", result);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function take(_x) {\n        return _take.apply(this, arguments);\n      }\n\n      return take;\n    }()\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      var pendingBits = bits;\n\n      while (pendingBits > 0) {\n        var hash = this._buffers[this._currentBufferIndex];\n        var availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n        hash.untake(availableForUntake);\n        pendingBits -= availableForUntake;\n        this._availableBits += availableForUntake;\n\n        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n          this._depth--;\n          this._currentBufferIndex--;\n        }\n      }\n    }\n  }, {\n    key: \"_produceMoreBits\",\n    value: function () {\n      var _produceMoreBits2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var value, hashValue, buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._depth++;\n                value = this._depth ? this._value + this._depth : this._value;\n                _context2.next = 4;\n                return this._hashFn(value);\n\n              case 4:\n                hashValue = _context2.sent;\n                buffer = new ConsumableBuffer(hashValue);\n\n                this._buffers.push(buffer);\n\n                this._availableBits += buffer.availableBits();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _produceMoreBits() {\n        return _produceMoreBits2.apply(this, arguments);\n      }\n\n      return _produceMoreBits;\n    }()\n  }]);\n\n  return InfiniteHash;\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/hamt-sharding/src/consumable-hash.js"],"names":["ConsumableBuffer","require","module","exports","wrapHash","hashFn","hashing","value","InfiniteHash","Buffer","isBuffer","Error","_value","_hashFn","_depth","_availableBits","_currentBufferIndex","_buffers","bits","pendingBits","_produceMoreBits","result","hash","available","Math","min","availableBits","took","take","availableForUntake","totalBits","untake","hashValue","buffer","push"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ConsumableBuffer = require('./consumable-buffer')\n\nmodule.exports = function wrapHash (hashFn) {\n  return function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n}\n\nclass InfiniteHash {\n  constructor (value, hashFn) {\n    if ((typeof value) !== 'string' && !Buffer.isBuffer(value)) {\n      throw new Error('can only hash strings or buffers')\n    }\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? this._value + this._depth : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}