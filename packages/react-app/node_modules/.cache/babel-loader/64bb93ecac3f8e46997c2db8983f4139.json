{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('peer-id'),\n    createFromPrivKey = _require.createFromPrivKey;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns');\nlog.error = debug('ipfs:ipns:error');\n\nvar IpnsPublisher = require('./publisher');\n\nvar IpnsRepublisher = require('./republisher');\n\nvar IpnsResolver = require('./resolver');\n\nvar _require2 = require('../utils'),\n    normalizePath = _require2.normalizePath;\n\nvar TLRU = require('../../utils/tlru');\n\nvar defaultRecordTtl = 60 * 1000;\n\nvar IPNS = /*#__PURE__*/function () {\n  function IPNS(routing, datastore, peerId, keychain, options) {\n    _classCallCheck(this, IPNS);\n\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  } // Publish\n\n\n  _createClass(IPNS, [{\n    key: \"publish\",\n    value: function () {\n      var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privKey, value) {\n        var lifetime,\n            peerId,\n            id,\n            ttEol,\n            ttl,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                lifetime = _args.length > 2 && _args[2] !== undefined ? _args[2] : IpnsPublisher.defaultRecordLifetime;\n                _context.prev = 1;\n                value = normalizePath(value);\n                _context.next = 5;\n                return createFromPrivKey(privKey.bytes);\n\n              case 5:\n                peerId = _context.sent;\n                _context.next = 8;\n                return this.publisher.publishWithEOL(privKey, value, lifetime);\n\n              case 8:\n                log(\"IPNS value \".concat(value, \" was published correctly\")); // // Add to cache\n\n                id = peerId.toB58String();\n                ttEol = parseFloat(lifetime);\n                ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n                this.cache.set(id, value, ttl);\n                log(\"IPNS value \".concat(value, \" was cached correctly\"));\n                return _context.abrupt(\"return\", {\n                  name: id,\n                  value: value\n                });\n\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](1);\n                log.error(_context.t0);\n                throw _context.t0;\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 17]]);\n      }));\n\n      function publish(_x, _x2) {\n        return _publish.apply(this, arguments);\n      }\n\n      return publish;\n    }() // Resolve\n\n  }, {\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, options) {\n        var id, result, _result;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof name !== 'string')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n\n              case 2:\n                options = options || {}; // If recursive, we should not try to get the cached value\n\n                if (!(!options.nocache && !options.recursive)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Try to get the record from cache\n                id = name.split('/')[2];\n                result = this.cache.get(id);\n\n                if (!result) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this.resolver.resolve(name, options);\n\n              case 11:\n                _result = _context2.sent;\n                log(\"IPNS record from \".concat(name, \" was resolved correctly\"));\n                return _context2.abrupt(\"return\", _result);\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](8);\n                log.error(_context2.t0);\n                throw _context2.t0;\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 16]]);\n      }));\n\n      function resolve(_x3, _x4) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }() // Initialize keyspace\n    // sets the ipns record for the given key to point to an empty directory\n\n  }, {\n    key: \"initializeKeyspace\",\n    value: function () {\n      var _initializeKeyspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(privKey, value) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function initializeKeyspace(_x5, _x6) {\n        return _initializeKeyspace.apply(this, arguments);\n      }\n\n      return initializeKeyspace;\n    }()\n  }]);\n\n  return IPNS;\n}();\n\nmodule.exports = IPNS;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/ipns/index.js"],"names":["require","createFromPrivKey","errcode","debug","log","error","IpnsPublisher","IpnsRepublisher","IpnsResolver","normalizePath","TLRU","defaultRecordTtl","IPNS","routing","datastore","peerId","keychain","options","publisher","republisher","resolver","cache","privKey","value","lifetime","defaultRecordLifetime","bytes","publishWithEOL","id","toB58String","ttEol","parseFloat","ttl","set","name","Error","nocache","recursive","split","result","get","resolve","publish","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { createFromPrivKey } = require('peer-id')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns')\nlog.error = debug('ipfs:ipns:error')\n\nconst IpnsPublisher = require('./publisher')\nconst IpnsRepublisher = require('./republisher')\nconst IpnsResolver = require('./resolver')\nconst { normalizePath } = require('../utils')\nconst TLRU = require('../../utils/tlru')\nconst defaultRecordTtl = 60 * 1000\n\nclass IPNS {\n  constructor (routing, datastore, peerId, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore)\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options)\n    this.resolver = new IpnsResolver(routing)\n    this.cache = new TLRU(1000)\n    this.routing = routing\n  }\n\n  // Publish\n  async publish (privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    try {\n      value = normalizePath(value)\n\n      const peerId = await createFromPrivKey(privKey.bytes)\n      await this.publisher.publishWithEOL(privKey, value, lifetime)\n\n      log(`IPNS value ${value} was published correctly`)\n\n      // // Add to cache\n      const id = peerId.toB58String()\n      const ttEol = parseFloat(lifetime)\n      const ttl = (ttEol < defaultRecordTtl) ? ttEol : defaultRecordTtl\n\n      this.cache.set(id, value, ttl)\n\n      log(`IPNS value ${value} was cached correctly`)\n\n      return {\n        name: id,\n        value: value\n      }\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  // Resolve\n  async resolve (name, options) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME')\n    }\n\n    options = options || {}\n\n    // If recursive, we should not try to get the cached value\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2]\n      const result = this.cache.get(id)\n\n      if (result) {\n        return result\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options)\n\n      log(`IPNS record from ${name} was resolved correctly`)\n\n      return result\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n  }\n\n  // Initialize keyspace\n  // sets the ipns record for the given key to point to an empty directory\n  async initializeKeyspace (privKey, value) { // eslint-disable-line require-await\n    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime)\n  }\n}\n\nmodule.exports = IPNS\n"]},"metadata":{},"sourceType":"script"}