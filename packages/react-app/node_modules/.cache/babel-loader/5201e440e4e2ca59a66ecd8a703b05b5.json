{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar mortice = require('mortice');\n\nvar lock;\n\nmodule.exports = function (repoOwner) {\n  if (lock) {\n    return lock;\n  }\n\n  var mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  });\n  lock = {\n    readLock: function readLock(func) {\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var releaseLock,\n            _len,\n            args,\n            _key,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return mutex.readLock();\n\n              case 2:\n                releaseLock = _context.sent;\n                _context.prev = 3;\n\n                for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = _args[_key];\n                }\n\n                _context.next = 7;\n                return func.apply(null, args);\n\n              case 7:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 8:\n                _context.prev = 8;\n                releaseLock();\n                return _context.finish(8);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3,, 8, 11]]);\n      }));\n    },\n    writeLock: function writeLock(func) {\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var releaseLock,\n            _len2,\n            args,\n            _key2,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return mutex.writeLock();\n\n              case 2:\n                releaseLock = _context2.sent;\n                _context2.prev = 3;\n\n                for (_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = _args2[_key2];\n                }\n\n                _context2.next = 7;\n                return func.apply(null, args);\n\n              case 7:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 8:\n                _context2.prev = 8;\n                releaseLock();\n                return _context2.finish(8);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[3,, 8, 11]]);\n      }));\n    }\n  };\n  return lock;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/utils/create-lock.js"],"names":["mortice","require","lock","module","exports","repoOwner","mutex","singleProcess","readLock","func","releaseLock","args","apply","writeLock"],"mappings":"AAAA;;;;;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AAEA,IAAIC,IAAJ;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAACC,SAAD,EAAe;AAC9B,MAAIH,IAAJ,EAAU;AACR,WAAOA,IAAP;AACD;;AAED,MAAMI,KAAK,GAAGN,OAAO,CAAC;AACpB;AACA;AACA;AACAO,IAAAA,aAAa,EAAEF;AAJK,GAAD,CAArB;AAOAH,EAAAA,IAAI,GAAG;AACLM,IAAAA,QAAQ,EAAE,kBAACC,IAAD,EAAU;AAClB,mFAAO;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACqBH,KAAK,CAACE,QAAN,EADrB;;AAAA;AACCE,gBAAAA,WADD;AAAA;;AAAA,0CAAUC,IAAV;AAAUA,kBAAAA,IAAV;AAAA;;AAAA;AAAA,uBAIUF,IAAI,CAACG,KAAL,CAAW,IAAX,EAAiBD,IAAjB,CAJV;;AAAA;AAAA;;AAAA;AAAA;AAMHD,gBAAAA,WAAW;AANR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAP;AASD,KAXI;AAaLG,IAAAA,SAAS,EAAE,mBAACJ,IAAD,EAAU;AACnB,mFAAO;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACqBH,KAAK,CAACO,SAAN,EADrB;;AAAA;AACCH,gBAAAA,WADD;AAAA;;AAAA,4CAAUC,IAAV;AAAUA,kBAAAA,IAAV;AAAA;;AAAA;AAAA,uBAIUF,IAAI,CAACG,KAAL,CAAW,IAAX,EAAiBD,IAAjB,CAJV;;AAAA;AAAA;;AAAA;AAAA;AAMHD,gBAAAA,WAAW;AANR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAP;AASD;AAvBI,GAAP;AA0BA,SAAOR,IAAP;AACD,CAvCD","sourcesContent":["'use strict'\n\nconst mortice = require('mortice')\n\nlet lock\n\nmodule.exports = (repoOwner) => {\n  if (lock) {\n    return lock\n  }\n\n  const mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  })\n\n  lock = {\n    readLock: (func) => {\n      return async (...args) => {\n        const releaseLock = await mutex.readLock()\n\n        try {\n          return await func.apply(null, args)\n        } finally {\n          releaseLock()\n        }\n      }\n    },\n\n    writeLock: (func) => {\n      return async (...args) => {\n        const releaseLock = await mutex.writeLock()\n\n        try {\n          return await func.apply(null, args)\n        } finally {\n          releaseLock()\n        }\n      }\n    }\n  }\n\n  return lock\n}\n"]},"metadata":{},"sourceType":"script"}