{"ast":null,"code":"'use strict';\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashing-async').multihash;\n\nconst pipe = require('it-pipe');\n\nconst importer = require('ipfs-unixfs-importer');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst last = require('it-last');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst persist = require('ipfs-unixfs-importer/src/utils/persist');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false,\n  signal: undefined\n};\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n} // https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [_, // eslint-disable-line no-unused-vars\n  references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n}\n\nfunction calculateMode(mode, metadata) {\n  if (typeof mode === 'string' || mode instanceof String) {\n    if (mode.match(/^\\d+$/g)) {\n      mode = parseInt(mode, 8);\n    } else {\n      mode = mode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode);\n    }\n  }\n\n  return mode;\n}\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsChmod(path, mode, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, options);\n\n    if (cid.codec !== 'dag-pb') {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n\n    if (options.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of exporter.recursive(cid, context.ipld)) {\n          let node = await context.ipld.get(entry.cid);\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          node = new DAGNode(entry.unixfs.marshal(), node.Links);\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, source => importer(source, context.block, { ...options,\n        pin: false,\n        dagBuilder: async function* (source, block, options) {\n          for await (const entry of source) {\n            yield async function () {\n              const cid = await persist(entry.content.serialize(), block, options);\n              return {\n                cid,\n                path: entry.path,\n                unixfs: UnixFS.unmarshal(entry.content.Data),\n                node: entry.content\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes)); // remove old path from mfs\n\n      await rm(context)(path, options); // add newly created tree to mfs at path\n\n      await cp(context)(`/ipfs/${root.cid}`, path, options);\n      return;\n    }\n\n    let node = await context.ipld.get(cid);\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    node = new DAGNode(metadata.marshal(), node.Links);\n    const updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n      cidVersion: cid.version,\n      hashAlg: mh.names[options.hashAlg],\n      onlyHash: !options.flush\n    });\n    const trail = await toTrail(context, mfsDirectory, options);\n    const parent = trail[trail.length - 1];\n    const parentNode = await context.ipld.get(parent.cid);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: node.serialize().length,\n      flush: options.flush,\n      hashAlg: options.hashAlg,\n      cidVersion: cid.version\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, options);\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/chmod.js"],"names":["applyDefaultOptions","require","toMfsPath","log","errCode","UnixFS","toTrail","addLink","updateTree","updateMfsRoot","DAGNode","mc","mh","multihash","pipe","importer","exporter","last","cp","rm","persist","withTimeoutOption","defaultOptions","flush","shardSplitThreshold","hashAlg","cidVersion","recursive","signal","undefined","calculateModification","mode","originalMode","isDirectory","modification","includes","calculateUGO","references","ugo","calculateSpecial","parseInt","parseSymbolicMode","input","match","Error","_","operator","calculateMode","metadata","String","split","reduce","curr","acc","module","exports","context","mfsChmod","path","options","cid","mfsDirectory","name","codec","root","entry","ipld","node","get","unixfs","marshal","Links","content","source","block","pin","dagBuilder","serialize","unmarshal","Data","nodes","updatedCid","put","DAG_PB","version","names","onlyHash","trail","parent","length","parentNode","result","size","newRootCid"],"mappings":"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","sourcesContent":["'use strict'\n\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst log = require('debug')('ipfs:mfs:touch')\nconst errCode = require('err-code')\nconst UnixFS = require('ipfs-unixfs')\nconst toTrail = require('./utils/to-trail')\nconst addLink = require('./utils/add-link')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst { DAGNode } = require('ipld-dag-pb')\nconst mc = require('multicodec')\nconst mh = require('multihashing-async').multihash\nconst pipe = require('it-pipe')\nconst importer = require('ipfs-unixfs-importer')\nconst exporter = require('ipfs-unixfs-exporter')\nconst last = require('it-last')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst persist = require('ipfs-unixfs-importer/src/utils/persist')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false,\n  signal: undefined\n}\n\nfunction calculateModification (mode, originalMode, isDirectory) {\n  let modification = 0\n\n  if (mode.includes('x') || (mode.includes('X') && (isDirectory || (originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)))) {\n    modification += 1\n  }\n\n  if (mode.includes('w')) {\n    modification += 2\n  }\n\n  if (mode.includes('r')) {\n    modification += 4\n  }\n\n  return modification\n}\n\nfunction calculateUGO (references, modification) {\n  let ugo = 0\n\n  if (references.includes('u')) {\n    ugo += (modification << 6)\n  }\n\n  if (references.includes('g')) {\n    ugo += (modification << 3)\n  }\n\n  if (references.includes('o')) {\n    ugo += (modification)\n  }\n\n  return ugo\n}\n\nfunction calculateSpecial (references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8)\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8)\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8)\n    }\n  }\n\n  return modification\n}\n\n// https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\nfunction parseSymbolicMode (input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/)\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`)\n  }\n\n  let [\n    _, // eslint-disable-line no-unused-vars\n    references,\n    operator,\n    mode\n  ] = match\n\n  if (references === 'a' || !references) {\n    references = 'ugo'\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory)\n  modification = calculateUGO(references, modification)\n  modification = calculateSpecial(references, mode, modification)\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8)\n\n      // or them together\n      originalMode = originalMode | modification\n    }\n\n    return originalMode\n  }\n\n  if (operator === '+') {\n    return modification | originalMode\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode\n  }\n}\n\nfunction calculateMode (mode, metadata) {\n  if (typeof mode === 'string' || mode instanceof String) {\n    if (mode.match(/^\\d+$/g)) {\n      mode = parseInt(mode, 8)\n    } else {\n      mode = mode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory())\n      }, metadata.mode)\n    }\n  }\n\n  return mode\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsChmod (path, mode, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    log(`Fetching stats for ${path}`)\n\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path, options)\n\n    if (cid.codec !== 'dag-pb') {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS')\n    }\n\n    if (options.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(\n        async function * () {\n          for await (const entry of exporter.recursive(cid, context.ipld)) {\n            let node = await context.ipld.get(entry.cid)\n            entry.unixfs.mode = calculateMode(mode, entry.unixfs)\n            node = new DAGNode(entry.unixfs.marshal(), node.Links)\n\n            yield {\n              path: entry.path,\n              content: node\n            }\n          }\n        },\n        (source) => importer(source, context.block, {\n          ...options,\n          pin: false,\n          dagBuilder: async function * (source, block, options) {\n            for await (const entry of source) {\n              yield async function () {\n                const cid = await persist(entry.content.serialize(), block, options)\n\n                return {\n                  cid,\n                  path: entry.path,\n                  unixfs: UnixFS.unmarshal(entry.content.Data),\n                  node: entry.content\n                }\n              }\n            }\n          }\n        }),\n        (nodes) => last(nodes)\n      )\n\n      // remove old path from mfs\n      await rm(context)(path, options)\n\n      // add newly created tree to mfs at path\n      await cp(context)(`/ipfs/${root.cid}`, path, options)\n\n      return\n    }\n\n    let node = await context.ipld.get(cid)\n    const metadata = UnixFS.unmarshal(node.Data)\n    metadata.mode = calculateMode(mode, metadata)\n    node = new DAGNode(metadata.marshal(), node.Links)\n\n    const updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n      cidVersion: cid.version,\n      hashAlg: mh.names[options.hashAlg],\n      onlyHash: !options.flush\n    })\n\n    const trail = await toTrail(context, mfsDirectory, options)\n    const parent = trail[trail.length - 1]\n    const parentNode = await context.ipld.get(parent.cid)\n\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: node.serialize().length,\n      flush: options.flush,\n      hashAlg: options.hashAlg,\n      cidVersion: cid.version\n    })\n\n    parent.cid = result.cid\n\n    // update the tree with the new child\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}