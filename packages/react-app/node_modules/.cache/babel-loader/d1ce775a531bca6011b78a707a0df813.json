{"ast":null,"code":"'use strict';\n\nconst mkdir = require('./mkdir');\n\nconst stat = require('./stat');\n\nconst log = require('debug')('ipfs:mfs:cp');\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst addLink = require('./utils/add-link');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination');\n\nconst toTrail = require('./utils/to-trail');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  signal: undefined\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsCp(...args) {\n    let {\n      sources,\n      destination,\n      options\n    } = await toSourcesAndDestination(context, args, defaultOptions);\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n    }\n\n    options.parents = options.p || options.parents; // make sure all sources exist\n\n    const missing = sources.find(source => !source.exists);\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS');\n    }\n\n    const destinationIsDirectory = isDirectory(destination);\n\n    if (destination.exists) {\n      log('Destination exists');\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n      }\n    } else {\n      log('Destination does not exist');\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n        }\n\n        await mkdir(context)(destination.path, options);\n        destination = await toMfsPath(context, destination.path, options);\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`;\n\n        try {\n          await stat(context)(parentFolder, options);\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err;\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          }\n\n          await mkdir(context)(parentFolder, options);\n          destination = await toMfsPath(context, destination.path, options);\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n    const trail = await toTrail(context, destinationPath, options);\n\n    if (sources.length === 1) {\n      const source = sources.pop();\n      const destinationName = destinationIsDirectory ? source.name : destination.name;\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`);\n      return copyToFile(context, source, destinationName, trail, options);\n    }\n\n    log('Multiple sources, wrapping in a directory');\n    return copyToDirectory(context, sources, destination, trail, options);\n  });\n};\n\nconst isDirectory = destination => {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop();\n  parent = await addSourceToParent(context, source, destination, parent, options); // update the tree with the new containing directory\n\n  destinationTrail.push(parent);\n  const newRootCid = await updateTree(context, destinationTrail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    destination = await addSourceToParent(context, source, source.name, destination, options);\n  } // update the tree with the new containing directory\n\n\n  destinationTrail[destinationTrail.length - 1] = destination;\n  const newRootCid = await updateTree(context, destinationTrail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid);\n  const {\n    node,\n    cid\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  });\n  parent.node = node;\n  parent.cid = cid;\n  parent.size = node.size;\n  return parent;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/cp.js"],"names":["mkdir","require","stat","log","errCode","updateTree","updateMfsRoot","addLink","toMfsPath","toSourcesAndDestination","toTrail","withTimeoutOption","defaultOptions","parents","flush","hashAlg","cidVersion","shardSplitThreshold","signal","undefined","module","exports","context","mfsCp","args","sources","destination","options","length","Error","p","missing","find","source","exists","path","destinationIsDirectory","isDirectory","parts","parentFolder","slice","join","err","code","destinationPath","mfsPath","mfsDirectory","trail","pop","destinationName","name","copyToFile","copyToDirectory","unixfs","type","includes","destinationTrail","parent","addSourceToParent","push","newRootCid","i","childName","sourceBlock","repo","blocks","get","cid","node","parentCid","size","data"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mkdir = require('./mkdir')\nconst stat = require('./stat')\nconst log = require('debug')('ipfs:mfs:cp')\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst addLink = require('./utils/add-link')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination')\nconst toTrail = require('./utils/to-trail')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsCp (...args) {\n    let {\n      sources,\n      destination,\n      options\n    } = await toSourcesAndDestination(context, args, defaultOptions)\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')\n    }\n\n    options.parents = options.p || options.parents\n\n    // make sure all sources exist\n    const missing = sources.find(source => !source.exists)\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')\n    }\n\n    const destinationIsDirectory = isDirectory(destination)\n\n    if (destination.exists) {\n      log('Destination exists')\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')\n      }\n    } else {\n      log('Destination does not exist')\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n        }\n\n        await mkdir(context)(destination.path, options)\n        destination = await toMfsPath(context, destination.path, options)\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`\n\n        try {\n          await stat(context)(parentFolder, options)\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n          }\n\n          await mkdir(context)(parentFolder, options)\n          destination = await toMfsPath(context, destination.path, options)\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory\n    const trail = await toTrail(context, destinationPath, options)\n\n    if (sources.length === 1) {\n      const source = sources.pop()\n      const destinationName = destinationIsDirectory ? source.name : destination.name\n\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)\n\n      return copyToFile(context, source, destinationName, trail, options)\n    }\n\n    log('Multiple sources, wrapping in a directory')\n    return copyToDirectory(context, sources, destination, trail, options)\n  })\n}\n\nconst isDirectory = (destination) => {\n  return destination.unixfs &&\n    destination.unixfs.type &&\n    destination.unixfs.type.includes('directory')\n}\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop()\n\n  parent = await addSourceToParent(context, source, destination, parent, options)\n\n  // update the tree with the new containing directory\n  destinationTrail.push(parent)\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n\n    destination = await addSourceToParent(context, source, source.name, destination, options)\n  }\n\n  // update the tree with the new containing directory\n  destinationTrail[destinationTrail.length - 1] = destination\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid)\n\n  const {\n    node,\n    cid\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  })\n\n  parent.node = node\n  parent.cid = cid\n  parent.size = node.size\n\n  return parent\n}\n"]},"metadata":{},"sourceType":"script"}