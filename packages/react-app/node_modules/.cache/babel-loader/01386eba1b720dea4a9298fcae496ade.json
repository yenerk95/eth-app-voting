{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\n\n\nvar libp2p_pubsub_1 = require(\"libp2p-pubsub\");\n\nvar messageCache_1 = require(\"./messageCache\");\n\nvar message_1 = require(\"./message\");\n\nvar constants = __importStar(require(\"./constants\"));\n\nvar heartbeat_1 = require(\"./heartbeat\");\n\nvar getGossipPeers_1 = require(\"./getGossipPeers\");\n\nvar utils_1 = require(\"./utils\"); // @ts-ignore\n\n\nvar TimeCache = require(\"time-cache\");\n\nvar BasicPubsub = require(\"./pubsub\");\n\nvar Gossipsub = /*#__PURE__*/function (_BasicPubsub) {\n  _inherits(Gossipsub, _BasicPubsub);\n\n  var _super2 = _createSuper(Gossipsub);\n\n  /**\n   * @param {PeerId} peerId instance of the peer's PeerId\n   * @param {Object} registrar\n   * @param {function} registrar.handle\n   * @param {function} registrar.register\n   * @param {function} registrar.unregister\n   * @param {Object} [options]\n   * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @param {function} [options.msgIdFn] override the default message id function\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @constructor\n   */\n  function Gossipsub(peerId, registrar) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Gossipsub);\n\n    var multicodecs = [constants.GossipsubID];\n\n    var _options = Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true\n    }, options); // Also wants to get notified of peers connected using floodsub\n\n\n    if (_options.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodSubID);\n    }\n\n    _this = _super2.call(this, {\n      debugName: 'libp2p:gossipsub',\n      multicodecs: multicodecs,\n      peerId: peerId,\n      registrar: registrar,\n      options: _options\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    _this.seenCache = new TimeCache();\n    /**\n     * Map of topic meshes\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    _this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    _this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     *\n     * @type {Map<string, Number>}\n     */\n\n    _this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     *\n     * @type {Map<Peer, Array<ControlIHave object>> }\n     */\n\n    _this.gossip = new Map();\n    /**\n     * Map of control messages\n     *\n     * @type {Map<Peer, ControlMessage object>}\n     */\n\n    _this.control = new Map();\n    /**\n     * Use the overriden mesgIdFn or the default one.\n     */\n\n    _this._msgIdFn = options.msgIdFn || _this.defaultMsgIdFn;\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    _this.messageCache = options.messageCache || new messageCache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, _this._msgIdFn);\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    _this.heartbeat = new heartbeat_1.Heartbeat(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {Peer} peer\n   * @returns {Peer}\n   */\n\n\n  _createClass(Gossipsub, [{\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"_removePeer\", this).call(this, peer); // Remove this peer from the mesh\n      // eslint-disable-next-line no-unused-vars\n\n\n      var _iterator = _createForOfIteratorHelper(this.mesh.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var peers = _step.value;\n          peers.delete(peer);\n        } // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.fanout.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _peers = _step2.value;\n\n          _peers.delete(peer);\n        } // Remove from gossip mapping\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.gossip.delete(peer); // Remove from control mapping\n\n      this.control.delete(peer);\n      return peer;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {Peer} peer\n     * @param {RPC} rpc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_processRpc\",\n    value: function _processRpc(idB58Str, peer, rpc) {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"_processRpc\", this).call(this, idB58Str, peer, rpc);\n\n      if (rpc.control) {\n        this._processRpcControlMessage(peer, rpc.control);\n      }\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {Peer} peer\n     * @param {ControlMessage} controlMsg\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_processRpcControlMessage\",\n    value: function _processRpcControlMessage(peer, controlMsg) {\n      if (!controlMsg) {\n        return;\n      }\n\n      var iwant = this._handleIHave(peer, controlMsg.ihave);\n\n      var ihave = this._handleIWant(peer, controlMsg.iwant);\n\n      var prune = this._handleGraft(peer, controlMsg.graft);\n\n      this._handlePrune(peer, controlMsg.prune);\n\n      if (!iwant || !ihave || !prune) {\n        return;\n      }\n\n      var outRpc = utils_1.createGossipRpc(ihave, {\n        iwant: [iwant],\n        prune: prune\n      });\n\n      this._sendRpc(peer, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {Peer} peer\n     * @param {Message} msg\n     */\n\n  }, {\n    key: \"_processRpcMessage\",\n    value: function _processRpcMessage(peer, msg) {\n      var _this2 = this;\n\n      var msgID = this.getMsgId(msg); // Ignore if we've already seen the message\n\n      if (this.seenCache.has(msgID)) {\n        return;\n      }\n\n      this.seenCache.put(msgID);\n\n      _get(_getPrototypeOf(Gossipsub.prototype), \"_processRpcMessage\", this).call(this, peer, msg);\n\n      var topics = msg.topicIDs; // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n\n      if (!this._options.gossipIncoming) {\n        return;\n      } // Emit to floodsub peers\n\n\n      this.peers.forEach(function (peer) {\n        if (peer.protocols.includes(constants.FloodSubID) && peer.id.toB58String() !== msg.from && libp2p_pubsub_1.utils.anyMatch(peer.topics, topics) && peer.isWritable) {\n          peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n\n          _this2.log('publish msg on topics - floodsub', topics, peer.id.toB58String());\n        }\n      }); // Emit to peers in the mesh\n\n      topics.forEach(function (topic) {\n        var meshPeers = _this2.mesh.get(topic);\n\n        if (!meshPeers) {\n          return;\n        }\n\n        meshPeers.forEach(function (peer) {\n          if (!peer.isWritable || peer.id.toB58String() === msg.from) {\n            return;\n          }\n\n          peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n\n          _this2.log('publish msg on topic - meshsub', topic, peer.id.toB58String());\n        });\n      });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {Peer} peer\n     * @param {Array<ControlIHave>} ihave\n     * @returns {ControlIWant}\n     */\n\n  }, {\n    key: \"_handleIHave\",\n    value: function _handleIHave(peer, ihave) {\n      var _this3 = this;\n\n      var iwant = new Set();\n      ihave.forEach(function (_ref) {\n        var topicID = _ref.topicID,\n            messageIDs = _ref.messageIDs;\n\n        if (!topicID || !_this3.mesh.has(topicID)) {\n          return;\n        }\n\n        messageIDs.forEach(function (msgID) {\n          if (_this3.seenCache.has(msgID)) {\n            return;\n          }\n\n          iwant.add(msgID);\n        });\n      });\n\n      if (!iwant.size) {\n        return;\n      }\n\n      this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.id.toB58String());\n      return {\n        messageIDs: Array.from(iwant)\n      };\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {Peer} peer\n     * @param {Array<ControlIWant>} iwant\n     * @returns {Array<Message>}\n     */\n\n  }, {\n    key: \"_handleIWant\",\n    value: function _handleIWant(peer, iwant) {\n      var _this4 = this;\n\n      // @type {Map<string, Message>}\n      var ihave = new Map();\n      iwant.forEach(function (_ref2) {\n        var messageIDs = _ref2.messageIDs;\n        messageIDs.forEach(function (msgID) {\n          var msg = _this4.messageCache.get(msgID);\n\n          if (msg) {\n            ihave.set(msgID, msg);\n          }\n        });\n      });\n\n      if (!ihave.size) {\n        return;\n      }\n\n      this.log('IWANT: Sending %d messages to %s', ihave.size, peer.id.toB58String());\n      return Array.from(ihave.values());\n    }\n    /**\n     * Handles Graft messages\n     * @param {Peer} peer\n     * @param {Array<ControlGraft>} graft\n     * @return {Array<ControlPrune>}\n     */\n\n  }, {\n    key: \"_handleGraft\",\n    value: function _handleGraft(peer, graft) {\n      var _this5 = this;\n\n      var prune = [];\n      graft.forEach(function (_ref3) {\n        var topicID = _ref3.topicID;\n\n        if (!topicID) {\n          return;\n        }\n\n        var peers = _this5.mesh.get(topicID);\n\n        if (!peers) {\n          prune.push(topicID);\n        } else {\n          _this5.log('GRAFT: Add mesh link from %s in %s', peer.id.toB58String(), topicID);\n\n          peers.add(peer);\n          peer.topics.add(topicID);\n\n          _this5.mesh.set(topicID, peers);\n        }\n      });\n\n      if (!prune.length) {\n        return;\n      }\n\n      var buildCtrlPruneMsg = function buildCtrlPruneMsg(topic) {\n        return {\n          topicID: topic\n        };\n      };\n\n      return prune.map(buildCtrlPruneMsg);\n    }\n    /**\n     * Handles Prune messages\n     * @param {Peer} peer\n     * @param {Array<ControlPrune>} prune\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handlePrune\",\n    value: function _handlePrune(peer, prune) {\n      var _this6 = this;\n\n      prune.forEach(function (_ref4) {\n        var topicID = _ref4.topicID;\n\n        if (!topicID) {\n          return;\n        }\n\n        var peers = _this6.mesh.get(topicID);\n\n        if (peers) {\n          _this6.log('PRUNE: Remove mesh link to %s in %s', peer.id.toB58String(), topicID);\n\n          peers.delete(peer);\n          peer.topics.delete(topicID);\n        }\n      });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this7 = this;\n\n      var _super = Object.create(null, {\n        start: {\n          get: function get() {\n            return _get(_getPrototypeOf(Gossipsub.prototype), \"start\", _this7);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _super.start.call(this);\n\n              case 2:\n                this.heartbeat.start();\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this8 = this;\n\n      var _super = Object.create(null, {\n        stop: {\n          get: function get() {\n            return _get(_getPrototypeOf(Gossipsub.prototype), \"stop\", _this8);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _super.stop.call(this);\n\n              case 2:\n                this.heartbeat.stop();\n                this.mesh = new Map();\n                this.fanout = new Map();\n                this.lastpub = new Map();\n                this.gossip = new Map();\n                this.control = new Map();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Subscribes to topics\n     *\n     * @override\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(topics) {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"_subscribe\", this).call(this, topics);\n\n      this.join(topics);\n    }\n    /**\n     * Unsubscribes to topics\n     *\n     * @override\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe(topics) {\n      _get(_getPrototypeOf(Gossipsub.prototype), \"_unsubscribe\", this).call(this, topics);\n\n      this.leave(topics);\n    }\n    /**\n     * Join topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(topics) {\n      var _this9 = this;\n\n      if (!this.started) {\n        throw new Error('Gossipsub has not started');\n      }\n\n      topics = libp2p_pubsub_1.utils.ensureArray(topics);\n      this.log('JOIN %s', topics);\n      topics.forEach(function (topic) {\n        // Send GRAFT to mesh peers\n        var fanoutPeers = _this9.fanout.get(topic);\n\n        if (fanoutPeers) {\n          _this9.mesh.set(topic, fanoutPeers);\n\n          _this9.fanout.delete(topic);\n\n          _this9.lastpub.delete(topic);\n        } else {\n          var peers = getGossipPeers_1.getGossipPeers(_this9, topic, constants.GossipsubD);\n\n          _this9.mesh.set(topic, peers);\n        }\n\n        _this9.mesh.get(topic).forEach(function (peer) {\n          _this9.log('JOIN: Add mesh link to %s in %s', peer.id.toB58String(), topic);\n\n          _this9._sendGraft(peer, topic);\n        });\n      });\n    }\n    /**\n     * Leave topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(topics) {\n      var _this10 = this;\n\n      topics = libp2p_pubsub_1.utils.ensureArray(topics);\n      this.log('LEAVE %s', topics);\n      topics.forEach(function (topic) {\n        // Send PRUNE to mesh peers\n        var meshPeers = _this10.mesh.get(topic);\n\n        if (meshPeers) {\n          meshPeers.forEach(function (peer) {\n            _this10.log('LEAVE: Remove mesh link to %s in %s', peer.id.toB58String(), topic);\n\n            _this10._sendPrune(peer, topic);\n          });\n\n          _this10.mesh.delete(topic);\n        }\n      });\n    }\n    /**\n     * Override the default implementation in BasicPubSub.\n     * If we don't provide msgIdFn in constructor option, it's the same.\n     * @override\n     * @param {Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n  }, {\n    key: \"getMsgId\",\n    value: function getMsgId(msg) {\n      return this._msgIdFn(msg);\n    }\n    /**\n     * Publish messages\n     *\n     * Note: this function assumes all messages are well-formed RPC objects\n     * @override\n     * @param {Array<Message>} msgs\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_publish\",\n    value: function _publish(msgs) {\n      var _this11 = this;\n\n      msgs.forEach(function (msgObj) {\n        var msgID = _this11.getMsgId(msgObj); // put in seen cache\n\n\n        _this11.seenCache.put(msgID);\n\n        _this11.messageCache.put(msgObj);\n\n        var tosend = new Set();\n        msgObj.topicIDs.forEach(function (topic) {\n          var peersInTopic = _this11.topics.get(topic);\n\n          if (!peersInTopic) {\n            return;\n          } // floodsub peers\n\n\n          peersInTopic.forEach(function (peer) {\n            if (peer.protocols.includes(constants.FloodSubID)) {\n              tosend.add(peer);\n            }\n          }); // Gossipsub peers handling\n\n          var meshPeers = _this11.mesh.get(topic);\n\n          if (!meshPeers || !meshPeers.size) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = _this11.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick any peers in topic\n              var peers = getGossipPeers_1.getGossipPeers(_this11, topic, constants.GossipsubD);\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n\n                _this11.fanout.set(topic, peers);\n              } else {\n                meshPeers = new Set();\n              }\n            } // Store the latest publishing time\n\n\n            _this11.lastpub.set(topic, _this11._now());\n          }\n\n          meshPeers.forEach(function (peer) {\n            tosend.add(peer);\n          });\n        }); // Publish messages to peers\n\n        tosend.forEach(function (peer) {\n          if (peer.id.toB58String() === msgObj.from) {\n            return;\n          }\n\n          _this11._sendRpc(peer, utils_1.createGossipRpc([libp2p_pubsub_1.utils.normalizeOutRpcMessage(msgObj)]));\n        });\n      });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendGraft\",\n    value: function _sendGraft(peer, topic) {\n      var graft = [{\n        topicID: topic\n      }];\n      var out = utils_1.createGossipRpc([], {\n        graft: graft\n      });\n\n      this._sendRpc(peer, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendPrune\",\n    value: function _sendPrune(peer, topic) {\n      var prune = [{\n        topicID: topic\n      }];\n      var out = utils_1.createGossipRpc([], {\n        prune: prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }, {\n    key: \"_sendRpc\",\n    value: function _sendRpc(peer, outRpc) {\n      if (!peer || !peer.isWritable) {\n        return;\n      } // piggyback control message retries\n\n\n      var ctrl = this.control.get(peer);\n\n      if (ctrl) {\n        this._piggybackControl(peer, outRpc, ctrl);\n\n        this.control.delete(peer);\n      } // piggyback gossip\n\n\n      var ihave = this.gossip.get(peer);\n\n      if (ihave) {\n        this._piggybackGossip(peer, outRpc, ihave);\n\n        this.gossip.delete(peer);\n      }\n\n      peer.write(message_1.RPCCodec.encode(outRpc));\n    }\n  }, {\n    key: \"_piggybackControl\",\n    value: function _piggybackControl(peer, outRpc, ctrl) {\n      var _this12 = this;\n\n      var tograft = (ctrl.graft || []).filter(function (_ref5) {\n        var topicID = _ref5.topicID;\n        return (topicID && _this12.mesh.get(topicID) || new Set()).has(peer);\n      });\n      var toprune = (ctrl.prune || []).filter(function (_ref6) {\n        var topicID = _ref6.topicID;\n        return !(topicID && _this12.mesh.get(topicID) || new Set()).has(peer);\n      });\n\n      if (!tograft.length && !toprune.length) {\n        return;\n      }\n\n      if (outRpc.control) {\n        outRpc.control.graft = outRpc.control.graft.concat(tograft);\n        outRpc.control.prune = outRpc.control.prune.concat(toprune);\n      } else {\n        outRpc.control = {\n          ihave: [],\n          iwant: [],\n          graft: tograft,\n          prune: toprune\n        };\n      }\n    }\n  }, {\n    key: \"_piggybackGossip\",\n    value: function _piggybackGossip(peer, outRpc, ihave) {\n      if (!outRpc.control) {\n        outRpc.control = {\n          ihave: [],\n          iwant: [],\n          graft: [],\n          prune: []\n        };\n      }\n\n      outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<Peer, Array<String>>} tograft\n     * @param {Map<Peer, Array<String>>} toprune\n     */\n\n  }, {\n    key: \"_sendGraftPrune\",\n    value: function _sendGraftPrune(tograft, toprune) {\n      var _iterator3 = _createForOfIteratorHelper(tograft),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              p = _step3$value[0],\n              topics = _step3$value[1];\n\n          var graft = topics.map(function (topicID) {\n            return {\n              topicID: topicID\n            };\n          });\n          var prune = []; // If a peer also has prunes, process them now\n\n          var pruneMsg = toprune.get(p);\n\n          if (pruneMsg) {\n            prune = pruneMsg.map(function (topicID) {\n              return {\n                topicID: topicID\n              };\n            });\n            toprune.delete(p);\n          }\n\n          var outRpc = utils_1.createGossipRpc([], {\n            graft: graft,\n            prune: prune\n          });\n\n          this._sendRpc(p, outRpc);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(toprune),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              _p = _step4$value[0],\n              _topics = _step4$value[1];\n\n          var _prune = _topics.map(function (topicID) {\n            return {\n              topicID: topicID\n            };\n          });\n\n          var _outRpc = utils_1.createGossipRpc([], {\n            prune: _prune\n          });\n\n          this._sendRpc(_p, _outRpc);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {String} topic\n     * @param {Set<Peer>} peers - peers to exclude\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_emitGossip\",\n    value: function _emitGossip(topic, peers) {\n      var _this13 = this;\n\n      var messageIDs = this.messageCache.getGossipIDs(topic);\n\n      if (!messageIDs.length) {\n        return;\n      }\n\n      var gossipSubPeers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n      gossipSubPeers.forEach(function (peer) {\n        // skip mesh peers\n        if (!peers.has(peer)) {\n          _this13._pushGossip(peer, {\n            topicID: topic,\n            messageIDs: messageIDs\n          });\n        }\n      });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      // send gossip first, which will also piggyback control\n      var _iterator5 = _createForOfIteratorHelper(this.gossip.entries()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              peer = _step5$value[0],\n              ihave = _step5$value[1];\n\n          this.gossip.delete(peer);\n          var out = utils_1.createGossipRpc([], {\n            ihave: ihave\n          });\n\n          this._sendRpc(peer, out);\n        } // send the remaining control messages\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this.control.entries()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              _peer = _step6$value[0],\n              control = _step6$value[1];\n\n          this.control.delete(_peer);\n\n          var _out = utils_1.createGossipRpc([], {\n            graft: control.graft,\n            prune: control.prune\n          });\n\n          this._sendRpc(_peer, _out);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {Peer} peer\n     * @param {Array<ControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_pushGossip\",\n    value: function _pushGossip(peer, controlIHaveMsgs) {\n      this.log('Add gossip to %s', peer.id.toB58String());\n      var gossip = this.gossip.get(peer) || [];\n      this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_now\",\n    value: function _now() {\n      return Date.now();\n    }\n  }]);\n\n  return Gossipsub;\n}(BasicPubsub);\n\nGossipsub.multicodec = constants.GossipsubID;\nmodule.exports = Gossipsub;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-gossipsub/src/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","libp2p_pubsub_1","require","messageCache_1","message_1","constants","heartbeat_1","getGossipPeers_1","utils_1","TimeCache","BasicPubsub","Gossipsub","peerId","registrar","options","multicodecs","GossipsubID","_options","assign","gossipIncoming","fallbackToFloodsub","push","FloodSubID","debugName","seenCache","mesh","Map","fanout","lastpub","gossip","control","_msgIdFn","msgIdFn","defaultMsgIdFn","messageCache","MessageCache","GossipsubHistoryGossip","GossipsubHistoryLength","heartbeat","Heartbeat","peer","values","peers","delete","idB58Str","rpc","_processRpcControlMessage","controlMsg","iwant","_handleIHave","ihave","_handleIWant","prune","_handleGraft","graft","_handlePrune","outRpc","createGossipRpc","_sendRpc","msg","msgID","getMsgId","has","put","topics","topicIDs","forEach","protocols","includes","id","toB58String","from","utils","anyMatch","isWritable","sendMessages","normalizeOutRpcMessages","log","topic","meshPeers","Set","topicID","messageIDs","add","size","Array","set","length","buildCtrlPruneMsg","map","_super","start","stop","join","leave","started","Error","ensureArray","fanoutPeers","getGossipPeers","GossipsubD","_sendGraft","_sendPrune","msgs","msgObj","tosend","peersInTopic","_now","normalizeOutRpcMessage","out","ctrl","_piggybackControl","_piggybackGossip","write","RPCCodec","encode","tograft","filter","toprune","concat","p","pruneMsg","getGossipIDs","gossipSubPeers","_pushGossip","entries","controlIHaveMsgs","Date","now","multicodec","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\nconst libp2p_pubsub_1 = require(\"libp2p-pubsub\");\nconst messageCache_1 = require(\"./messageCache\");\nconst message_1 = require(\"./message\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst getGossipPeers_1 = require(\"./getGossipPeers\");\nconst utils_1 = require(\"./utils\");\n// @ts-ignore\nconst TimeCache = require(\"time-cache\");\nconst BasicPubsub = require(\"./pubsub\");\nclass Gossipsub extends BasicPubsub {\n    /**\n     * @param {PeerId} peerId instance of the peer's PeerId\n     * @param {Object} registrar\n     * @param {function} registrar.handle\n     * @param {function} registrar.register\n     * @param {function} registrar.unregister\n     * @param {Object} [options]\n     * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n     * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n     * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n     * @param {function} [options.msgIdFn] override the default message id function\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @constructor\n     */\n    constructor(peerId, registrar, options = {}) {\n        const multicodecs = [constants.GossipsubID];\n        const _options = Object.assign({ gossipIncoming: true, fallbackToFloodsub: true }, options);\n        // Also wants to get notified of peers connected using floodsub\n        if (_options.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodSubID);\n        }\n        super({\n            debugName: 'libp2p:gossipsub',\n            multicodecs,\n            peerId,\n            registrar,\n            options: _options\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {TimeCache}\n         */\n        this.seenCache = new TimeCache();\n        /**\n         * Map of topic meshes\n         *\n         * @type {Map<string, Set<Peer>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         *\n         * @type {Map<string, Set<Peer>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         *\n         * @type {Map<string, Number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         *\n         * @type {Map<Peer, Array<ControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         *\n         * @type {Map<Peer, ControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Use the overriden mesgIdFn or the default one.\n         */\n        this._msgIdFn = options.msgIdFn || this.defaultMsgIdFn;\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         *\n         */\n        this.messageCache = options.messageCache || new messageCache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this._msgIdFn);\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {Peer} peer\n     * @returns {Peer}\n     */\n    _removePeer(peer) {\n        super._removePeer(peer);\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(peer);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(peer);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(peer);\n        // Remove from control mapping\n        this.control.delete(peer);\n        return peer;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {Peer} peer\n     * @param {RPC} rpc\n     * @returns {void}\n     */\n    _processRpc(idB58Str, peer, rpc) {\n        super._processRpc(idB58Str, peer, rpc);\n        if (rpc.control) {\n            this._processRpcControlMessage(peer, rpc.control);\n        }\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {Peer} peer\n     * @param {ControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(peer, controlMsg) {\n        if (!controlMsg) {\n            return;\n        }\n        const iwant = this._handleIHave(peer, controlMsg.ihave);\n        const ihave = this._handleIWant(peer, controlMsg.iwant);\n        const prune = this._handleGraft(peer, controlMsg.graft);\n        this._handlePrune(peer, controlMsg.prune);\n        if (!iwant || !ihave || !prune) {\n            return;\n        }\n        const outRpc = utils_1.createGossipRpc(ihave, { iwant: [iwant], prune });\n        this._sendRpc(peer, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {Peer} peer\n     * @param {Message} msg\n     */\n    _processRpcMessage(peer, msg) {\n        const msgID = this.getMsgId(msg);\n        // Ignore if we've already seen the message\n        if (this.seenCache.has(msgID)) {\n            return;\n        }\n        this.seenCache.put(msgID);\n        super._processRpcMessage(peer, msg);\n        const topics = msg.topicIDs;\n        // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n        if (!this._options.gossipIncoming) {\n            return;\n        }\n        // Emit to floodsub peers\n        this.peers.forEach((peer) => {\n            if (peer.protocols.includes(constants.FloodSubID) &&\n                peer.id.toB58String() !== msg.from &&\n                libp2p_pubsub_1.utils.anyMatch(peer.topics, topics) &&\n                peer.isWritable) {\n                peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n                this.log('publish msg on topics - floodsub', topics, peer.id.toB58String());\n            }\n        });\n        // Emit to peers in the mesh\n        topics.forEach((topic) => {\n            const meshPeers = this.mesh.get(topic);\n            if (!meshPeers) {\n                return;\n            }\n            meshPeers.forEach((peer) => {\n                if (!peer.isWritable || peer.id.toB58String() === msg.from) {\n                    return;\n                }\n                peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n                this.log('publish msg on topic - meshsub', topic, peer.id.toB58String());\n            });\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {Peer} peer\n     * @param {Array<ControlIHave>} ihave\n     * @returns {ControlIWant}\n     */\n    _handleIHave(peer, ihave) {\n        const iwant = new Set();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgID) => {\n                if (this.seenCache.has(msgID)) {\n                    return;\n                }\n                iwant.add(msgID);\n            });\n        });\n        if (!iwant.size) {\n            return;\n        }\n        this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.id.toB58String());\n        return {\n            messageIDs: Array.from(iwant)\n        };\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {Peer} peer\n     * @param {Array<ControlIWant>} iwant\n     * @returns {Array<Message>}\n     */\n    _handleIWant(peer, iwant) {\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs.forEach((msgID) => {\n                const msg = this.messageCache.get(msgID);\n                if (msg) {\n                    ihave.set(msgID, msg);\n                }\n            });\n        });\n        if (!ihave.size) {\n            return;\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, peer.id.toB58String());\n        return Array.from(ihave.values());\n    }\n    /**\n     * Handles Graft messages\n     * @param {Peer} peer\n     * @param {Array<ControlGraft>} graft\n     * @return {Array<ControlPrune>}\n     */\n    _handleGraft(peer, graft) {\n        const prune = [];\n        graft.forEach(({ topicID }) => {\n            if (!topicID) {\n                return;\n            }\n            const peers = this.mesh.get(topicID);\n            if (!peers) {\n                prune.push(topicID);\n            }\n            else {\n                this.log('GRAFT: Add mesh link from %s in %s', peer.id.toB58String(), topicID);\n                peers.add(peer);\n                peer.topics.add(topicID);\n                this.mesh.set(topicID, peers);\n            }\n        });\n        if (!prune.length) {\n            return;\n        }\n        const buildCtrlPruneMsg = (topic) => {\n            return {\n                topicID: topic\n            };\n        };\n        return prune.map(buildCtrlPruneMsg);\n    }\n    /**\n     * Handles Prune messages\n     * @param {Peer} peer\n     * @param {Array<ControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(peer, prune) {\n        prune.forEach(({ topicID }) => {\n            if (!topicID) {\n                return;\n            }\n            const peers = this.mesh.get(topicID);\n            if (peers) {\n                this.log('PRUNE: Remove mesh link to %s in %s', peer.id.toB58String(), topicID);\n                peers.delete(peer);\n                peer.topics.delete(topicID);\n            }\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {Promise}\n     */\n    start() {\n        const _super = Object.create(null, {\n            start: { get: () => super.start }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.start.call(this);\n            this.heartbeat.start();\n        });\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {Promise}\n     */\n    stop() {\n        const _super = Object.create(null, {\n            stop: { get: () => super.stop }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.stop.call(this);\n            this.heartbeat.stop();\n            this.mesh = new Map();\n            this.fanout = new Map();\n            this.lastpub = new Map();\n            this.gossip = new Map();\n            this.control = new Map();\n        });\n    }\n    /**\n     * Subscribes to topics\n     *\n     * @override\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _subscribe(topics) {\n        super._subscribe(topics);\n        this.join(topics);\n    }\n    /**\n     * Unsubscribes to topics\n     *\n     * @override\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _unsubscribe(topics) {\n        super._unsubscribe(topics);\n        this.leave(topics);\n    }\n    /**\n     * Join topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    join(topics) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        topics = libp2p_pubsub_1.utils.ensureArray(topics);\n        this.log('JOIN %s', topics);\n        topics.forEach((topic) => {\n            // Send GRAFT to mesh peers\n            const fanoutPeers = this.fanout.get(topic);\n            if (fanoutPeers) {\n                this.mesh.set(topic, fanoutPeers);\n                this.fanout.delete(topic);\n                this.lastpub.delete(topic);\n            }\n            else {\n                const peers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n                this.mesh.set(topic, peers);\n            }\n            this.mesh.get(topic).forEach((peer) => {\n                this.log('JOIN: Add mesh link to %s in %s', peer.id.toB58String(), topic);\n                this._sendGraft(peer, topic);\n            });\n        });\n    }\n    /**\n     * Leave topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    leave(topics) {\n        topics = libp2p_pubsub_1.utils.ensureArray(topics);\n        this.log('LEAVE %s', topics);\n        topics.forEach((topic) => {\n            // Send PRUNE to mesh peers\n            const meshPeers = this.mesh.get(topic);\n            if (meshPeers) {\n                meshPeers.forEach((peer) => {\n                    this.log('LEAVE: Remove mesh link to %s in %s', peer.id.toB58String(), topic);\n                    this._sendPrune(peer, topic);\n                });\n                this.mesh.delete(topic);\n            }\n        });\n    }\n    /**\n     * Override the default implementation in BasicPubSub.\n     * If we don't provide msgIdFn in constructor option, it's the same.\n     * @override\n     * @param {Message} msg the message object\n     * @returns {string} message id as string\n     */\n    getMsgId(msg) {\n        return this._msgIdFn(msg);\n    }\n    /**\n     * Publish messages\n     *\n     * Note: this function assumes all messages are well-formed RPC objects\n     * @override\n     * @param {Array<Message>} msgs\n     * @returns {void}\n     */\n    _publish(msgs) {\n        msgs.forEach((msgObj) => {\n            const msgID = this.getMsgId(msgObj);\n            // put in seen cache\n            this.seenCache.put(msgID);\n            this.messageCache.put(msgObj);\n            const tosend = new Set();\n            msgObj.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                // floodsub peers\n                peersInTopic.forEach((peer) => {\n                    if (peer.protocols.includes(constants.FloodSubID)) {\n                        tosend.add(peer);\n                    }\n                });\n                // Gossipsub peers handling\n                let meshPeers = this.mesh.get(topic);\n                if (!meshPeers || !meshPeers.size) {\n                    // We are not in the mesh for topic, use fanout peers\n                    meshPeers = this.fanout.get(topic);\n                    if (!meshPeers) {\n                        // If we are not in the fanout, then pick any peers in topic\n                        const peers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n                        if (peers.size > 0) {\n                            meshPeers = peers;\n                            this.fanout.set(topic, peers);\n                        }\n                        else {\n                            meshPeers = new Set();\n                        }\n                    }\n                    // Store the latest publishing time\n                    this.lastpub.set(topic, this._now());\n                }\n                meshPeers.forEach((peer) => {\n                    tosend.add(peer);\n                });\n            });\n            // Publish messages to peers\n            tosend.forEach((peer) => {\n                if (peer.id.toB58String() === msgObj.from) {\n                    return;\n                }\n                this._sendRpc(peer, utils_1.createGossipRpc([libp2p_pubsub_1.utils.normalizeOutRpcMessage(msgObj)]));\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n    _sendGraft(peer, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(peer, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n    _sendPrune(peer, topic) {\n        const prune = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { prune });\n        this._sendRpc(peer, out);\n    }\n    _sendRpc(peer, outRpc) {\n        if (!peer || !peer.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(peer);\n        if (ctrl) {\n            this._piggybackControl(peer, outRpc, ctrl);\n            this.control.delete(peer);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(peer);\n        if (ihave) {\n            this._piggybackGossip(peer, outRpc, ihave);\n            this.gossip.delete(peer);\n        }\n        peer.write(message_1.RPCCodec.encode(outRpc));\n    }\n    _piggybackControl(peer, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(peer));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(peer));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(peer, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<Peer, Array<String>>} tograft\n     * @param {Map<Peer, Array<String>>} toprune\n     */\n    _sendGraftPrune(tograft, toprune) {\n        for (const [p, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruneMsg = toprune.get(p);\n            if (pruneMsg) {\n                prune = pruneMsg.map((topicID) => ({ topicID }));\n                toprune.delete(p);\n            }\n            const outRpc = utils_1.createGossipRpc([], { graft, prune });\n            this._sendRpc(p, outRpc);\n        }\n        for (const [p, topics] of toprune) {\n            const prune = topics.map((topicID) => ({ topicID }));\n            const outRpc = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(p, outRpc);\n        }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {String} topic\n     * @param {Set<Peer>} peers - peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, peers) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        const gossipSubPeers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n        gossipSubPeers.forEach((peer) => {\n            // skip mesh peers\n            if (!peers.has(peer)) {\n                this._pushGossip(peer, {\n                    topicID: topic,\n                    messageIDs: messageIDs\n                });\n            }\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {Peer} peer\n     * @param {Array<ControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(peer, controlIHaveMsgs) {\n        this.log('Add gossip to %s', peer.id.toB58String());\n        const gossip = this.gossip.get(peer) || [];\n        this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n}\nGossipsub.multicodec = constants.GossipsubID;\nmodule.exports = Gossipsub;\n"]},"metadata":{},"sourceType":"script"}