{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar PeerId = require('peer-id');\n\nvar CID = require('cids');\n\nvar errCode = require('err-code');\n\nvar _require = require('../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar _require2 = require('buffer'),\n    Buffer = _require2.Buffer;\n\nmodule.exports = function (_ref3) {\n  var libp2p = _ref3.libp2p,\n      repo = _ref3.repo;\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Buffer>}\n     */\n    get: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, options) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // eslint-disable-line require-await\n                options = options || {};\n\n                if (Buffer.isBuffer(key)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.prev = 2;\n                key = new CID(key).buffer;\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](2);\n                throw errCode(_context.t0, 'ERR_INVALID_CID');\n\n              case 9:\n                return _context.abrupt(\"return\", libp2p._dht.get(key, options));\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 6]]);\n      }));\n\n      return function (_x4, _x5) {\n        return _ref4.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key, value) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (Buffer.isBuffer(key)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.prev = 1;\n                key = new CID(key).buffer;\n                _context2.next = 8;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](1);\n                throw errCode(_context2.t0, 'ERR_INVALID_CID');\n\n              case 8:\n                return _context2.abrupt(\"return\", libp2p._dht.put(key, value));\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[1, 5]]);\n      }));\n\n      return function (_x6, _x7) {\n        return _ref5.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, options) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, peer;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // eslint-disable-line require-await\n                options = options || {};\n\n                if (!(typeof key === 'string')) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.prev = 2;\n                key = new CID(key);\n                _context3.next = 9;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](2);\n                throw errCode(_context3.t0, 'ERR_INVALID_CID');\n\n              case 9:\n                if (options.numProviders) {\n                  options.maxNumProviders = options.numProviders;\n                }\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context3.prev = 12;\n                _iterator = _asyncIterator(libp2p._dht.findProviders(key, options));\n\n              case 14:\n                _context3.next = 16;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 16:\n                _step = _context3.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context3.next = 20;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 20:\n                _value = _context3.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                peer = _value;\n                _context3.next = 25;\n                return {\n                  id: peer.id.toB58String(),\n                  addrs: peer.addrs\n                };\n\n              case 25:\n                _iteratorNormalCompletion = true;\n                _context3.next = 14;\n                break;\n\n              case 28:\n                _context3.next = 34;\n                break;\n\n              case 30:\n                _context3.prev = 30;\n                _context3.t1 = _context3[\"catch\"](12);\n                _didIteratorError = true;\n                _iteratorError = _context3.t1;\n\n              case 34:\n                _context3.prev = 34;\n                _context3.prev = 35;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context3.next = 39;\n                  break;\n                }\n\n                _context3.next = 39;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 39:\n                _context3.prev = 39;\n\n                if (!_didIteratorError) {\n                  _context3.next = 42;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 42:\n                return _context3.finish(39);\n\n              case 43:\n                return _context3.finish(34);\n\n              case 44:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[2, 6], [12, 30, 34, 44], [35,, 39, 43]]);\n      }));\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peerId) {\n        var peer;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // eslint-disable-line require-await\n                if (typeof peerId === 'string') {\n                  peerId = PeerId.createFromCID(peerId);\n                }\n\n                _context4.next = 3;\n                return libp2p._dht.findPeer(peerId);\n\n              case 3:\n                peer = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  id: peer.id.toB58String(),\n                  addrs: peer.addrs\n                });\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x8) {\n        return _ref6.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} keys - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(keys, options) {\n        var i, hasKeys, hasAll;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                keys = Array.isArray(keys) ? keys : [keys];\n                options = options || {};\n                _context5.t0 = _regeneratorRuntime.keys(keys);\n\n              case 3:\n                if ((_context5.t1 = _context5.t0()).done) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                i = _context5.t1.value;\n\n                if (!(typeof keys[i] === 'string')) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                _context5.prev = 6;\n                keys[i] = new CID(keys[i]);\n                _context5.next = 13;\n                break;\n\n              case 10:\n                _context5.prev = 10;\n                _context5.t2 = _context5[\"catch\"](6);\n                throw errCode(_context5.t2, 'ERR_INVALID_CID');\n\n              case 13:\n                _context5.next = 3;\n                break;\n\n              case 15:\n                _context5.next = 17;\n                return Promise.all(keys.map(function (k) {\n                  return repo.blocks.has(k);\n                }));\n\n              case 17:\n                hasKeys = _context5.sent;\n                hasAll = hasKeys.every(function (has) {\n                  return has;\n                });\n\n                if (hasAll) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                throw errCode('block(s) not found locally, cannot provide', 'ERR_BLOCK_NOT_FOUND');\n\n              case 21:\n                if (!options.recursive) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                throw errCode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET');\n\n              case 25:\n                _context5.next = 27;\n                return Promise.all(keys.map(function (k) {\n                  return libp2p._dht.provide(k);\n                }));\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[6, 10]]);\n      }));\n\n      return function (_x9, _x10) {\n        return _ref7.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peerId) {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, closerPeerId;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (typeof peerId === 'string') {\n                  peerId = PeerId.createFromCID(peerId);\n                }\n\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context6.prev = 3;\n                _iterator2 = _asyncIterator(libp2p._dht.getClosestPeers(peerId.toBytes()));\n\n              case 5:\n                _context6.next = 7;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 7:\n                _step2 = _context6.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context6.next = 11;\n                return _awaitAsyncGenerator(_step2.value);\n\n              case 11:\n                _value2 = _context6.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                closerPeerId = _value2;\n                _context6.next = 16;\n                return {\n                  id: closerPeerId.toB58String(),\n                  addrs: [] // TODO: get addrs?\n\n                };\n\n              case 16:\n                _iteratorNormalCompletion2 = true;\n                _context6.next = 5;\n                break;\n\n              case 19:\n                _context6.next = 25;\n                break;\n\n              case 21:\n                _context6.prev = 21;\n                _context6.t0 = _context6[\"catch\"](3);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context6.t0;\n\n              case 25:\n                _context6.prev = 25;\n                _context6.prev = 26;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context6.next = 30;\n                  break;\n                }\n\n                _context6.next = 30;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 30:\n                _context6.prev = 30;\n\n                if (!_didIteratorError2) {\n                  _context6.next = 33;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 33:\n                return _context6.finish(30);\n\n              case 34:\n                return _context6.finish(25);\n\n              case 35:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[3, 21, 25, 35], [26,, 30, 34]]);\n      }));\n\n      return function (_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }())\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/dht.js"],"names":["PeerId","require","CID","errCode","withTimeoutOption","Buffer","module","exports","libp2p","repo","get","key","options","isBuffer","buffer","_dht","put","value","findProvs","numProviders","maxNumProviders","findProviders","peer","id","toB58String","addrs","findPeer","peerId","createFromCID","provide","keys","Array","isArray","i","Promise","all","map","k","blocks","has","hasKeys","hasAll","every","recursive","query","getClosestPeers","toBytes","closerPeerId"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst CID = require('cids')\nconst errCode = require('err-code')\nconst { withTimeoutOption } = require('../utils')\nconst { Buffer } = require('buffer')\n\nmodule.exports = ({ libp2p, repo }) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Buffer>}\n     */\n    get: withTimeoutOption(async (key, options) => { // eslint-disable-line require-await\n      options = options || {}\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return libp2p._dht.get(key, options)\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption(async (key, value) => { // eslint-disable-line require-await\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return libp2p._dht.put(key, value)\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption(async function * (key, options) { // eslint-disable-line require-await\n      options = options || {}\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key)\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders\n      }\n\n      for await (const peer of libp2p._dht.findProviders(key, options)) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        }\n      }\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption(async peerId => { // eslint-disable-line require-await\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId)\n      }\n\n      const peer = await libp2p._dht.findPeer(peerId)\n\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.addrs\n      }\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} keys - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption(async (keys, options) => {\n      keys = Array.isArray(keys) ? keys : [keys]\n      options = options || {}\n\n      for (var i in keys) {\n        if (typeof keys[i] === 'string') {\n          try {\n            keys[i] = new CID(keys[i])\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID')\n          }\n        }\n      }\n\n      // ensure blocks are actually local\n      const hasKeys = await Promise.all(keys.map(k => repo.blocks.has(k)))\n      const hasAll = hasKeys.every(has => has)\n\n      if (!hasAll) {\n        throw errCode('block(s) not found locally, cannot provide', 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET')\n      } else {\n        await Promise.all(keys.map(k => libp2p._dht.provide(k)))\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption(async function * (peerId) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId)\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n        }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}