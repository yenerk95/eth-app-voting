{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nfunction normalizeMultihash(multihash, enc) {\n  if (typeof multihash === 'string') {\n    if (enc === 'base58' || !enc) {\n      return multihash;\n    }\n\n    return Buffer.from(multihash, enc);\n  } else if (Buffer.isBuffer(multihash)) {\n    return multihash;\n  } else if (CID.isCID(multihash)) {\n    return multihash.buffer;\n  }\n\n  throw new Error('unsupported multihash');\n}\n\nmodule.exports = ({\n  ipld,\n  preload\n}) => {\n  return withTimeoutOption(async function get(multihash, options) {\n    // eslint-disable-line require-await\n    options = options || {};\n    let mh, cid;\n\n    try {\n      mh = normalizeMultihash(multihash, options.enc);\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_MULTIHASH');\n    }\n\n    try {\n      cid = new CID(mh);\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID');\n    }\n\n    if (options.cidVersion === 1) {\n      cid = cid.toV1();\n    }\n\n    if (options.preload !== false) {\n      preload(cid);\n    }\n\n    return ipld.get(cid, {\n      signal: options.signal\n    });\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/object/get.js"],"names":["CID","require","errCode","Buffer","withTimeoutOption","normalizeMultihash","multihash","enc","from","isBuffer","isCID","buffer","Error","module","exports","ipld","preload","get","options","mh","cid","err","cidVersion","toV1","signal"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAaF,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAwBH,OAAO,CAAC,aAAD,CAArC;;AAEA,SAASI,kBAAT,CAA6BC,SAA7B,EAAwCC,GAAxC,EAA6C;AAC3C,MAAI,OAAOD,SAAP,KAAqB,QAAzB,EAAmC;AACjC,QAAIC,GAAG,KAAK,QAAR,IAAoB,CAACA,GAAzB,EAA8B;AAC5B,aAAOD,SAAP;AACD;;AACD,WAAOH,MAAM,CAACK,IAAP,CAAYF,SAAZ,EAAuBC,GAAvB,CAAP;AACD,GALD,MAKO,IAAIJ,MAAM,CAACM,QAAP,CAAgBH,SAAhB,CAAJ,EAAgC;AACrC,WAAOA,SAAP;AACD,GAFM,MAEA,IAAIN,GAAG,CAACU,KAAJ,CAAUJ,SAAV,CAAJ,EAA0B;AAC/B,WAAOA,SAAS,CAACK,MAAjB;AACD;;AACD,QAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAuB;AACtC,SAAOZ,iBAAiB,CAAC,eAAea,GAAf,CAAoBX,SAApB,EAA+BY,OAA/B,EAAwC;AAAE;AACjEA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAIC,EAAJ,EAAQC,GAAR;;AAEA,QAAI;AACFD,MAAAA,EAAE,GAAGd,kBAAkB,CAACC,SAAD,EAAYY,OAAO,CAACX,GAApB,CAAvB;AACD,KAFD,CAEE,OAAOc,GAAP,EAAY;AACZ,YAAMnB,OAAO,CAACmB,GAAD,EAAM,uBAAN,CAAb;AACD;;AAED,QAAI;AACFD,MAAAA,GAAG,GAAG,IAAIpB,GAAJ,CAAQmB,EAAR,CAAN;AACD,KAFD,CAEE,OAAOE,GAAP,EAAY;AACZ,YAAMnB,OAAO,CAACmB,GAAD,EAAM,iBAAN,CAAb;AACD;;AAED,QAAIH,OAAO,CAACI,UAAR,KAAuB,CAA3B,EAA8B;AAC5BF,MAAAA,GAAG,GAAGA,GAAG,CAACG,IAAJ,EAAN;AACD;;AAED,QAAIL,OAAO,CAACF,OAAR,KAAoB,KAAxB,EAA+B;AAC7BA,MAAAA,OAAO,CAACI,GAAD,CAAP;AACD;;AAED,WAAOL,IAAI,CAACE,GAAL,CAASG,GAAT,EAAc;AAAEI,MAAAA,MAAM,EAAEN,OAAO,CAACM;AAAlB,KAAd,CAAP;AACD,GA1BuB,CAAxB;AA2BD,CA5BD","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst errCode = require('err-code')\nconst { Buffer } = require('buffer')\nconst { withTimeoutOption } = require('../../utils')\n\nfunction normalizeMultihash (multihash, enc) {\n  if (typeof multihash === 'string') {\n    if (enc === 'base58' || !enc) {\n      return multihash\n    }\n    return Buffer.from(multihash, enc)\n  } else if (Buffer.isBuffer(multihash)) {\n    return multihash\n  } else if (CID.isCID(multihash)) {\n    return multihash.buffer\n  }\n  throw new Error('unsupported multihash')\n}\n\nmodule.exports = ({ ipld, preload }) => {\n  return withTimeoutOption(async function get (multihash, options) { // eslint-disable-line require-await\n    options = options || {}\n\n    let mh, cid\n\n    try {\n      mh = normalizeMultihash(multihash, options.enc)\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_MULTIHASH')\n    }\n\n    try {\n      cid = new CID(mh)\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID')\n    }\n\n    if (options.cidVersion === 1) {\n      cid = cid.toV1()\n    }\n\n    if (options.preload !== false) {\n      preload(cid)\n    }\n\n    return ipld.get(cid, { signal: options.signal })\n  })\n}\n"]},"metadata":{},"sourceType":"script"}