{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar errcode = require('err-code');\n\nvar pipe = require('it-pipe');\n\nvar lp = require('it-length-prefixed');\n\nvar pTimeout = require('p-timeout');\n\nvar _require = require('streaming-iterables'),\n    consume = _require.consume;\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nvar rpc = require('./rpc');\n\nvar c = require('./constants');\n\nvar Message = require('./message');\n\nvar utils = require('./utils');\n/**\n * Handle network operations for the dht\n */\n\n\nvar Network = /*#__PURE__*/function () {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  function Network(self) {\n    _classCallCheck(this, Network);\n\n    this.dht = self;\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;\n    this._log = utils.logger(this.dht.peerId, 'net');\n    this._rpc = rpc(this.dht);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._running = false;\n  }\n  /**\n   * Start the network.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var topology;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._running) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                if (this.dht.isStarted) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK');\n\n              case 4:\n                this._running = true; // Only respond to queries when not in client mode\n\n                if (this.dht._clientMode === false) {\n                  // Incoming streams\n                  this.dht.registrar.handle(c.PROTOCOL_DHT, this._rpc);\n                } // register protocol with topology\n\n\n                topology = new MulticodecTopology({\n                  multicodecs: [c.PROTOCOL_DHT],\n                  handlers: {\n                    onConnect: this._onPeerConnected,\n                    onDisconnect: function onDisconnect() {}\n                  }\n                });\n                _context.next = 9;\n                return this.dht.registrar.register(topology);\n\n              case 9:\n                this._registrarId = _context.sent;\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop all network activity.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(!this.dht.isStarted && !this.isStarted)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                this._running = false; // unregister protocol and handlers\n\n                _context2.next = 5;\n                return this.dht.registrar.unregister(this._registrarId);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Is the network online?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n\n    /**\n     * Registrar notifies a connection successfully with dht protocol.\n     * @private\n     * @param {PeerId} peerId remote peer id\n     * @returns {Promise<void>}\n     */\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.dht._add(peerId);\n\n              case 2:\n                this._log('added to the routing table: %s', peerId.toB58String());\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _onPeerConnected(_x) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }()\n    /**\n     * Send a request and record RTT for latency measurements.\n     * @async\n     * @param {PeerId} to - The peer that should receive a message\n     * @param {Message} msg - The message to send.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(to, msg) {\n        var id, conn, _yield$conn$newStream, stream;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');\n\n              case 2:\n                id = to.toB58String();\n\n                this._log('sending to: %s', id);\n\n                conn = this.dht.registrar.connectionManager.get(to);\n\n                if (conn) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                _context4.next = 8;\n                return this.dht.dialer.connectToPeer(to);\n\n              case 8:\n                conn = _context4.sent;\n\n              case 9:\n                _context4.next = 11;\n                return conn.newStream(c.PROTOCOL_DHT);\n\n              case 11:\n                _yield$conn$newStream = _context4.sent;\n                stream = _yield$conn$newStream.stream;\n                return _context4.abrupt(\"return\", this._writeReadMessage(stream, msg.serialize()));\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function sendRequest(_x2, _x3) {\n        return _sendRequest.apply(this, arguments);\n      }\n\n      return sendRequest;\n    }()\n    /**\n     * Sends a message without expecting an answer.\n     *\n     * @param {PeerId} to\n     * @param {Message} msg\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(to, msg) {\n        var id, conn, _yield$conn$newStream2, stream;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');\n\n              case 2:\n                id = to.toB58String();\n\n                this._log('sending to: %s', id);\n\n                conn = this.dht.registrar.connectionManager.get(to);\n\n                if (conn) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                _context5.next = 8;\n                return this.dht.dialer.connectToPeer(to);\n\n              case 8:\n                conn = _context5.sent;\n\n              case 9:\n                _context5.next = 11;\n                return conn.newStream(c.PROTOCOL_DHT);\n\n              case 11:\n                _yield$conn$newStream2 = _context5.sent;\n                stream = _yield$conn$newStream2.stream;\n                return _context5.abrupt(\"return\", this._writeMessage(stream, msg.serialize()));\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendMessage(_x4, _x5) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Write a message and read its response.\n     * If no response is received after the specified timeout\n     * this will error out.\n     *\n     * @param {DuplexIterable} stream - the stream to use\n     * @param {Buffer} msg - the message to send\n     * @returns {Promise<Message>}\n     * @private\n     */\n\n  }, {\n    key: \"_writeReadMessage\",\n    value: function () {\n      var _writeReadMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(stream, msg) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", pTimeout(writeReadMessage(stream, msg), this.readMessageTimeout));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _writeReadMessage(_x6, _x7) {\n        return _writeReadMessage2.apply(this, arguments);\n      }\n\n      return _writeReadMessage;\n    }()\n    /**\n     * Write a message to the given stream.\n     *\n     * @param {DuplexIterable} stream - the stream to use\n     * @param {Buffer} msg - the message to send\n     * @returns {Promise<void>}\n     * @private\n     */\n\n  }, {\n    key: \"_writeMessage\",\n    value: function _writeMessage(stream, msg) {\n      return pipe([msg], lp.encode(), stream, consume);\n    }\n  }, {\n    key: \"isStarted\",\n    get: function get() {\n      return this._running;\n    }\n    /**\n     * Are all network components there?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      // TODO add a way to check if switch has started or not\n      return this.dht.isStarted && this.isStarted;\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeReadMessage(_x8, _x9) {\n  return _writeReadMessage3.apply(this, arguments);\n}\n\nfunction _writeReadMessage3() {\n  _writeReadMessage3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(stream, msg) {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return pipe([msg], lp.encode(), stream, lp.decode(), /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(source) {\n                var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n                return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        _iteratorNormalCompletion = true;\n                        _didIteratorError = false;\n                        _context7.prev = 2;\n                        _iterator = _asyncIterator(source);\n\n                      case 4:\n                        _context7.next = 6;\n                        return _iterator.next();\n\n                      case 6:\n                        _step = _context7.sent;\n                        _iteratorNormalCompletion = _step.done;\n                        _context7.next = 10;\n                        return _step.value;\n\n                      case 10:\n                        _value = _context7.sent;\n\n                        if (_iteratorNormalCompletion) {\n                          _context7.next = 17;\n                          break;\n                        }\n\n                        chunk = _value;\n                        return _context7.abrupt(\"return\", chunk.slice());\n\n                      case 14:\n                        _iteratorNormalCompletion = true;\n                        _context7.next = 4;\n                        break;\n\n                      case 17:\n                        _context7.next = 23;\n                        break;\n\n                      case 19:\n                        _context7.prev = 19;\n                        _context7.t0 = _context7[\"catch\"](2);\n                        _didIteratorError = true;\n                        _iteratorError = _context7.t0;\n\n                      case 23:\n                        _context7.prev = 23;\n                        _context7.prev = 24;\n\n                        if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                          _context7.next = 28;\n                          break;\n                        }\n\n                        _context7.next = 28;\n                        return _iterator.return();\n\n                      case 28:\n                        _context7.prev = 28;\n\n                        if (!_didIteratorError) {\n                          _context7.next = 31;\n                          break;\n                        }\n\n                        throw _iteratorError;\n\n                      case 31:\n                        return _context7.finish(28);\n\n                      case 32:\n                        return _context7.finish(23);\n\n                      case 33:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7, null, [[2, 19, 23, 33], [24,, 28, 32]]);\n              }));\n\n              return function (_x10) {\n                return _ref.apply(this, arguments);\n              };\n            }());\n\n          case 2:\n            res = _context8.sent;\n\n            if (!(res.length === 0)) {\n              _context8.next = 5;\n              break;\n            }\n\n            throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED');\n\n          case 5:\n            return _context8.abrupt(\"return\", Message.deserialize(res));\n\n          case 6:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _writeReadMessage3.apply(this, arguments);\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/network.js"],"names":["errcode","require","pipe","lp","pTimeout","consume","MulticodecTopology","rpc","c","Message","utils","Network","self","dht","readMessageTimeout","READ_MESSAGE_TIMEOUT","_log","logger","peerId","_rpc","_onPeerConnected","bind","_running","isStarted","Error","_clientMode","registrar","handle","PROTOCOL_DHT","topology","multicodecs","handlers","onConnect","onDisconnect","register","_registrarId","unregister","_add","toB58String","to","msg","isConnected","id","conn","connectionManager","get","dialer","connectToPeer","newStream","stream","_writeReadMessage","serialize","_writeMessage","writeReadMessage","encode","decode","source","chunk","slice","res","length","deserialize","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\n\nconst pipe = require('it-pipe')\nconst lp = require('it-length-prefixed')\nconst pTimeout = require('p-timeout')\nconst { consume } = require('streaming-iterables')\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst rpc = require('./rpc')\nconst c = require('./constants')\nconst Message = require('./message')\nconst utils = require('./utils')\n\n/**\n * Handle network operations for the dht\n */\nclass Network {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  constructor (self) {\n    this.dht = self\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT\n    this._log = utils.logger(this.dht.peerId, 'net')\n    this._rpc = rpc(this.dht)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._running = false\n  }\n\n  /**\n   * Start the network.\n   * @returns {Promise<void>}\n   */\n  async start () {\n    if (this._running) {\n      return\n    }\n\n    if (!this.dht.isStarted) {\n      throw errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK')\n    }\n\n    this._running = true\n\n    // Only respond to queries when not in client mode\n    if (this.dht._clientMode === false) {\n      // Incoming streams\n      this.dht.registrar.handle(c.PROTOCOL_DHT, this._rpc)\n    }\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: [c.PROTOCOL_DHT],\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: () => {}\n      }\n    })\n    this._registrarId = await this.dht.registrar.register(topology)\n  }\n\n  /**\n   * Stop all network activity.\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    if (!this.dht.isStarted && !this.isStarted) {\n      return\n    }\n    this._running = false\n\n    // unregister protocol and handlers\n    await this.dht.registrar.unregister(this._registrarId)\n  }\n\n  /**\n   * Is the network online?\n   *\n   * @type {bool}\n   */\n  get isStarted () {\n    return this._running\n  }\n\n  /**\n   * Are all network components there?\n   *\n   * @type {bool}\n   */\n  get isConnected () {\n    // TODO add a way to check if switch has started or not\n    return this.dht.isStarted && this.isStarted\n  }\n\n  /**\n   * Registrar notifies a connection successfully with dht protocol.\n   * @private\n   * @param {PeerId} peerId remote peer id\n   * @returns {Promise<void>}\n   */\n  async _onPeerConnected (peerId) {\n    await this.dht._add(peerId)\n    this._log('added to the routing table: %s', peerId.toB58String())\n  }\n\n  /**\n   * Send a request and record RTT for latency measurements.\n   * @async\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send.\n   * @returns {Promise<Message>}\n   */\n  async sendRequest (to, msg) {\n    // TODO: record latency\n    if (!this.isConnected) {\n      throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE')\n    }\n\n    const id = to.toB58String()\n    this._log('sending to: %s', id)\n\n    let conn = this.dht.registrar.connectionManager.get(to)\n    if (!conn) {\n      conn = await this.dht.dialer.connectToPeer(to)\n    }\n\n    const { stream } = await conn.newStream(c.PROTOCOL_DHT)\n\n    return this._writeReadMessage(stream, msg.serialize())\n  }\n\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n  async sendMessage (to, msg) {\n    if (!this.isConnected) {\n      throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE')\n    }\n\n    const id = to.toB58String()\n    this._log('sending to: %s', id)\n\n    let conn = this.dht.registrar.connectionManager.get(to)\n    if (!conn) {\n      conn = await this.dht.dialer.connectToPeer(to)\n    }\n    const { stream } = await conn.newStream(c.PROTOCOL_DHT)\n\n    return this._writeMessage(stream, msg.serialize())\n  }\n\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {DuplexIterable} stream - the stream to use\n   * @param {Buffer} msg - the message to send\n   * @returns {Promise<Message>}\n   * @private\n   */\n  async _writeReadMessage (stream, msg) { // eslint-disable-line require-await\n    return pTimeout(\n      writeReadMessage(stream, msg),\n      this.readMessageTimeout\n    )\n  }\n\n  /**\n   * Write a message to the given stream.\n   *\n   * @param {DuplexIterable} stream - the stream to use\n   * @param {Buffer} msg - the message to send\n   * @returns {Promise<void>}\n   * @private\n   */\n  _writeMessage (stream, msg) {\n    return pipe(\n      [msg],\n      lp.encode(),\n      stream,\n      consume\n    )\n  }\n}\n\nasync function writeReadMessage (stream, msg) {\n  const res = await pipe(\n    [msg],\n    lp.encode(),\n    stream,\n    lp.decode(),\n    async source => {\n      for await (const chunk of source) {\n        return chunk.slice()\n      }\n    }\n  )\n\n  if (res.length === 0) {\n    throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED')\n  }\n\n  return Message.deserialize(res)\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}