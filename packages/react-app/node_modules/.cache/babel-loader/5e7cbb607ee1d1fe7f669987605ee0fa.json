{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar debug = require('debug');\n\nvar EventEmitter = require('events');\n\nvar errcode = require('err-code');\n\nvar PeerId = require('peer-id');\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nvar message = require('./message');\n\nvar Peer = require('./peer');\n\nvar utils = require('./utils');\n\nvar _require = require('./message/sign'),\n    signMessage = _require.signMessage,\n    verifySignature = _require.verifySignature;\n\nfunction validateRegistrar(registrar) {\n  // registrar handling\n  if (typeof registrar !== 'object') {\n    throw new Error('a registrar object is required');\n  }\n\n  if (typeof registrar.handle !== 'function') {\n    throw new Error('a handle function must be provided in registrar');\n  }\n\n  if (typeof registrar.register !== 'function') {\n    throw new Error('a register function must be provided in registrar');\n  }\n\n  if (typeof registrar.unregister !== 'function') {\n    throw new Error('a unregister function must be provided in registrar');\n  }\n}\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nvar PubsubBaseProtocol = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PubsubBaseProtocol, _EventEmitter);\n\n  var _super = _createSuper(PubsubBaseProtocol);\n\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {PeerId} props.peerId peer's peerId\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {boolean} [props.signMessages] if messages should be signed, defaults to true\n   * @param {boolean} [props.strictSigning] if message signing should be required, defaults to true\n   * @abstract\n   */\n  function PubsubBaseProtocol(_ref) {\n    var _this;\n\n    var debugName = _ref.debugName,\n        multicodecs = _ref.multicodecs,\n        peerId = _ref.peerId,\n        registrar = _ref.registrar,\n        _ref$signMessages = _ref.signMessages,\n        signMessages = _ref$signMessages === void 0 ? true : _ref$signMessages,\n        _ref$strictSigning = _ref.strictSigning,\n        strictSigning = _ref$strictSigning === void 0 ? true : _ref$strictSigning;\n\n    _classCallCheck(this, PubsubBaseProtocol);\n\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!PeerId.isPeerId(peerId)) {\n      throw new Error('peerId must be an instance of `peer-id`');\n    }\n\n    validateRegistrar(registrar);\n    _this = _super.call(this);\n    _this.log = debug(debugName);\n    _this.log.err = debug(\"\".concat(debugName, \":error\"));\n    _this.multicodecs = utils.ensureArray(multicodecs);\n    _this.registrar = registrar;\n    _this.started = false;\n    _this.peerId = peerId;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.topics = new Map();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.peers = new Map(); // Message signing\n\n    _this.signMessages = signMessages;\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n\n    _this.strictSigning = strictSigning;\n    _this._registrarId = undefined;\n    _this._onIncomingStream = _this._onIncomingStream.bind(_assertThisInitialized(_this));\n    _this._onPeerConnected = _this._onPeerConnected.bind(_assertThisInitialized(_this));\n    _this._onPeerDisconnected = _this._onPeerDisconnected.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(PubsubBaseProtocol, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var topology;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.started) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                this.log('starting'); // Incoming streams\n\n                this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n\n                topology = new MulticodecTopology({\n                  multicodecs: this.multicodecs,\n                  handlers: {\n                    onConnect: this._onPeerConnected,\n                    onDisconnect: this._onPeerDisconnected\n                  }\n                });\n                _context.next = 7;\n                return this.registrar.register(topology);\n\n              case 7:\n                this._registrarId = _context.sent;\n                this.log('started');\n                this.started = true;\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Unregister the pubsub protocol and the streams with other peers will be closed.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.started) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                _context2.next = 4;\n                return this.registrar.unregister(this._registrarId);\n\n              case 4:\n                this.log('stopping');\n                this.peers.forEach(function (peer) {\n                  return peer.close();\n                });\n                this.peers = new Map();\n                this.started = false;\n                this.log('stopped');\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * On an incoming stream event.\n     * @private\n     * @param {Object} props\n     * @param {string} props.protocol\n     * @param {DuplexStream} props.strean\n     * @param {Connection} props.connection connection\n     */\n\n  }, {\n    key: \"_onIncomingStream\",\n    value: function _onIncomingStream(_ref2) {\n      var protocol = _ref2.protocol,\n          stream = _ref2.stream,\n          connection = _ref2.connection;\n      var peerId = connection.remotePeer;\n      var idB58Str = peerId.toB58String();\n\n      var peer = this._addPeer(peerId, [protocol]);\n\n      this._processMessages(idB58Str, stream, peer);\n    }\n    /**\n     * Registrar notifies a connection successfully with pubsub protocol.\n     * @private\n     * @param {PeerId} peerId remote peer-id\n     * @param {Connection} conn connection to the peer\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId, conn) {\n        var idB58Str, peer, _yield$conn$newStream, stream;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                idB58Str = peerId.toB58String();\n                this.log('connected', idB58Str);\n                peer = this._addPeer(peerId, this.multicodecs);\n                _context3.prev = 3;\n                _context3.next = 6;\n                return conn.newStream(this.multicodecs);\n\n              case 6:\n                _yield$conn$newStream = _context3.sent;\n                stream = _yield$conn$newStream.stream;\n                peer.attachConnection(stream);\n                _context3.next = 14;\n                break;\n\n              case 11:\n                _context3.prev = 11;\n                _context3.t0 = _context3[\"catch\"](3);\n                this.log.err(_context3.t0);\n\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 11]]);\n      }));\n\n      function _onPeerConnected(_x, _x2) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }()\n    /**\n     * Registrar notifies a closing connection with pubsub protocol.\n     * @private\n     * @param {PeerId} peerId peerId\n     * @param {Error} err error for connection end\n     */\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId, err) {\n      var idB58Str = peerId.toB58String();\n      var peer = this.peers.get(idB58Str);\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peer);\n    }\n    /**\n     * Add a new connected peer to the peers map.\n     * @private\n     * @param {PeerId} peerId\n     * @param {Array<string>} protocols\n     * @returns {Peer}\n     */\n\n  }, {\n    key: \"_addPeer\",\n    value: function _addPeer(peerId, protocols) {\n      var _this2 = this;\n\n      var id = peerId.toB58String();\n      var existing = this.peers.get(id);\n\n      if (!existing) {\n        this.log('new peer', id);\n        var peer = new Peer({\n          id: peerId,\n          protocols: protocols\n        });\n        this.peers.set(id, peer);\n        existing = peer;\n        peer.once('close', function () {\n          return _this2._removePeer(peer);\n        });\n      }\n\n      return existing;\n    }\n    /**\n     * Remove a peer from the peers map.\n     * @private\n     * @param {Peer} peer peer state\n     * @returns {Peer}\n     */\n\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      if (!peer) return;\n      var id = peer.id.toB58String();\n      this.log('delete peer', id);\n      this.peers.delete(id);\n      return peer;\n    }\n    /**\n     * Validates the given message. The signature will be checked for authenticity.\n     * @param {rpc.RPC.Message} message\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(message) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.strictSigning && !message.signature)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                this.log('Signing required and no signature was present, dropping message:', message);\n                return _context4.abrupt(\"return\", false);\n\n              case 3:\n                if (!message.signature) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", verifySignature(message));\n\n              case 7:\n                return _context4.abrupt(\"return\", true);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function validate(_x3) {\n        return _validate.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n    /**\n     * Normalizes the message and signs it, if signing is enabled\n     * @private\n     * @param {Message} message\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"_buildMessage\",\n    value: function _buildMessage(message) {\n      var msg = utils.normalizeOutRpcMessage(message);\n\n      if (this.signMessages) {\n        return signMessage(this.peerId, msg);\n      } else {\n        return message;\n      }\n    }\n    /**\n     * Get a list of the peer-ids that are subscribed to one topic.\n     * @param {string} topic\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"getSubscribers\",\n    value: function getSubscribers(topic) {\n      if (!this.started) {\n        throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n      }\n\n      if (!topic || typeof topic !== 'string') {\n        throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n      }\n\n      return Array.from(this.peers.values()).filter(function (peer) {\n        return peer.topics.has(topic);\n      }).map(function (peer) {\n        return peer.id.toB58String();\n      });\n    }\n    /**\n     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @returns {Promise}\n     *\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages) {\n      throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      throw errcode(new Error('subscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      throw errcode(new Error('unsubscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of getTopics should handle the appropriate algorithms for the publish/subscriber implementation.\n     * Get the list of subscriptions the peer is subscribed to.\n     * @abstract\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"getTopics\",\n    value: function getTopics() {\n      throw errcode(new Error('getTopics must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of _processMessages should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @abstract\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {Peer} peer A Pubsub Peer\n     * @returns {void}\n     *\n     */\n\n  }, {\n    key: \"_processMessages\",\n    value: function _processMessages(idB58Str, conn, peer) {\n      throw errcode(new Error('_processMessages must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n  }]);\n\n  return PubsubBaseProtocol;\n}(EventEmitter);\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-pubsub/src/index.js"],"names":["debug","require","EventEmitter","errcode","PeerId","MulticodecTopology","message","Peer","utils","signMessage","verifySignature","validateRegistrar","registrar","Error","handle","register","unregister","PubsubBaseProtocol","debugName","multicodecs","peerId","signMessages","strictSigning","isPeerId","log","err","ensureArray","started","topics","Map","peers","_registrarId","undefined","_onIncomingStream","bind","_onPeerConnected","_onPeerDisconnected","topology","handlers","onConnect","onDisconnect","forEach","peer","close","protocol","stream","connection","remotePeer","idB58Str","toB58String","_addPeer","_processMessages","conn","newStream","attachConnection","get","_removePeer","protocols","id","existing","set","once","delete","signature","msg","normalizeOutRpcMessage","topic","Array","from","values","filter","has","map","messages","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMC,YAAY,GAAGD,OAAO,CAAC,QAAD,CAA5B;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AAEA,IAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;;AACA,IAAMI,kBAAkB,GAAGJ,OAAO,CAAC,oDAAD,CAAlC;;AAEA,IAAMK,OAAO,GAAGL,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAMM,IAAI,GAAGN,OAAO,CAAC,QAAD,CAApB;;AACA,IAAMO,KAAK,GAAGP,OAAO,CAAC,SAAD,CAArB;;eAIIA,OAAO,CAAC,gBAAD,C;IAFTQ,W,YAAAA,W;IACAC,e,YAAAA,e;;AAGF,SAASC,iBAAT,CAA4BC,SAA5B,EAAuC;AACrC;AACA,MAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,UAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,MAAI,OAAOD,SAAS,CAACE,MAAjB,KAA4B,UAAhC,EAA4C;AAC1C,UAAM,IAAID,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAED,MAAI,OAAOD,SAAS,CAACG,QAAjB,KAA8B,UAAlC,EAA8C;AAC5C,UAAM,IAAIF,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,MAAI,OAAOD,SAAS,CAACI,UAAjB,KAAgC,UAApC,EAAgD;AAC9C,UAAM,IAAIH,KAAJ,CAAU,qDAAV,CAAN;AACD;AACF;AAED;;;;;IAGMI,kB;;;;;AACJ;;;;;;;;;;;;;AAaA,oCAOG;AAAA;;AAAA,QANDC,SAMC,QANDA,SAMC;AAAA,QALDC,WAKC,QALDA,WAKC;AAAA,QAJDC,MAIC,QAJDA,MAIC;AAAA,QAHDR,SAGC,QAHDA,SAGC;AAAA,iCAFDS,YAEC;AAAA,QAFDA,YAEC,kCAFc,IAEd;AAAA,kCADDC,aACC;AAAA,QADDA,aACC,mCADe,IACf;;AAAA;;AACD,QAAI,OAAOJ,SAAP,KAAqB,QAAzB,EAAmC;AACjC,YAAM,IAAIL,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAED,QAAI,CAACM,WAAL,EAAkB;AAChB,YAAM,IAAIN,KAAJ,CAAU,0BAAV,CAAN;AACD;;AAED,QAAI,CAACT,MAAM,CAACmB,QAAP,CAAgBH,MAAhB,CAAL,EAA8B;AAC5B,YAAM,IAAIP,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAEDF,IAAAA,iBAAiB,CAACC,SAAD,CAAjB;AAEA;AAEA,UAAKY,GAAL,GAAWxB,KAAK,CAACkB,SAAD,CAAhB;AACA,UAAKM,GAAL,CAASC,GAAT,GAAezB,KAAK,WAAIkB,SAAJ,YAApB;AAEA,UAAKC,WAAL,GAAmBX,KAAK,CAACkB,WAAN,CAAkBP,WAAlB,CAAnB;AACA,UAAKP,SAAL,GAAiBA,SAAjB;AAEA,UAAKe,OAAL,GAAe,KAAf;AAEA,UAAKP,MAAL,GAAcA,MAAd;AAEA;;;;;;AAKA,UAAKQ,MAAL,GAAc,IAAIC,GAAJ,EAAd;AAEA;;;;;;AAKA,UAAKC,KAAL,GAAa,IAAID,GAAJ,EAAb,CAvCC,CAyCD;;AACA,UAAKR,YAAL,GAAoBA,YAApB;AAEA;;;;;AAIA,UAAKC,aAAL,GAAqBA,aAArB;AAEA,UAAKS,YAAL,GAAoBC,SAApB;AACA,UAAKC,iBAAL,GAAyB,MAAKA,iBAAL,CAAuBC,IAAvB,+BAAzB;AACA,UAAKC,gBAAL,GAAwB,MAAKA,gBAAL,CAAsBD,IAAtB,+BAAxB;AACA,UAAKE,mBAAL,GAA2B,MAAKA,mBAAL,CAAyBF,IAAzB,+BAA3B;AArDC;AAsDF;AAED;;;;;;;;;;;;;;;qBAKM,KAAKP,O;;;;;;;;AAGT,qBAAKH,GAAL,CAAS,UAAT,E,CAEA;;AACA,qBAAKZ,SAAL,CAAeE,MAAf,CAAsB,KAAKK,WAA3B,EAAwC,KAAKc,iBAA7C,E,CAEA;;AACMI,gBAAAA,Q,GAAW,IAAIhC,kBAAJ,CAAuB;AACtCc,kBAAAA,WAAW,EAAE,KAAKA,WADoB;AAEtCmB,kBAAAA,QAAQ,EAAE;AACRC,oBAAAA,SAAS,EAAE,KAAKJ,gBADR;AAERK,oBAAAA,YAAY,EAAE,KAAKJ;AAFX;AAF4B,iBAAvB,C;;uBAOS,KAAKxB,SAAL,CAAeG,QAAf,CAAwBsB,QAAxB,C;;;AAA1B,qBAAKN,Y;AAEL,qBAAKP,GAAL,CAAS,SAAT;AACA,qBAAKG,OAAL,GAAe,IAAf;;;;;;;;;;;;;;;;AAGF;;;;;;;;;;;;;oBAKO,KAAKA,O;;;;;;;;;uBAKJ,KAAKf,SAAL,CAAeI,UAAf,CAA0B,KAAKe,YAA/B,C;;;AAEN,qBAAKP,GAAL,CAAS,UAAT;AACA,qBAAKM,KAAL,CAAWW,OAAX,CAAmB,UAACC,IAAD;AAAA,yBAAUA,IAAI,CAACC,KAAL,EAAV;AAAA,iBAAnB;AAEA,qBAAKb,KAAL,GAAa,IAAID,GAAJ,EAAb;AACA,qBAAKF,OAAL,GAAe,KAAf;AACA,qBAAKH,GAAL,CAAS,SAAT;;;;;;;;;;;;;;;;AAGF;;;;;;;;;;;6CAQqD;AAAA,UAAhCoB,QAAgC,SAAhCA,QAAgC;AAAA,UAAtBC,MAAsB,SAAtBA,MAAsB;AAAA,UAAdC,UAAc,SAAdA,UAAc;AACnD,UAAM1B,MAAM,GAAG0B,UAAU,CAACC,UAA1B;AACA,UAAMC,QAAQ,GAAG5B,MAAM,CAAC6B,WAAP,EAAjB;;AACA,UAAMP,IAAI,GAAG,KAAKQ,QAAL,CAAc9B,MAAd,EAAsB,CAACwB,QAAD,CAAtB,CAAb;;AAEA,WAAKO,gBAAL,CAAsBH,QAAtB,EAAgCH,MAAhC,EAAwCH,IAAxC;AACD;AAED;;;;;;;;;;yGAMwBtB,M,EAAQgC,I;;;;;;;AACxBJ,gBAAAA,Q,GAAW5B,MAAM,CAAC6B,WAAP,E;AACjB,qBAAKzB,GAAL,CAAS,WAAT,EAAsBwB,QAAtB;AAEMN,gBAAAA,I,GAAO,KAAKQ,QAAL,CAAc9B,MAAd,EAAsB,KAAKD,WAA3B,C;;;uBAGciC,IAAI,CAACC,SAAL,CAAe,KAAKlC,WAApB,C;;;;AAAjB0B,gBAAAA,M,yBAAAA,M;AACRH,gBAAAA,IAAI,CAACY,gBAAL,CAAsBT,MAAtB;;;;;;;AAEA,qBAAKrB,GAAL,CAASC,GAAT;;;;;;;;;;;;;;;;AAIJ;;;;;;;;;wCAMqBL,M,EAAQK,G,EAAK;AAChC,UAAMuB,QAAQ,GAAG5B,MAAM,CAAC6B,WAAP,EAAjB;AACA,UAAMP,IAAI,GAAG,KAAKZ,KAAL,CAAWyB,GAAX,CAAeP,QAAf,CAAb;AAEA,WAAKxB,GAAL,CAAS,kBAAT,EAA6BwB,QAA7B,EAAuCvB,GAAG,GAAGA,GAAG,CAACnB,OAAP,GAAiB,EAA3D;;AACA,WAAKkD,WAAL,CAAiBd,IAAjB;AACD;AAED;;;;;;;;;;6BAOUtB,M,EAAQqC,S,EAAW;AAAA;;AAC3B,UAAMC,EAAE,GAAGtC,MAAM,CAAC6B,WAAP,EAAX;AACA,UAAIU,QAAQ,GAAG,KAAK7B,KAAL,CAAWyB,GAAX,CAAeG,EAAf,CAAf;;AAEA,UAAI,CAACC,QAAL,EAAe;AACb,aAAKnC,GAAL,CAAS,UAAT,EAAqBkC,EAArB;AAEA,YAAMhB,IAAI,GAAG,IAAInC,IAAJ,CAAS;AACpBmD,UAAAA,EAAE,EAAEtC,MADgB;AAEpBqC,UAAAA,SAAS,EAATA;AAFoB,SAAT,CAAb;AAKA,aAAK3B,KAAL,CAAW8B,GAAX,CAAeF,EAAf,EAAmBhB,IAAnB;AACAiB,QAAAA,QAAQ,GAAGjB,IAAX;AAEAA,QAAAA,IAAI,CAACmB,IAAL,CAAU,OAAV,EAAmB;AAAA,iBAAM,MAAI,CAACL,WAAL,CAAiBd,IAAjB,CAAN;AAAA,SAAnB;AACD;;AAED,aAAOiB,QAAP;AACD;AAED;;;;;;;;;gCAMajB,I,EAAM;AACjB,UAAI,CAACA,IAAL,EAAW;AACX,UAAMgB,EAAE,GAAGhB,IAAI,CAACgB,EAAL,CAAQT,WAAR,EAAX;AAEA,WAAKzB,GAAL,CAAS,aAAT,EAAwBkC,EAAxB;AACA,WAAK5B,KAAL,CAAWgC,MAAX,CAAkBJ,EAAlB;AAEA,aAAOhB,IAAP;AACD;AAED;;;;;;;;;iGAKgBpC,O;;;;;sBAEV,KAAKgB,aAAL,IAAsB,CAAChB,OAAO,CAACyD,S;;;;;AACjC,qBAAKvC,GAAL,CAAS,kEAAT,EAA6ElB,OAA7E;kDACO,K;;;qBAILA,OAAO,CAACyD,S;;;;;kDACHrD,eAAe,CAACJ,OAAD,C;;;kDAEf,I;;;;;;;;;;;;;;;;AAIX;;;;;;;;;kCAMeA,O,EAAS;AACtB,UAAM0D,GAAG,GAAGxD,KAAK,CAACyD,sBAAN,CAA6B3D,OAA7B,CAAZ;;AACA,UAAI,KAAKe,YAAT,EAAuB;AACrB,eAAOZ,WAAW,CAAC,KAAKW,MAAN,EAAc4C,GAAd,CAAlB;AACD,OAFD,MAEO;AACL,eAAO1D,OAAP;AACD;AACF;AAED;;;;;;;;mCAKgB4D,K,EAAO;AACrB,UAAI,CAAC,KAAKvC,OAAV,EAAmB;AACjB,cAAMxB,OAAO,CAAC,IAAIU,KAAJ,CAAU,iBAAV,CAAD,EAA+B,qBAA/B,CAAb;AACD;;AAED,UAAI,CAACqD,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA/B,EAAyC;AACvC,cAAM/D,OAAO,CAAC,IAAIU,KAAJ,CAAU,iCAAV,CAAD,EAA+C,qBAA/C,CAAb;AACD;;AAED,aAAOsD,KAAK,CAACC,IAAN,CAAW,KAAKtC,KAAL,CAAWuC,MAAX,EAAX,EACJC,MADI,CACG,UAAC5B,IAAD;AAAA,eAAUA,IAAI,CAACd,MAAL,CAAY2C,GAAZ,CAAgBL,KAAhB,CAAV;AAAA,OADH,EAEJM,GAFI,CAEA,UAAC9B,IAAD;AAAA,eAAUA,IAAI,CAACgB,EAAL,CAAQT,WAAR,EAAV;AAAA,OAFA,CAAP;AAGD;AAED;;;;;;;;;;;;4BASSrB,M,EAAQ6C,Q,EAAU;AACzB,YAAMtE,OAAO,CAAC,IAAIU,KAAJ,CAAU,6CAAV,CAAD,EAA2D,qBAA3D,CAAb;AACD;AAED;;;;;;;;;;8BAOWe,M,EAAQ;AACjB,YAAMzB,OAAO,CAAC,IAAIU,KAAJ,CAAU,+CAAV,CAAD,EAA6D,qBAA7D,CAAb;AACD;AAED;;;;;;;;;;gCAOae,M,EAAQ;AACnB,YAAMzB,OAAO,CAAC,IAAIU,KAAJ,CAAU,iDAAV,CAAD,EAA+D,qBAA/D,CAAb;AACD;AAED;;;;;;;;;gCAMa;AACX,YAAMV,OAAO,CAAC,IAAIU,KAAJ,CAAU,+CAAV,CAAD,EAA6D,qBAA7D,CAAb;AACD;AAED;;;;;;;;;;;;;qCAUkBmC,Q,EAAUI,I,EAAMV,I,EAAM;AACtC,YAAMvC,OAAO,CAAC,IAAIU,KAAJ,CAAU,sDAAV,CAAD,EAAoE,qBAApE,CAAb;AACD;;;;EAzU8BX,Y;;AA4UjCwE,MAAM,CAACC,OAAP,GAAiB1D,kBAAjB;AACAyD,MAAM,CAACC,OAAP,CAAerE,OAAf,GAAyBA,OAAzB;AACAoE,MAAM,CAACC,OAAP,CAAenE,KAAf,GAAuBA,KAAvB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst EventEmitter = require('events')\nconst errcode = require('err-code')\n\nconst PeerId = require('peer-id')\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst message = require('./message')\nconst Peer = require('./peer')\nconst utils = require('./utils')\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign')\n\nfunction validateRegistrar (registrar) {\n  // registrar handling\n  if (typeof registrar !== 'object') {\n    throw new Error('a registrar object is required')\n  }\n\n  if (typeof registrar.handle !== 'function') {\n    throw new Error('a handle function must be provided in registrar')\n  }\n\n  if (typeof registrar.register !== 'function') {\n    throw new Error('a register function must be provided in registrar')\n  }\n\n  if (typeof registrar.unregister !== 'function') {\n    throw new Error('a unregister function must be provided in registrar')\n  }\n}\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {PeerId} props.peerId peer's peerId\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {boolean} [props.signMessages] if messages should be signed, defaults to true\n   * @param {boolean} [props.strictSigning] if message signing should be required, defaults to true\n   * @abstract\n   */\n  constructor ({\n    debugName,\n    multicodecs,\n    peerId,\n    registrar,\n    signMessages = true,\n    strictSigning = true\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required')\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required')\n    }\n\n    if (!PeerId.isPeerId(peerId)) {\n      throw new Error('peerId must be an instance of `peer-id`')\n    }\n\n    validateRegistrar(registrar)\n\n    super()\n\n    this.log = debug(debugName)\n    this.log.err = debug(`${debugName}:error`)\n\n    this.multicodecs = utils.ensureArray(multicodecs)\n    this.registrar = registrar\n\n    this.started = false\n\n    this.peerId = peerId\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.topics = new Map()\n\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.peers = new Map()\n\n    // Message signing\n    this.signMessages = signMessages\n\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n    this.strictSigning = strictSigning\n\n    this._registrarId = undefined\n    this._onIncomingStream = this._onIncomingStream.bind(this)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n  }\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {Promise<void>}\n   */\n  async start () {\n    if (this.started) {\n      return\n    }\n    this.log('starting')\n\n    // Incoming streams\n    this.registrar.handle(this.multicodecs, this._onIncomingStream)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    })\n    this._registrarId = await this.registrar.register(topology)\n\n    this.log('started')\n    this.started = true\n  }\n\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   * @returns {Promise}\n   */\n  async stop () {\n    if (!this.started) {\n      return\n    }\n\n    // unregister protocol and handlers\n    await this.registrar.unregister(this._registrarId)\n\n    this.log('stopping')\n    this.peers.forEach((peer) => peer.close())\n\n    this.peers = new Map()\n    this.started = false\n    this.log('stopped')\n  }\n\n  /**\n   * On an incoming stream event.\n   * @private\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {DuplexStream} props.strean\n   * @param {Connection} props.connection connection\n   */\n  _onIncomingStream ({ protocol, stream, connection }) {\n    const peerId = connection.remotePeer\n    const idB58Str = peerId.toB58String()\n    const peer = this._addPeer(peerId, [protocol])\n\n    this._processMessages(idB58Str, stream, peer)\n  }\n\n  /**\n   * Registrar notifies a connection successfully with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId remote peer-id\n   * @param {Connection} conn connection to the peer\n   */\n  async _onPeerConnected (peerId, conn) {\n    const idB58Str = peerId.toB58String()\n    this.log('connected', idB58Str)\n\n    const peer = this._addPeer(peerId, this.multicodecs)\n\n    try {\n      const { stream } = await conn.newStream(this.multicodecs)\n      peer.attachConnection(stream)\n    } catch (err) {\n      this.log.err(err)\n    }\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId peerId\n   * @param {Error} err error for connection end\n   */\n  _onPeerDisconnected (peerId, err) {\n    const idB58Str = peerId.toB58String()\n    const peer = this.peers.get(idB58Str)\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peer)\n  }\n\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Array<string>} protocols\n   * @returns {Peer}\n   */\n  _addPeer (peerId, protocols) {\n    const id = peerId.toB58String()\n    let existing = this.peers.get(id)\n\n    if (!existing) {\n      this.log('new peer', id)\n\n      const peer = new Peer({\n        id: peerId,\n        protocols\n      })\n\n      this.peers.set(id, peer)\n      existing = peer\n\n      peer.once('close', () => this._removePeer(peer))\n    }\n\n    return existing\n  }\n\n  /**\n   * Remove a peer from the peers map.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {Peer}\n   */\n  _removePeer (peer) {\n    if (!peer) return\n    const id = peer.id.toB58String()\n\n    this.log('delete peer', id)\n    this.peers.delete(id)\n\n    return peer\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * @param {rpc.RPC.Message} message\n   * @returns {Promise<Boolean>}\n   */\n  async validate (message) { // eslint-disable-line require-await\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      this.log('Signing required and no signature was present, dropping message:', message)\n      return false\n    }\n\n    // Check the message signature if present\n    if (message.signature) {\n      return verifySignature(message)\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   * @private\n   * @param {Message} message\n   * @returns {Promise<Message>}\n   */\n  _buildMessage (message) {\n    const msg = utils.normalizeOutRpcMessage(message)\n    if (this.signMessages) {\n      return signMessage(this.peerId, msg)\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n  getSubscribers (topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET')\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC')\n    }\n\n    return Array.from(this.peers.values())\n      .filter((peer) => peer.topics.has(topic))\n      .map((peer) => peer.id.toB58String())\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @returns {Promise}\n   *\n   */\n  publish (topics, messages) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  subscribe (topics) {\n    throw errcode(new Error('subscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  unsubscribe (topics) {\n    throw errcode(new Error('unsubscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of getTopics should handle the appropriate algorithms for the publish/subscriber implementation.\n   * Get the list of subscriptions the peer is subscribed to.\n   * @abstract\n   * @returns {Array<string>}\n   */\n  getTopics () {\n    throw errcode(new Error('getTopics must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of _processMessages should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {Peer} peer A Pubsub Peer\n   * @returns {void}\n   *\n   */\n  _processMessages (idB58Str, conn, peer) {\n    throw errcode(new Error('_processMessages must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n}\n\nmodule.exports = PubsubBaseProtocol\nmodule.exports.message = message\nmodule.exports.utils = utils\n"]},"metadata":{},"sourceType":"script"}