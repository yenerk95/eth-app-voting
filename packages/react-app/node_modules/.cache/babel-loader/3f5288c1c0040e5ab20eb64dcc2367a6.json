{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst CID = require('cids');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst errCode = require('err-code');\n\nconst multicodec = require('multicodec');\n\nconst dagCborLinks = require('dag-cbor-links');\n\nconst debug = require('debug');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  cidToString\n} = require('../../../utils/cid');\n\nconst createPinSet = require('./pin-set');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code; // arbitrary limit to the number of concurrent dag operations\n\nconst WALK_DAG_CONCURRENCY_LIMIT = 300;\nconst IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300;\nconst PIN_DS_KEY = new Key('/local/pins');\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n};\n\nclass PinManager {\n  constructor(repo, dag) {\n    this.repo = repo;\n    this.dag = dag;\n    this.log = debug('ipfs:pin');\n    this.pinset = createPinSet(dag);\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  async _walkDag({\n    cid,\n    preload = false,\n    onCid = () => {}\n  }) {\n    if (!CID.isCID(cid)) {\n      cid = new CID(cid);\n    }\n\n    const walk = cid => {\n      return async () => {\n        const {\n          value: node\n        } = await this.dag.get(cid, {\n          preload\n        });\n        onCid(cid);\n\n        if (cid.codec === 'dag-pb') {\n          queue.addAll(node.Links.map(link => walk(link.Hash)));\n        } else if (cid.codec === 'dag-cbor') {\n          for (const [_, childCid] of dagCborLinks(node)) {\n            // eslint-disable-line no-unused-vars\n            queue.add(walk(childCid));\n          }\n        }\n      };\n    };\n\n    const queue = new Queue({\n      concurrency: WALK_DAG_CONCURRENCY_LIMIT\n    });\n    queue.add(walk(cid));\n    await queue.onIdle();\n  }\n\n  directKeys() {\n    return Array.from(this.directPins, key => new CID(key).buffer);\n  }\n\n  recursiveKeys() {\n    return Array.from(this.recursivePins, key => new CID(key).buffer);\n  }\n\n  async getIndirectKeys({\n    preload\n  }) {\n    const indirectKeys = new Set();\n\n    for (const multihash of this.recursiveKeys()) {\n      await this._walkDag({\n        cid: new CID(multihash),\n        preload: preload || false,\n        onCid: cid => {\n          cid = cid.toString(); // recursive pins pre-empt indirect pins\n\n          if (!this.recursivePins.has(cid)) {\n            indirectKeys.add(cid);\n          }\n        }\n      });\n    }\n\n    return Array.from(indirectKeys);\n  } // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n\n\n  async flushPins() {\n    const [dLink, rLink] = await Promise.all([// create a DAGLink to the node with direct pins\n    this.pinset.storeSet(this.directKeys()).then(result => {\n      return new DAGLink(PinTypes.direct, result.node.size, result.cid);\n    }), // create a DAGLink to the node with recursive pins\n    this.pinset.storeSet(this.recursiveKeys()).then(result => {\n      return new DAGLink(PinTypes.recursive, result.node.size, result.cid);\n    }), // the pin-set nodes link to a special 'empty' node, so make sure it exists\n    this.dag.put(new DAGNode(Buffer.alloc(0)), {\n      version: 0,\n      format: multicodec.DAG_PB,\n      hashAlg: multicodec.SHA2_256,\n      preload: false\n    })]); // create a root node with DAGLinks to the direct and recursive DAGs\n\n    const rootNode = new DAGNode(Buffer.alloc(0), [dLink, rLink]);\n    const rootCid = await this.dag.put(rootNode, {\n      version: 0,\n      format: multicodec.DAG_PB,\n      hashAlg: multicodec.SHA2_256,\n      preload: false\n    }); // save root to datastore under a consistent key\n\n    await this.repo.datastore.put(PIN_DS_KEY, rootCid.buffer);\n    this.log(`Flushed pins with root: ${rootCid}`);\n  }\n\n  async load() {\n    const has = await this.repo.datastore.has(PIN_DS_KEY);\n\n    if (!has) {\n      return;\n    }\n\n    const mh = await this.repo.datastore.get(PIN_DS_KEY);\n    const pinRoot = await this.dag.get(new CID(mh), '', {\n      preload: false\n    });\n    const [rKeys, dKeys] = await Promise.all([this.pinset.loadSet(pinRoot.value, PinTypes.recursive), this.pinset.loadSet(pinRoot.value, PinTypes.direct)]);\n    this.directPins = new Set(dKeys.map(k => cidToString(k)));\n    this.recursivePins = new Set(rKeys.map(k => cidToString(k)));\n    this.log('Loaded pins from the datastore');\n  }\n\n  async isPinnedWithType(multihash, type) {\n    const key = cidToString(multihash);\n    const {\n      recursive,\n      direct,\n      all\n    } = PinTypes; // recursive\n\n    if ((type === recursive || type === all) && this.recursivePins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: recursive\n      };\n    }\n\n    if (type === recursive) {\n      return {\n        key,\n        pinned: false\n      };\n    } // direct\n\n\n    if ((type === direct || type === all) && this.directPins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: direct\n      };\n    }\n\n    if (type === direct) {\n      return {\n        key,\n        pinned: false\n      };\n    } // indirect (default)\n    // check each recursive key to see if multihash is under it\n    // arbitrary limit, enables handling 1000s of pins.\n\n\n    const queue = new Queue({\n      concurrency: IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT\n    });\n    let cid;\n    queue.addAll(this.recursiveKeys().map(childKey => {\n      childKey = new CID(childKey);\n      return async () => {\n        const has = await this.pinset.hasDescendant(childKey, key);\n\n        if (has) {\n          cid = childKey;\n          queue.clear();\n        }\n      };\n    }));\n    await queue.onIdle();\n    return {\n      key,\n      pinned: Boolean(cid),\n      reason: cid\n    };\n  } // Gets CIDs of blocks used internally by the pinner\n\n\n  async getInternalBlocks() {\n    let mh;\n\n    try {\n      mh = await this.repo.datastore.get(PIN_DS_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        this.log('No pinned blocks');\n        return [];\n      }\n\n      throw new Error(`Could not get pin sets root from datastore: ${err.message}`);\n    }\n\n    const cid = new CID(mh);\n    const obj = await this.dag.get(cid, '', {\n      preload: false\n    }); // The pinner stores an object that has two links to pin sets:\n    // 1. The directly pinned CIDs\n    // 2. The recursively pinned CIDs\n    // If large enough, these pin sets may have links to buckets to hold\n    // the pins\n\n    const cids = await this.pinset.getInternalCids(obj.value);\n    return cids.concat(cid);\n  }\n\n  async fetchCompleteDag(cid, options) {\n    await this._walkDag({\n      cid,\n      preload: options.preload\n    });\n  } // Returns an error if the pin type is invalid\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      return invalidPinTypeErr(type);\n    }\n  }\n\n}\n\nPinManager.PinTypes = PinTypes;\nmodule.exports = PinManager;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/pin-manager.js"],"names":["DAGNode","DAGLink","require","CID","default","Queue","Key","errCode","multicodec","dagCborLinks","debug","Buffer","cidToString","createPinSet","Errors","ERR_NOT_FOUND","notFoundError","code","WALK_DAG_CONCURRENCY_LIMIT","IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT","PIN_DS_KEY","invalidPinTypeErr","type","errMsg","Error","PinTypes","direct","recursive","indirect","all","PinManager","constructor","repo","dag","log","pinset","directPins","Set","recursivePins","_walkDag","cid","preload","onCid","isCID","walk","value","node","get","codec","queue","addAll","Links","map","link","Hash","_","childCid","add","concurrency","onIdle","directKeys","Array","from","key","buffer","recursiveKeys","getIndirectKeys","indirectKeys","multihash","toString","has","flushPins","dLink","rLink","Promise","storeSet","then","result","size","put","alloc","version","format","DAG_PB","hashAlg","SHA2_256","rootNode","rootCid","datastore","load","mh","pinRoot","rKeys","dKeys","loadSet","k","isPinnedWithType","pinned","reason","childKey","hasDescendant","clear","Boolean","getInternalBlocks","err","message","obj","cids","getInternalCids","concat","fetchCompleteDag","options","checkPinType","Object","keys","includes","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { DAGNode, DAGLink } = require('ipld-dag-pb')\nconst CID = require('cids')\nconst { default: Queue } = require('p-queue')\nconst { Key } = require('interface-datastore')\nconst errCode = require('err-code')\nconst multicodec = require('multicodec')\nconst dagCborLinks = require('dag-cbor-links')\nconst debug = require('debug')\nconst { Buffer } = require('buffer')\nconst { cidToString } = require('../../../utils/cid')\n\nconst createPinSet = require('./pin-set')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\n// arbitrary limit to the number of concurrent dag operations\nconst WALK_DAG_CONCURRENCY_LIMIT = 300\nconst IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300\nconst PIN_DS_KEY = new Key('/local/pins')\n\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nconst PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n}\n\nclass PinManager {\n  constructor (repo, dag) {\n    this.repo = repo\n    this.dag = dag\n    this.log = debug('ipfs:pin')\n    this.pinset = createPinSet(dag)\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  async _walkDag ({ cid, preload = false, onCid = () => {} }) {\n    if (!CID.isCID(cid)) {\n      cid = new CID(cid)\n    }\n\n    const walk = (cid) => {\n      return async () => {\n        const { value: node } = await this.dag.get(cid, { preload })\n\n        onCid(cid)\n\n        if (cid.codec === 'dag-pb') {\n          queue.addAll(\n            node.Links.map(link => walk(link.Hash))\n          )\n        } else if (cid.codec === 'dag-cbor') {\n          for (const [_, childCid] of dagCborLinks(node)) { // eslint-disable-line no-unused-vars\n            queue.add(walk(childCid))\n          }\n        }\n      }\n    }\n\n    const queue = new Queue({\n      concurrency: WALK_DAG_CONCURRENCY_LIMIT\n    })\n    queue.add(walk(cid))\n\n    await queue.onIdle()\n  }\n\n  directKeys () {\n    return Array.from(this.directPins, key => new CID(key).buffer)\n  }\n\n  recursiveKeys () {\n    return Array.from(this.recursivePins, key => new CID(key).buffer)\n  }\n\n  async getIndirectKeys ({ preload }) {\n    const indirectKeys = new Set()\n\n    for (const multihash of this.recursiveKeys()) {\n      await this._walkDag({\n        cid: new CID(multihash),\n        preload: preload || false,\n        onCid: (cid) => {\n          cid = cid.toString()\n\n          // recursive pins pre-empt indirect pins\n          if (!this.recursivePins.has(cid)) {\n            indirectKeys.add(cid)\n          }\n        }\n      })\n    }\n\n    return Array.from(indirectKeys)\n  }\n\n  // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n  async flushPins () {\n    const [\n      dLink,\n      rLink\n    ] = await Promise.all([\n      // create a DAGLink to the node with direct pins\n      this.pinset.storeSet(this.directKeys())\n        .then((result) => {\n          return new DAGLink(PinTypes.direct, result.node.size, result.cid)\n        }),\n      // create a DAGLink to the node with recursive pins\n      this.pinset.storeSet(this.recursiveKeys())\n        .then((result) => {\n          return new DAGLink(PinTypes.recursive, result.node.size, result.cid)\n        }),\n      // the pin-set nodes link to a special 'empty' node, so make sure it exists\n      this.dag.put(new DAGNode(Buffer.alloc(0)), {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      })\n    ])\n\n    // create a root node with DAGLinks to the direct and recursive DAGs\n    const rootNode = new DAGNode(Buffer.alloc(0), [dLink, rLink])\n    const rootCid = await this.dag.put(rootNode, {\n      version: 0,\n      format: multicodec.DAG_PB,\n      hashAlg: multicodec.SHA2_256,\n      preload: false\n    })\n\n    // save root to datastore under a consistent key\n    await this.repo.datastore.put(PIN_DS_KEY, rootCid.buffer)\n\n    this.log(`Flushed pins with root: ${rootCid}`)\n  }\n\n  async load () {\n    const has = await this.repo.datastore.has(PIN_DS_KEY)\n\n    if (!has) {\n      return\n    }\n\n    const mh = await this.repo.datastore.get(PIN_DS_KEY)\n    const pinRoot = await this.dag.get(new CID(mh), '', { preload: false })\n\n    const [\n      rKeys, dKeys\n    ] = await Promise.all([\n      this.pinset.loadSet(pinRoot.value, PinTypes.recursive),\n      this.pinset.loadSet(pinRoot.value, PinTypes.direct)\n    ])\n\n    this.directPins = new Set(dKeys.map(k => cidToString(k)))\n    this.recursivePins = new Set(rKeys.map(k => cidToString(k)))\n\n    this.log('Loaded pins from the datastore')\n  }\n\n  async isPinnedWithType (multihash, type) {\n    const key = cidToString(multihash)\n    const { recursive, direct, all } = PinTypes\n\n    // recursive\n    if ((type === recursive || type === all) && this.recursivePins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: recursive\n      }\n    }\n\n    if (type === recursive) {\n      return {\n        key,\n        pinned: false\n      }\n    }\n\n    // direct\n    if ((type === direct || type === all) && this.directPins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: direct\n      }\n    }\n\n    if (type === direct) {\n      return {\n        key,\n        pinned: false\n      }\n    }\n\n    // indirect (default)\n    // check each recursive key to see if multihash is under it\n    // arbitrary limit, enables handling 1000s of pins.\n    const queue = new Queue({\n      concurrency: IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT\n    })\n    let cid\n\n    queue.addAll(\n      this.recursiveKeys()\n        .map(childKey => {\n          childKey = new CID(childKey)\n\n          return async () => {\n            const has = await this.pinset.hasDescendant(childKey, key)\n\n            if (has) {\n              cid = childKey\n              queue.clear()\n            }\n          }\n        })\n    )\n\n    await queue.onIdle()\n\n    return {\n      key,\n      pinned: Boolean(cid),\n      reason: cid\n    }\n  }\n\n  // Gets CIDs of blocks used internally by the pinner\n  async getInternalBlocks () {\n    let mh\n\n    try {\n      mh = await this.repo.datastore.get(PIN_DS_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        this.log('No pinned blocks')\n\n        return []\n      }\n\n      throw new Error(`Could not get pin sets root from datastore: ${err.message}`)\n    }\n\n    const cid = new CID(mh)\n    const obj = await this.dag.get(cid, '', { preload: false })\n\n    // The pinner stores an object that has two links to pin sets:\n    // 1. The directly pinned CIDs\n    // 2. The recursively pinned CIDs\n    // If large enough, these pin sets may have links to buckets to hold\n    // the pins\n    const cids = await this.pinset.getInternalCids(obj.value)\n\n    return cids.concat(cid)\n  }\n\n  async fetchCompleteDag (cid, options) {\n    await this._walkDag({\n      cid,\n      preload: options.preload\n    })\n  }\n\n  // Returns an error if the pin type is invalid\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      return invalidPinTypeErr(type)\n    }\n  }\n}\n\nPinManager.PinTypes = PinTypes\n\nmodule.exports = PinManager\n"]},"metadata":{},"sourceType":"script"}