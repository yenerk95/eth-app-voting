{"ast":null,"code":"import _regeneratorRuntime from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { Buffer } from \"buffer\";\nimport { XX } from \"./handshakes/xx\";\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from \"./utils\";\nimport { logger, logLocalStaticKeys, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey, logCipherState } from \"./logger\";\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from \"./encoder\";\nexport var XXHandshake = /*#__PURE__*/function () {\n  function XXHandshake(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n    _classCallCheck(this, XXHandshake);\n\n    _defineProperty(this, \"isInitiator\", void 0);\n\n    _defineProperty(this, \"session\", void 0);\n\n    _defineProperty(this, \"remotePeer\", void 0);\n\n    _defineProperty(this, \"remoteEarlyData\", void 0);\n\n    _defineProperty(this, \"payload\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"xx\", void 0);\n\n    _defineProperty(this, \"staticKeypair\", void 0);\n\n    _defineProperty(this, \"prologue\", void 0);\n\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake || new XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = Buffer.alloc(0);\n  } // stage 0\n\n\n  _createClass(XXHandshake, [{\n    key: \"propose\",\n    value: function () {\n      var _propose = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var messageBuffer, receivedMessageBuffer, _this$xx$recvMessage, valid;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logLocalStaticKeys(this.session.hs.s);\n\n                if (!this.isInitiator) {\n                  _context.next = 9;\n                  break;\n                }\n\n                logger(\"Stage 0 - Initiator starting to send first message.\");\n                messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0));\n                this.connection.writeLP(encode0(messageBuffer));\n                logger(\"Stage 0 - Initiator finished sending first message.\");\n                logLocalEphemeralKeys(this.session.hs.e);\n                _context.next = 20;\n                break;\n\n              case 9:\n                logger(\"Stage 0 - Responder waiting to receive first message...\");\n                _context.t0 = decode0;\n                _context.next = 13;\n                return this.connection.readLP();\n\n              case 13:\n                _context.t1 = _context.sent.slice();\n                receivedMessageBuffer = (0, _context.t0)(_context.t1);\n                _this$xx$recvMessage = this.xx.recvMessage(this.session, receivedMessageBuffer), valid = _this$xx$recvMessage.valid;\n\n                if (valid) {\n                  _context.next = 18;\n                  break;\n                }\n\n                throw new Error(\"xx handshake stage 0 validation fail\");\n\n              case 18:\n                logger(\"Stage 0 - Responder received first message.\");\n                logRemoteEphemeralKey(this.session.hs.re);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function propose() {\n        return _propose.apply(this, arguments);\n      }\n\n      return propose;\n    }() // stage 1\n\n  }, {\n    key: \"exchange\",\n    value: function () {\n      var _exchange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var receivedMessageBuffer, _this$xx$recvMessage2, plaintext, valid, decodedPayload, messageBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.isInitiator) {\n                  _context2.next = 36;\n                  break;\n                }\n\n                logger('Stage 1 - Initiator waiting to receive first message from responder...');\n                _context2.t0 = decode1;\n                _context2.next = 5;\n                return this.connection.readLP();\n\n              case 5:\n                _context2.t1 = _context2.sent.slice();\n                receivedMessageBuffer = (0, _context2.t0)(_context2.t1);\n                _this$xx$recvMessage2 = this.xx.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$xx$recvMessage2.plaintext, valid = _this$xx$recvMessage2.valid;\n\n                if (valid) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw new Error(\"xx handshake stage 1 validation fail\");\n\n              case 10:\n                logger('Stage 1 - Initiator received the message.');\n                logRemoteEphemeralKey(this.session.hs.re);\n                logRemoteStaticKey(this.session.hs.rs);\n                logger(\"Initiator going to check remote's signature...\");\n                _context2.prev = 14;\n                _context2.next = 17;\n                return decodePayload(plaintext);\n\n              case 17:\n                decodedPayload = _context2.sent;\n                _context2.t2 = this.remotePeer;\n\n                if (_context2.t2) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                _context2.next = 22;\n                return getPeerIdFromPayload(decodedPayload);\n\n              case 22:\n                _context2.t2 = _context2.sent;\n\n              case 23:\n                this.remotePeer = _context2.t2;\n                _context2.next = 26;\n                return verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n\n              case 26:\n                this.remotePeer = _context2.sent;\n                this.setRemoteEarlyData(decodedPayload.data);\n                _context2.next = 33;\n                break;\n\n              case 30:\n                _context2.prev = 30;\n                _context2.t3 = _context2[\"catch\"](14);\n                throw new Error(\"Error occurred while verifying signed payload: \".concat(_context2.t3.message));\n\n              case 33:\n                logger(\"All good with the signature!\");\n                _context2.next = 41;\n                break;\n\n              case 36:\n                logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n                messageBuffer = this.xx.sendMessage(this.session, this.payload);\n                this.connection.writeLP(encode1(messageBuffer));\n                logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n                logLocalEphemeralKeys(this.session.hs.e);\n\n              case 41:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[14, 30]]);\n      }));\n\n      function exchange() {\n        return _exchange.apply(this, arguments);\n      }\n\n      return exchange;\n    }() // stage 2\n\n  }, {\n    key: \"finish\",\n    value: function () {\n      var _finish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var messageBuffer, receivedMessageBuffer, _this$xx$recvMessage3, plaintext, valid, decodedPayload;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.isInitiator) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                logger('Stage 2 - Initiator sending third handshake message.');\n                messageBuffer = this.xx.sendMessage(this.session, this.payload);\n                this.connection.writeLP(encode2(messageBuffer));\n                logger('Stage 2 - Initiator sent message with signed payload.');\n                _context3.next = 35;\n                break;\n\n              case 7:\n                logger('Stage 2 - Responder waiting for third handshake message...');\n                _context3.t0 = decode2;\n                _context3.next = 11;\n                return this.connection.readLP();\n\n              case 11:\n                _context3.t1 = _context3.sent.slice();\n                receivedMessageBuffer = (0, _context3.t0)(_context3.t1);\n                _this$xx$recvMessage3 = this.xx.recvMessage(this.session, receivedMessageBuffer), plaintext = _this$xx$recvMessage3.plaintext, valid = _this$xx$recvMessage3.valid;\n\n                if (valid) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                throw new Error(\"xx handshake stage 2 validation fail\");\n\n              case 16:\n                logger('Stage 2 - Responder received the message, finished handshake.');\n                _context3.prev = 17;\n                _context3.next = 20;\n                return decodePayload(plaintext);\n\n              case 20:\n                decodedPayload = _context3.sent;\n                _context3.t2 = this.remotePeer;\n\n                if (_context3.t2) {\n                  _context3.next = 26;\n                  break;\n                }\n\n                _context3.next = 25;\n                return getPeerIdFromPayload(decodedPayload);\n\n              case 25:\n                _context3.t2 = _context3.sent;\n\n              case 26:\n                this.remotePeer = _context3.t2;\n                _context3.next = 29;\n                return verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n\n              case 29:\n                this.setRemoteEarlyData(decodedPayload.data);\n                _context3.next = 35;\n                break;\n\n              case 32:\n                _context3.prev = 32;\n                _context3.t3 = _context3[\"catch\"](17);\n                throw new Error(\"Error occurred while verifying signed payload: \".concat(_context3.t3.message));\n\n              case 35:\n                logCipherState(this.session);\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[17, 32]]);\n      }));\n\n      function finish() {\n        return _finish.apply(this, arguments);\n      }\n\n      return finish;\n    }()\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(plaintext, session) {\n      var cs = this.getCS(session);\n      return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(ciphertext, session) {\n      var cs = this.getCS(session, false);\n      return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n    }\n  }, {\n    key: \"getRemoteStaticKey\",\n    value: function getRemoteStaticKey() {\n      return this.session.hs.rs;\n    }\n  }, {\n    key: \"getCS\",\n    value: function getCS(session) {\n      var encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!session.cs1 || !session.cs2) {\n        throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n      }\n\n      if (this.isInitiator) {\n        return encryption ? session.cs1 : session.cs2;\n      } else {\n        return encryption ? session.cs2 : session.cs1;\n      }\n    }\n  }, {\n    key: \"setRemoteEarlyData\",\n    value: function setRemoteEarlyData(data) {\n      if (data) {\n        this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n      }\n    }\n  }]);\n\n  return XXHandshake;\n}();","map":{"version":3,"sources":["../src/handshake-xx.ts"],"names":["constructor","handshake","Buffer","logLocalStaticKeys","logger","messageBuffer","encode0","logLocalEphemeralKeys","receivedMessageBuffer","decode0","valid","logRemoteEphemeralKey","decode1","logRemoteStaticKey","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","e","encode1","encode2","decode2","logCipherState","cs","encryption","session","data"],"mappings":"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","sourcesContent":["import { Buffer } from \"buffer\";\n\nimport { XX } from \"./handshakes/xx\";\nimport { KeyPair } from \"./@types/libp2p\";\nimport { bytes, bytes32 } from \"./@types/basic\";\nimport { NoiseSession } from \"./@types/handshake\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload,\n} from \"./utils\";\nimport {\n  logger, \n  logLocalStaticKeys, \n  logLocalEphemeralKeys, \n  logRemoteEphemeralKey, \n  logRemoteStaticKey, \n  logCipherState, \n} from \"./logger\";\nimport {decode0, decode1, decode2, encode0, encode1, encode2} from \"./encoder\";\nimport { WrappedConnection } from \"./noise\";\nimport PeerId from \"peer-id\";\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  protected payload: bytes;\n  protected connection: WrappedConnection;\n  protected xx: XX;\n  protected staticKeypair: KeyPair;\n\n  private prologue: bytes32;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remotePeer?: PeerId,\n    handshake?: XX,\n  ) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n    if(remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n    this.xx = handshake || new XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  // stage 0\n  public async propose(): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger(\"Stage 0 - Initiator starting to send first message.\");\n      const messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0));\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"Stage 0 - Initiator finished sending first message.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"Stage 0 - Responder waiting to receive first message...\");\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).slice());\n      const {valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 0 validation fail\");\n      }\n      logger(\"Stage 0 - Responder received first message.\");\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange(): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).slice());\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 1 validation fail\");\n      }\n      logger('Stage 1 - Initiator received the message.');\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\");\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        this.remotePeer = await verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n      }\n      logger(\"All good with the signature!\");\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish(): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode2(messageBuffer));\n      logger('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).slice());\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx handshake stage 2 validation fail\");\n      }\n      logger('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt(plaintext: bytes, session: NoiseSession): bytes {\n    const cs = this.getCS(session);\n\n    return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  public decrypt(ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  public getRemoteStaticKey(): bytes {\n    return this.session.hs.rs;\n  }\n\n  private getCS(session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  protected setRemoteEarlyData(data: Uint8Array|null|undefined): void {\n    if(data){\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}