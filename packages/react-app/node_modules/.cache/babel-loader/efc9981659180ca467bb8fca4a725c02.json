{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { generateKeypair, isValidPublicKey } from '../utils';\nimport { AbstractHandshake } from \"./abstract-handshake\";\nexport class XX extends AbstractHandshake {\n  initializeInitiator(prologue, s, rs, psk) {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      psk,\n      re\n    };\n  }\n\n  initializeResponder(prologue, s, rs, psk) {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      psk,\n      re\n    };\n  }\n\n  writeMessageA(hs, payload, e) {\n    const ns = Buffer.alloc(0);\n\n    if (e) {\n      hs.e = e;\n    } else {\n      hs.e = generateKeypair();\n    }\n\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageB(hs, payload) {\n    hs.e = generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageC(hs, payload) {\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    const ne = this.createEmptyKey();\n    const messageBuffer = {\n      ne,\n      ns,\n      ciphertext\n    };\n    const {\n      cs1,\n      cs2\n    } = this.split(hs.ss);\n    return {\n      h: hs.ss.h,\n      messageBuffer,\n      cs1,\n      cs2\n    };\n  }\n\n  readMessageA(hs, message) {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    return this.decryptAndHash(hs.ss, message.ciphertext);\n  }\n\n  readMessageB(hs, message) {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const {\n      plaintext: ns,\n      valid: valid1\n    } = this.decryptAndHash(hs.ss, message.ns);\n\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const {\n      plaintext,\n      valid: valid2\n    } = this.decryptAndHash(hs.ss, message.ciphertext);\n    return {\n      plaintext,\n      valid: valid1 && valid2\n    };\n  }\n\n  readMessageC(hs, message) {\n    const {\n      plaintext: ns,\n      valid: valid1\n    } = this.decryptAndHash(hs.ss, message.ns);\n\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const {\n      plaintext,\n      valid: valid2\n    } = this.decryptAndHash(hs.ss, message.ciphertext);\n    const {\n      cs1,\n      cs2\n    } = this.split(hs.ss);\n    return {\n      h: hs.ss.h,\n      plaintext,\n      valid: valid1 && valid2,\n      cs1,\n      cs2\n    };\n  }\n\n  initSession(initiator, prologue, s) {\n    const psk = this.createEmptyKey();\n    const rs = Buffer.alloc(32); // no static key yet\n\n    let hs;\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk);\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk);\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0\n    };\n  }\n\n  sendMessage(session, message, ephemeral) {\n    let messageBuffer;\n\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n    } else if (session.mc === 1) {\n      messageBuffer = this.writeMessageB(session.hs, message);\n    } else if (session.mc === 2) {\n      const {\n        h,\n        messageBuffer: resultingBuffer,\n        cs1,\n        cs2\n      } = this.writeMessageC(session.hs, message);\n      messageBuffer = resultingBuffer;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    } else if (session.mc > 2) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error(\"CS1 (cipher state) is not defined\");\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message);\n      } else {\n        if (!session.cs2) {\n          throw new Error(\"CS2 (cipher state) is not defined\");\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message);\n      }\n    } else {\n      throw new Error(\"Session invalid.\");\n    }\n\n    session.mc++;\n    return messageBuffer;\n  }\n\n  recvMessage(session, message) {\n    let plaintext = Buffer.alloc(0);\n    let valid = false;\n\n    if (session.mc === 0) {\n      ({\n        plaintext,\n        valid\n      } = this.readMessageA(session.hs, message));\n    } else if (session.mc === 1) {\n      ({\n        plaintext,\n        valid\n      } = this.readMessageB(session.hs, message));\n    } else if (session.mc === 2) {\n      const {\n        h,\n        plaintext: resultingPlaintext,\n        valid: resultingValid,\n        cs1,\n        cs2\n      } = this.readMessageC(session.hs, message);\n      plaintext = resultingPlaintext;\n      valid = resultingValid;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    }\n\n    session.mc++;\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n}","map":{"version":3,"sources":["../../src/handshakes/xx.ts"],"names":["initializeInitiator","name","ss","re","Buffer","initializeResponder","writeMessageA","ns","hs","generateKeypair","ne","ciphertext","writeMessageB","spk","writeMessageC","messageBuffer","cs2","h","readMessageA","isValidPublicKey","message","readMessageB","plaintext","valid","valid1","valid2","readMessageC","initSession","psk","rs","i","mc","sendMessage","session","recvMessage"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport { bytes32, bytes } from '../@types/basic'\nimport { KeyPair } from '../@types/libp2p'\nimport {generateKeypair, isValidPublicKey} from '../utils';\nimport {CipherState, HandshakeState, MessageBuffer, NoiseSession} from \"../@types/handshake\";\nimport {AbstractHandshake} from \"./abstract-handshake\";\n\n\nexport class XX extends AbstractHandshake {\n  private initializeInitiator(prologue: bytes32, s: KeyPair, rs: bytes32, psk: bytes32): HandshakeState {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n\n    return { ss, s, rs, psk, re };\n  }\n\n  private initializeResponder(prologue: bytes32, s: KeyPair, rs: bytes32, psk: bytes32): HandshakeState {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n\n    return { ss, s, rs, psk, re };\n  }\n\n  private writeMessageA(hs: HandshakeState, payload: bytes, e?: KeyPair): MessageBuffer {\n    const ns = Buffer.alloc(0);\n\n    if (e) {\n      hs.e = e;\n    } else {\n      hs.e = generateKeypair();\n    }\n\n    const ne = hs.e.publicKey;\n\n    this.mixHash(hs.ss, ne);\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n\n    return {ne, ns, ciphertext};\n  }\n\n  private writeMessageB(hs: HandshakeState, payload: bytes): MessageBuffer {\n    hs.e = generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n\n    return { ne, ns, ciphertext };\n  }\n\n  private writeMessageC(hs: HandshakeState, payload: bytes) {\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    const ne = this.createEmptyKey();\n    const messageBuffer: MessageBuffer = {ne, ns, ciphertext};\n    const { cs1, cs2 } = this.split(hs.ss);\n\n    return { h: hs.ss.h, messageBuffer, cs1, cs2 };\n  }\n\n  private readMessageA(hs: HandshakeState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    return this.decryptAndHash(hs.ss, message.ciphertext);\n  }\n\n  private readMessageB(hs: HandshakeState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);\n    return {plaintext, valid: (valid1 && valid2)};\n  }\n\n  private readMessageC(hs: HandshakeState, message: MessageBuffer): {h: bytes; plaintext: bytes; valid: boolean; cs1: CipherState; cs2: CipherState} {\n    const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n    const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);\n    const { cs1, cs2 } = this.split(hs.ss);\n\n    return { h: hs.ss.h, plaintext, valid: (valid1 && valid2), cs1, cs2 };\n  }\n\n  public initSession(initiator: boolean, prologue: bytes32, s: KeyPair): NoiseSession {\n    const psk = this.createEmptyKey();\n    const rs = Buffer.alloc(32); // no static key yet\n    let hs;\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk);\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk);\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0,\n    };\n  }\n\n  public sendMessage(session: NoiseSession, message: bytes, ephemeral?: KeyPair): MessageBuffer {\n    let messageBuffer: MessageBuffer;\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n    } else if (session.mc === 1) {\n      messageBuffer = this.writeMessageB(session.hs, message);\n    } else if (session.mc === 2) {\n      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);\n      messageBuffer = resultingBuffer;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    } else if (session.mc > 2) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error(\"CS1 (cipher state) is not defined\")\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message);\n      } else {\n        if (!session.cs2) {\n          throw new Error(\"CS2 (cipher state) is not defined\")\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message);\n      }\n    } else {\n      throw new Error(\"Session invalid.\")\n    }\n\n    session.mc++;\n    return messageBuffer;\n  }\n\n  public recvMessage(session: NoiseSession, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    let plaintext: bytes = Buffer.alloc(0);\n    let valid = false;\n    if (session.mc === 0) {\n      ({plaintext, valid} = this.readMessageA(session.hs, message));\n    } else if (session.mc === 1) {\n      ({plaintext, valid} = this.readMessageB(session.hs, message));\n    } else if (session.mc === 2) {\n      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);\n      plaintext = resultingPlaintext;\n      valid = resultingValid;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    }\n    session.mc++;\n    return {plaintext, valid};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}