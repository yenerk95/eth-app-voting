{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar _require = require('streaming-iterables'),\n    parallelMap = _require.parallelMap;\n\nvar CID = require('cids');\n\nvar _require2 = require('../../utils'),\n    resolvePath = _require2.resolvePath;\n\nvar PinManager = require('./pin-manager');\n\nvar PinTypes = PinManager.PinTypes;\n\nvar _require3 = require('../../utils'),\n    withTimeoutOption = _require3.withTimeoutOption;\n\nvar PIN_LS_CONCURRENCY = 8;\n\nmodule.exports = function (_ref) {\n  var pinManager = _ref.pinManager,\n      dag = _ref.dag;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _ls = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths, options) {\n      var type, err, cids, pins, indirects;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = options || {};\n              type = PinTypes.all;\n\n              if (paths && !Array.isArray(paths) && !CID.isCID(paths) && typeof paths !== 'string') {\n                options = paths;\n                paths = null;\n              }\n\n              if (!options.type) {\n                _context2.next = 9;\n                break;\n              }\n\n              type = options.type;\n\n              if (typeof options.type === 'string') {\n                type = options.type.toLowerCase();\n              }\n\n              err = PinManager.checkPinType(type);\n\n              if (!err) {\n                _context2.next = 9;\n                break;\n              }\n\n              throw err;\n\n            case 9:\n              if (!paths) {\n                _context2.next = 16;\n                break;\n              }\n\n              paths = Array.isArray(paths) ? paths : [paths]; // check the pinned state of specific hashes\n\n              _context2.next = 13;\n              return _awaitAsyncGenerator(resolvePath(dag, paths));\n\n            case 13:\n              cids = _context2.sent;\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(parallelMap(PIN_LS_CONCURRENCY, /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid) {\n                  var _yield$pinManager$isP, reason, pinned;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return pinManager.isPinnedWithType(cid, type);\n\n                        case 2:\n                          _yield$pinManager$isP = _context.sent;\n                          reason = _yield$pinManager$isP.reason;\n                          pinned = _yield$pinManager$isP.pinned;\n\n                          if (pinned) {\n                            _context.next = 7;\n                            break;\n                          }\n\n                          throw new Error(\"path '\".concat(paths[cids.indexOf(cid)], \"' is not pinned\"));\n\n                        case 7:\n                          if (!(reason === PinTypes.direct || reason === PinTypes.recursive)) {\n                            _context.next = 9;\n                            break;\n                          }\n\n                          return _context.abrupt(\"return\", {\n                            cid: cid,\n                            type: reason\n                          });\n\n                        case 9:\n                          return _context.abrupt(\"return\", {\n                            cid: cid,\n                            type: \"\".concat(PinTypes.indirect, \" through \").concat(reason)\n                          });\n\n                        case 10:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }(), cids)), _awaitAsyncGenerator), \"t0\", 15);\n\n            case 15:\n              return _context2.abrupt(\"return\");\n\n            case 16:\n              // show all pinned items of type\n              pins = [];\n\n              if (type === PinTypes.direct || type === PinTypes.all) {\n                pins = pins.concat(Array.from(pinManager.directPins).map(function (cid) {\n                  return {\n                    type: PinTypes.direct,\n                    cid: new CID(cid)\n                  };\n                }));\n              }\n\n              if (type === PinTypes.recursive || type === PinTypes.all) {\n                pins = pins.concat(Array.from(pinManager.recursivePins).map(function (cid) {\n                  return {\n                    type: PinTypes.recursive,\n                    cid: new CID(cid)\n                  };\n                }));\n              }\n\n              if (!(type === PinTypes.indirect || type === PinTypes.all)) {\n                _context2.next = 24;\n                break;\n              }\n\n              _context2.next = 22;\n              return _awaitAsyncGenerator(pinManager.getIndirectKeys(options));\n\n            case 22:\n              indirects = _context2.sent;\n              pins = pins // if something is pinned both directly and indirectly,\n              // report the indirect entry\n              .filter(function (_ref3) {\n                var cid = _ref3.cid;\n                return !indirects.includes(cid.toString()) || !pinManager.directPins.has(cid.toString());\n              }).concat(indirects.map(function (cid) {\n                return {\n                  type: PinTypes.indirect,\n                  cid: new CID(cid)\n                };\n              }));\n\n            case 24:\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pins), _awaitAsyncGenerator), \"t1\", 25);\n\n            case 25:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function ls(_x, _x2) {\n      return _ls.apply(this, arguments);\n    }\n\n    return ls;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/ls.js"],"names":["require","parallelMap","CID","resolvePath","PinManager","PinTypes","withTimeoutOption","PIN_LS_CONCURRENCY","module","exports","pinManager","dag","paths","options","type","all","Array","isArray","isCID","toLowerCase","err","checkPinType","cids","cid","isPinnedWithType","reason","pinned","Error","indexOf","direct","recursive","indirect","pins","concat","from","directPins","map","recursivePins","getIndirectKeys","indirects","filter","includes","toString","has","ls"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { parallelMap } = require('streaming-iterables')\nconst CID = require('cids')\nconst { resolvePath } = require('../../utils')\nconst PinManager = require('./pin-manager')\nconst { PinTypes } = PinManager\nconst { withTimeoutOption } = require('../../utils')\n\nconst PIN_LS_CONCURRENCY = 8\n\nmodule.exports = ({ pinManager, dag }) => {\n  return withTimeoutOption(async function * ls (paths, options) {\n    options = options || {}\n\n    let type = PinTypes.all\n\n    if (paths && !Array.isArray(paths) && !CID.isCID(paths) && typeof paths !== 'string') {\n      options = paths\n      paths = null\n    }\n\n    if (options.type) {\n      type = options.type\n      if (typeof options.type === 'string') {\n        type = options.type.toLowerCase()\n      }\n      const err = PinManager.checkPinType(type)\n      if (err) {\n        throw err\n      }\n    }\n\n    if (paths) {\n      paths = Array.isArray(paths) ? paths : [paths]\n\n      // check the pinned state of specific hashes\n      const cids = await resolvePath(dag, paths)\n\n      yield * parallelMap(PIN_LS_CONCURRENCY, async cid => {\n        const { reason, pinned } = await pinManager.isPinnedWithType(cid, type)\n\n        if (!pinned) {\n          throw new Error(`path '${paths[cids.indexOf(cid)]}' is not pinned`)\n        }\n\n        if (reason === PinTypes.direct || reason === PinTypes.recursive) {\n          return { cid, type: reason }\n        }\n\n        return { cid, type: `${PinTypes.indirect} through ${reason}` }\n      }, cids)\n\n      return\n    }\n\n    // show all pinned items of type\n    let pins = []\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      pins = pins.concat(\n        Array.from(pinManager.directPins).map(cid => ({\n          type: PinTypes.direct,\n          cid: new CID(cid)\n        }))\n      )\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      pins = pins.concat(\n        Array.from(pinManager.recursivePins).map(cid => ({\n          type: PinTypes.recursive,\n          cid: new CID(cid)\n        }))\n      )\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      const indirects = await pinManager.getIndirectKeys(options)\n\n      pins = pins\n        // if something is pinned both directly and indirectly,\n        // report the indirect entry\n        .filter(({ cid }) => !indirects.includes(cid.toString()) || !pinManager.directPins.has(cid.toString()))\n        .concat(indirects.map(cid => ({ type: PinTypes.indirect, cid: new CID(cid) })))\n    }\n\n    // FIXME: https://github.com/ipfs/js-ipfs/issues/2244\n    yield * pins\n  })\n}\n"]},"metadata":{},"sourceType":"script"}