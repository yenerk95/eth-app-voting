{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar isTypedArray = require('is-typedarray').strict;\n\nvar secp256k1 = require('secp256k1');\n\nvar sha = require('multihashing-async/src/sha');\n\nvar HASH_ALGORITHM = 'sha2-256';\n\nfunction typedArrayTobuffer(arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer);\n\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n    }\n\n    return buf;\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr);\n  }\n}\n\nmodule.exports = function (randomBytes) {\n  var privateKeyLength = 32;\n\n  function generateKey() {\n    var privateKey;\n\n    do {\n      privateKey = randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privateKey));\n\n    return privateKey;\n  }\n\n  function hashAndSign(_x, _x2) {\n    return _hashAndSign.apply(this, arguments);\n  }\n\n  function _hashAndSign() {\n    _hashAndSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, msg) {\n      var digest, sig;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return sha.digest(msg, HASH_ALGORITHM);\n\n            case 2:\n              digest = _context.sent;\n              sig = secp256k1.ecdsaSign(digest, key);\n              return _context.abrupt(\"return\", typedArrayTobuffer(secp256k1.signatureExport(sig.signature)));\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _hashAndSign.apply(this, arguments);\n  }\n\n  function hashAndVerify(_x3, _x4, _x5) {\n    return _hashAndVerify.apply(this, arguments);\n  }\n\n  function _hashAndVerify() {\n    _hashAndVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key, sig, msg) {\n      var digest;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return sha.digest(msg, HASH_ALGORITHM);\n\n            case 2:\n              digest = _context2.sent;\n              sig = typedArrayTobuffer(secp256k1.signatureImport(sig));\n              return _context2.abrupt(\"return\", secp256k1.ecdsaVerify(sig, digest, key));\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _hashAndVerify.apply(this, arguments);\n  }\n\n  function compressPublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n\n    return typedArrayTobuffer(secp256k1.publicKeyConvert(key, true));\n  }\n\n  function decompressPublicKey(key) {\n    return typedArrayTobuffer(secp256k1.publicKeyConvert(key, false));\n  }\n\n  function validatePrivateKey(key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key');\n    }\n  }\n\n  function validatePublicKey(key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key');\n    }\n  }\n\n  function computePublicKey(privateKey) {\n    validatePrivateKey(privateKey);\n    return typedArrayTobuffer(secp256k1.publicKeyCreate(privateKey));\n  }\n\n  return {\n    generateKey: generateKey,\n    privateKeyLength: privateKeyLength,\n    hashAndSign: hashAndSign,\n    hashAndVerify: hashAndVerify,\n    compressPublicKey: compressPublicKey,\n    decompressPublicKey: decompressPublicKey,\n    validatePrivateKey: validatePrivateKey,\n    validatePublicKey: validatePublicKey,\n    computePublicKey: computePublicKey\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/secp256k1.js"],"names":["require","Buffer","isTypedArray","strict","secp256k1","sha","HASH_ALGORITHM","typedArrayTobuffer","arr","buf","from","buffer","byteLength","slice","byteOffset","module","exports","randomBytes","privateKeyLength","generateKey","privateKey","privateKeyVerify","hashAndSign","key","msg","digest","sig","ecdsaSign","signatureExport","signature","hashAndVerify","signatureImport","ecdsaVerify","compressPublicKey","publicKeyVerify","Error","publicKeyConvert","decompressPublicKey","validatePrivateKey","validatePublicKey","computePublicKey","publicKeyCreate"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nvar isTypedArray = require('is-typedarray').strict\nconst secp256k1 = require('secp256k1')\nconst sha = require('multihashing-async/src/sha')\nconst HASH_ALGORITHM = 'sha2-256'\n\nfunction typedArrayTobuffer (arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n\nmodule.exports = (randomBytes) => {\n  const privateKeyLength = 32\n\n  function generateKey () {\n    let privateKey\n    do {\n      privateKey = randomBytes(32)\n    } while (!secp256k1.privateKeyVerify(privateKey))\n    return privateKey\n  }\n\n  async function hashAndSign (key, msg) {\n    const digest = await sha.digest(msg, HASH_ALGORITHM)\n    const sig = secp256k1.ecdsaSign(digest, key)\n    return typedArrayTobuffer(secp256k1.signatureExport(sig.signature))\n  }\n\n  async function hashAndVerify (key, sig, msg) {\n    const digest = await sha.digest(msg, HASH_ALGORITHM)\n    sig = typedArrayTobuffer(secp256k1.signatureImport(sig))\n    return secp256k1.ecdsaVerify(sig, digest, key)\n  }\n\n  function compressPublicKey (key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key')\n    }\n    return typedArrayTobuffer(secp256k1.publicKeyConvert(key, true))\n  }\n\n  function decompressPublicKey (key) {\n    return typedArrayTobuffer(secp256k1.publicKeyConvert(key, false))\n  }\n\n  function validatePrivateKey (key) {\n    if (!secp256k1.privateKeyVerify(key)) {\n      throw new Error('Invalid private key')\n    }\n  }\n\n  function validatePublicKey (key) {\n    if (!secp256k1.publicKeyVerify(key)) {\n      throw new Error('Invalid public key')\n    }\n  }\n\n  function computePublicKey (privateKey) {\n    validatePrivateKey(privateKey)\n    return typedArrayTobuffer(secp256k1.publicKeyCreate(privateKey))\n  }\n\n  return {\n    generateKey,\n    privateKeyLength,\n    hashAndSign,\n    hashAndVerify,\n    compressPublicKey,\n    decompressPublicKey,\n    validatePrivateKey,\n    validatePublicKey,\n    computePublicKey\n  }\n}\n"]},"metadata":{},"sourceType":"script"}