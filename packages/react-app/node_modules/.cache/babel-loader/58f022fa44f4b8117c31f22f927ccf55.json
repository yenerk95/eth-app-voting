{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar defaultMigrations = require('../migrations');\n\nvar repoVersion = require('./repo/version');\n\nvar repoLock = require('./repo/lock');\n\nvar errors = require('./errors');\n\nvar log = require('debug')('repo-migrations:migrator');\n\nexports.getCurrentRepoVersion = repoVersion.getVersion;\nexports.errors = errors;\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {array?} migrations - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {int}\n */\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n\nexports.getLatestMigrationVersion = getLatestMigrationVersion;\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {int} toVersion - Version to which the repo should be migrated.\n * @param {Object} options - Options for migration\n * @param {boolean?} options.ignoreLock - Won't lock the repo for applying the migrations. Use with caution.\n * @param {object?} options.repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {function?} options.onProgress - Callback which will be called after each executed migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the migrations without any effect.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nfunction migrate(_x, _x2, _x3) {\n  return _migrate.apply(this, arguments);\n}\n\nfunction _migrate() {\n  _migrate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, toVersion, _ref) {\n    var _ref$ignoreLock, ignoreLock, repoOptions, onProgress, _ref$isDryRun, isDryRun, migrations, currentVersion, lock, counter, totalMigrations, _iterator2, _step2, migration, lastSuccessfullyMigratedVersion;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref$ignoreLock = _ref.ignoreLock, ignoreLock = _ref$ignoreLock === void 0 ? false : _ref$ignoreLock, repoOptions = _ref.repoOptions, onProgress = _ref.onProgress, _ref$isDryRun = _ref.isDryRun, isDryRun = _ref$isDryRun === void 0 ? false : _ref$isDryRun, migrations = _ref.migrations;\n            migrations = migrations || defaultMigrations;\n\n            onProgress = onProgress || function () {};\n\n            if (path) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('Path argument is required!');\n\n          case 5:\n            if (toVersion) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('toVersion argument is required!');\n\n          case 7:\n            if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n              _context.next = 9;\n              break;\n            }\n\n            throw new errors.InvalidValueError('Version has to be positive integer!');\n\n          case 9:\n            _context.next = 11;\n            return repoVersion.getVersion(path);\n\n          case 11:\n            currentVersion = _context.sent;\n\n            if (!(currentVersion === toVersion)) {\n              _context.next = 15;\n              break;\n            }\n\n            log('Nothing to migrate.');\n            return _context.abrupt(\"return\");\n\n          case 15:\n            if (!(currentVersion > toVersion)) {\n              _context.next = 17;\n              break;\n            }\n\n            throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is higher then toVersion (\").concat(toVersion, \"), you probably wanted to revert it?\"));\n\n          case 17:\n            verifyAvailableMigrations(migrations, currentVersion, toVersion);\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context.next = 22;\n              break;\n            }\n\n            _context.next = 21;\n            return repoLock.lock(currentVersion, path);\n\n          case 21:\n            lock = _context.sent;\n\n          case 22:\n            _context.prev = 22;\n            counter = 0;\n            totalMigrations = toVersion - currentVersion;\n            _iterator2 = _createForOfIteratorHelper(migrations);\n            _context.prev = 26;\n\n            _iterator2.s();\n\n          case 28:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 54;\n              break;\n            }\n\n            migration = _step2.value;\n\n            if (!(toVersion !== undefined && migration.version > toVersion)) {\n              _context.next = 32;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 54);\n\n          case 32:\n            if (!(migration.version <= currentVersion)) {\n              _context.next = 34;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 52);\n\n          case 34:\n            counter++;\n            log(\"Migrating version \".concat(migration.version));\n            _context.prev = 36;\n\n            if (isDryRun) {\n              _context.next = 40;\n              break;\n            }\n\n            _context.next = 40;\n            return migration.migrate(path, repoOptions);\n\n          case 40:\n            _context.next = 50;\n            break;\n\n          case 42:\n            _context.prev = 42;\n            _context.t0 = _context[\"catch\"](36);\n            lastSuccessfullyMigratedVersion = migration.version - 1;\n            log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: \".concat(lastSuccessfullyMigratedVersion));\n            _context.next = 48;\n            return repoVersion.setVersion(path, lastSuccessfullyMigratedVersion);\n\n          case 48:\n            _context.t0.message = \"During migration to version \".concat(migration.version, \" exception was raised: \").concat(_context.t0.message);\n            throw _context.t0;\n\n          case 50:\n            onProgress(migration, counter, totalMigrations); // Reports on migration process\n\n            log(\"Migrating to version \".concat(migration.version, \" finished\"));\n\n          case 52:\n            _context.next = 28;\n            break;\n\n          case 54:\n            _context.next = 59;\n            break;\n\n          case 56:\n            _context.prev = 56;\n            _context.t1 = _context[\"catch\"](26);\n\n            _iterator2.e(_context.t1);\n\n          case 59:\n            _context.prev = 59;\n\n            _iterator2.f();\n\n            return _context.finish(59);\n\n          case 62:\n            if (isDryRun) {\n              _context.next = 65;\n              break;\n            }\n\n            _context.next = 65;\n            return repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations));\n\n          case 65:\n            log('Repo successfully migrated ', toVersion !== undefined ? \"to version \".concat(toVersion, \"!\") : 'to latest version!');\n\n          case 66:\n            _context.prev = 66;\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context.next = 70;\n              break;\n            }\n\n            _context.next = 70;\n            return lock.close();\n\n          case 70:\n            return _context.finish(66);\n\n          case 71:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[22,, 66, 71], [26, 56, 59, 62], [36, 42]]);\n  }));\n  return _migrate.apply(this, arguments);\n}\n\nexports.migrate = migrate;\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {int} toVersion - Version to which the repo will be reverted.\n * @param {Object} options - Options for the reversion\n * @param {function?} options.onProgress - Callback which will be called after each reverted migration to report progress\n * @param {object?} options.repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.\n * @param {boolean?} options.ignoreLock - Won't lock the repo for reverting the migrations. Use with caution.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nfunction revert(_x4, _x5, _x6) {\n  return _revert.apply(this, arguments);\n}\n\nfunction _revert() {\n  _revert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, toVersion, _ref2) {\n    var _ref2$ignoreLock, ignoreLock, repoOptions, onProgress, _ref2$isDryRun, isDryRun, migrations, currentVersion, lock, counter, totalMigrations, reversedMigrationArray, _iterator3, _step3, migration, lastSuccessfullyRevertedVersion;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2$ignoreLock = _ref2.ignoreLock, ignoreLock = _ref2$ignoreLock === void 0 ? false : _ref2$ignoreLock, repoOptions = _ref2.repoOptions, onProgress = _ref2.onProgress, _ref2$isDryRun = _ref2.isDryRun, isDryRun = _ref2$isDryRun === void 0 ? false : _ref2$isDryRun, migrations = _ref2.migrations;\n            migrations = migrations || defaultMigrations;\n\n            onProgress = onProgress || function () {};\n\n            if (path) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('Path argument is required!');\n\n          case 5:\n            if (toVersion) {\n              _context2.next = 7;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n\n          case 7:\n            if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new errors.InvalidValueError('Version has to be positive integer!');\n\n          case 9:\n            _context2.next = 11;\n            return repoVersion.getVersion(path);\n\n          case 11:\n            currentVersion = _context2.sent;\n\n            if (!(currentVersion === toVersion)) {\n              _context2.next = 15;\n              break;\n            }\n\n            log('Nothing to revert.');\n            return _context2.abrupt(\"return\");\n\n          case 15:\n            if (!(currentVersion < toVersion)) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is lower then toVersion (\").concat(toVersion, \"), you probably wanted to migrate it?\"));\n\n          case 17:\n            verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context2.next = 22;\n              break;\n            }\n\n            _context2.next = 21;\n            return repoLock.lock(currentVersion, path);\n\n          case 21:\n            lock = _context2.sent;\n\n          case 22:\n            log(\"Reverting from version \".concat(currentVersion, \" to \").concat(toVersion));\n            _context2.prev = 23;\n            counter = 0;\n            totalMigrations = currentVersion - toVersion;\n            reversedMigrationArray = migrations.slice().reverse();\n            _iterator3 = _createForOfIteratorHelper(reversedMigrationArray);\n            _context2.prev = 28;\n\n            _iterator3.s();\n\n          case 30:\n            if ((_step3 = _iterator3.n()).done) {\n              _context2.next = 56;\n              break;\n            }\n\n            migration = _step3.value;\n\n            if (!(migration.version <= toVersion)) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 56);\n\n          case 34:\n            if (!(migration.version > currentVersion)) {\n              _context2.next = 36;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 54);\n\n          case 36:\n            counter++;\n            log(\"Reverting migration version \".concat(migration.version));\n            _context2.prev = 38;\n\n            if (isDryRun) {\n              _context2.next = 42;\n              break;\n            }\n\n            _context2.next = 42;\n            return migration.revert(path, repoOptions);\n\n          case 42:\n            _context2.next = 52;\n            break;\n\n          case 44:\n            _context2.prev = 44;\n            _context2.t0 = _context2[\"catch\"](38);\n            lastSuccessfullyRevertedVersion = migration.version;\n            log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: \".concat(lastSuccessfullyRevertedVersion));\n            _context2.next = 50;\n            return repoVersion.setVersion(path, lastSuccessfullyRevertedVersion);\n\n          case 50:\n            _context2.t0.message = \"During reversion to version \".concat(migration.version, \" exception was raised: \").concat(_context2.t0.message);\n            throw _context2.t0;\n\n          case 52:\n            onProgress(migration, counter, totalMigrations); // Reports on migration process\n\n            log(\"Reverting to version \".concat(migration.version, \" finished\"));\n\n          case 54:\n            _context2.next = 30;\n            break;\n\n          case 56:\n            _context2.next = 61;\n            break;\n\n          case 58:\n            _context2.prev = 58;\n            _context2.t1 = _context2[\"catch\"](28);\n\n            _iterator3.e(_context2.t1);\n\n          case 61:\n            _context2.prev = 61;\n\n            _iterator3.f();\n\n            return _context2.finish(61);\n\n          case 64:\n            if (isDryRun) {\n              _context2.next = 67;\n              break;\n            }\n\n            _context2.next = 67;\n            return repoVersion.setVersion(path, toVersion);\n\n          case 67:\n            log(\"All migrations successfully reverted to version \".concat(toVersion, \"!\"));\n\n          case 68:\n            _context2.prev = 68;\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context2.next = 72;\n              break;\n            }\n\n            _context2.next = 72;\n            return lock.close();\n\n          case 72:\n            return _context2.finish(68);\n\n          case 73:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[23,, 68, 73], [28, 58, 61, 64], [38, 44]]);\n  }));\n  return _revert.apply(this, arguments);\n}\n\nexports.revert = revert;\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {array} migrations\n * @param {int} fromVersion\n * @param {int} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n * @returns {void}\n */\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion) {\n  var checkReversibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var migrationCounter = 0;\n\n  var _iterator = _createForOfIteratorHelper(migrations),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var migration = _step.value;\n\n      if (migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version > fromVersion) {\n        if (checkReversibility && !migration.revert) {\n          throw new errors.NonReversibleMigrationError(\"It is not possible to revert to version \".concat(fromVersion, \" because migration version \").concat(migration.version, \" is not reversible. Cancelling reversion.\"));\n        }\n\n        migrationCounter++;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(\"The ipfs-repo-migrations package does not have all migration to migrate from version \".concat(fromVersion, \" to \").concat(toVersion));\n  }\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo-migrations/src/index.js"],"names":["defaultMigrations","require","repoVersion","repoLock","errors","log","exports","getCurrentRepoVersion","getVersion","getLatestMigrationVersion","migrations","Array","isArray","length","version","migrate","path","toVersion","ignoreLock","repoOptions","onProgress","isDryRun","RequiredParameterError","Number","isInteger","InvalidValueError","currentVersion","verifyAvailableMigrations","lock","counter","totalMigrations","migration","undefined","lastSuccessfullyMigratedVersion","setVersion","message","close","revert","reversedMigrationArray","slice","reverse","lastSuccessfullyRevertedVersion","fromVersion","checkReversibility","migrationCounter","NonReversibleMigrationError"],"mappings":"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","sourcesContent":["'use strict'\n\nconst defaultMigrations = require('../migrations')\nconst repoVersion = require('./repo/version')\nconst repoLock = require('./repo/lock')\nconst errors = require('./errors')\n\nconst log = require('debug')('repo-migrations:migrator')\n\nexports.getCurrentRepoVersion = repoVersion.getVersion\nexports.errors = errors\n\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {array?} migrations - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {int}\n */\nfunction getLatestMigrationVersion (migrations) {\n  migrations = migrations || defaultMigrations\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0\n  }\n\n  return migrations[migrations.length - 1].version\n}\n\nexports.getLatestMigrationVersion = getLatestMigrationVersion\n\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {int} toVersion - Version to which the repo should be migrated.\n * @param {Object} options - Options for migration\n * @param {boolean?} options.ignoreLock - Won't lock the repo for applying the migrations. Use with caution.\n * @param {object?} options.repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {function?} options.onProgress - Callback which will be called after each executed migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the migrations without any effect.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\nasync function migrate (path, toVersion, { ignoreLock = false, repoOptions, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n  onProgress = onProgress || (() => {})\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  const currentVersion = await repoVersion.getVersion(path)\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.')\n    return\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`)\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion)\n\n  let lock\n  if (!isDryRun && !ignoreLock) lock = await repoLock.lock(currentVersion, path)\n\n  try {\n    let counter = 0\n    const totalMigrations = toVersion - currentVersion\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break\n      }\n      if (migration.version <= currentVersion) {\n        continue\n      }\n\n      counter++\n      log(`Migrating version ${migration.version}`)\n      try {\n        if (!isDryRun) await migration.migrate(path, repoOptions)\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`)\n        await repoVersion.setVersion(path, lastSuccessfullyMigratedVersion)\n\n        e.message = `During migration to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      onProgress(migration, counter, totalMigrations) // Reports on migration process\n      log(`Migrating to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) await repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations))\n    log('Repo successfully migrated ', toVersion !== undefined ? `to version ${toVersion}!` : 'to latest version!')\n  } finally {\n    if (!isDryRun && !ignoreLock) await lock.close()\n  }\n}\n\nexports.migrate = migrate\n\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {int} toVersion - Version to which the repo will be reverted.\n * @param {Object} options - Options for the reversion\n * @param {function?} options.onProgress - Callback which will be called after each reverted migration to report progress\n * @param {object?} options.repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.\n * @param {boolean?} options.ignoreLock - Won't lock the repo for reverting the migrations. Use with caution.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\nasync function revert (path, toVersion, { ignoreLock = false, repoOptions, onProgress, isDryRun = false, migrations }) {\n  migrations = migrations || defaultMigrations\n  onProgress = onProgress || (() => {})\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!')\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!')\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!')\n  }\n\n  const currentVersion = await repoVersion.getVersion(path)\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.')\n    return\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`)\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true)\n\n  let lock\n  if (!isDryRun && !ignoreLock) lock = await repoLock.lock(currentVersion, path)\n\n  log(`Reverting from version ${currentVersion} to ${toVersion}`)\n  try {\n    let counter = 0\n    const totalMigrations = currentVersion - toVersion\n    const reversedMigrationArray = migrations.slice().reverse()\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break\n      }\n\n      if (migration.version > currentVersion) {\n        continue\n      }\n\n      counter++\n      log(`Reverting migration version ${migration.version}`)\n      try {\n        if (!isDryRun) await migration.revert(path, repoOptions)\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version\n        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`)\n        await repoVersion.setVersion(path, lastSuccessfullyRevertedVersion)\n\n        e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`\n        throw e\n      }\n\n      onProgress(migration, counter, totalMigrations) // Reports on migration process\n      log(`Reverting to version ${migration.version} finished`)\n    }\n\n    if (!isDryRun) await repoVersion.setVersion(path, toVersion)\n    log(`All migrations successfully reverted to version ${toVersion}!`)\n  } finally {\n    if (!isDryRun && !ignoreLock) await lock.close()\n  }\n}\n\nexports.revert = revert\n\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {array} migrations\n * @param {int} fromVersion\n * @param {int} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n * @returns {void}\n */\nfunction verifyAvailableMigrations (migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`)\n      }\n\n      migrationCounter++\n    }\n  }\n\n  if (migrationCounter !== (toVersion - fromVersion)) {\n    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}