{"ast":null,"code":"'use strict';\n\nconst NanoDate = require('timestamp-nano');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst multihash = require('multihashes');\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst multibase = require('multibase');\n\nconst debug = require('debug');\n\nconst log = debug('jsipns');\nlog.error = debug('jsipns:error');\n\nconst ipnsEntryProto = require('./pb/ipns.proto');\n\nconst {\n  parseRFC3339\n} = require('./utils');\n\nconst ERRORS = require('./errors');\n\nconst ID_MULTIHASH_CODE = multihash.names.id;\nconst namespace = '/ipns/';\n/**\n * IPNS entry\n * @typedef {Object} IpnsEntry\n * @property {string} value - value to be stored in the record\n * @property {Buffer} signature - signature of the record\n * @property {number} validityType - Type of validation being used\n * @property {string} validity - expiration datetime for the record in RFC3339 format\n * @property {number} sequence - number representing the version of the record\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @returns {Promise<IpnsEntry>} entry\n */\n\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString();\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, isoValidity, validityType);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @returns {Promise<IpnsEntry>} entry\n */\n\n\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, expiration, validityType);\n};\n\nconst _create = async (privateKey, value, seq, isoValidity, validityType) => {\n  const signature = await sign(privateKey, value, validityType, isoValidity);\n  const entry = {\n    value: value,\n    signature: signature,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq\n  };\n  log(`ipns entry for ${value} created`);\n  return entry;\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Promise}\n */\n\n\nconst validate = async (publicKey, entry) => {\n  const {\n    value,\n    validityType,\n    validity\n  } = entry;\n  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity); // Validate Signature\n\n  let isValid;\n\n  try {\n    isValid = await publicKey.verify(dataForSignature, entry.signature);\n  } catch (err) {\n    isValid = false;\n  }\n\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  } // Validate according to the validity type\n\n\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate;\n\n    try {\n      validityDate = parseRFC3339(validity.toString());\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n    }\n\n    if (validityDate < Date.now()) {\n      log.error('record has expired');\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type');\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  log(`ipns entry for ${value} is valid`);\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @return {IpnsEntry} entry with public key embedded\n */\n\n\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  } // Create a peer id from the public key.\n\n\n  let peerId;\n\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes);\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n  } // Try to extract the public key from the ID. If we can, no need to embed it\n\n\n  let extractedPublicKey;\n\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId);\n  } catch (err) {\n    log.error(err);\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n  }\n\n  if (extractedPublicKey) {\n    return null;\n  } // If we failed to extract the public key from the peer ID, embed it in the record.\n\n\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n  } catch (err) {\n    log.error(err);\n    throw err;\n  }\n\n  return entry;\n};\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Object} the public key\n */\n\n\nconst extractPublicKey = (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  if (entry.pubKey) {\n    let pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return pubKey;\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey;\n  }\n\n  throw Object.assign(new Error('no public key is available'), {\n    code: ERRORS.ERR_UNDEFINED_PARAMETER\n  });\n}; // rawStdEncoding with RFC4648\n\n\nconst rawStdEncoding = key => multibase.encode('base32', key).toString().slice(1).toUpperCase();\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\n\n\nconst getLocalKey = key => new Key(`/ipns/${rawStdEncoding(key)}`);\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\n\n\nconst getIdKeys = pid => {\n  const pkBuffer = Buffer.from('/pk/');\n  const ipnsBuffer = Buffer.from('/ipns/');\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  };\n}; // Sign ipns record data\n\n\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForSig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n}; // Utility for getting the validity type code name of a validity\n\n\nconst getValidityType = validityType => {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`);\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n}; // Utility for creating the record data for being signed\n\n\nconst ipnsEntryDataForSig = (value, validityType, validity) => {\n  const valueBuffer = Buffer.from(value);\n  const validityTypeBuffer = Buffer.from(getValidityType(validityType));\n  const validityBuffer = Buffer.from(validity);\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer]);\n}; // Utility for extracting the public key from a peer-id\n\n\nconst extractPublicKeyFromId = peerId => {\n  const decodedId = multihash.decode(peerId.id);\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest);\n};\n\nconst marshal = ipnsEntryProto.encode;\nconst unmarshal = ipnsEntryProto.decode;\nconst validator = {\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData);\n    const bufferId = key.slice('/ipns/'.length);\n    const peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n    const pubKey = extractPublicKey(peerId, receivedEntry); // Record validation\n\n    await validate(pubKey, receivedEntry);\n    return true;\n  },\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA);\n    const entryB = unmarshal(dataB);\n    return entryA.sequence > entryB.sequence ? 0 : 1;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipns/src/index.js"],"names":["NanoDate","require","Key","crypto","PeerId","multihash","errCode","Buffer","multibase","debug","log","error","ipnsEntryProto","parseRFC3339","ERRORS","ID_MULTIHASH_CODE","names","id","namespace","create","privateKey","value","seq","lifetime","isoValidity","Date","now","Number","toString","validityType","ValidityType","EOL","_create","createWithExpiration","expiration","signature","sign","entry","validity","sequence","validate","publicKey","dataForSignature","ipnsEntryDataForSig","isValid","verify","err","Error","ERR_SIGNATURE_VERIFICATION","validityDate","e","ERR_UNRECOGNIZED_FORMAT","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","embedPublicKey","bytes","ERR_UNDEFINED_PARAMETER","peerId","createFromPubKey","ERR_PEER_ID_FROM_PUBLIC_KEY","extractedPublicKey","extractPublicKeyFromId","ERR_PUBLIC_KEY_FROM_ID","pubKey","keys","marshalPublicKey","extractPublicKey","unmarshalPublicKey","Object","assign","code","rawStdEncoding","key","encode","slice","toUpperCase","getLocalKey","getIdKeys","pid","pkBuffer","from","ipnsBuffer","routingPubKey","concat","pkKey","routingKey","ipnsKey","message","ERR_SIGNATURE_CREATION","getValidityType","valueBuffer","validityTypeBuffer","validityBuffer","decodedId","decode","digest","marshal","unmarshal","validator","marshalledData","receivedEntry","bufferId","length","createFromBytes","select","dataA","dataB","entryA","entryB","module","exports","namespaceLength"],"mappings":"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","sourcesContent":["'use strict'\n\nconst NanoDate = require('timestamp-nano')\nconst { Key } = require('interface-datastore')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst multihash = require('multihashes')\nconst errCode = require('err-code')\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\n\nconst debug = require('debug')\nconst log = debug('jsipns')\nlog.error = debug('jsipns:error')\n\nconst ipnsEntryProto = require('./pb/ipns.proto')\nconst { parseRFC3339 } = require('./utils')\nconst ERRORS = require('./errors')\n\nconst ID_MULTIHASH_CODE = multihash.names.id\n\nconst namespace = '/ipns/'\n\n/**\n * IPNS entry\n * @typedef {Object} IpnsEntry\n * @property {string} value - value to be stored in the record\n * @property {Buffer} signature - signature of the record\n * @property {number} validityType - Type of validation being used\n * @property {string} validity - expiration datetime for the record in RFC3339 format\n * @property {number} sequence - number representing the version of the record\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @returns {Promise<IpnsEntry>} entry\n */\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString()\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  return _create(privateKey, value, seq, isoValidity, validityType)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @returns {Promise<IpnsEntry>} entry\n */\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  return _create(privateKey, value, seq, expiration, validityType)\n}\n\nconst _create = async (privateKey, value, seq, isoValidity, validityType) => {\n  const signature = await sign(privateKey, value, validityType, isoValidity)\n\n  const entry = {\n    value: value,\n    signature: signature,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq\n  }\n\n  log(`ipns entry for ${value} created`)\n  return entry\n}\n\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Promise}\n */\nconst validate = async (publicKey, entry) => {\n  const { value, validityType, validity } = entry\n  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)\n\n  // Validate Signature\n  let isValid\n  try {\n    isValid = await publicKey.verify(dataForSignature, entry.signature)\n  } catch (err) {\n    isValid = false\n  }\n  if (!isValid) {\n    log.error('record signature verification failed')\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate according to the validity type\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate\n\n    try {\n      validityDate = parseRFC3339(validity.toString())\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)')\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT)\n    }\n\n    if (validityDate < Date.now()) {\n      log.error('record has expired')\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD)\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type')\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  log(`ipns entry for ${value} is valid`)\n}\n\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @return {IpnsEntry} entry with public key embedded\n */\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined')\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  // Create a peer id from the public key.\n  let peerId\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes)\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY)\n  }\n\n  // Try to extract the public key from the ID. If we can, no need to embed it\n  let extractedPublicKey\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId)\n  } catch (err) {\n    log.error(err)\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID)\n  }\n\n  if (extractedPublicKey) {\n    return null\n  }\n\n  // If we failed to extract the public key from the peer ID, embed it in the record.\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey)\n  } catch (err) {\n    log.error(err)\n    throw err\n  }\n  return entry\n}\n\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Object} the public key\n */\nconst extractPublicKey = (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined')\n\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  if (entry.pubKey) {\n    let pubKey\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n    return pubKey\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey\n  }\n  throw Object.assign(new Error('no public key is available'), { code: ERRORS.ERR_UNDEFINED_PARAMETER })\n}\n\n// rawStdEncoding with RFC4648\nconst rawStdEncoding = (key) => multibase.encode('base32', key).toString().slice(1).toUpperCase()\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\nconst getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`)\n\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\nconst getIdKeys = (pid) => {\n  const pkBuffer = Buffer.from('/pk/')\n  const ipnsBuffer = Buffer.from('/ipns/')\n\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  }\n}\n\n// Sign ipns record data\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)\n\n    return privateKey.sign(dataForSignature)\n  } catch (error) {\n    log.error('record signature creation failed')\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION)\n  }\n}\n\n// Utility for getting the validity type code name of a validity\nconst getValidityType = (validityType) => {\n  if (validityType.toString() === '0') {\n    return 'EOL'\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`)\n  log.error(error)\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n}\n\n// Utility for creating the record data for being signed\nconst ipnsEntryDataForSig = (value, validityType, validity) => {\n  const valueBuffer = Buffer.from(value)\n  const validityTypeBuffer = Buffer.from(getValidityType(validityType))\n  const validityBuffer = Buffer.from(validity)\n\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer])\n}\n\n// Utility for extracting the public key from a peer-id\nconst extractPublicKeyFromId = (peerId) => {\n  const decodedId = multihash.decode(peerId.id)\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest)\n}\n\nconst marshal = ipnsEntryProto.encode\n\nconst unmarshal = ipnsEntryProto.decode\n\nconst validator = {\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData)\n    const bufferId = key.slice('/ipns/'.length)\n    const peerId = PeerId.createFromBytes(bufferId)\n\n    // extract public key\n    const pubKey = extractPublicKey(peerId, receivedEntry)\n\n    // Record validation\n    await validate(pubKey, receivedEntry)\n    return true\n  },\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA)\n    const entryB = unmarshal(dataB)\n\n    return entryA.sequence > entryB.sequence ? 0 : 1\n  }\n}\n\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n}\n"]},"metadata":{},"sourceType":"script"}