{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  messages,\n  codes\n} = require('./errors');\n\nconst all = require('it-all');\n\nconst pAny = require('p-any');\n\nmodule.exports = node => {\n  const routers = node._modules.contentRouting || [];\n  const dht = node._dht; // If we have the dht, make it first\n\n  if (dht) {\n    routers.unshift(dht);\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] How long the query should run\n     * @param {number} [options.maxNumProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async *findProviders(key, options) {\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      const result = await pAny(routers.map(async router => {\n        const provs = await all(router.findProviders(key, options));\n\n        if (!provs || !provs.length) {\n          throw errCode(new Error('not found'), 'NOT_FOUND');\n        }\n\n        return provs;\n      }));\n\n      for (const peer of result) {\n        yield peer;\n      }\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n    async provide(key) {\n      // eslint-disable-line require-await\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      return Promise.all(routers.map(router => router.provide(key)));\n    },\n\n    /**\n     * Store the given key/value pair in the DHT.\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n    async put(key, value, options) {\n      // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return dht.put(key, value, options);\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<{from: PeerId, val: Buffer}>}\n     */\n    async get(key, options) {\n      // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return dht.get(key, options);\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     * @param {Buffer} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany(key, nVals, options) {\n      // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return dht.getMany(key, nVals, options);\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/content-routing.js"],"names":["errCode","require","messages","codes","all","pAny","module","exports","node","routers","_modules","contentRouting","dht","_dht","unshift","findProviders","key","options","length","Error","result","map","router","provs","peer","provide","Promise","put","value","isStarted","NOT_STARTED_YET","DHT_NOT_STARTED","get","getMany","nVals"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,IAAsBF,OAAO,CAAC,UAAD,CAAnC;;AAEA,MAAMG,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,OAAD,CAApB;;AAEAK,MAAM,CAACC,OAAP,GAAkBC,IAAD,IAAU;AACzB,QAAMC,OAAO,GAAGD,IAAI,CAACE,QAAL,CAAcC,cAAd,IAAgC,EAAhD;AACA,QAAMC,GAAG,GAAGJ,IAAI,CAACK,IAAjB,CAFyB,CAIzB;;AACA,MAAID,GAAJ,EAAS;AACPH,IAAAA,OAAO,CAACK,OAAR,CAAgBF,GAAhB;AACD;;AAED,SAAO;AACL;;;;;;;;;;AAUA,WAAQG,aAAR,CAAuBC,GAAvB,EAA4BC,OAA5B,EAAqC;AACnC,UAAI,CAACR,OAAO,CAACS,MAAb,EAAqB;AACnB,cAAMlB,OAAO,CAAC,IAAImB,KAAJ,CAAU,8BAAV,CAAD,EAA4C,sBAA5C,CAAb;AACD;;AAED,YAAMC,MAAM,GAAG,MAAMf,IAAI,CACvBI,OAAO,CAACY,GAAR,CAAY,MAAOC,MAAP,IAAkB;AAC5B,cAAMC,KAAK,GAAG,MAAMnB,GAAG,CAACkB,MAAM,CAACP,aAAP,CAAqBC,GAArB,EAA0BC,OAA1B,CAAD,CAAvB;;AAEA,YAAI,CAACM,KAAD,IAAU,CAACA,KAAK,CAACL,MAArB,EAA6B;AAC3B,gBAAMlB,OAAO,CAAC,IAAImB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAAb;AACD;;AACD,eAAOI,KAAP;AACD,OAPD,CADuB,CAAzB;;AAWA,WAAK,MAAMC,IAAX,IAAmBJ,MAAnB,EAA2B;AACzB,cAAMI,IAAN;AACD;AACF,KA9BI;;AAgCL;;;;;;;AAOA,UAAMC,OAAN,CAAeT,GAAf,EAAoB;AAAE;AACpB,UAAI,CAACP,OAAO,CAACS,MAAb,EAAqB;AACnB,cAAMlB,OAAO,CAAC,IAAImB,KAAJ,CAAU,8BAAV,CAAD,EAA4C,sBAA5C,CAAb;AACD;;AAED,aAAOO,OAAO,CAACtB,GAAR,CAAYK,OAAO,CAACY,GAAR,CAAaC,MAAD,IAAYA,MAAM,CAACG,OAAP,CAAeT,GAAf,CAAxB,CAAZ,CAAP;AACD,KA7CI;;AA+CL;;;;;;;;AAQA,UAAMW,GAAN,CAAWX,GAAX,EAAgBY,KAAhB,EAAuBX,OAAvB,EAAgC;AAAE;AAChC,UAAI,CAACT,IAAI,CAACqB,SAAL,EAAD,IAAqB,CAACjB,GAAG,CAACiB,SAA9B,EAAyC;AACvC,cAAM7B,OAAO,CAAC,IAAImB,KAAJ,CAAUjB,QAAQ,CAAC4B,eAAnB,CAAD,EAAsC3B,KAAK,CAAC4B,eAA5C,CAAb;AACD;;AAED,aAAOnB,GAAG,CAACe,GAAJ,CAAQX,GAAR,EAAaY,KAAb,EAAoBX,OAApB,CAAP;AACD,KA7DI;;AA+DL;;;;;;;;AAQA,UAAMe,GAAN,CAAWhB,GAAX,EAAgBC,OAAhB,EAAyB;AAAE;AACzB,UAAI,CAACT,IAAI,CAACqB,SAAL,EAAD,IAAqB,CAACjB,GAAG,CAACiB,SAA9B,EAAyC;AACvC,cAAM7B,OAAO,CAAC,IAAImB,KAAJ,CAAUjB,QAAQ,CAAC4B,eAAnB,CAAD,EAAsC3B,KAAK,CAAC4B,eAA5C,CAAb;AACD;;AAED,aAAOnB,GAAG,CAACoB,GAAJ,CAAQhB,GAAR,EAAaC,OAAb,CAAP;AACD,KA7EI;;AA+EL;;;;;;;;AAQA,UAAMgB,OAAN,CAAejB,GAAf,EAAoBkB,KAApB,EAA2BjB,OAA3B,EAAoC;AAAE;AACpC,UAAI,CAACT,IAAI,CAACqB,SAAL,EAAD,IAAqB,CAACjB,GAAG,CAACiB,SAA9B,EAAyC;AACvC,cAAM7B,OAAO,CAAC,IAAImB,KAAJ,CAAUjB,QAAQ,CAAC4B,eAAnB,CAAD,EAAsC3B,KAAK,CAAC4B,eAA5C,CAAb;AACD;;AAED,aAAOnB,GAAG,CAACqB,OAAJ,CAAYjB,GAAZ,EAAiBkB,KAAjB,EAAwBjB,OAAxB,CAAP;AACD;;AA7FI,GAAP;AA+FD,CAxGD","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { messages, codes } = require('./errors')\n\nconst all = require('it-all')\nconst pAny = require('p-any')\n\nmodule.exports = (node) => {\n  const routers = node._modules.contentRouting || []\n  const dht = node._dht\n\n  // If we have the dht, make it first\n  if (dht) {\n    routers.unshift(dht)\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] How long the query should run\n     * @param {number} [options.maxNumProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async * findProviders (key, options) {\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n      }\n\n      const result = await pAny(\n        routers.map(async (router) => {\n          const provs = await all(router.findProviders(key, options))\n\n          if (!provs || !provs.length) {\n            throw errCode(new Error('not found'), 'NOT_FOUND')\n          }\n          return provs\n        })\n      )\n\n      for (const peer of result) {\n        yield peer\n      }\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n    async provide (key) { // eslint-disable-line require-await\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n      }\n\n      return Promise.all(routers.map((router) => router.provide(key)))\n    },\n\n    /**\n     * Store the given key/value pair in the DHT.\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n    async put (key, value, options) { // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n      }\n\n      return dht.put(key, value, options)\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<{from: PeerId, val: Buffer}>}\n     */\n    async get (key, options) { // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n      }\n\n      return dht.get(key, options)\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     * @param {Buffer} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany (key, nVals, options) { // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n      }\n\n      return dht.getMany(key, nVals, options)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}