{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar PeerId = require('peer-id');\n\nvar crypto = require('libp2p-crypto');\n\nvar c = require('../constants');\n\nvar Message = require('../message');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n\nmodule.exports = function (dht) {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   * @param {PeerId} peer\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  var findPeerLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer) {\n      var p, peerData;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dht._log('findPeerLocal %s', peer.toB58String());\n\n              _context.next = 3;\n              return dht.routingTable.find(peer);\n\n            case 3:\n              p = _context.sent;\n              peerData = p && dht.peerStore.get(p);\n\n              if (!peerData) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\", {\n                id: peerData.id,\n                multiaddrs: peerData.addresses.map(function (address) {\n                  return address.multiaddr;\n                })\n              });\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function findPeerLocal(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get a value via rpc call for the given parameters.\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  var getValueSingle = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peer, key) {\n      var msg;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // eslint-disable-line require-await\n              msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n              return _context2.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function getValueSingle(_x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Find close peers for a given peer\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  var closerPeersSingle = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, peer) {\n      var msg;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              dht._log('closerPeersSingle %b from %s', key, peer.toB58String());\n\n              _context3.next = 3;\n              return dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n\n            case 3:\n              msg = _context3.sent;\n              return _context3.abrupt(\"return\", msg.closerPeers.filter(function (peerData) {\n                return !dht._isSelf(peerData.id);\n              }).map(function (peerData) {\n                dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n                return peerData;\n              }));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function closerPeersSingle(_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the public key directly from a node.\n   * @param {PeerId} peer\n   * @returns {Promise<PublicKey>}\n   * @private\n   */\n\n\n  var getPublicKeyFromNode = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peer) {\n      var pkKey, msg, recPeer;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              pkKey = utils.keyForPublicKey(peer);\n              _context4.next = 3;\n              return getValueSingle(peer, pkKey);\n\n            case 3:\n              msg = _context4.sent;\n\n              if (!(!msg.record || !msg.record.value)) {\n                _context4.next = 6;\n                break;\n              }\n\n              throw errcode(\"Node not responding with its public key: \".concat(peer.toB58String()), 'ERR_INVALID_RECORD');\n\n            case 6:\n              recPeer = PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n              if (recPeer.isEqual(peer)) {\n                _context4.next = 9;\n                break;\n              }\n\n              throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n\n            case 9:\n              return _context4.abrupt(\"return\", recPeer.pubKey);\n\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function getPublicKeyFromNode(_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    _findPeerSingle: function _findPeerSingle(peer, target) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var msg;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // eslint-disable-line require-await\n                dht._log('findPeerSingle %s', peer.toB58String());\n\n                msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n                return _context5.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findPeer: function findPeer(id) {\n      var _arguments = arguments,\n          _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var options, pi, key, peers, match, peer, query, error, result, success, peerData;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n                _context7.next = 5;\n                return findPeerLocal(id);\n\n              case 5:\n                pi = _context7.sent;\n\n                if (!(pi != null)) {\n                  _context7.next = 9;\n                  break;\n                }\n\n                dht._log('found local');\n\n                return _context7.abrupt(\"return\", pi);\n\n              case 9:\n                _context7.next = 11;\n                return utils.convertPeerId(id);\n\n              case 11:\n                key = _context7.sent;\n                peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n                if (!(peers.length === 0)) {\n                  _context7.next = 15;\n                  break;\n                }\n\n                throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n\n              case 15:\n                // sanity check\n                match = peers.find(function (p) {\n                  return p.isEqual(id);\n                });\n\n                if (!match) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                peer = dht.peerStore.get(id);\n\n                if (!peer) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                dht._log('found in peerStore');\n\n                return _context7.abrupt(\"return\", {\n                  id: peer.id,\n                  multiaddrs: peer.addresses.map(function (address) {\n                    return address.multiaddr;\n                  })\n                });\n\n              case 21:\n                // query the network\n                query = new Query(dht, id.id, function () {\n                  // There is no distinction between the disjoint paths,\n                  // so there are no per-path variables in dht scope.\n                  // Just return the actual query function.\n                  return /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peer) {\n                      var msg, match;\n                      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                        while (1) {\n                          switch (_context6.prev = _context6.next) {\n                            case 0:\n                              _context6.next = 2;\n                              return _this._findPeerSingle(peer, id);\n\n                            case 2:\n                              msg = _context6.sent;\n                              match = msg.closerPeers.find(function (p) {\n                                return p.id.isEqual(id);\n                              }); // found it\n\n                              if (!match) {\n                                _context6.next = 6;\n                                break;\n                              }\n\n                              return _context6.abrupt(\"return\", {\n                                peer: match,\n                                queryComplete: true\n                              });\n\n                            case 6:\n                              return _context6.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 7:\n                            case \"end\":\n                              return _context6.stop();\n                          }\n                        }\n                      }, _callee6);\n                    }));\n\n                    return function (_x7) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }();\n                });\n                _context7.prev = 22;\n                _context7.next = 25;\n                return pTimeout(query.run(peers), options.timeout);\n\n              case 25:\n                result = _context7.sent;\n                _context7.next = 31;\n                break;\n\n              case 28:\n                _context7.prev = 28;\n                _context7.t0 = _context7[\"catch\"](22);\n                error = _context7.t0;\n\n              case 31:\n                query.stop();\n\n                if (!error) {\n                  _context7.next = 34;\n                  break;\n                }\n\n                throw error;\n\n              case 34:\n                success = false;\n                result.paths.forEach(function (result) {\n                  if (result.success) {\n                    success = true;\n                    dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n                  }\n                });\n\n                dht._log('findPeer %s: %s', id.toB58String(), success);\n\n                if (success) {\n                  _context7.next = 39;\n                  break;\n                }\n\n                throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n\n              case 39:\n                peerData = dht.peerStore.get(id);\n                return _context7.abrupt(\"return\", {\n                  id: peerData.id,\n                  multiaddrs: peerData.addresses.map(function (address) {\n                    return address.multiaddr;\n                  })\n                });\n\n              case 41:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[22, 28]]);\n      }))();\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     * @param {Buffer} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow] shallow query (default: false)\n     * @returns {AsyncIterable<PeerId>}\n     */\n    getClosestPeers: function getClosestPeers(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shallow: false\n      };\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var id, tablePeers, q, res, sorted, _iterator, _step, pId;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                dht._log('getClosestPeers to %b', key);\n\n                _context9.next = 3;\n                return _awaitAsyncGenerator(utils.convertBuffer(key));\n\n              case 3:\n                id = _context9.sent;\n                tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n                q = new Query(dht, key, function () {\n                  // There is no distinction between the disjoint paths,\n                  // so there are no per-path variables in dht scope.\n                  // Just return the actual query function.\n                  return /*#__PURE__*/function () {\n                    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(peer) {\n                      var closer;\n                      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                        while (1) {\n                          switch (_context8.prev = _context8.next) {\n                            case 0:\n                              _context8.next = 2;\n                              return closerPeersSingle(key, peer);\n\n                            case 2:\n                              closer = _context8.sent;\n                              return _context8.abrupt(\"return\", {\n                                closerPeers: closer,\n                                pathComplete: options.shallow ? true : undefined\n                              });\n\n                            case 4:\n                            case \"end\":\n                              return _context8.stop();\n                          }\n                        }\n                      }, _callee8);\n                    }));\n\n                    return function (_x8) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }();\n                });\n                _context9.next = 8;\n                return _awaitAsyncGenerator(q.run(tablePeers));\n\n              case 8:\n                res = _context9.sent;\n\n                if (!(!res || !res.finalSet)) {\n                  _context9.next = 11;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", []);\n\n              case 11:\n                _context9.next = 13;\n                return _awaitAsyncGenerator(utils.sortClosestPeers(Array.from(res.finalSet), id));\n\n              case 13:\n                sorted = _context9.sent;\n                _iterator = _createForOfIteratorHelper(sorted.slice(0, dht.kBucketSize));\n                _context9.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                pId = _step.value;\n                _context9.next = 21;\n                return pId;\n\n              case 21:\n                _context9.next = 17;\n                break;\n\n              case 23:\n                _context9.next = 28;\n                break;\n\n              case 25:\n                _context9.prev = 25;\n                _context9.t0 = _context9[\"catch\"](15);\n\n                _iterator.e(_context9.t0);\n\n              case 28:\n                _context9.prev = 28;\n\n                _iterator.f();\n\n                return _context9.finish(28);\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[15, 25, 28, 31]]);\n      }))();\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     * @param {PeerId} peer\n     * @returns {Promise<PubKey>}\n     */\n    getPublicKey: function getPublicKey(peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var peerData, pk, pkKey, value, addrs;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n                peerData = dht.peerStore.get(peer);\n\n                if (!(peerData && peerData.id.pubKey)) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                dht._log('getPublicKey: found local copy');\n\n                return _context10.abrupt(\"return\", peerData.id.pubKey);\n\n              case 5:\n                _context10.prev = 5;\n                _context10.next = 8;\n                return getPublicKeyFromNode(peer);\n\n              case 8:\n                pk = _context10.sent;\n                _context10.next = 18;\n                break;\n\n              case 11:\n                _context10.prev = 11;\n                _context10.t0 = _context10[\"catch\"](5);\n                // try dht directly\n                pkKey = utils.keyForPublicKey(peer);\n                _context10.next = 16;\n                return dht.get(pkKey);\n\n              case 16:\n                value = _context10.sent;\n                pk = crypto.keys.unmarshalPublicKey(value);\n\n              case 18:\n                peerData.id = new PeerId(peer.id, null, pk);\n                addrs = peerData.addresses.map(function (address) {\n                  return address.multiaddr;\n                });\n                dht.peerStore.addressBook.add(peerData.id, addrs);\n                dht.peerStore.keyBook.set(peerData.id, pk);\n                return _context10.abrupt(\"return\", pk);\n\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[5, 11]]);\n      }))();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"names":["errcode","require","pTimeout","PeerId","crypto","c","Message","Query","utils","module","exports","dht","findPeerLocal","peer","_log","toB58String","routingTable","find","p","peerData","peerStore","get","id","multiaddrs","addresses","map","address","multiaddr","getValueSingle","key","msg","TYPES","GET_VALUE","network","sendRequest","closerPeersSingle","peerRouting","_findPeerSingle","closerPeers","filter","_isSelf","addressBook","add","getPublicKeyFromNode","pkKey","keyForPublicKey","record","value","recPeer","createFromPubKey","isEqual","pubKey","target","FIND_NODE","findPeer","options","timeout","minute","pi","convertPeerId","peers","closestPeers","kBucketSize","length","Error","match","query","queryComplete","run","result","error","stop","success","paths","forEach","getClosestPeers","shallow","convertBuffer","tablePeers","q","closer","pathComplete","undefined","res","finalSet","sortClosestPeers","Array","from","sorted","slice","pId","getPublicKey","pk","keys","unmarshalPublicKey","addrs","keyBook","set"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\n\nconst c = require('../constants')\nconst Message = require('../message')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\nmodule.exports = (dht) => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   * @param {PeerId} peer\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  const findPeerLocal = async (peer) => {\n    dht._log('findPeerLocal %s', peer.toB58String())\n    const p = await dht.routingTable.find(peer)\n\n    const peerData = p && dht.peerStore.get(p)\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n  const getValueSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  /**\n   * Find close peers for a given peer\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log('closerPeersSingle %b from %s', key, peer.toB58String())\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key))\n\n    return msg.closerPeers\n      .filter((peerData) => !dht._isSelf(peerData.id))\n      .map((peerData) => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs)\n\n        return peerData\n      })\n  }\n\n  /**\n   * Get the public key directly from a node.\n   * @param {PeerId} peer\n   * @returns {Promise<PublicKey>}\n   * @private\n   */\n  const getPublicKeyFromNode = async (peer) => {\n    const pkKey = utils.keyForPublicKey(peer)\n    const msg = await getValueSingle(peer, pkKey)\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = PeerId.createFromPubKey(msg.record.value)\n\n    // compare hashes of the pub key\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  }\n\n  return {\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @returns {Promise<Message>}\n   * @private\n   */\n    async _findPeerSingle (peer, target) { // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String())\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n\n      return dht.network.sendRequest(peer, msg)\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer (id, options = {}) {\n      options.timeout = options.timeout || c.minute\n      dht._log('findPeer %s', id.toB58String())\n\n      // Try to find locally\n      const pi = await findPeerLocal(id)\n\n      // already got it\n      if (pi != null) {\n        dht._log('found local')\n        return pi\n      }\n\n      const key = await utils.convertPeerId(id)\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize)\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n      }\n\n      // sanity check\n      const match = peers.find((p) => p.isEqual(id))\n      if (match) {\n        const peer = dht.peerStore.get(id)\n\n        if (peer) {\n          dht._log('found in peerStore')\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        }\n      }\n\n      // query the network\n      const query = new Query(dht, id.id, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const msg = await this._findPeerSingle(peer, id)\n          const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n          // found it\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            }\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          }\n        }\n      })\n\n      let error, result\n      try {\n        result = await pTimeout(query.run(peers), options.timeout)\n      } catch (err) {\n        error = err\n      }\n      query.stop()\n      if (error) throw error\n\n      let success = false\n      result.paths.forEach((result) => {\n        if (result.success) {\n          success = true\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs)\n        }\n      })\n      dht._log('findPeer %s: %s', id.toB58String(), success)\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND')\n      }\n\n      const peerData = dht.peerStore.get(id)\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     * @param {Buffer} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow] shallow query (default: false)\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async * getClosestPeers (key, options = { shallow: false }) {\n      dht._log('getClosestPeers to %b', key)\n\n      const id = await utils.convertBuffer(key)\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await closerPeersSingle(key, peer)\n\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      const res = await q.run(tablePeers)\n      if (!res || !res.finalSet) {\n        return []\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id)\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     * @param {PeerId} peer\n     * @returns {Promise<PubKey>}\n     */\n    async getPublicKey (peer) {\n      dht._log('getPublicKey %s', peer.toB58String())\n\n      // local check\n      const peerData = dht.peerStore.get(peer)\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n\n      // try the node directly\n      let pk\n      try {\n        pk = await getPublicKeyFromNode(peer)\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer)\n        const value = await dht.get(pkKey)\n        pk = crypto.keys.unmarshalPublicKey(value)\n      }\n\n      peerData.id = new PeerId(peer.id, null, pk)\n      const addrs = peerData.addresses.map((address) => address.multiaddr)\n      dht.peerStore.addressBook.add(peerData.id, addrs)\n      dht.peerStore.keyBook.set(peerData.id, pk)\n\n      return pk\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}