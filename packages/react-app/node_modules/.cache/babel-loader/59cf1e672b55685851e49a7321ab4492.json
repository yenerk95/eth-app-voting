{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  nanoid\n} = require('nanoid');\n\nconst withIs = require('class-is');\n\nconst pathSepS = '/';\nconst pathSepB = Buffer.from(pathSepS);\nconst pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\n\nclass Key {\n  constructor(s, clean) {\n    if (typeof s === 'string') {\n      this._buf = Buffer.from(s);\n    } else if (Buffer.isBuffer(s)) {\n      this._buf = s;\n    }\n\n    if (clean == null) {\n      clean = true;\n    }\n\n    if (clean) {\n      this.clean();\n    }\n\n    if (this._buf.length === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key');\n    }\n  }\n  /**\n   * Convert to the string representation\n   *\n   * @param {string} [encoding='utf8']\n   * @returns {string}\n   */\n\n\n  toString(encoding) {\n    return this._buf.toString(encoding || 'utf8');\n  }\n  /**\n   * Return the buffer representation of the key\n   *\n   * @returns {Buffer}\n   */\n\n\n  toBuffer() {\n    return this._buf;\n  }\n  /**\n   * @returns {String}\n   */\n\n\n  get [Symbol.toStringTag]() {\n    return `Key(${this.toString()})`;\n  }\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list\n   * @returns {Key}\n   *\n   * @example\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   *\n   */\n\n\n  static withNamespaces(list) {\n    return new _Key(list.join(pathSepS));\n  }\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * Key.random()\n   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n   *\n   */\n\n\n  static random() {\n    return new _Key(nanoid().replace(/-/g, ''));\n  }\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n\n\n  clean() {\n    if (!this._buf || this._buf.length === 0) {\n      this._buf = Buffer.from(pathSepS);\n    }\n\n    if (this._buf[0] !== pathSep) {\n      this._buf = Buffer.concat([pathSepB, this._buf]);\n    } // normalize does not remove trailing slashes\n\n\n    while (this._buf.length > 1 && this._buf[this._buf.length - 1] === pathSep) {\n      this._buf = this._buf.slice(0, -1);\n    }\n  }\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key\n   * @returns {bool}\n   */\n\n\n  less(key) {\n    const list1 = this.list();\n    const list2 = key.list();\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false;\n      }\n\n      const c1 = list1[i];\n      const c2 = list2[i];\n\n      if (c1 < c2) {\n        return true;\n      } else if (c1 > c2) {\n        return false;\n      }\n    }\n\n    return list1.length < list2.length;\n  }\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   */\n\n\n  reverse() {\n    return Key.withNamespaces(this.list().slice().reverse());\n  }\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  namespaces() {\n    return this.list();\n  }\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   *\n   */\n\n\n  baseNamespace() {\n    const ns = this.namespaces();\n    return ns[ns.length - 1];\n  }\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   *\n   */\n\n\n  list() {\n    return this.toString().split(pathSepS).slice(1);\n  }\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   *\n   */\n\n\n  type() {\n    return namespaceType(this.baseNamespace());\n  }\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   */\n\n\n  name() {\n    return namespaceValue(this.baseNamespace());\n  }\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   */\n\n\n  instance(s) {\n    return new _Key(this.toString() + ':' + s);\n  }\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   *\n   */\n\n\n  path() {\n    let p = this.parent().toString();\n\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS;\n    }\n\n    p += this.type();\n    return new _Key(p);\n  }\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   *\n   */\n\n\n  parent() {\n    const list = this.list();\n\n    if (list.length === 1) {\n      return new _Key(pathSepS);\n    }\n\n    return new _Key(list.slice(0, -1).join(pathSepS));\n  }\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   *\n   */\n\n\n  child(key) {\n    if (this.toString() === pathSepS) {\n      return key;\n    } else if (key.toString() === pathSepS) {\n      return this;\n    }\n\n    return new _Key(this.toString() + key.toString(), false);\n  }\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other\n   * @returns {bool}\n   *\n   * @example\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   *\n   */\n\n\n  isAncestorOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n\n    return other.toString().startsWith(this.toString());\n  }\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other\n   * @returns {bool}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   *\n   */\n\n\n  isDecendantOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n\n    return this.toString().startsWith(other.toString());\n  }\n  /**\n   * Returns wether this key has only one namespace.\n   *\n   * @returns {bool}\n   *\n   */\n\n\n  isTopLevel() {\n    return this.list().length === 1;\n  }\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys\n   * @returns {Key}\n   */\n\n\n  concat(...keys) {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))]);\n  }\n\n}\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceType(ns) {\n  const parts = ns.split(':');\n\n  if (parts.length < 2) {\n    return '';\n  }\n\n  return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceValue(ns) {\n  const parts = ns.split(':');\n  return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n * @param {Array<Array>} arr\n * @return {*}\n */\n\n\nfunction flatten(arr) {\n  return [].concat(...arr);\n}\n\nconst _Key = withIs(Key, {\n  className: 'Key',\n  symbolName: '@ipfs/interface-datastore/key'\n});\n\nmodule.exports = _Key;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/interface-datastore/src/key.js"],"names":["Buffer","require","nanoid","withIs","pathSepS","pathSepB","from","pathSep","Key","constructor","s","clean","_buf","isBuffer","length","Error","toString","encoding","toBuffer","Symbol","toStringTag","withNamespaces","list","_Key","join","random","replace","concat","slice","less","key","list1","list2","i","c1","c2","reverse","namespaces","baseNamespace","ns","split","type","namespaceType","name","namespaceValue","instance","path","p","parent","endsWith","child","isAncestorOf","other","startsWith","isDecendantOf","isTopLevel","keys","flatten","map","parts","arr","className","symbolName","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst { nanoid } = require('nanoid')\nconst withIs = require('class-is')\n\nconst pathSepS = '/'\nconst pathSepB = Buffer.from(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nclass Key {\n  constructor (s, clean) {\n    if (typeof s === 'string') {\n      this._buf = Buffer.from(s)\n    } else if (Buffer.isBuffer(s)) {\n      this._buf = s\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.length === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {string} [encoding='utf8']\n   * @returns {string}\n   */\n  toString (encoding) {\n    return this._buf.toString(encoding || 'utf8')\n  }\n\n  /**\n   * Return the buffer representation of the key\n   *\n   * @returns {Buffer}\n   */\n  toBuffer () {\n    return this._buf\n  }\n\n  /**\n   * @returns {String}\n   */\n  get [Symbol.toStringTag] () {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list\n   * @returns {Key}\n   *\n   * @example\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   *\n   */\n  static withNamespaces (list) {\n    return new _Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * Key.random()\n   * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n   *\n   */\n  static random () {\n    return new _Key(nanoid().replace(/-/g, ''))\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean () {\n    if (!this._buf || this._buf.length === 0) {\n      this._buf = Buffer.from(pathSepS)\n    }\n\n    if (this._buf[0] !== pathSep) {\n      this._buf = Buffer.concat([pathSepB, this._buf])\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.length > 1 && this._buf[this._buf.length - 1] === pathSep) {\n      this._buf = this._buf.slice(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key\n   * @returns {bool}\n   */\n  less (key) {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   */\n  reverse () {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces () {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   *\n   */\n  baseNamespace () {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   *\n   */\n  list () {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   *\n   */\n  type () {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   */\n  name () {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   */\n  instance (s) {\n    return new _Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   *\n   */\n  path () {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new _Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   *\n   */\n  parent () {\n    const list = this.list()\n    if (list.length === 1) {\n      return new _Key(pathSepS)\n    }\n\n    return new _Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key\n   * @returns {Key}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   *\n   */\n  child (key) {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new _Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other\n   * @returns {bool}\n   *\n   * @example\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   *\n   */\n  isAncestorOf (other) {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other\n   * @returns {bool}\n   *\n   * @example\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   *\n   */\n  isDecendantOf (other) {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Returns wether this key has only one namespace.\n   *\n   * @returns {bool}\n   *\n   */\n  isTopLevel () {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys\n   * @returns {Key}\n   */\n  concat (...keys) {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns) {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns) {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n * @param {Array<Array>} arr\n * @return {*}\n */\nfunction flatten (arr) {\n  return [].concat(...arr)\n}\n\nconst _Key = withIs(Key, { className: 'Key', symbolName: '@ipfs/interface-datastore/key' })\n\nmodule.exports = _Key\n"]},"metadata":{},"sourceType":"script"}