{"ast":null,"code":"import _slicedToArray from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Buffer } from \"buffer\";\nimport AEAD from 'bcrypto/lib/js/aead';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\nimport { getHkdf } from \"../utils\";\nimport { logger } from \"../logger\";\nexport var MIN_NONCE = 0;\nexport var AbstractHandshake = /*#__PURE__*/function () {\n  function AbstractHandshake() {\n    _classCallCheck(this, AbstractHandshake);\n  }\n\n  _createClass(AbstractHandshake, [{\n    key: \"encryptWithAd\",\n    value: function encryptWithAd(cs, ad, plaintext) {\n      var e = this.encrypt(cs.k, cs.n, ad, plaintext);\n      this.setNonce(cs, this.incrementNonce(cs.n));\n      return e;\n    }\n  }, {\n    key: \"decryptWithAd\",\n    value: function decryptWithAd(cs, ad, ciphertext) {\n      var _this$decrypt = this.decrypt(cs.k, cs.n, ad, ciphertext),\n          plaintext = _this$decrypt.plaintext,\n          valid = _this$decrypt.valid;\n\n      this.setNonce(cs, this.incrementNonce(cs.n));\n      return {\n        plaintext: plaintext,\n        valid: valid\n      };\n    } // Cipher state related\n\n  }, {\n    key: \"hasKey\",\n    value: function hasKey(cs) {\n      return !this.isEmptyKey(cs.k);\n    }\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(cs, nonce) {\n      cs.n = nonce;\n    }\n  }, {\n    key: \"createEmptyKey\",\n    value: function createEmptyKey() {\n      return Buffer.alloc(32);\n    }\n  }, {\n    key: \"isEmptyKey\",\n    value: function isEmptyKey(k) {\n      var emptyKey = this.createEmptyKey();\n      return emptyKey.equals(k);\n    }\n  }, {\n    key: \"incrementNonce\",\n    value: function incrementNonce(n) {\n      return n + 1;\n    }\n  }, {\n    key: \"nonceToBytes\",\n    value: function nonceToBytes(n) {\n      var nonce = Buffer.alloc(12);\n      nonce.writeUInt32LE(n, 4);\n      return nonce;\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(k, n, ad, plaintext) {\n      var nonce = this.nonceToBytes(n);\n      var ctx = new AEAD();\n      plaintext = Buffer.from(plaintext);\n      ctx.init(k, nonce);\n      ctx.aad(ad);\n      ctx.encrypt(plaintext); // Encryption is done on the sent reference\n\n      return Buffer.concat([plaintext, ctx.final()]);\n    }\n  }, {\n    key: \"encryptAndHash\",\n    value: function encryptAndHash(ss, plaintext) {\n      var ciphertext;\n\n      if (this.hasKey(ss.cs)) {\n        ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n      } else {\n        ciphertext = plaintext;\n      }\n\n      this.mixHash(ss, ciphertext);\n      return ciphertext;\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(k, n, ad, ciphertext) {\n      var nonce = this.nonceToBytes(n);\n      var ctx = new AEAD();\n      ciphertext = Buffer.from(ciphertext);\n      var tag = ciphertext.slice(ciphertext.length - 16);\n      ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n      ctx.init(k, nonce);\n      ctx.aad(ad);\n      ctx.decrypt(ciphertext); // Decryption is done on the sent reference\n\n      return {\n        plaintext: ciphertext,\n        valid: ctx.verify(tag)\n      };\n    }\n  }, {\n    key: \"decryptAndHash\",\n    value: function decryptAndHash(ss, ciphertext) {\n      var plaintext,\n          valid = true;\n\n      if (this.hasKey(ss.cs)) {\n        var _this$decryptWithAd = this.decryptWithAd(ss.cs, ss.h, ciphertext);\n\n        plaintext = _this$decryptWithAd.plaintext;\n        valid = _this$decryptWithAd.valid;\n      } else {\n        plaintext = ciphertext;\n      }\n\n      this.mixHash(ss, ciphertext);\n      return {\n        plaintext: plaintext,\n        valid: valid\n      };\n    }\n  }, {\n    key: \"dh\",\n    value: function dh(privateKey, publicKey) {\n      try {\n        var derived = x25519.derive(publicKey, privateKey);\n        var result = Buffer.alloc(32);\n        derived.copy(result);\n        return result;\n      } catch (e) {\n        logger(e.message);\n        return Buffer.alloc(32);\n      }\n    }\n  }, {\n    key: \"mixHash\",\n    value: function mixHash(ss, data) {\n      ss.h = this.getHash(ss.h, data);\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash(a, b) {\n      return SHA256.digest(Buffer.from([].concat(_toConsumableArray(a), _toConsumableArray(b))));\n    }\n  }, {\n    key: \"mixKey\",\n    value: function mixKey(ss, ikm) {\n      var _getHkdf = getHkdf(ss.ck, ikm),\n          _getHkdf2 = _slicedToArray(_getHkdf, 2),\n          ck = _getHkdf2[0],\n          tempK = _getHkdf2[1];\n\n      ss.cs = this.initializeKey(tempK);\n      ss.ck = ck;\n    }\n  }, {\n    key: \"initializeKey\",\n    value: function initializeKey(k) {\n      var n = MIN_NONCE;\n      return {\n        k: k,\n        n: n\n      };\n    } // Symmetric state related\n\n  }, {\n    key: \"initializeSymmetric\",\n    value: function initializeSymmetric(protocolName) {\n      var protocolNameBytes = Buffer.from(protocolName, 'utf-8');\n      var h = this.hashProtocolName(protocolNameBytes);\n      var ck = h;\n      var key = this.createEmptyKey();\n      var cs = this.initializeKey(key);\n      return {\n        cs: cs,\n        ck: ck,\n        h: h\n      };\n    }\n  }, {\n    key: \"hashProtocolName\",\n    value: function hashProtocolName(protocolName) {\n      if (protocolName.length <= 32) {\n        var h = Buffer.alloc(32);\n        protocolName.copy(h);\n        return h;\n      } else {\n        return this.getHash(protocolName, Buffer.alloc(0));\n      }\n    }\n  }, {\n    key: \"split\",\n    value: function split(ss) {\n      var _getHkdf3 = getHkdf(ss.ck, Buffer.alloc(0)),\n          _getHkdf4 = _slicedToArray(_getHkdf3, 2),\n          tempk1 = _getHkdf4[0],\n          tempk2 = _getHkdf4[1];\n\n      var cs1 = this.initializeKey(tempk1);\n      var cs2 = this.initializeKey(tempk2);\n      return {\n        cs1: cs1,\n        cs2: cs2\n      };\n    }\n  }, {\n    key: \"writeMessageRegular\",\n    value: function writeMessageRegular(cs, payload) {\n      var ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload);\n      var ne = this.createEmptyKey();\n      var ns = Buffer.alloc(0);\n      return {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n    }\n  }, {\n    key: \"readMessageRegular\",\n    value: function readMessageRegular(cs, message) {\n      return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext);\n    }\n  }]);\n\n  return AbstractHandshake;\n}();","map":{"version":3,"sources":["../../src/handshakes/abstract-handshake.ts"],"names":["MIN_NONCE","e","cs","valid","plaintext","Buffer","emptyKey","n","nonce","ctx","ss","ciphertext","tag","derived","x25519","result","logger","SHA256","getHkdf","k","protocolNameBytes","h","ck","key","protocolName","cs1","cs2","ne","ns","message"],"mappings":"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","sourcesContent":["import {Buffer} from \"buffer\";\nimport AEAD from 'bcrypto/lib/js/aead';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\n\nimport {bytes, bytes32, uint32} from \"../@types/basic\";\nimport {CipherState, MessageBuffer, SymmetricState} from \"../@types/handshake\";\nimport {getHkdf} from \"../utils\";\nimport {logger} from \"../logger\";\n\nexport const MIN_NONCE = 0;\n\nexport abstract class AbstractHandshake {\n  public encryptWithAd(cs: CipherState, ad: bytes, plaintext: bytes): bytes {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n\n    return e;\n  }\n\n  public decryptWithAd(cs: CipherState, ad: bytes, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    const {plaintext, valid} = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n\n    return {plaintext, valid};\n  }\n\n\n  // Cipher state related\n  protected hasKey(cs: CipherState): boolean {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  protected setNonce(cs: CipherState, nonce: uint32): void {\n    cs.n = nonce;\n  }\n\n  protected createEmptyKey(): bytes32 {\n    return Buffer.alloc(32);\n  }\n\n  protected isEmptyKey(k: bytes32): boolean {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  protected incrementNonce(n: uint32): uint32 {\n    return n + 1;\n  }\n\n  protected nonceToBytes(n: uint32): bytes {\n    const nonce = Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n\n    return nonce;\n  }\n\n  protected encrypt(k: bytes32, n: uint32, ad: bytes, plaintext: bytes): bytes {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    plaintext = Buffer.from(plaintext);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.encrypt(plaintext);\n\n    // Encryption is done on the sent reference\n    return Buffer.concat([plaintext, ctx.final()]);\n  }\n\n  protected encryptAndHash(ss: SymmetricState, plaintext: bytes): bytes {\n    let ciphertext;\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  protected decrypt(k: bytes32, n: uint32, ad: bytes, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    ciphertext = Buffer.from(ciphertext);\n    const tag = ciphertext.slice(ciphertext.length - 16);\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.decrypt(ciphertext);\n    // Decryption is done on the sent reference\n    return {plaintext: ciphertext, valid: ctx.verify(tag)};\n  }\n\n  protected decryptAndHash(ss: SymmetricState, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    let plaintext: bytes, valid = true;\n    if (this.hasKey(ss.cs)) {\n      ({plaintext, valid} = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {plaintext, valid};\n  }\n\n  protected dh(privateKey: bytes32, publicKey: bytes32): bytes32 {\n    try {\n      const derived = x25519.derive(publicKey, privateKey);\n      const result = Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger(e.message);\n      return Buffer.alloc(32);\n    }\n  }\n\n  protected mixHash(ss: SymmetricState, data: bytes): void {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  protected getHash(a: bytes, b: bytes): bytes32 {\n    return SHA256.digest(Buffer.from([...a, ...b]));\n  }\n\n  protected mixKey(ss: SymmetricState, ikm: bytes32): void {\n    const [ ck, tempK ] = getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK) as CipherState;\n    ss.ck = ck;\n  }\n\n  protected initializeKey(k: bytes32): CipherState {\n    const n = MIN_NONCE;\n    return { k, n };\n  }\n\n  // Symmetric state related\n\n  protected initializeSymmetric(protocolName: string): SymmetricState {\n    const protocolNameBytes: bytes = Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs: CipherState = this.initializeKey(key);\n\n    return { cs, ck, h };\n  }\n\n  protected hashProtocolName(protocolName: bytes): bytes32 {\n    if (protocolName.length <= 32) {\n      const h = Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, Buffer.alloc(0));\n    }\n  }\n\n  protected split(ss: SymmetricState) {\n    const [ tempk1, tempk2 ] = getHkdf(ss.ck, Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n\n    return { cs1, cs2 };\n  }\n\n  protected writeMessageRegular(cs: CipherState, payload: bytes): MessageBuffer {\n    const ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = Buffer.alloc(0);\n\n    return { ne, ns, ciphertext };\n  }\n\n  protected readMessageRegular(cs: CipherState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}