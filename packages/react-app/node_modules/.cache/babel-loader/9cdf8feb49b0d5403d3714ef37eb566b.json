{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar pipe = require('it-pipe');\n\nvar pushable = require('it-pushable');\n\nvar log = require('debug')('libp2p:mplex');\n\nvar abortable = require('abortable-iterator');\n\nvar Coder = require('./coder');\n\nvar restrictSize = require('./restrict-size');\n\nvar _require = require('./message-types'),\n    MessageTypes = _require.MessageTypes,\n    MessageTypeNames = _require.MessageTypeNames;\n\nvar createStream = require('./stream');\n\nvar Mplex = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {function(*)} options.onStream Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd Called whenever a stream ends\n   * @param {AbortSignal} options.signal An AbortController signal\n   */\n  function Mplex(options) {\n    _classCallCheck(this, Mplex);\n\n    options = options || {};\n    options = typeof options === 'function' ? {\n      onStream: options\n    } : options;\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._options = options;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    this.source = this._createSource();\n    /**\n     * @property {function} onStream\n     */\n\n    this.onStream = options.onStream;\n    /**\n     * @property {function} onStreamEnd\n     */\n\n    this.onStreamEnd = options.onStreamEnd;\n  }\n  /**\n   * Returns a Map of streams and their ids\n   * @returns {Map<number,*>}\n   */\n\n\n  _createClass(Mplex, [{\n    key: \"newStream\",\n\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of th stream will be used.\n     * @param {string} [name] If name is not a string it will be cast to one\n     * @returns {Stream}\n     */\n    value: function newStream(name) {\n      var id = this._streamId++;\n      name = name == null ? id.toString() : String(name);\n      var registry = this._streams.initiators;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'initiator',\n        registry: registry\n      });\n    }\n    /**\n     * Called whenever an inbound stream is created\n     * @private\n     * @param {*} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @returns {*} A muxed stream\n     */\n\n  }, {\n    key: \"_newReceiverStream\",\n    value: function _newReceiverStream(_ref) {\n      var id = _ref.id,\n          name = _ref.name;\n      var registry = this._streams.receivers;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'receiver',\n        registry: registry\n      });\n    }\n    /**\n     * Creates a new stream\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @param {string} options.type\n     * @param {Map<number, *>} options.registry A map of streams to their ids\n     * @returns {*} A muxed stream\n     */\n\n  }, {\n    key: \"_newStream\",\n    value: function _newStream(_ref2) {\n      var _this = this;\n\n      var id = _ref2.id,\n          name = _ref2.name,\n          type = _ref2.type,\n          registry = _ref2.registry;\n\n      if (registry.has(id)) {\n        throw new Error(\"\".concat(type, \" stream \").concat(id, \" already exists!\"));\n      }\n\n      log('new %s stream %s %s', type, id, name);\n\n      var send = function send(msg) {\n        if (log.enabled) {\n          log('%s stream %s %s send', type, id, name, _objectSpread(_objectSpread({}, msg), {}, {\n            type: MessageTypeNames[msg.type],\n            data: msg.data && msg.data.slice()\n          }));\n        }\n\n        return _this.source.push(msg);\n      };\n\n      var onEnd = function onEnd() {\n        log('%s stream %s %s ended', type, id, name);\n        registry.delete(id);\n        _this.onStreamEnd && _this.onStreamEnd(stream);\n      };\n\n      var stream = createStream({\n        id: id,\n        name: name,\n        send: send,\n        type: type,\n        onEnd: onEnd,\n        maxMsgSize: this._options.maxMsgSize\n      });\n      registry.set(id, stream);\n      return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     * @private\n     * @returns {*} Returns an iterable sink\n     */\n\n  }, {\n    key: \"_createSink\",\n    value: function _createSink() {\n      var _this2 = this;\n\n      return /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (_this2._options.signal) {\n                    source = abortable(source, _this2._options.signal);\n                  }\n\n                  _context2.prev = 1;\n                  _context2.next = 4;\n                  return pipe(source, Coder.decode, restrictSize(_this2._options.maxMsgSize), /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n                      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, msgs, _iterator2, _step2, msg;\n\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _iteratorNormalCompletion = true;\n                              _didIteratorError = false;\n                              _context.prev = 2;\n                              _iterator = _asyncIterator(source);\n\n                            case 4:\n                              _context.next = 6;\n                              return _iterator.next();\n\n                            case 6:\n                              _step = _context.sent;\n                              _iteratorNormalCompletion = _step.done;\n                              _context.next = 10;\n                              return _step.value;\n\n                            case 10:\n                              _value = _context.sent;\n\n                              if (_iteratorNormalCompletion) {\n                                _context.next = 18;\n                                break;\n                              }\n\n                              msgs = _value;\n                              _iterator2 = _createForOfIteratorHelper(msgs);\n\n                              try {\n                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                                  msg = _step2.value;\n\n                                  _this2._handleIncoming(msg);\n                                }\n                              } catch (err) {\n                                _iterator2.e(err);\n                              } finally {\n                                _iterator2.f();\n                              }\n\n                            case 15:\n                              _iteratorNormalCompletion = true;\n                              _context.next = 4;\n                              break;\n\n                            case 18:\n                              _context.next = 24;\n                              break;\n\n                            case 20:\n                              _context.prev = 20;\n                              _context.t0 = _context[\"catch\"](2);\n                              _didIteratorError = true;\n                              _iteratorError = _context.t0;\n\n                            case 24:\n                              _context.prev = 24;\n                              _context.prev = 25;\n\n                              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                                _context.next = 29;\n                                break;\n                              }\n\n                              _context.next = 29;\n                              return _iterator.return();\n\n                            case 29:\n                              _context.prev = 29;\n\n                              if (!_didIteratorError) {\n                                _context.next = 32;\n                                break;\n                              }\n\n                              throw _iteratorError;\n\n                            case 32:\n                              return _context.finish(29);\n\n                            case 33:\n                              return _context.finish(24);\n\n                            case 34:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n                    }));\n\n                    return function (_x2) {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }());\n\n                case 4:\n                  _context2.next = 10;\n                  break;\n\n                case 6:\n                  _context2.prev = 6;\n                  _context2.t0 = _context2[\"catch\"](1);\n                  log('error in sink', _context2.t0);\n                  return _context2.abrupt(\"return\", _this2.source.end(_context2.t0));\n\n                case 10:\n                  _this2.source.end();\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[1, 6]]);\n        }));\n\n        return function (_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n    }\n    /**\n     * Creates a source that restricts outgoing message sizes\n     * and varint encodes them.\n     * @private\n     * @returns {*} An iterable source\n     */\n\n  }, {\n    key: \"_createSource\",\n    value: function _createSource() {\n      var _this3 = this;\n\n      var onEnd = function onEnd(err) {\n        var _this3$_streams = _this3._streams,\n            initiators = _this3$_streams.initiators,\n            receivers = _this3$_streams.receivers; // Abort all the things!\n\n        var _iterator3 = _createForOfIteratorHelper(initiators.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var s = _step3.value;\n            s.abort(err);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var _iterator4 = _createForOfIteratorHelper(receivers.values()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _s = _step4.value;\n\n            _s.abort(err);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      };\n\n      var source = pushable({\n        onEnd: onEnd,\n        writev: true\n      });\n      return Object.assign(Coder.encode(source), {\n        push: source.push,\n        end: source.end,\n        return: source.return\n      });\n    }\n    /**\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.type\n     * @param {Buffer|BufferList} options.data\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleIncoming\",\n    value: function _handleIncoming(_ref5) {\n      var id = _ref5.id,\n          type = _ref5.type,\n          data = _ref5.data;\n\n      if (log.enabled) {\n        log('incoming message', {\n          id: id,\n          type: MessageTypeNames[type],\n          data: data.slice()\n        });\n      } // Create a new stream?\n\n\n      if (type === MessageTypes.NEW_STREAM && this.onStream) {\n        var _stream = this._newReceiverStream({\n          id: id,\n          name: data.toString()\n        });\n\n        return this.onStream(_stream);\n      }\n\n      var list = type & 1 ? this._streams.initiators : this._streams.receivers;\n      var stream = list.get(id);\n      if (!stream) return log('missing stream %s', id);\n\n      switch (type) {\n        case MessageTypes.MESSAGE_INITIATOR:\n        case MessageTypes.MESSAGE_RECEIVER:\n          stream.source.push(data);\n          break;\n\n        case MessageTypes.CLOSE_INITIATOR:\n        case MessageTypes.CLOSE_RECEIVER:\n          stream.close();\n          break;\n\n        case MessageTypes.RESET_INITIATOR:\n        case MessageTypes.RESET_RECEIVER:\n          stream.reset();\n          break;\n\n        default:\n          log('unknown message type %s', type);\n      }\n    }\n  }, {\n    key: \"streams\",\n    get: function get() {\n      // Inbound and Outbound streams may have the same ids, so we need to make those unique\n      var streams = [];\n\n      this._streams.initiators.forEach(function (stream) {\n        streams.push(stream);\n      });\n\n      this._streams.receivers.forEach(function (stream) {\n        streams.push(stream);\n      });\n\n      return streams;\n    }\n  }]);\n\n  return Mplex;\n}();\n\nMplex.multicodec = '/mplex/6.7.0';\nmodule.exports = Mplex;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-mplex/src/mplex.js"],"names":["pipe","require","pushable","log","abortable","Coder","restrictSize","MessageTypes","MessageTypeNames","createStream","Mplex","options","onStream","_streamId","_streams","initiators","Map","receivers","_options","sink","_createSink","source","_createSource","onStreamEnd","name","id","toString","String","registry","_newStream","type","has","Error","send","msg","enabled","data","slice","push","onEnd","delete","stream","maxMsgSize","set","signal","decode","msgs","_handleIncoming","end","err","values","s","abort","writev","Object","assign","encode","return","NEW_STREAM","_newReceiverStream","list","get","MESSAGE_INITIATOR","MESSAGE_RECEIVER","CLOSE_INITIATOR","CLOSE_RECEIVER","close","RESET_INITIATOR","RESET_RECEIVER","reset","streams","forEach","multicodec","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pipe = require('it-pipe')\nconst pushable = require('it-pushable')\nconst log = require('debug')('libp2p:mplex')\nconst abortable = require('abortable-iterator')\nconst Coder = require('./coder')\nconst restrictSize = require('./restrict-size')\nconst { MessageTypes, MessageTypeNames } = require('./message-types')\nconst createStream = require('./stream')\n\nclass Mplex {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {function(*)} options.onStream Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd Called whenever a stream ends\n   * @param {AbortSignal} options.signal An AbortController signal\n   */\n  constructor (options) {\n    options = options || {}\n    options = typeof options === 'function' ? { onStream: options } : options\n\n    this._streamId = 0\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    }\n    this._options = options\n\n    /**\n     * An iterable sink\n     */\n    this.sink = this._createSink()\n\n    /**\n     * An iterable source\n     */\n    this.source = this._createSource()\n\n    /**\n     * @property {function} onStream\n     */\n    this.onStream = options.onStream\n\n    /**\n     * @property {function} onStreamEnd\n     */\n    this.onStreamEnd = options.onStreamEnd\n  }\n\n  /**\n   * Returns a Map of streams and their ids\n   * @returns {Map<number,*>}\n   */\n  get streams () {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = []\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream)\n    })\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream)\n    })\n    return streams\n  }\n\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   * @param {string} [name] If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n  newStream (name) {\n    const id = this._streamId++\n    name = name == null ? id.toString() : String(name)\n    const registry = this._streams.initiators\n    return this._newStream({ id, name, type: 'initiator', registry })\n  }\n\n  /**\n   * Called whenever an inbound stream is created\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n  _newReceiverStream ({ id, name }) {\n    const registry = this._streams.receivers\n    return this._newStream({ id, name, type: 'receiver', registry })\n  }\n\n  /**\n   * Creates a new stream\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n  _newStream ({ id, name, type, registry }) {\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`)\n    }\n    log('new %s stream %s %s', type, id, name)\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() })\n      }\n      return this.source.push(msg)\n    }\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name)\n      registry.delete(id)\n      this.onStreamEnd && this.onStreamEnd(stream)\n    }\n    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize })\n    registry.set(id, stream)\n    return stream\n  }\n\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n  _createSink () {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal)\n      }\n\n      try {\n        await pipe(\n          source,\n          Coder.decode,\n          restrictSize(this._options.maxMsgSize),\n          async source => {\n            for await (const msgs of source) {\n              for (const msg of msgs) {\n                this._handleIncoming(msg)\n              }\n            }\n          }\n        )\n      } catch (err) {\n        log('error in sink', err)\n        return this.source.end(err) // End the source with an error\n      }\n\n      this.source.end()\n    }\n  }\n\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   * @private\n   * @returns {*} An iterable source\n   */\n  _createSource () {\n    const onEnd = err => {\n      const { initiators, receivers } = this._streams\n      // Abort all the things!\n      for (const s of initiators.values()) s.abort(err)\n      for (const s of receivers.values()) s.abort(err)\n    }\n    const source = pushable({ onEnd, writev: true })\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    })\n  }\n\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Buffer|BufferList} options.data\n   * @returns {void}\n   */\n  _handleIncoming ({ id, type, data }) {\n    if (log.enabled) {\n      log('incoming message', { id, type: MessageTypeNames[type], data: data.slice() })\n    }\n\n    // Create a new stream?\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({ id, name: data.toString() })\n      return this.onStream(stream)\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers\n    const stream = list.get(id)\n\n    if (!stream) return log('missing stream %s', id)\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data)\n        break\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close()\n        break\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset()\n        break\n      default:\n        log('unknown message type %s', type)\n    }\n  }\n}\n\nMplex.multicodec = '/mplex/6.7.0'\n\nmodule.exports = Mplex\n"]},"metadata":{},"sourceType":"script"}