{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Block = require('ipld-block');\n\nvar CID = require('cids');\n\nvar _require = require('multicodec'),\n    getName = _require.getName;\n\nvar vd = require('varint-decoder');\n\nvar multihashing = require('multihashing-async');\n\nvar _require2 = require('../../utils'),\n    isMapEqual = _require2.isMapEqual;\n\nvar _require3 = require('./message.proto'),\n    Message = _require3.Message;\n\nvar Entry = require('./entry');\n\nvar BitswapMessage = /*#__PURE__*/function () {\n  function BitswapMessage(full) {\n    _classCallCheck(this, BitswapMessage);\n\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  _createClass(BitswapMessage, [{\n    key: \"addEntry\",\n    value: function addEntry(cid, priority, wantType, cancel, sendDontHave) {\n      if (wantType == null) {\n        wantType = BitswapMessage.WantType.Block;\n      }\n\n      var cidStr = cid.toString('base58btc');\n      var entry = this.wantlist.get(cidStr);\n\n      if (entry) {\n        // Only change priority if want is of the same type\n        if (entry.wantType === wantType) {\n          entry.priority = priority;\n        } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n        if (cancel) {\n          entry.cancel = Boolean(cancel);\n        } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n        if (sendDontHave) {\n          entry.sendDontHave = Boolean(sendDontHave);\n        } // want-block overrides existing want-have\n\n\n        if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n          entry.wantType = wantType;\n        }\n      } else {\n        this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n      }\n    }\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(block) {\n      var cidStr = block.cid.toString('base58btc');\n      this.blocks.set(cidStr, block);\n    }\n  }, {\n    key: \"addHave\",\n    value: function addHave(cid) {\n      var cidStr = cid.toString('base58btc');\n\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n      }\n    }\n  }, {\n    key: \"addDontHave\",\n    value: function addDontHave(cid) {\n      var cidStr = cid.toString('base58btc');\n\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(cid) {\n      var cidStr = cid.toString('base58btc');\n      this.wantlist.delete(cidStr);\n      this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n  }, {\n    key: \"setPendingBytes\",\n    value: function setPendingBytes(size) {\n      this.pendingBytes = size;\n    }\n    /*\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     */\n\n  }, {\n    key: \"serializeToBitswap100\",\n    value: function serializeToBitswap100() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.buffer,\n              // cid\n              priority: Number(entry.priority),\n              cancel: Boolean(entry.cancel)\n            };\n          })\n        },\n        blocks: Array.from(this.blocks.values()).map(function (block) {\n          return block.data;\n        })\n      };\n\n      if (this.full) {\n        msg.wantlist.full = true;\n      }\n\n      return Message.encode(msg);\n    }\n    /*\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     */\n\n  }, {\n    key: \"serializeToBitswap110\",\n    value: function serializeToBitswap110() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.buffer,\n              // cid\n              priority: Number(entry.priority),\n              wantType: entry.wantType,\n              cancel: Boolean(entry.cancel),\n              sendDontHave: Boolean(entry.sendDontHave)\n            };\n          })\n        },\n        blockPresences: [],\n        payload: []\n      };\n\n      if (this.full) {\n        msg.wantlist.full = true;\n      }\n\n      this.blocks.forEach(function (block) {\n        msg.payload.push({\n          prefix: block.cid.prefix,\n          data: block.data\n        });\n      });\n\n      var _iterator = _createForOfIteratorHelper(this.blockPresences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              cidStr = _step$value[0],\n              bpType = _step$value[1];\n\n          msg.blockPresences.push({\n            cid: new CID(cidStr).buffer,\n            type: bpType\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this.pendingBytes > 0) {\n        msg.pendingBytes = this.pendingBytes;\n      }\n\n      return Message.encode(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      var list = Array.from(this.wantlist.keys());\n      var blocks = Array.from(this.blocks.keys());\n      return \"BitswapMessage <full: \".concat(this.full, \", list: \").concat(list, \", blocks: \").concat(blocks, \">\");\n    }\n  }]);\n\n  return BitswapMessage;\n}();\n\nBitswapMessage.deserialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(raw) {\n    var decoded, isFull, msg;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            decoded = Message.decode(raw);\n            isFull = decoded.wantlist && decoded.wantlist.full || false;\n            msg = new BitswapMessage(isFull);\n\n            if (decoded.wantlist) {\n              decoded.wantlist.entries.forEach(function (entry) {\n                // note: entry.block is the CID here\n                var cid = new CID(entry.block);\n                msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave);\n              });\n            }\n\n            if (decoded.blockPresences) {\n              decoded.blockPresences.forEach(function (blockPresence) {\n                var cid = new CID(blockPresence.cid);\n\n                if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                  msg.addHave(cid);\n                } else {\n                  msg.addDontHave(cid);\n                }\n              });\n            } // Bitswap 1.0.0\n            // decoded.blocks are just the byte arrays\n\n\n            if (!(decoded.blocks.length > 0)) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.next = 8;\n            return Promise.all(decoded.blocks.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(b) {\n                var hash, cid;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return multihashing(b, 'sha2-256');\n\n                      case 2:\n                        hash = _context.sent;\n                        cid = new CID(hash);\n                        msg.addBlock(new Block(b, cid));\n\n                      case 5:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x2) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 8:\n            return _context3.abrupt(\"return\", msg);\n\n          case 9:\n            if (!(decoded.payload.length > 0)) {\n              _context3.next = 14;\n              break;\n            }\n\n            _context3.next = 12;\n            return Promise.all(decoded.payload.map( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(p) {\n                var values, cidVersion, multicodec, hashAlg, hash, cid;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        if (!(!p.prefix || !p.data)) {\n                          _context2.next = 2;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\");\n\n                      case 2:\n                        values = vd(p.prefix);\n                        cidVersion = values[0];\n                        multicodec = values[1];\n                        hashAlg = values[2]; // const hashLen = values[3] // We haven't need to use this so far\n\n                        _context2.next = 8;\n                        return multihashing(p.data, hashAlg);\n\n                      case 8:\n                        hash = _context2.sent;\n                        cid = new CID(cidVersion, getName(multicodec), hash);\n                        msg.addBlock(new Block(p.data, cid));\n\n                      case 11:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }()));\n\n          case 12:\n            msg.setPendingBytes(decoded.pendingBytes);\n            return _context3.abrupt(\"return\", msg);\n\n          case 14:\n            return _context3.abrupt(\"return\", msg);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nBitswapMessage.blockPresenceSize = function (cid) {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.buffer.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/types/message/index.js"],"names":["Block","require","CID","getName","vd","multihashing","isMapEqual","Message","Entry","BitswapMessage","full","wantlist","Map","blocks","blockPresences","pendingBytes","cid","priority","wantType","cancel","sendDontHave","WantType","cidStr","toString","entry","get","Boolean","Have","set","block","has","BlockPresenceType","DontHave","delete","addEntry","size","msg","entries","Array","from","values","map","buffer","Number","data","encode","payload","forEach","push","prefix","bpType","type","other","Symbol","toStringTag","list","keys","deserialize","raw","decoded","decode","isFull","blockPresence","addHave","addDontHave","length","Promise","all","b","hash","addBlock","p","cidVersion","multicodec","hashAlg","setPendingBytes","blockPresenceSize","Wantlist","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Block = require('ipld-block')\nconst CID = require('cids')\nconst { getName } = require('multicodec')\nconst vd = require('varint-decoder')\nconst multihashing = require('multihashing-async')\nconst { isMapEqual } = require('../../utils')\nconst { Message } = require('./message.proto')\nconst Entry = require('./entry')\n\nclass BitswapMessage {\n  constructor (full) {\n    this.full = full\n    this.wantlist = new Map()\n    this.blocks = new Map()\n    this.blockPresences = new Map()\n    this.pendingBytes = 0\n  }\n\n  get empty () {\n    return this.blocks.size === 0 &&\n           this.wantlist.size === 0 &&\n           this.blockPresences.size === 0\n  }\n\n  addEntry (cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block\n    }\n\n    const cidStr = cid.toString('base58btc')\n    const entry = this.wantlist.get(cidStr)\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority\n      }\n      // Only change from \"dont cancel\" to \"do cancel\"\n      if (cancel) {\n        entry.cancel = Boolean(cancel)\n      }\n      // Only change from \"dont send\" to \"do send\" DONT_HAVE\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave)\n      }\n      // want-block overrides existing want-have\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave))\n    }\n  }\n\n  addBlock (block) {\n    const cidStr = block.cid.toString('base58btc')\n    this.blocks.set(cidStr, block)\n  }\n\n  addHave (cid) {\n    const cidStr = cid.toString('base58btc')\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have)\n    }\n  }\n\n  addDontHave (cid) {\n    const cidStr = cid.toString('base58btc')\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave)\n    }\n  }\n\n  cancel (cid) {\n    const cidStr = cid.toString('base58btc')\n    this.wantlist.delete(cidStr)\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false)\n  }\n\n  setPendingBytes (size) {\n    this.pendingBytes = size\n  }\n\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   */\n  serializeToBitswap100 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.buffer, // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          }\n        })\n      },\n      blocks: Array.from(this.blocks.values())\n        .map((block) => block.data)\n    }\n\n    if (this.full) {\n      msg.wantlist.full = true\n    }\n\n    return Message.encode(msg)\n  }\n\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   */\n  serializeToBitswap110 () {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map((entry) => {\n          return {\n            block: entry.cid.buffer, // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          }\n        })\n      },\n      blockPresences: [],\n      payload: []\n    }\n\n    if (this.full) {\n      msg.wantlist.full = true\n    }\n\n    this.blocks.forEach((block) => {\n      msg.payload.push({\n        prefix: block.cid.prefix,\n        data: block.data\n      })\n    })\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push({\n        cid: new CID(cidStr).buffer,\n        type: bpType\n      })\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes\n    }\n\n    return Message.encode(msg)\n  }\n\n  equals (other) {\n    if (this.full !== other.full ||\n        this.pendingBytes !== other.pendingBytes ||\n        !isMapEqual(this.wantlist, other.wantlist) ||\n        !isMapEqual(this.blocks, other.blocks) ||\n        !isMapEqual(this.blockPresences, other.blockPresences)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  get [Symbol.toStringTag] () {\n    const list = Array.from(this.wantlist.keys())\n    const blocks = Array.from(this.blocks.keys())\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`\n  }\n}\n\nBitswapMessage.deserialize = async (raw) => {\n  const decoded = Message.decode(raw)\n\n  const isFull = (decoded.wantlist && decoded.wantlist.full) || false\n  const msg = new BitswapMessage(isFull)\n\n  if (decoded.wantlist) {\n    decoded.wantlist.entries.forEach((entry) => {\n      // note: entry.block is the CID here\n      const cid = new CID(entry.block)\n      msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave)\n    })\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach((blockPresence) => {\n      const cid = new CID(blockPresence.cid)\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid)\n      } else {\n        msg.addDontHave(cid)\n      }\n    })\n  }\n\n  // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async (b) => {\n      const hash = await multihashing(b, 'sha2-256')\n      const cid = new CID(hash)\n      msg.addBlock(new Block(b, cid))\n    }))\n    return msg\n  }\n\n  // Bitswap 1.1.0\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async (p) => {\n      if (!p.prefix || !p.data) {\n        return\n      }\n      const values = vd(p.prefix)\n      const cidVersion = values[0]\n      const multicodec = values[1]\n      const hashAlg = values[2]\n      // const hashLen = values[3] // We haven't need to use this so far\n      const hash = await multihashing(p.data, hashAlg)\n      const cid = new CID(cidVersion, getName(multicodec), hash)\n      msg.addBlock(new Block(p.data, cid))\n    }))\n    msg.setPendingBytes(decoded.pendingBytes)\n    return msg\n  }\n\n  return msg\n}\n\nBitswapMessage.blockPresenceSize = (cid) => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.buffer.length + 1\n}\n\nBitswapMessage.Entry = Entry\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n}\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n}\nmodule.exports = BitswapMessage\n"]},"metadata":{},"sourceType":"script"}