{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:persistent-peer-store');\nlog.error = debug('libp2p:persistent-peer-store:error');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar multiaddr = require('multiaddr');\n\nvar PeerId = require('peer-id');\n\nvar PeerStore = require('..');\n\nvar _require2 = require('./consts'),\n    NAMESPACE_ADDRESS = _require2.NAMESPACE_ADDRESS,\n    NAMESPACE_COMMON = _require2.NAMESPACE_COMMON,\n    NAMESPACE_KEYS = _require2.NAMESPACE_KEYS,\n    NAMESPACE_METADATA = _require2.NAMESPACE_METADATA,\n    NAMESPACE_PROTOCOL = _require2.NAMESPACE_PROTOCOL;\n\nvar Addresses = require('./pb/address-book.proto');\n\nvar Protocols = require('./pb/proto-book.proto');\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nvar PersistentPeerStore = /*#__PURE__*/function (_PeerStore) {\n  _inherits(PersistentPeerStore, _PeerStore);\n\n  var _super = _createSuper(PersistentPeerStore);\n\n  /**\n   * @constructor\n   * @param {Object} properties\n   * @param {Datastore} properties.datastore Datastore to persist data.\n   * @param {number} [properties.threshold = 5] Number of dirty peers allowed before commit data.\n   */\n  function PersistentPeerStore(_ref) {\n    var _this;\n\n    var datastore = _ref.datastore,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === void 0 ? 5 : _ref$threshold;\n\n    _classCallCheck(this, PersistentPeerStore);\n\n    _this = _super.call(this);\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    _this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    _this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     * @type {Map<string, Set<string>>}\n     */\n\n    _this._dirtyMetadata = new Map();\n    _this.threshold = threshold;\n    _this._addDirtyPeer = _this._addDirtyPeer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Start Persistent PeerStore.\n   * @return {Promise<void>}\n   */\n\n\n  _createClass(PersistentPeerStore, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, entry;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('PeerStore is starting'); // Handlers for dirty peers\n\n                this.on('change:protocols', this._addDirtyPeer);\n                this.on('change:multiaddrs', this._addDirtyPeer);\n                this.on('change:pubkey', this._addDirtyPeer);\n                this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 7;\n                _iterator = _asyncIterator(this._datastore.query({\n                  prefix: NAMESPACE_COMMON\n                }));\n\n              case 9:\n                _context.next = 11;\n                return _iterator.next();\n\n              case 11:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 15;\n                return _step.value;\n\n              case 15:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 23;\n                  break;\n                }\n\n                entry = _value;\n                _context.next = 20;\n                return this._processDatastoreEntry(entry);\n\n              case 20:\n                _iteratorNormalCompletion = true;\n                _context.next = 9;\n                break;\n\n              case 23:\n                _context.next = 29;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](7);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 29:\n                _context.prev = 29;\n                _context.prev = 30;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 34;\n                  break;\n                }\n\n                _context.next = 34;\n                return _iterator.return();\n\n              case 34:\n                _context.prev = 34;\n\n                if (!_didIteratorError) {\n                  _context.next = 37;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 37:\n                return _context.finish(34);\n\n              case 38:\n                return _context.finish(29);\n\n              case 39:\n                log('PeerStore started');\n\n              case 40:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 25, 29, 39], [30,, 34, 38]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                log('PeerStore is stopping');\n                this.removeAllListeners();\n                _context2.next = 4;\n                return this._commitData();\n\n              case 4:\n                log('PeerStore stopped');\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Add modified peer to the dirty set\n     * @private\n     * @param {Object} params\n     * @param {PeerId} params.peerId\n     */\n\n  }, {\n    key: \"_addDirtyPeer\",\n    value: function _addDirtyPeer(_ref2) {\n      var peerId = _ref2.peerId;\n      var peerIdstr = peerId.toB58String();\n      log('add dirty peer', peerIdstr);\n\n      this._dirtyPeers.add(peerIdstr);\n\n      if (this._dirtyPeers.size >= this.threshold) {\n        // Commit current data\n        this._commitData().catch(function (err) {\n          log.error('error committing data', err);\n        });\n      }\n    }\n    /**\n     * Add modified metadata peer to the set.\n     * @private\n     * @param {Object} params\n     * @param {PeerId} params.peerId\n     * @param {string} params.metadata\n     */\n\n  }, {\n    key: \"_addDirtyPeerMetadata\",\n    value: function _addDirtyPeerMetadata(_ref3) {\n      var peerId = _ref3.peerId,\n          metadata = _ref3.metadata;\n      var peerIdstr = peerId.toB58String();\n      log('add dirty metadata peer', peerIdstr);\n\n      this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n      var mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n      mData.add(metadata);\n\n      this._dirtyMetadata.set(peerIdstr, mData);\n\n      if (this._dirtyPeers.size >= this.threshold) {\n        // Commit current data\n        this._commitData().catch(function (err) {\n          log.error('error committing data', err);\n        });\n      }\n    }\n    /**\n     * Add all the peers current data to a datastore batch and commit it.\n     * @private\n     * @param {Array<string>} peers\n     * @return {Promise<void>}\n     */\n\n  }, {\n    key: \"_commitData\",\n    value: function () {\n      var _commitData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var commitPeers, batch, _i, _commitPeers, peerIdStr, peerId;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                commitPeers = Array.from(this._dirtyPeers);\n\n                if (commitPeers.length) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                // Clear Dirty Peers set\n                this._dirtyPeers.clear();\n\n                log('create batch commit');\n                batch = this._datastore.batch();\n\n                for (_i = 0, _commitPeers = commitPeers; _i < _commitPeers.length; _i++) {\n                  peerIdStr = _commitPeers[_i];\n                  // PeerId\n                  peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr); // Address Book\n\n                  this._batchAddressBook(peerId, batch); // Key Book\n\n\n                  this._batchKeyBook(peerId, batch); // Metadata Book\n\n\n                  this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n                  this._batchProtoBook(peerId, batch);\n                }\n\n                _context3.next = 9;\n                return batch.commit();\n\n              case 9:\n                log('batch committed');\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _commitData() {\n        return _commitData2.apply(this, arguments);\n      }\n\n      return _commitData;\n    }()\n    /**\n     * Add address book data of the peer to the batch.\n     * @private\n     * @param {PeerId} peerId\n     * @param {Object} batch\n     */\n\n  }, {\n    key: \"_batchAddressBook\",\n    value: function _batchAddressBook(peerId, batch) {\n      var b32key = peerId.toString();\n      var key = new Key(\"\".concat(NAMESPACE_ADDRESS).concat(b32key));\n      var addresses = this.addressBook.get(peerId);\n\n      try {\n        // Deleted from the book\n        if (!addresses) {\n          batch.delete(key);\n          return;\n        }\n\n        var encodedData = Addresses.encode({\n          addrs: addresses.map(function (address) {\n            return {\n              multiaddr: address.multiaddr.buffer\n            };\n          })\n        });\n        batch.put(key, encodedData);\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Add Key book data of the peer to the batch.\n     * @private\n     * @param {PeerId} peerId\n     * @param {Object} batch\n     */\n\n  }, {\n    key: \"_batchKeyBook\",\n    value: function _batchKeyBook(peerId, batch) {\n      var b32key = peerId.toString();\n      var key = new Key(\"\".concat(NAMESPACE_KEYS).concat(b32key));\n\n      try {\n        // Deleted from the book\n        if (!peerId.pubKey) {\n          batch.delete(key);\n          return;\n        }\n\n        var encodedData = peerId.marshalPubKey();\n        batch.put(key, encodedData);\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Add metadata book data of the peer to the batch.\n     * @private\n     * @param {PeerId} peerId\n     * @param {Object} batch\n     */\n\n  }, {\n    key: \"_batchMetadataBook\",\n    value: function _batchMetadataBook(peerId, batch) {\n      var _this2 = this;\n\n      var b32key = peerId.toString();\n      var dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n      try {\n        dirtyMetada.forEach(function (dirtyKey) {\n          var key = new Key(\"\".concat(NAMESPACE_METADATA).concat(b32key, \"/\").concat(dirtyKey));\n\n          var dirtyValue = _this2.metadataBook.getValue(peerId, dirtyKey);\n\n          if (dirtyValue) {\n            batch.put(key, dirtyValue);\n          } else {\n            batch.delete(key);\n          }\n        });\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Add proto book data of the peer to the batch.\n     * @private\n     * @param {PeerId} peerId\n     * @param {Object} batch\n     */\n\n  }, {\n    key: \"_batchProtoBook\",\n    value: function _batchProtoBook(peerId, batch) {\n      var b32key = peerId.toString();\n      var key = new Key(\"\".concat(NAMESPACE_PROTOCOL).concat(b32key));\n      var protocols = this.protoBook.get(peerId);\n\n      try {\n        // Deleted from the book\n        if (!protocols) {\n          batch.delete(key);\n          return;\n        }\n\n        var encodedData = Protocols.encode({\n          protocols: protocols\n        });\n        batch.put(key, encodedData);\n      } catch (err) {\n        log.error(err);\n      }\n    }\n    /**\n     * Process datastore entry and add its data to the correct book.\n     * @private\n     * @param {Object} params\n     * @param {Key} params.key datastore key\n     * @param {Buffer} params.value datastore value stored\n     * @return {Promise<void>}\n     */\n\n  }, {\n    key: \"_processDatastoreEntry\",\n    value: function () {\n      var _processDatastoreEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref4) {\n        var key, value, keyParts, peerId, decoded;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                key = _ref4.key, value = _ref4.value;\n                _context4.prev = 1;\n                keyParts = key.toString().split('/');\n                peerId = PeerId.createFromCID(keyParts[3]);\n                _context4.t0 = keyParts[2];\n                _context4.next = _context4.t0 === 'addrs' ? 7 : _context4.t0 === 'keys' ? 10 : _context4.t0 === 'metadata' ? 15 : _context4.t0 === 'protos' ? 17 : 20;\n                break;\n\n              case 7:\n                decoded = Addresses.decode(value);\n\n                this.addressBook._setData(peerId, decoded.addrs.map(function (address) {\n                  return {\n                    multiaddr: multiaddr(address.multiaddr)\n                  };\n                }), {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 10:\n                _context4.next = 12;\n                return PeerId.createFromPubKey(value);\n\n              case 12:\n                decoded = _context4.sent;\n\n                this.keyBook._setData(decoded, decoded, {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 15:\n                this.metadataBook._setValue(peerId, keyParts[4], value, {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 17:\n                decoded = Protocols.decode(value);\n\n                this.protoBook._setData(peerId, new Set(decoded.protocols), {\n                  emit: false\n                });\n\n                return _context4.abrupt(\"break\", 21);\n\n              case 20:\n                log('invalid data persisted for: ', key.toString());\n\n              case 21:\n                _context4.next = 26;\n                break;\n\n              case 23:\n                _context4.prev = 23;\n                _context4.t1 = _context4[\"catch\"](1);\n                log.error(_context4.t1);\n\n              case 26:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 23]]);\n      }));\n\n      function _processDatastoreEntry(_x) {\n        return _processDatastoreEntry2.apply(this, arguments);\n      }\n\n      return _processDatastoreEntry;\n    }()\n  }]);\n\n  return PersistentPeerStore;\n}(PeerStore);\n\nmodule.exports = PersistentPeerStore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/peer-store/persistent/index.js"],"names":["debug","require","log","error","Key","multiaddr","PeerId","PeerStore","NAMESPACE_ADDRESS","NAMESPACE_COMMON","NAMESPACE_KEYS","NAMESPACE_METADATA","NAMESPACE_PROTOCOL","Addresses","Protocols","PersistentPeerStore","datastore","threshold","_datastore","_dirtyPeers","Set","_dirtyMetadata","Map","_addDirtyPeer","bind","on","_addDirtyPeerMetadata","query","prefix","entry","_processDatastoreEntry","removeAllListeners","_commitData","peerId","peerIdstr","toB58String","add","size","catch","err","metadata","mData","get","set","commitPeers","Array","from","length","clear","batch","peerIdStr","keyBook","data","createFromCID","_batchAddressBook","_batchKeyBook","_batchMetadataBook","_batchProtoBook","commit","b32key","toString","key","addresses","addressBook","delete","encodedData","encode","addrs","map","address","buffer","put","pubKey","marshalPubKey","dirtyMetada","forEach","dirtyKey","dirtyValue","metadataBook","getValue","protocols","protoBook","value","keyParts","split","decoded","decode","_setData","emit","createFromPubKey","_setValue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:persistent-peer-store')\nlog.error = debug('libp2p:persistent-peer-store:error')\n\nconst { Key } = require('interface-datastore')\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst PeerStore = require('..')\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts')\n\nconst Addresses = require('./pb/address-book.proto')\nconst Protocols = require('./pb/proto-book.proto')\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @constructor\n   * @param {Object} properties\n   * @param {Datastore} properties.datastore Datastore to persist data.\n   * @param {number} [properties.threshold = 5] Number of dirty peers allowed before commit data.\n   */\n  constructor ({ datastore, threshold = 5 }) {\n    super()\n\n    /**\n     * Backend datastore used to persist data.\n     */\n    this._datastore = datastore\n\n    /**\n     * Peers modified after the latest data persisted.\n     */\n    this._dirtyPeers = new Set()\n\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     * @type {Map<string, Set<string>>}\n     */\n    this._dirtyMetadata = new Map()\n\n    this.threshold = threshold\n    this._addDirtyPeer = this._addDirtyPeer.bind(this)\n  }\n\n  /**\n   * Start Persistent PeerStore.\n   * @return {Promise<void>}\n   */\n  async start () {\n    log('PeerStore is starting')\n\n    // Handlers for dirty peers\n    this.on('change:protocols', this._addDirtyPeer)\n    this.on('change:multiaddrs', this._addDirtyPeer)\n    this.on('change:pubkey', this._addDirtyPeer)\n    this.on('change:metadata', this._addDirtyPeerMetadata)\n\n    // Load data\n    for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {\n      await this._processDatastoreEntry(entry)\n    }\n\n    log('PeerStore started')\n  }\n\n  async stop () {\n    log('PeerStore is stopping')\n    this.removeAllListeners()\n    await this._commitData()\n    log('PeerStore stopped')\n  }\n\n  /**\n   * Add modified peer to the dirty set\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeer ({ peerId }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified metadata peer to the set.\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n  _addDirtyPeerMetadata ({ peerId, metadata }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty metadata peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    // Add dirty metadata key\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set()\n    mData.add(metadata)\n    this._dirtyMetadata.set(peerIdstr, mData)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   * @private\n   * @param {Array<string>} peers\n   * @return {Promise<void>}\n   */\n  async _commitData () {\n    const commitPeers = Array.from(this._dirtyPeers)\n\n    if (!commitPeers.length) {\n      return\n    }\n\n    // Clear Dirty Peers set\n    this._dirtyPeers.clear()\n\n    log('create batch commit')\n    const batch = this._datastore.batch()\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr)\n\n      // Address Book\n      this._batchAddressBook(peerId, batch)\n\n      // Key Book\n      this._batchKeyBook(peerId, batch)\n\n      // Metadata Book\n      this._batchMetadataBook(peerId, batch)\n\n      // Proto Book\n      this._batchProtoBook(peerId, batch)\n    }\n\n    await batch.commit()\n    log('batch committed')\n  }\n\n  /**\n   * Add address book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchAddressBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`)\n\n    const addresses = this.addressBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!addresses) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: addresses.map((address) => ({\n          multiaddr: address.multiaddr.buffer\n        }))\n      })\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add Key book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchKeyBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`)\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = peerId.marshalPubKey()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add metadata book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchMetadataBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || []\n\n    try {\n      dirtyMetada.forEach((dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`)\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey)\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue)\n        } else {\n          batch.delete(key)\n        }\n      })\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add proto book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchProtoBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`)\n\n    const protocols = this.protoBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Protocols.encode({ protocols })\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Process datastore entry and add its data to the correct book.\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key datastore key\n   * @param {Buffer} params.value datastore value stored\n   * @return {Promise<void>}\n   */\n  async _processDatastoreEntry ({ key, value }) {\n    try {\n      const keyParts = key.toString().split('/')\n      const peerId = PeerId.createFromCID(keyParts[3])\n\n      let decoded\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value)\n\n          this.addressBook._setData(\n            peerId,\n            decoded.addrs.map((address) => ({\n              multiaddr: multiaddr(address.multiaddr)\n            })),\n            { emit: false })\n          break\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value)\n\n          this.keyBook._setData(\n            decoded,\n            decoded,\n            { emit: false })\n          break\n        case 'metadata':\n          this.metadataBook._setValue(\n            peerId,\n            keyParts[4],\n            value,\n            { emit: false })\n          break\n        case 'protos':\n          decoded = Protocols.decode(value)\n\n          this.protoBook._setData(\n            peerId,\n            new Set(decoded.protocols),\n            { emit: false })\n          break\n        default:\n          log('invalid data persisted for: ', key.toString())\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\nmodule.exports = PersistentPeerStore\n"]},"metadata":{},"sourceType":"script"}