{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst crypto = require('libp2p-crypto');\n\nconst multibase = require('multibase');\n\nexports = module.exports;\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\n\nexports.randomSeqno = () => {\n  return crypto.randomBytes(8);\n};\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\n\n\nexports.msgId = (from, seqno) => {\n  return from + seqno.toString('hex');\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\n\n\nexports.anyMatch = (a, b) => {\n  let bHas;\n\n  if (Array.isArray(b)) {\n    bHas = val => b.indexOf(val) > -1;\n  } else {\n    bHas = val => b.has(val);\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\n\n\nexports.ensureArray = maybeArray => {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n/**\n * Ensures `message.from` is base58 encoded\n * @param {Object} message\n * @param {Buffer|String} message.from\n * @return {Object}\n */\n\n\nexports.normalizeInRpcMessage = message => {\n  const m = Object.assign({}, message);\n\n  if (Buffer.isBuffer(message.from)) {\n    m.from = multibase.encode('base58btc', message.from).toString().slice(1);\n  }\n\n  return m;\n};\n/**\n * The same as `normalizeInRpcMessage`, but performed on an array of messages\n * @param {Object[]} messages\n * @return {Object[]}\n */\n\n\nexports.normalizeInRpcMessages = messages => {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeInRpcMessage);\n};\n\nexports.normalizeOutRpcMessage = message => {\n  const m = Object.assign({}, message);\n\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = multibase.decode('z' + message.from);\n  }\n\n  return m;\n};\n\nexports.normalizeOutRpcMessages = messages => {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeOutRpcMessage);\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-pubsub/src/utils.js"],"names":["Buffer","require","crypto","multibase","exports","module","randomSeqno","randomBytes","msgId","from","seqno","toString","anyMatch","a","b","bHas","Array","isArray","val","indexOf","has","ensureArray","maybeArray","normalizeInRpcMessage","message","m","Object","assign","isBuffer","encode","slice","normalizeInRpcMessages","messages","map","normalizeOutRpcMessage","String","decode","normalizeOutRpcMessages"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst crypto = require('libp2p-crypto')\nconst multibase = require('multibase')\n\nexports = module.exports\n\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\nexports.randomSeqno = () => {\n  return crypto.randomBytes(8)\n}\n\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\nexports.msgId = (from, seqno) => {\n  return from + seqno.toString('hex')\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\nexports.anyMatch = (a, b) => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val) => b.indexOf(val) > -1\n  } else {\n    bHas = (val) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\nexports.ensureArray = (maybeArray) => {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\n/**\n * Ensures `message.from` is base58 encoded\n * @param {Object} message\n * @param {Buffer|String} message.from\n * @return {Object}\n */\nexports.normalizeInRpcMessage = (message) => {\n  const m = Object.assign({}, message)\n  if (Buffer.isBuffer(message.from)) {\n    m.from = multibase.encode('base58btc', message.from).toString().slice(1)\n  }\n  return m\n}\n\n/**\n * The same as `normalizeInRpcMessage`, but performed on an array of messages\n * @param {Object[]} messages\n * @return {Object[]}\n */\nexports.normalizeInRpcMessages = (messages) => {\n  if (!messages) {\n    return messages\n  }\n  return messages.map(exports.normalizeInRpcMessage)\n}\n\nexports.normalizeOutRpcMessage = (message) => {\n  const m = Object.assign({}, message)\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = multibase.decode('z' + message.from)\n  }\n  return m\n}\n\nexports.normalizeOutRpcMessages = (messages) => {\n  if (!messages) {\n    return messages\n  }\n  return messages.map(exports.normalizeOutRpcMessage)\n}\n"]},"metadata":{},"sourceType":"script"}