{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst c = require('../constants');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nconst Record = libp2pRecord.Record;\n\nmodule.exports = dht => {\n  const putLocal = async (key, rec) => {\n    // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec);\n  };\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @returns {Promise<Record>}\n   *\n   * @private\n   */\n\n\n  const getLocal = async key => {\n    dht._log('getLocal %b', key);\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key));\n\n    dht._log('found %b in local datastore', key);\n\n    const rec = Record.deserialize(raw);\n    await dht._verifyRecordLocally(rec);\n    return rec;\n  };\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n\n\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best);\n    return Promise.all(vals.map(async v => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return;\n      } // correct ourself\n\n\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec);\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err);\n        }\n\n        return;\n      } // send correction\n\n\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from);\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err);\n      }\n    }));\n  };\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _putLocal(key, rec) {\n      // eslint-disable-line require-await\n      return putLocal(key, rec);\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     * @returns {Promise<void>}\n     */\n    async put(key, value, options = {}) {\n      dht._log('PutValue %b', key); // create record in the dht format\n\n\n      const record = await utils.createPutRecord(key, value); // store the record locally\n\n      await putLocal(key, record); // put record to the closest peers\n\n      let counterAll = 0;\n      let counterSuccess = 0;\n      await utils.mapParallel(dht.getClosestPeers(key, {\n        shallow: true\n      }), async peer => {\n        try {\n          counterAll += 1;\n          await dht._putValueToPeer(key, record, peer);\n          counterSuccess += 1;\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err);\n        }\n      }); // verify if we were able to put to enough peers\n\n      const minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n        dht._log.error(error);\n\n        throw error;\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Buffer>}\n     */\n    async get(key, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('_get %b', key);\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n      const recs = vals.map(v => v.val);\n      let i = 0;\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err;\n        }\n      }\n\n      const best = recs[i];\n\n      dht._log('GetValue %b %s', key, best);\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n      }\n\n      await sendCorrectionRecord(key, vals, best);\n      return best;\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany(key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('getMany %b (%s)', key, nvals);\n\n      let vals = [];\n      let localRec;\n\n      try {\n        localRec = await getLocal(key);\n      } catch (err) {\n        if (nvals === 0) {\n          throw err;\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        });\n      }\n\n      if (vals.length >= nvals) {\n        return vals;\n      }\n\n      const paths = [];\n      const id = await utils.convertBuffer(key);\n      const rtp = dht.routingTable.closestPeers(id, this.kBucketSize);\n\n      dht._log('peers in rt: %d', rtp.length);\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n        dht._log.error(errMsg);\n\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n        }\n\n        return vals;\n      } // we have peers, lets do the actual query to them\n\n\n      const query = new Query(dht, key, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - vals.length, numPaths);\n        const pathVals = [];\n        paths.push(pathVals); // Here we return the query function to use on this particular disjoint path\n\n        return async peer => {\n          let rec, peers, lookupErr;\n\n          try {\n            const results = await dht._getValueOrPeers(peer, key);\n            rec = results.record;\n            peers = results.peers;\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err;\n            }\n\n            lookupErr = err;\n          }\n\n          const res = {\n            closerPeers: peers\n          };\n\n          if (rec && rec.value || lookupErr) {\n            pathVals.push({\n              val: rec && rec.value,\n              from: peer\n            });\n          } // enough is enough\n\n\n          if (pathVals.length >= pathSize) {\n            res.pathComplete = true;\n          }\n\n          return res;\n        };\n      });\n      let error;\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout);\n      } catch (err) {\n        error = err;\n      }\n\n      query.stop(); // combine vals from each path\n\n      vals = [].concat.apply(vals, paths).slice(0, nvals);\n\n      if (error && vals.length === 0) {\n        throw error;\n      }\n\n      return vals;\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"names":["errcode","require","pTimeout","libp2pRecord","c","Query","utils","Record","module","exports","dht","putLocal","key","rec","datastore","put","bufferToKey","getLocal","_log","raw","get","deserialize","_verifyRecordLocally","sendCorrectionRecord","vals","best","fixupRec","createPutRecord","Promise","all","map","v","val","equals","_isSelf","from","_putLocal","err","error","_putValueToPeer","value","options","record","counterAll","counterSuccess","mapParallel","getClosestPeers","shallow","peer","id","minPeers","Error","timeout","minute","getMany","GET_MANY_RECORD_COUNT","recs","i","selection","bestRecord","selectors","code","nvals","localRec","push","peerId","length","paths","convertBuffer","rtp","routingTable","closestPeers","kBucketSize","errMsg","query","pathIndex","numPaths","pathSize","pathVals","peers","lookupErr","results","_getValueOrPeers","res","closerPeers","pathComplete","run","stop","concat","apply","slice"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst libp2pRecord = require('libp2p-record')\n\nconst c = require('../constants')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\nconst Record = libp2pRecord.Record\n\nmodule.exports = (dht) => {\n  const putLocal = async (key, rec) => { // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @returns {Promise<Record>}\n   *\n   * @private\n   */\n  const getLocal = async (key) => {\n    dht._log('getLocal %b', key)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log('found %b in local datastore', key)\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocally(rec)\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  }\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _putLocal (key, rec) { // eslint-disable-line require-await\n      return putLocal(key, rec)\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     * @returns {Promise<void>}\n     */\n    async put (key, value, options = {}) {\n      dht._log('PutValue %b', key)\n\n      // create record in the dht format\n      const record = await utils.createPutRecord(key, value)\n\n      // store the record locally\n      await putLocal(key, record)\n\n      // put record to the closest peers\n      let counterAll = 0\n      let counterSuccess = 0\n\n      await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {\n        try {\n          counterAll += 1\n          await dht._putValueToPeer(key, record, peer)\n          counterSuccess += 1\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err)\n        }\n      })\n\n      // verify if we were able to put to enough peers\n      const minPeers = options.minPeers || counterAll // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n        dht._log.error(error)\n        throw error\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Buffer>}\n     */\n    async get (key, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('_get %b', key)\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options)\n      const recs = vals.map((v) => v.val)\n      let i = 0\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err\n        }\n      }\n\n      const best = recs[i]\n      dht._log('GetValue %b %s', key, best)\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n      }\n\n      await sendCorrectionRecord(key, vals, best)\n\n      return best\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany (key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('getMany %b (%s)', key, nvals)\n\n      let vals = []\n      let localRec\n\n      try {\n        localRec = await getLocal(key)\n      } catch (err) {\n        if (nvals === 0) {\n          throw err\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return vals\n      }\n\n      const paths = []\n      const id = await utils.convertBuffer(key)\n      const rtp = dht.routingTable.closestPeers(id, this.kBucketSize)\n\n      dht._log('peers in rt: %d', rtp.length)\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n        dht._log.error(errMsg)\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n        }\n        return vals\n      }\n\n      // we have peers, lets do the actual query to them\n      const query = new Query(dht, key, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - vals.length, numPaths)\n        const pathVals = []\n        paths.push(pathVals)\n\n        // Here we return the query function to use on this particular disjoint path\n        return async (peer) => {\n          let rec, peers, lookupErr\n          try {\n            const results = await dht._getValueOrPeers(peer, key)\n            rec = results.record\n            peers = results.peers\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err\n            }\n            lookupErr = err\n          }\n\n          const res = { closerPeers: peers }\n\n          if ((rec && rec.value) || lookupErr) {\n            pathVals.push({\n              val: rec && rec.value,\n              from: peer\n            })\n          }\n\n          // enough is enough\n          if (pathVals.length >= pathSize) {\n            res.pathComplete = true\n          }\n\n          return res\n        }\n      })\n\n      let error\n      try {\n        await pTimeout(query.run(rtp), options.timeout)\n      } catch (err) {\n        error = err\n      }\n      query.stop()\n\n      // combine vals from each path\n      vals = [].concat.apply(vals, paths).slice(0, nvals)\n\n      if (error && vals.length === 0) {\n        throw error\n      }\n\n      return vals\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}