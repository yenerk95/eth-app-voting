{"ast":null,"code":"import _slicedToArray from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport { Buffer } from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport { encode, decode } from 'it-length-prefixed';\nimport { XXHandshake } from \"./handshake-xx\";\nimport { IKHandshake } from \"./handshake-ik\";\nimport { XXFallbackHandshake } from \"./handshake-xx-fallback\";\nimport { generateKeypair, getPayload } from \"./utils\";\nimport { uint16BEDecode, uint16BEEncode } from \"./encoder\";\nimport { decryptStream, encryptStream } from \"./crypto\";\nimport { KeyCache } from \"./keycache\";\nimport { logger } from \"./logger\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from \"./constants\";\nexport var Noise = /*#__PURE__*/function () {\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  function Noise(staticNoiseKey, earlyData) {\n    _classCallCheck(this, Noise);\n\n    _defineProperty(this, \"protocol\", \"/noise\");\n\n    _defineProperty(this, \"prologue\", Buffer.alloc(0));\n\n    _defineProperty(this, \"staticKeys\", void 0);\n\n    _defineProperty(this, \"earlyData\", void 0);\n\n    _defineProperty(this, \"useNoisePipes\", void 0);\n\n    this.earlyData = earlyData || Buffer.alloc(0); //disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      var publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey: publicKey\n      };\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  _createClass(Noise, [{\n    key: \"secureOutbound\",\n    value: function () {\n      var _secureOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                wrappedConnection = Wrap(connection, {\n                  lengthEncoder: uint16BEEncode,\n                  lengthDecoder: uint16BEDecode,\n                  maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n                });\n                _context.next = 3;\n                return this.performHandshake({\n                  connection: wrappedConnection,\n                  isInitiator: true,\n                  localPeer: localPeer,\n                  remotePeer: remotePeer\n                });\n\n              case 3:\n                handshake = _context.sent;\n                _context.next = 6;\n                return this.createSecureConnection(wrappedConnection, handshake);\n\n              case 6:\n                conn = _context.sent;\n                return _context.abrupt(\"return\", {\n                  conn: conn,\n                  remoteEarlyData: handshake.remoteEarlyData,\n                  remotePeer: handshake.remotePeer\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function secureOutbound(_x, _x2, _x3) {\n        return _secureOutbound.apply(this, arguments);\n      }\n\n      return secureOutbound;\n    }()\n    /**\n     * Decrypt incoming data (handshake as responder).\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecureOutbound>}\n     */\n\n  }, {\n    key: \"secureInbound\",\n    value: function () {\n      var _secureInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                wrappedConnection = Wrap(connection, {\n                  lengthEncoder: uint16BEEncode,\n                  lengthDecoder: uint16BEDecode,\n                  maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n                });\n                _context2.next = 3;\n                return this.performHandshake({\n                  connection: wrappedConnection,\n                  isInitiator: false,\n                  localPeer: localPeer,\n                  remotePeer: remotePeer\n                });\n\n              case 3:\n                handshake = _context2.sent;\n                _context2.next = 6;\n                return this.createSecureConnection(wrappedConnection, handshake);\n\n              case 6:\n                conn = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  conn: conn,\n                  remoteEarlyData: handshake.remoteEarlyData,\n                  remotePeer: handshake.remotePeer\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function secureInbound(_x4, _x5, _x6) {\n        return _secureInbound.apply(this, arguments);\n      }\n\n      return secureInbound;\n    }()\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     * @param params\n     */\n\n  }, {\n    key: \"performHandshake\",\n    value: function () {\n      var _performHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {\n        var payload, tryIK, remotePeer, connection, isInitiator, ikHandshake, ephemeralKeys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n\n              case 2:\n                payload = _context3.sent;\n                tryIK = this.useNoisePipes;\n\n                if (params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n                  //if we are initiator and remote static key is unknown, don't try IK\n                  tryIK = false;\n                } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n                if (!tryIK) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                // Try IK first\n                remotePeer = params.remotePeer, connection = params.connection, isInitiator = params.isInitiator;\n                ikHandshake = new IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, //safe to cast as we did checks\n                KeyCache.load(params.remotePeer) || Buffer.alloc(32), remotePeer);\n                _context3.prev = 8;\n                _context3.next = 11;\n                return this.performIKHandshake(ikHandshake);\n\n              case 11:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3[\"catch\"](8);\n\n                // IK failed, go to XX fallback\n                if (params.isInitiator) {\n                  ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n                }\n\n                _context3.next = 19;\n                return this.performXXFallbackHandshake(params, payload, _context3.t0.initialMsg, ephemeralKeys);\n\n              case 19:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 20:\n                _context3.next = 25;\n                break;\n\n              case 22:\n                _context3.next = 24;\n                return this.performXXHandshake(params, payload);\n\n              case 24:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[8, 14]]);\n      }));\n\n      function performHandshake(_x7) {\n        return _performHandshake.apply(this, arguments);\n      }\n\n      return performHandshake;\n    }()\n  }, {\n    key: \"performXXFallbackHandshake\",\n    value: function () {\n      var _performXXFallbackHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(params, payload, initialMsg, ephemeralKeys) {\n        var isInitiator, remotePeer, connection, handshake;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n                handshake = new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n                _context4.prev = 2;\n                _context4.next = 5;\n                return handshake.propose();\n\n              case 5:\n                _context4.next = 7;\n                return handshake.exchange();\n\n              case 7:\n                _context4.next = 9;\n                return handshake.finish();\n\n              case 9:\n                _context4.next = 15;\n                break;\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](2);\n                logger(_context4.t0);\n                throw new Error(\"Error occurred during XX Fallback handshake: \".concat(_context4.t0.message));\n\n              case 15:\n                return _context4.abrupt(\"return\", handshake);\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[2, 11]]);\n      }));\n\n      function performXXFallbackHandshake(_x8, _x9, _x10, _x11) {\n        return _performXXFallbackHandshake.apply(this, arguments);\n      }\n\n      return performXXFallbackHandshake;\n    }()\n  }, {\n    key: \"performXXHandshake\",\n    value: function () {\n      var _performXXHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(params, payload) {\n        var isInitiator, remotePeer, connection, handshake;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n                handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n                _context5.prev = 2;\n                _context5.next = 5;\n                return handshake.propose();\n\n              case 5:\n                _context5.next = 7;\n                return handshake.exchange();\n\n              case 7:\n                _context5.next = 9;\n                return handshake.finish();\n\n              case 9:\n                if (this.useNoisePipes && handshake.remotePeer) {\n                  KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n                }\n\n                _context5.next = 15;\n                break;\n\n              case 12:\n                _context5.prev = 12;\n                _context5.t0 = _context5[\"catch\"](2);\n                throw new Error(\"Error occurred during XX handshake: \".concat(_context5.t0.message));\n\n              case 15:\n                return _context5.abrupt(\"return\", handshake);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 12]]);\n      }));\n\n      function performXXHandshake(_x12, _x13) {\n        return _performXXHandshake.apply(this, arguments);\n      }\n\n      return performXXHandshake;\n    }()\n  }, {\n    key: \"performIKHandshake\",\n    value: function () {\n      var _performIKHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(handshake) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return handshake.stage0();\n\n              case 2:\n                _context6.next = 4;\n                return handshake.stage1();\n\n              case 4:\n                return _context6.abrupt(\"return\", handshake);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function performIKHandshake(_x14) {\n        return _performIKHandshake.apply(this, arguments);\n      }\n\n      return performIKHandshake;\n    }()\n  }, {\n    key: \"createSecureConnection\",\n    value: function () {\n      var _createSecureConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(connection, handshake) {\n        var _DuplexPair, _DuplexPair2, secure, user, network;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // Create encryption box/unbox wrapper\n                _DuplexPair = DuplexPair(), _DuplexPair2 = _slicedToArray(_DuplexPair, 2), secure = _DuplexPair2[0], user = _DuplexPair2[1];\n                network = connection.unwrap();\n                pipe(secure, // write to wrapper\n                ensureBuffer, // ensure any type of data is converted to buffer\n                encryptStream(handshake), // data is encrypted\n                encode({\n                  lengthEncoder: uint16BEEncode\n                }), // prefix with message length\n                network, // send to the remote peer\n                decode({\n                  lengthDecoder: uint16BEDecode\n                }), // read message length prefix\n                ensureBuffer, // ensure any type of data is converted to buffer\n                decryptStream(handshake), // decrypt the incoming data\n                secure // pipe to the wrapper\n                );\n                return _context7.abrupt(\"return\", user);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function createSecureConnection(_x15, _x16) {\n        return _createSecureConnection.apply(this, arguments);\n      }\n\n      return createSecureConnection;\n    }()\n  }]);\n\n  return Noise;\n}();","map":{"version":3,"sources":["../src/noise.ts"],"names":["Buffer","constructor","earlyData","publicKey","x25519","privateKey","generateKeypair","wrappedConnection","Wrap","lengthEncoder","lengthDecoder","maxDataLength","NOISE_MSG_MAX_LENGTH_BYTES","handshake","connection","isInitiator","localPeer","remotePeer","conn","remoteEarlyData","payload","getPayload","params","tryIK","KeyCache","ikHandshake","ephemeralKeys","e","logger","DuplexPair","network","pipe","encryptStream","encode","uint16BEEncode","decode","uint16BEDecode","decryptStream"],"mappings":"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","sourcesContent":["import x25519 from 'bcrypto/lib/js/x25519';\nimport {Buffer} from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport {encode, decode} from 'it-length-prefixed';\n\nimport {XXHandshake} from \"./handshake-xx\";\nimport {IKHandshake} from \"./handshake-ik\";\nimport {XXFallbackHandshake} from \"./handshake-xx-fallback\";\nimport {generateKeypair, getPayload} from \"./utils\";\nimport {uint16BEDecode, uint16BEEncode} from \"./encoder\";\nimport {decryptStream, encryptStream} from \"./crypto\";\nimport {bytes} from \"./@types/basic\";\nimport {INoiseConnection, KeyPair, SecureOutbound} from \"./@types/libp2p\";\nimport {Duplex} from \"it-pair\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {KeyCache} from \"./keycache\";\nimport {logger} from \"./logger\";\nimport PeerId from \"peer-id\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES} from \"./constants\";\n\nexport type WrappedConnection = ReturnType<typeof Wrap>;\n\ntype HandshakeParams = {\n  connection: WrappedConnection;\n  isInitiator: boolean;\n  localPeer: PeerId;\n  remotePeer?: PeerId;\n};\n\nexport class Noise implements INoiseConnection {\n  public protocol = \"/noise\";\n\n  private readonly prologue = Buffer.alloc(0);\n  private readonly staticKeys: KeyPair;\n  private readonly earlyData?: bytes;\n  private useNoisePipes: boolean;\n\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  constructor(staticNoiseKey?: bytes, earlyData?: bytes) {\n    this.earlyData = earlyData || Buffer.alloc(0);\n    //disabled until properly specked\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey,\n      }\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureOutbound(localPeer: PeerId, connection: any, remotePeer: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer,\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer,\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureInbound(localPeer: PeerId, connection: any, remotePeer?: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param params\n   */\n  private async performHandshake(params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n    if(params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      //if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    }\n    // Try IK if acting as responder or initiator that has remote's static key.\n    if (tryIK) {\n      // Try IK first\n      const { remotePeer, connection, isInitiator } = params;\n      const ikHandshake = new IKHandshake(\n        isInitiator,\n        payload,\n        this.prologue,\n        this.staticKeys,\n        connection,\n        //safe to cast as we did checks\n        KeyCache.load(params.remotePeer) || Buffer.alloc(32),\n        remotePeer as PeerId,\n      );\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  private async performXXFallbackHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n    initialMsg: bytes,\n    ephemeralKeys?: KeyPair,\n  ): Promise<XXFallbackHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake =\n      new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger(e);\n      throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performXXHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      throw new Error(`Error occurred during XX handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performIKHandshake(\n    handshake: IKHandshake,\n  ): Promise<IKHandshake> {\n\n    await handshake.stage0();\n    await handshake.stage1();\n\n    return handshake;\n  }\n\n  private async createSecureConnection(\n    connection: WrappedConnection,\n    handshake: IHandshake,\n  ): Promise<Duplex> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair();\n    const network = connection.unwrap();\n\n    pipe(\n      secure, // write to wrapper\n      ensureBuffer, // ensure any type of data is converted to buffer\n      encryptStream(handshake), // data is encrypted\n      encode({ lengthEncoder: uint16BEEncode }), // prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode}), // read message length prefix\n      ensureBuffer, // ensure any type of data is converted to buffer\n      decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n    );\n\n    return user;\n  }\n\n\n}\n"]},"metadata":{},"sourceType":"module"}