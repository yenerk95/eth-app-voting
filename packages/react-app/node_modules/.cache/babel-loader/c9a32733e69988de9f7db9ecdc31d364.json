{"ast":null,"code":"'use strict';\n\nconst {\n  map\n} = require('streaming-iterables');\n\nconst errcode = require('err-code');\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\n\n\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor(ipfsRepo) {\n    this._repo = ipfsRepo;\n    this._bitswap = null;\n  }\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n\n\n  setExchange(bitswap) {\n    this._bitswap = bitswap;\n  }\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n\n\n  unsetExchange() {\n    this._bitswap = null;\n  }\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n\n\n  hasExchange() {\n    return this._bitswap != null;\n  }\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  put(block, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block, options);\n    } else {\n      return this._repo.blocks.put(block, options);\n    }\n  }\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {AsyncIterator<Block>} blocks\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  putMany(blocks, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks, options);\n    } else {\n      return this._repo.blocks.putMany(blocks, options);\n    }\n  }\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise<Block>}\n   */\n\n\n  get(cid, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid, options);\n    } else {\n      return this._repo.blocks.get(cid, options);\n    }\n  }\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {AsyncIterator<Block>}\n   */\n\n\n  getMany(cids, options) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids');\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids, options);\n    } else {\n      const getRepoBlocks = map(cid => this._repo.blocks.get(cid, options));\n      return getRepoBlocks(cids);\n    }\n  }\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  async delete(cid, options) {\n    if (!(await this._repo.blocks.has(cid))) {\n      throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n    }\n\n    return this._repo.blocks.delete(cid, options);\n  }\n  /**\n   * Delete multiple blocks from the blockstore.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  deleteMany(cids, options) {\n    const repo = this._repo;\n    return this._repo.blocks.deleteMany(async function* () {\n      for await (const cid of cids) {\n        if (!(await repo.blocks.has(cid))) {\n          throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n        }\n\n        yield cid;\n      }\n    }(), options);\n  }\n\n}\n\nmodule.exports = BlockService;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-block-service/src/index.js"],"names":["map","require","errcode","BlockService","constructor","ipfsRepo","_repo","_bitswap","setExchange","bitswap","unsetExchange","hasExchange","put","block","options","blocks","putMany","get","cid","getMany","cids","Array","isArray","Error","getRepoBlocks","delete","has","deleteMany","repo","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { map } = require('streaming-iterables')\nconst errcode = require('err-code')\n\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor (ipfsRepo) {\n    this._repo = ipfsRepo\n    this._bitswap = null\n  }\n\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n  setExchange (bitswap) {\n    this._bitswap = bitswap\n  }\n\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n  unsetExchange () {\n    this._bitswap = null\n  }\n\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n  hasExchange () {\n    return this._bitswap != null\n  }\n\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  put (block, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block, options)\n    } else {\n      return this._repo.blocks.put(block, options)\n    }\n  }\n\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {AsyncIterator<Block>} blocks\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  putMany (blocks, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks, options)\n    } else {\n      return this._repo.blocks.putMany(blocks, options)\n    }\n  }\n\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise<Block>}\n   */\n  get (cid, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid, options)\n    } else {\n      return this._repo.blocks.get(cid, options)\n    }\n  }\n\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {AsyncIterator<Block>}\n   */\n  getMany (cids, options) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids')\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids, options)\n    } else {\n      const getRepoBlocks = map((cid) => this._repo.blocks.get(cid, options))\n      return getRepoBlocks(cids)\n    }\n  }\n\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  async delete (cid, options) {\n    if (!await this._repo.blocks.has(cid)) {\n      throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND')\n    }\n\n    return this._repo.blocks.delete(cid, options)\n  }\n\n  /**\n   * Delete multiple blocks from the blockstore.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n  deleteMany (cids, options) {\n    const repo = this._repo\n\n    return this._repo.blocks.deleteMany((async function * () {\n      for await (const cid of cids) {\n        if (!await repo.blocks.has(cid)) {\n          throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND')\n        }\n\n        yield cid\n      }\n    }()), options)\n  }\n}\n\nmodule.exports = BlockService\n"]},"metadata":{},"sourceType":"script"}