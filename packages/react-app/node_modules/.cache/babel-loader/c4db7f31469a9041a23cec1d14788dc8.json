{"ast":null,"code":"/* @flow */\n'use strict';\n\nconst Key = require('interface-datastore').Key;\n\nconst readme = require('./shard-readme'); // eslint-disable-next-line\n\n/*:: import type {Datastore, Callback} from 'interface-datastore'\n\nexport interface ShardV1 {\n  name: string;\n  param: number;\n  fun(string): string;\n  toString(): string;\n}\n*/\n\n\nconst PREFIX = exports.PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = exports.SHARDING_FN = 'SHARDING';\nexports.README_FN = '_README';\n\nclass Shard {\n  /* :: name: string */\n\n  /* :: param: number */\n\n  /* :: _padding: string */\n  constructor(param\n  /* : number */\n  ) {\n    this.param = param;\n  }\n\n  fun(str\n  /* : string */\n  )\n  /* : string */\n  {\n    throw new Error('implement me');\n  }\n\n  toString()\n  /* : string */\n  {\n    return `${PREFIX}v1/${this.name}/${this.param}`;\n  }\n\n}\n\nclass Prefix extends Shard {\n  constructor(prefixLen\n  /* : number */\n  ) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n\n  fun(noslash\n  /* : string */\n  )\n  /* : string */\n  {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n\n}\n\nclass Suffix extends Shard {\n  constructor(suffixLen\n  /* : number */\n  ) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n\n  fun(noslash\n  /* : string */\n  )\n  /* : string */\n  {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n\n}\n\nclass NextToLast extends Shard {\n  constructor(suffixLen\n  /* : number */\n  ) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n\n  fun(noslash\n  /* : string */\n  )\n  /* : string */\n  {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n\n}\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {ShardV1}\n */\n\n\nfunction parseShardFun(str\n/* : string */\n) {\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`);\n  }\n\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`);\n  }\n\n  const name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  const param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(`unkown sharding function: ${name}`);\n  }\n}\n\nexports.readShardFun = async (path\n/* : string */\n, store) =>\n/* : Promise<ShardV1> */\n{\n  const key = new Key(path).child(new Key(SHARDING_FN));\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  const res = await get(key);\n  return parseShardFun((res || '').toString().trim());\n};\n\nexports.readme = readme;\nexports.parseShardFun = parseShardFun;\nexports.Prefix = Prefix;\nexports.Suffix = Suffix;\nexports.NextToLast = NextToLast;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-core/src/shard.js"],"names":["Key","require","readme","PREFIX","exports","SHARDING_FN","README_FN","Shard","constructor","param","fun","str","Error","toString","name","Prefix","prefixLen","_padding","padStart","noslash","slice","Suffix","suffixLen","s","length","NextToLast","offset","parseShardFun","trim","startsWith","parts","split","version","parseInt","readShardFun","path","store","key","child","get","getRaw","bind","res"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst Key = require('interface-datastore').Key\n\nconst readme = require('./shard-readme')\n\n// eslint-disable-next-line\n/*:: import type {Datastore, Callback} from 'interface-datastore'\n\nexport interface ShardV1 {\n  name: string;\n  param: number;\n  fun(string): string;\n  toString(): string;\n}\n*/\n\nconst PREFIX = exports.PREFIX = '/repo/flatfs/shard/'\nconst SHARDING_FN = exports.SHARDING_FN = 'SHARDING'\nexports.README_FN = '_README'\n\nclass Shard {\n  /* :: name: string */\n  /* :: param: number */\n  /* :: _padding: string */\n\n  constructor (param /* : number */) {\n    this.param = param\n  }\n\n  fun (str /* : string */) /* : string */ {\n    throw new Error('implement me')\n  }\n\n  toString () /* : string */ {\n    return `${PREFIX}v1/${this.name}/${this.param}`\n  }\n}\n\nclass Prefix extends Shard {\n  constructor (prefixLen /* : number */) {\n    super(prefixLen)\n    this._padding = ''.padStart(prefixLen, '_')\n    this.name = 'prefix'\n  }\n\n  fun (noslash /* : string */) /* : string */ {\n    return (noslash + this._padding).slice(0, this.param)\n  }\n}\n\nclass Suffix extends Shard {\n  constructor (suffixLen /* : number */) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen, '_')\n    this.name = 'suffix'\n  }\n\n  fun (noslash /* : string */) /* : string */ {\n    const s = this._padding + noslash\n    return s.slice(s.length - this.param)\n  }\n}\n\nclass NextToLast extends Shard {\n  constructor (suffixLen /* : number */) {\n    super(suffixLen)\n    this._padding = ''.padStart(suffixLen + 1, '_')\n    this.name = 'next-to-last'\n  }\n\n  fun (noslash /* : string */) /* : string */ {\n    const s = this._padding + noslash\n    const offset = s.length - this.param - 1\n    return s.slice(offset, offset + this.param)\n  }\n}\n\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {ShardV1}\n */\nfunction parseShardFun (str /* : string */) {\n  str = str.trim()\n\n  if (str.length === 0) {\n    throw new Error('empty shard string')\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`)\n  }\n\n  const parts = str.slice(PREFIX.length).split('/')\n  const version = parts[0]\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`)\n  }\n\n  const name = parts[1]\n\n  if (!parts[2]) {\n    throw new Error('missing param')\n  }\n\n  const param = parseInt(parts[2], 10)\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param)\n    case 'suffix':\n      return new Suffix(param)\n    case 'next-to-last':\n      return new NextToLast(param)\n    default:\n      throw new Error(`unkown sharding function: ${name}`)\n  }\n}\n\nexports.readShardFun = async (path /* : string */, store) /* : Promise<ShardV1> */ => {\n  const key = new Key(path).child(new Key(SHARDING_FN))\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store)\n  const res = await get(key)\n  return parseShardFun((res || '').toString().trim())\n}\n\nexports.readme = readme\nexports.parseShardFun = parseShardFun\nexports.Prefix = Prefix\nexports.Suffix = Suffix\nexports.NextToLast = NextToLast\n"]},"metadata":{},"sourceType":"script"}