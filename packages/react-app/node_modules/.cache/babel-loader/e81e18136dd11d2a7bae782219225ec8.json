{"ast":null,"code":"/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('./internal/assert');\n/**\n * HKDF\n */\n\n\nvar HKDF = /*#__PURE__*/function () {\n  function HKDF(hash, ikm, salt, info) {\n    _classCallCheck(this, HKDF);\n\n    assert(hash && typeof hash.id === 'string');\n    this.hash = hash;\n    this.size = hash.size;\n    this.prk = null;\n    this.state = null;\n    this.slab = null;\n    this.save = 0;\n    if (ikm || salt || info) this.init(ikm, salt, info);\n  }\n\n  _createClass(HKDF, [{\n    key: \"init\",\n    value: function init(ikm, salt, info) {\n      if (ikm == null) ikm = Buffer.alloc(0);\n      if (salt == null) salt = Buffer.alloc(this.size, 0x00);\n      this.prk = this.hash.mac(ikm, salt);\n      this.reset(info);\n      return this;\n    }\n  }, {\n    key: \"set\",\n    value: function set(prk, info) {\n      assert(Buffer.isBuffer(prk));\n      assert(prk.length === this.size);\n      this.prk = prk;\n      this.reset(info);\n      return this;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(info) {\n      if (info == null) info = Buffer.alloc(0);\n      assert(Buffer.isBuffer(info)); // state = prev || info || counter\n\n      var state = Buffer.alloc(this.size + info.length + 1);\n      state.fill(0x00, 0, this.size);\n      info.copy(state, this.size);\n      state[state.length - 1] = 0;\n      this.state = state;\n      this.slab = Buffer.alloc(this.size);\n      this.save = 0;\n      return this;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(len) {\n      assert(len >>> 0 === len);\n      if (!this.prk || !this.state || !this.slab) throw new Error('HKDF is not initialized.');\n      var left = (255 - this.state[this.state.length - 1]) * this.size;\n      if (len > this.save + left) throw new Error('Too many bytes requested.');\n      var blocks = Math.ceil(Math.max(0, len - this.save) / this.size);\n      var okm = Buffer.alloc(this.save + blocks * this.size);\n      this.slab.copy(okm, 0, 0, this.save);\n\n      for (var i = 0; i < blocks; i++) {\n        var state = this.state;\n        if (state[state.length - 1] === 0) state = state.slice(this.size);\n        assert(state[state.length - 1] !== 255);\n        state[state.length - 1] += 1;\n        var mac = this.hash.mac(state, this.prk);\n        mac.copy(this.state, 0);\n        mac.copy(okm, this.save + i * this.size);\n      }\n\n      this.save = okm.copy(this.slab, 0, len);\n      return okm.slice(0, len);\n    }\n  }, {\n    key: \"randomBytes\",\n    value: function randomBytes(size) {\n      return this.generate(size);\n    }\n  }], [{\n    key: \"extract\",\n    value: function extract(hash, ikm, salt) {\n      assert(hash && typeof hash.id === 'string');\n      if (ikm == null) ikm = Buffer.alloc(0);\n      if (salt == null) salt = Buffer.alloc(hash.size, 0x00);\n      return hash.mac(ikm, salt);\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(hash, prk, info, len) {\n      var hkdf = new HKDF(hash);\n      return hkdf.set(prk, info).generate(len);\n    }\n  }, {\n    key: \"derive\",\n    value: function derive(hash, ikm, salt, info, len) {\n      var hkdf = new HKDF(hash);\n      return hkdf.init(ikm, salt, info).generate(len);\n    }\n  }]);\n\n  return HKDF;\n}();\n/*\n * Static\n */\n\n\nHKDF.native = 0;\n/*\n * Expose\n */\n\nmodule.exports = HKDF;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/bcrypto/lib/hkdf.js"],"names":["assert","require","HKDF","hash","ikm","salt","info","id","size","prk","state","slab","save","init","Buffer","alloc","mac","reset","isBuffer","length","fill","copy","len","Error","left","blocks","Math","ceil","max","okm","i","slice","generate","hkdf","set","native","module","exports"],"mappings":"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","sourcesContent":["/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n\n'use strict';\n\nconst assert = require('./internal/assert');\n\n/**\n * HKDF\n */\n\nclass HKDF {\n  constructor(hash, ikm, salt, info) {\n    assert(hash && typeof hash.id === 'string');\n\n    this.hash = hash;\n    this.size = hash.size;\n    this.prk = null;\n    this.state = null;\n    this.slab = null;\n    this.save = 0;\n\n    if (ikm || salt || info)\n      this.init(ikm, salt, info);\n  }\n\n  init(ikm, salt, info) {\n    if (ikm == null)\n      ikm = Buffer.alloc(0);\n\n    if (salt == null)\n      salt = Buffer.alloc(this.size, 0x00);\n\n    this.prk = this.hash.mac(ikm, salt);\n    this.reset(info);\n\n    return this;\n  }\n\n  set(prk, info) {\n    assert(Buffer.isBuffer(prk));\n    assert(prk.length === this.size);\n\n    this.prk = prk;\n    this.reset(info);\n\n    return this;\n  }\n\n  reset(info) {\n    if (info == null)\n      info = Buffer.alloc(0);\n\n    assert(Buffer.isBuffer(info));\n\n    // state = prev || info || counter\n    const state = Buffer.alloc(this.size + info.length + 1);\n\n    state.fill(0x00, 0, this.size);\n\n    info.copy(state, this.size);\n\n    state[state.length - 1] = 0;\n\n    this.state = state;\n    this.slab = Buffer.alloc(this.size);\n    this.save = 0;\n\n    return this;\n  }\n\n  generate(len) {\n    assert((len >>> 0) === len);\n\n    if (!this.prk || !this.state || !this.slab)\n      throw new Error('HKDF is not initialized.');\n\n    const left = (255 - this.state[this.state.length - 1]) * this.size;\n\n    if (len > this.save + left)\n      throw new Error('Too many bytes requested.');\n\n    const blocks = Math.ceil(Math.max(0, len - this.save) / this.size);\n    const okm = Buffer.alloc(this.save + blocks * this.size);\n\n    this.slab.copy(okm, 0, 0, this.save);\n\n    for (let i = 0; i < blocks; i++) {\n      let state = this.state;\n\n      if (state[state.length - 1] === 0)\n        state = state.slice(this.size);\n\n      assert(state[state.length - 1] !== 255);\n\n      state[state.length - 1] += 1;\n\n      const mac = this.hash.mac(state, this.prk);\n\n      mac.copy(this.state, 0);\n      mac.copy(okm, this.save + i * this.size);\n    }\n\n    this.save = okm.copy(this.slab, 0, len);\n\n    return okm.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n\n  static extract(hash, ikm, salt) {\n    assert(hash && typeof hash.id === 'string');\n\n    if (ikm == null)\n      ikm = Buffer.alloc(0);\n\n    if (salt == null)\n      salt = Buffer.alloc(hash.size, 0x00);\n\n    return hash.mac(ikm, salt);\n  }\n\n  static expand(hash, prk, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.set(prk, info)\n               .generate(len);\n  }\n\n  static derive(hash, ikm, salt, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.init(ikm, salt, info)\n               .generate(len);\n  }\n}\n\n/*\n * Static\n */\n\nHKDF.native = 0;\n\n/*\n * Expose\n */\n\nmodule.exports = HKDF;\n"]},"metadata":{},"sourceType":"script"}