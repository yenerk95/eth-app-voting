{"ast":null,"code":"'use strict';\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar batch = require('it-batch');\n\nmodule.exports = /*#__PURE__*/_regeneratorRuntime.mark(function trickleReduceToRoot(source, reduce, options) {\n  return _regeneratorRuntime.wrap(function trickleReduceToRoot$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return trickleStream(source, reduce, options);\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, trickleReduceToRoot);\n});\n\nfunction trickleStream(_x, _x2, _x3) {\n  return _trickleStream.apply(this, arguments);\n}\n\nfunction _trickleStream() {\n  _trickleStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source, reduce, options) {\n    var root, iteration, maxDepth, subTree, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, layer;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            iteration = 0;\n            maxDepth = 1;\n            subTree = root = new Root(options.layerRepeat);\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context3.prev = 5;\n            _iterator = _asyncIterator(batch(source, options.maxChildrenPerNode));\n\n          case 7:\n            _context3.next = 9;\n            return _iterator.next();\n\n          case 9:\n            _step = _context3.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context3.next = 13;\n            return _step.value;\n\n          case 13:\n            _value = _context3.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context3.next = 30;\n              break;\n            }\n\n            layer = _value;\n\n            if (!subTree.isFull()) {\n              _context3.next = 26;\n              break;\n            }\n\n            if (!(subTree !== root)) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.t0 = root;\n            _context3.next = 21;\n            return subTree.reduce(reduce);\n\n          case 21:\n            _context3.t1 = _context3.sent;\n\n            _context3.t0.addChild.call(_context3.t0, _context3.t1);\n\n          case 23:\n            if (iteration && iteration % options.layerRepeat === 0) {\n              maxDepth++;\n            }\n\n            subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n            iteration++;\n\n          case 26:\n            subTree.append(layer);\n\n          case 27:\n            _iteratorNormalCompletion = true;\n            _context3.next = 7;\n            break;\n\n          case 30:\n            _context3.next = 36;\n            break;\n\n          case 32:\n            _context3.prev = 32;\n            _context3.t2 = _context3[\"catch\"](5);\n            _didIteratorError = true;\n            _iteratorError = _context3.t2;\n\n          case 36:\n            _context3.prev = 36;\n            _context3.prev = 37;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context3.next = 41;\n              break;\n            }\n\n            _context3.next = 41;\n            return _iterator.return();\n\n          case 41:\n            _context3.prev = 41;\n\n            if (!_didIteratorError) {\n              _context3.next = 44;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 44:\n            return _context3.finish(41);\n\n          case 45:\n            return _context3.finish(36);\n\n          case 46:\n            if (!(subTree && subTree !== root)) {\n              _context3.next = 52;\n              break;\n            }\n\n            _context3.t3 = root;\n            _context3.next = 50;\n            return subTree.reduce(reduce);\n\n          case 50:\n            _context3.t4 = _context3.sent;\n\n            _context3.t3.addChild.call(_context3.t3, _context3.t4);\n\n          case 52:\n            return _context3.abrupt(\"return\", root.reduce(reduce));\n\n          case 53:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2, null, [[5, 32, 36, 46], [37,, 41, 45]]);\n  }));\n  return _trickleStream.apply(this, arguments);\n}\n\nvar SubTree = /*#__PURE__*/function () {\n  function SubTree(maxDepth, layerRepeat, iteration) {\n    _classCallCheck(this, SubTree);\n\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth: maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n\n  _createClass(SubTree, [{\n    key: \"isFull\",\n    value: function isFull() {\n      if (!this.root.data) {\n        return false;\n      }\n\n      if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n        // can descend\n        this._addNextNodeToParent(this.node);\n\n        return false;\n      } // try to find new node from node.parent\n\n\n      var distantRelative = this._findParent(this.node, this.currentDepth);\n\n      if (distantRelative) {\n        this._addNextNodeToParent(distantRelative);\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_addNextNodeToParent\",\n    value: function _addNextNodeToParent(parent) {\n      this.parent = parent; // find site for new node\n\n      var nextNode = {\n        children: [],\n        depth: parent.depth + 1,\n        parent: parent,\n        maxDepth: this.maxDepth,\n        maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n      };\n      parent.children.push(nextNode);\n      this.currentDepth = nextNode.depth;\n      this.node = nextNode;\n    }\n  }, {\n    key: \"append\",\n    value: function append(layer) {\n      this.node.data = layer;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(_reduce) {\n      return this._reduce(this.root, _reduce);\n    }\n  }, {\n    key: \"_reduce\",\n    value: function () {\n      var _reduce2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node, reduce) {\n        var _this = this;\n\n        var children;\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                children = [];\n\n                if (!node.children.length) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return Promise.all(node.children.filter(function (child) {\n                  return child.data;\n                }).map(function (child) {\n                  return _this._reduce(child, reduce);\n                }));\n\n              case 4:\n                children = _context2.sent;\n\n              case 5:\n                return _context2.abrupt(\"return\", reduce(node.data.concat(children)));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _reduce(_x4, _x5) {\n        return _reduce2.apply(this, arguments);\n      }\n\n      return _reduce;\n    }()\n  }, {\n    key: \"_findParent\",\n    value: function _findParent(node, depth) {\n      var parent = node.parent;\n\n      if (!parent || parent.depth === 0) {\n        return;\n      }\n\n      if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n        // this layer is full, may be able to traverse to a different branch\n        return this._findParent(parent, depth);\n      }\n\n      return parent;\n    }\n  }]);\n\n  return SubTree;\n}();\n\nvar Root = /*#__PURE__*/function (_SubTree) {\n  _inherits(Root, _SubTree);\n\n  var _super = _createSuper(Root);\n\n  function Root(layerRepeat) {\n    var _this2;\n\n    _classCallCheck(this, Root);\n\n    _this2 = _super.call(this, 0, layerRepeat);\n    _this2.root.depth = 0;\n    _this2.currentDepth = 1;\n    return _this2;\n  }\n\n  _createClass(Root, [{\n    key: \"addChild\",\n    value: function addChild(child) {\n      this.root.children.push(child);\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(_reduce3) {\n      return _reduce3(this.root.data.concat(this.root.children));\n    }\n  }]);\n\n  return Root;\n}(SubTree);","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js"],"names":["batch","require","module","exports","trickleReduceToRoot","source","reduce","options","trickleStream","iteration","maxDepth","subTree","root","Root","layerRepeat","maxChildrenPerNode","layer","isFull","addChild","SubTree","append","currentDepth","node","parent","children","depth","maxChildren","data","_addNextNodeToParent","distantRelative","_findParent","nextNode","Math","floor","length","push","_reduce","Promise","all","filter","child","map","concat"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;;AAEAC,MAAM,CAACC,OAAP,yCAAiB,SAAWC,mBAAX,CAAgCC,MAAhC,EAAwCC,MAAxC,EAAgDC,OAAhD;AAAA;AAAA;AAAA;AAAA;AAAA;AACf,iBAAMC,aAAa,CAACH,MAAD,EAASC,MAAT,EAAiBC,OAAjB,CAAnB;;AADe;AAAA;AAAA;AAAA;AAAA;AAAA,KAAWH,mBAAX;AAAA,CAAjB;;SAIeI,a;;;;;4EAAf,kBAA8BH,MAA9B,EAAsCC,MAAtC,EAA8CC,OAA9C;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEME,YAAAA,SAFN,GAEkB,CAFlB;AAGMC,YAAAA,QAHN,GAGiB,CAHjB;AAIMC,YAAAA,OAJN,GAIgBC,IAAI,GAAG,IAAIC,IAAJ,CAASN,OAAO,CAACO,WAAjB,CAJvB;AAAA;AAAA;AAAA;AAAA,uCAM4Bd,KAAK,CAACK,MAAD,EAASE,OAAO,CAACQ,kBAAjB,CANjC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAMmBC,YAAAA,KANnB;;AAAA,iBAOQL,OAAO,CAACM,MAAR,EAPR;AAAA;AAAA;AAAA;;AAAA,kBAQUN,OAAO,KAAKC,IARtB;AAAA;AAAA;AAAA;;AAAA,2BASQA,IATR;AAAA;AAAA,mBAS4BD,OAAO,CAACL,MAAR,CAAeA,MAAf,CAT5B;;AAAA;AAAA;;AAAA,yBASaY,QATb;;AAAA;AAYM,gBAAIT,SAAS,IAAIA,SAAS,GAAGF,OAAO,CAACO,WAApB,KAAoC,CAArD,EAAwD;AACtDJ,cAAAA,QAAQ;AACT;;AAEDC,YAAAA,OAAO,GAAG,IAAIQ,OAAJ,CAAYT,QAAZ,EAAsBH,OAAO,CAACO,WAA9B,EAA2CL,SAA3C,CAAV;AAEAA,YAAAA,SAAS;;AAlBf;AAqBIE,YAAAA,OAAO,CAACS,MAAR,CAAeJ,KAAf;;AArBJ;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,kBAwBML,OAAO,IAAIA,OAAO,KAAKC,IAxB7B;AAAA;AAAA;AAAA;;AAAA,2BAyBIA,IAzBJ;AAAA;AAAA,mBAyBwBD,OAAO,CAACL,MAAR,CAAeA,MAAf,CAzBxB;;AAAA;AAAA;;AAAA,yBAyBSY,QAzBT;;AAAA;AAAA,8CA4BSN,IAAI,CAACN,MAAL,CAAYA,MAAZ,CA5BT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;IA+BMa,O;AACJ,mBAAaT,QAAb,EAAuBI,WAAvB,EAAoCL,SAApC,EAA+C;AAAA;;AAC7C,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKI,WAAL,GAAmBA,WAAnB;AACA,SAAKO,YAAL,GAAoB,CAApB;AACA,SAAKZ,SAAL,GAAiBA,SAAjB;AAEA,SAAKG,IAAL,GAAY,KAAKU,IAAL,GAAY,KAAKC,MAAL,GAAc;AACpCC,MAAAA,QAAQ,EAAE,EAD0B;AAEpCC,MAAAA,KAAK,EAAE,KAAKJ,YAFwB;AAGpCX,MAAAA,QAAQ,EAARA,QAHoC;AAIpCgB,MAAAA,WAAW,EAAE,CAAC,KAAKhB,QAAL,GAAgB,KAAKW,YAAtB,IAAsC,KAAKP;AAJpB,KAAtC;AAMD;;;;6BAES;AACR,UAAI,CAAC,KAAKF,IAAL,CAAUe,IAAf,EAAqB;AACnB,eAAO,KAAP;AACD;;AAED,UAAI,KAAKN,YAAL,GAAoB,KAAKX,QAAzB,IAAqC,KAAKY,IAAL,CAAUI,WAAnD,EAAgE;AAC9D;AACA,aAAKE,oBAAL,CAA0B,KAAKN,IAA/B;;AAEA,eAAO,KAAP;AACD,OAVO,CAYR;;;AACA,UAAMO,eAAe,GAAG,KAAKC,WAAL,CAAiB,KAAKR,IAAtB,EAA4B,KAAKD,YAAjC,CAAxB;;AAEA,UAAIQ,eAAJ,EAAqB;AACnB,aAAKD,oBAAL,CAA0BC,eAA1B;;AAEA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD;;;yCAEqBN,M,EAAQ;AAC5B,WAAKA,MAAL,GAAcA,MAAd,CAD4B,CAG5B;;AACA,UAAMQ,QAAQ,GAAG;AACfP,QAAAA,QAAQ,EAAE,EADK;AAEfC,QAAAA,KAAK,EAAEF,MAAM,CAACE,KAAP,GAAe,CAFP;AAGfF,QAAAA,MAAM,EAANA,MAHe;AAIfb,QAAAA,QAAQ,EAAE,KAAKA,QAJA;AAKfgB,QAAAA,WAAW,EAAEM,IAAI,CAACC,KAAL,CAAWV,MAAM,CAACC,QAAP,CAAgBU,MAAhB,GAAyB,KAAKpB,WAAzC,IAAwD,KAAKA;AAL3D,OAAjB;AAQAS,MAAAA,MAAM,CAACC,QAAP,CAAgBW,IAAhB,CAAqBJ,QAArB;AAEA,WAAKV,YAAL,GAAoBU,QAAQ,CAACN,KAA7B;AACA,WAAKH,IAAL,GAAYS,QAAZ;AACD;;;2BAEOf,K,EAAO;AACb,WAAKM,IAAL,CAAUK,IAAV,GAAiBX,KAAjB;AACD;;;2BAEOV,O,EAAQ;AACd,aAAO,KAAK8B,OAAL,CAAa,KAAKxB,IAAlB,EAAwBN,OAAxB,CAAP;AACD;;;;+FAEcgB,I,EAAMhB,M;;;;;;;;AACfkB,gBAAAA,Q,GAAW,E;;qBAEXF,IAAI,CAACE,QAAL,CAAcU,M;;;;;;uBACCG,OAAO,CAACC,GAAR,CACfhB,IAAI,CAACE,QAAL,CACGe,MADH,CACU,UAAAC,KAAK;AAAA,yBAAIA,KAAK,CAACb,IAAV;AAAA,iBADf,EAEGc,GAFH,CAEO,UAAAD,KAAK;AAAA,yBAAI,KAAI,CAACJ,OAAL,CAAaI,KAAb,EAAoBlC,MAApB,CAAJ;AAAA,iBAFZ,CADe,C;;;AAAjBkB,gBAAAA,Q;;;kDAOKlB,MAAM,CAACgB,IAAI,CAACK,IAAL,CAAUe,MAAV,CAAiBlB,QAAjB,CAAD,C;;;;;;;;;;;;;;;;;;gCAGFF,I,EAAMG,K,EAAO;AACxB,UAAMF,MAAM,GAAGD,IAAI,CAACC,MAApB;;AAEA,UAAI,CAACA,MAAD,IAAWA,MAAM,CAACE,KAAP,KAAiB,CAAhC,EAAmC;AACjC;AACD;;AAED,UAAIF,MAAM,CAACC,QAAP,CAAgBU,MAAhB,KAA2BX,MAAM,CAACG,WAAlC,IAAiD,CAACH,MAAM,CAACG,WAA7D,EAA0E;AACxE;AACA,eAAO,KAAKI,WAAL,CAAiBP,MAAjB,EAAyBE,KAAzB,CAAP;AACD;;AAED,aAAOF,MAAP;AACD;;;;;;IAGGV,I;;;;;AACJ,gBAAaC,WAAb,EAA0B;AAAA;;AAAA;;AACxB,+BAAM,CAAN,EAASA,WAAT;AAEA,WAAKF,IAAL,CAAUa,KAAV,GAAkB,CAAlB;AACA,WAAKJ,YAAL,GAAoB,CAApB;AAJwB;AAKzB;;;;6BAESmB,K,EAAO;AACf,WAAK5B,IAAL,CAAUY,QAAV,CAAmBW,IAAnB,CAAwBK,KAAxB;AACD;;;2BAEOlC,Q,EAAQ;AACd,aAAOA,QAAM,CAAC,KAAKM,IAAL,CAAUe,IAAV,CAAee,MAAf,CAAsB,KAAK9B,IAAL,CAAUY,QAAhC,CAAD,CAAb;AACD;;;;EAdgBL,O","sourcesContent":["'use strict'\n\nconst batch = require('it-batch')\n\nmodule.exports = function * trickleReduceToRoot (source, reduce, options) {\n  yield trickleStream(source, reduce, options)\n}\n\nasync function trickleStream (source, reduce, options) {\n  let root\n  let iteration = 0\n  let maxDepth = 1\n  let subTree = root = new Root(options.layerRepeat)\n\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce))\n      }\n\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++\n      }\n\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration)\n\n      iteration++\n    }\n\n    subTree.append(layer)\n  }\n\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce))\n  }\n\n  return root.reduce(reduce)\n}\n\nclass SubTree {\n  constructor (maxDepth, layerRepeat, iteration) {\n    this.maxDepth = maxDepth\n    this.layerRepeat = layerRepeat\n    this.currentDepth = 1\n    this.iteration = iteration\n\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    }\n  }\n\n  isFull () {\n    if (!this.root.data) {\n      return false\n    }\n\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      // can descend\n      this._addNextNodeToParent(this.node)\n\n      return false\n    }\n\n    // try to find new node from node.parent\n    const distantRelative = this._findParent(this.node, this.currentDepth)\n\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative)\n\n      return false\n    }\n\n    return true\n  }\n\n  _addNextNodeToParent (parent) {\n    this.parent = parent\n\n    // find site for new node\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    }\n\n    parent.children.push(nextNode)\n\n    this.currentDepth = nextNode.depth\n    this.node = nextNode\n  }\n\n  append (layer) {\n    this.node.data = layer\n  }\n\n  reduce (reduce) {\n    return this._reduce(this.root, reduce)\n  }\n\n  async _reduce (node, reduce) {\n    let children = []\n\n    if (node.children.length) {\n      children = await Promise.all(\n        node.children\n          .filter(child => child.data)\n          .map(child => this._reduce(child, reduce))\n      )\n    }\n\n    return reduce(node.data.concat(children))\n  }\n\n  _findParent (node, depth) {\n    const parent = node.parent\n\n    if (!parent || parent.depth === 0) {\n      return\n    }\n\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      // this layer is full, may be able to traverse to a different branch\n      return this._findParent(parent, depth)\n    }\n\n    return parent\n  }\n}\n\nclass Root extends SubTree {\n  constructor (layerRepeat) {\n    super(0, layerRepeat)\n\n    this.root.depth = 0\n    this.currentDepth = 1\n  }\n\n  addChild (child) {\n    this.root.children.push(child)\n  }\n\n  reduce (reduce) {\n    return reduce(this.root.data.concat(this.root.children))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}