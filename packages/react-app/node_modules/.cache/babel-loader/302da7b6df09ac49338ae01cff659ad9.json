{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nvar errcode = require('err-code');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar PeerId = require('peer-id');\n\nvar pipe = require('it-pipe');\n\nvar lp = require('it-length-prefixed');\n\nvar pMap = require('p-map');\n\nvar Pubsub = require('libp2p-pubsub');\n\nvar _require2 = require('libp2p-pubsub'),\n    utils = _require2.utils;\n\nvar _require3 = require('./message'),\n    RPCCodec = _require3.RPCCodec;\n\nvar BasicPubSub = /*#__PURE__*/function (_Pubsub) {\n  _inherits(BasicPubSub, _Pubsub);\n\n  var _super2 = _createSuper(BasicPubSub);\n\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {string[]} props.multicodecs protocol identifiers to connect\n   * @param {PeerId} props.peerId peer's peerId\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {Object} [props.options]\n   * @param {boolean} [props.options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @constructor\n   */\n  function BasicPubSub(_ref) {\n    var _this;\n\n    var debugName = _ref.debugName,\n        multicodecs = _ref.multicodecs,\n        peerId = _ref.peerId,\n        registrar = _ref.registrar,\n        _ref$options = _ref.options,\n        options = _ref$options === void 0 ? {} : _ref$options;\n\n    _classCallCheck(this, BasicPubSub);\n\n    if (!PeerId.isPeerId(peerId)) {\n      throw new Error('peerId must be an instance of `peer-id`');\n    }\n\n    var _options = Object.assign({\n      emitSelf: false\n    }, options);\n\n    _this = _super2.call(this, Object.assign({\n      debugName: debugName,\n      multicodecs: multicodecs,\n      peerId: peerId,\n      registrar: registrar\n    }, _options));\n    /**\n     * A set of subscriptions\n     */\n\n    _this.subscriptions = new Set();\n    /**\n     * Pubsub options\n     */\n\n    _this._options = _options;\n    /**\n     * The default msgID implementation\n     * @param {RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n    _this.defaultMsgIdFn = function (msg) {\n      return utils.msgId(msg.from, msg.seqno);\n    };\n    /**\n     * Topic validator function\n     * @typedef {function(string, Peer, RPC): boolean} validator\n     */\n\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     * @type {Map<string, validator>}\n     */\n\n\n    _this.topicValidators = new Map();\n    return _this;\n  }\n  /**\n   * Peer connected successfully with pubsub protocol.\n   * @override\n   * @param {PeerId} peerId peer id\n   * @param {Connection} conn connection to the peer\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(BasicPubSub, [{\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId, conn) {\n      var _this2 = this;\n\n      var _super = Object.create(null, {\n        _onPeerConnected: {\n          get: function get() {\n            return _get(_getPrototypeOf(BasicPubSub.prototype), \"_onPeerConnected\", _this2);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var idB58Str, peer;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _super._onPeerConnected.call(this, peerId, conn);\n\n              case 2:\n                idB58Str = peerId.toB58String();\n                peer = this.peers.get(idB58Str);\n\n                if (peer && peer.isWritable) {\n                  // Immediately send my own subscriptions to the newly established conn\n                  peer.sendSubscriptions(this.subscriptions);\n                }\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @override\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {Peer} peer PubSub peer\n     * @returns {void}\n     *\n     */\n\n  }, {\n    key: \"_processMessages\",\n    value: function _processMessages(idB58Str, conn, peer) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return pipe(conn, lp.decode(), function (source) {\n                  var source_1, source_1_1;\n                  return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                    var e_1, _a, data, rpcMsgBuf, rpcMsg;\n\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _context2.prev = 0;\n                            source_1 = __asyncValues(source);\n\n                          case 2:\n                            _context2.next = 4;\n                            return source_1.next();\n\n                          case 4:\n                            source_1_1 = _context2.sent;\n\n                            if (source_1_1.done) {\n                              _context2.next = 12;\n                              break;\n                            }\n\n                            data = source_1_1.value;\n                            rpcMsgBuf = Buffer.isBuffer(data) ? data : data.slice();\n                            rpcMsg = this._decodeRpc(rpcMsgBuf);\n\n                            this._processRpc(idB58Str, peer, rpcMsg);\n\n                          case 10:\n                            _context2.next = 2;\n                            break;\n\n                          case 12:\n                            _context2.next = 17;\n                            break;\n\n                          case 14:\n                            _context2.prev = 14;\n                            _context2.t0 = _context2[\"catch\"](0);\n                            e_1 = {\n                              error: _context2.t0\n                            };\n\n                          case 17:\n                            _context2.prev = 17;\n                            _context2.prev = 18;\n\n                            if (!(source_1_1 && !source_1_1.done && (_a = source_1.return))) {\n                              _context2.next = 22;\n                              break;\n                            }\n\n                            _context2.next = 22;\n                            return _a.call(source_1);\n\n                          case 22:\n                            _context2.prev = 22;\n\n                            if (!e_1) {\n                              _context2.next = 25;\n                              break;\n                            }\n\n                            throw e_1.error;\n\n                          case 25:\n                            return _context2.finish(22);\n\n                          case 26:\n                            return _context2.finish(17);\n\n                          case 27:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, this, [[0, 14, 17, 27], [18,, 22, 26]]);\n                  }));\n                });\n\n              case 3:\n                _context3.next = 8;\n                break;\n\n              case 5:\n                _context3.prev = 5;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                this._onPeerDisconnected(peer.id, _context3.t0);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 5]]);\n      }));\n    }\n    /**\n     * Decode a buffer into an RPC object\n     *\n     * Override to use an extended protocol-specific protobuf decoder\n     *\n     * @param {Buffer} buf\n     * @returns {RPC}\n     */\n\n  }, {\n    key: \"_decodeRpc\",\n    value: function _decodeRpc(buf) {\n      return RPCCodec.decode(buf);\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @param {String} idB58Str\n     * @param {Peer} peer\n     * @param {RPC} rpc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_processRpc\",\n    value: function _processRpc(idB58Str, peer, rpc) {\n      var _this4 = this;\n\n      this.log('rpc from', idB58Str);\n      var subs = rpc.subscriptions;\n      var msgs = rpc.msgs;\n\n      if (subs.length) {\n        // update peer subscriptions\n        peer.updateSubscriptions(subs);\n        subs.forEach(function (subOpt) {\n          return _this4._processRpcSubOpt(peer, subOpt);\n        });\n        this.emit('pubsub:subscription-change', peer.id, peer.topics, subs);\n      }\n\n      if (msgs.length) {\n        msgs.forEach(function (message) {\n          return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n            var msg, isValid;\n            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    msg = utils.normalizeInRpcMessage(message); // Ensure the message is valid before processing it\n\n                    _context4.prev = 1;\n                    _context4.next = 4;\n                    return this.validate(message, peer);\n\n                  case 4:\n                    isValid = _context4.sent;\n\n                    if (isValid) {\n                      _context4.next = 8;\n                      break;\n                    }\n\n                    this.log('Message is invalid, dropping it.');\n                    return _context4.abrupt(\"return\");\n\n                  case 8:\n                    _context4.next = 14;\n                    break;\n\n                  case 10:\n                    _context4.prev = 10;\n                    _context4.t0 = _context4[\"catch\"](1);\n                    this.log('Error in message validation, dropping it. %O', _context4.t0);\n                    return _context4.abrupt(\"return\");\n\n                  case 14:\n                    this._processRpcMessage(peer, msg);\n\n                  case 15:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, this, [[1, 10]]);\n          }));\n        });\n      }\n    }\n    /**\n     * Validates the given message.\n     * @param {RPC.Message} message\n     * @param {Peer} [peer]\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(message, peer) {\n      var _this5 = this;\n\n      var _super = Object.create(null, {\n        validate: {\n          get: function get() {\n            return _get(_getPrototypeOf(BasicPubSub.prototype), \"validate\", _this5);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this6 = this;\n\n        var isValid;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _super.validate.call(this, message, peer);\n\n              case 2:\n                isValid = _context5.sent;\n\n                if (isValid) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 5:\n                if (peer) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", true);\n\n              case 7:\n                return _context5.abrupt(\"return\", message.topicIDs.every(function (topic) {\n                  var validatorFn = _this6.topicValidators.get(topic);\n\n                  if (!validatorFn) {\n                    return true;\n                  }\n\n                  return _this6._processTopicValidatorResult(topic, peer, message, validatorFn(topic, peer, message));\n                }));\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Coerces topic validator result to determine message validity\n     *\n     * Defaults to true if truthy\n     *\n     * Override this method to provide custom topic validator result processing (eg: scoring)\n     *\n     * @param {String} topic\n     * @param {Peer} peer\n     * @param {RPC.Message} message\n     * @param {unknown} result\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_processTopicValidatorResult\",\n    value: function _processTopicValidatorResult(topic, peer, message, result) {\n      return Boolean(result);\n    }\n    /**\n     * Handles an subscription change from a peer\n     *\n     * @param {Peer} peer\n     * @param {RPC.SubOpt} subOpt\n     */\n\n  }, {\n    key: \"_processRpcSubOpt\",\n    value: function _processRpcSubOpt(peer, subOpt) {\n      var t = subOpt.topicID;\n      var topicSet = this.topics.get(t);\n\n      if (!topicSet) {\n        topicSet = new Set();\n        this.topics.set(t, topicSet);\n      }\n\n      if (subOpt.subscribe) {\n        // subscribe peer to new topic\n        topicSet.add(peer);\n      } else {\n        // unsubscribe from existing topic\n        topicSet.delete(peer);\n      }\n    }\n    /**\n     * Handles an message from a peer\n     *\n     * @param {Peer} peer\n     * @param {RPC.Message} msg\n     */\n\n  }, {\n    key: \"_processRpcMessage\",\n    value: function _processRpcMessage(peer, msg) {\n      if (this.peerId.toB58String() === msg.from && !this._options.emitSelf) {\n        return;\n      } // Emit to self\n\n\n      this._emitMessage(msg.topicIDs, msg);\n    }\n  }, {\n    key: \"_emitMessage\",\n    value: function _emitMessage(topics, message) {\n      var _this7 = this;\n\n      topics.forEach(function (topic) {\n        if (_this7.subscriptions.has(topic)) {\n          _this7.emit(topic, message);\n        }\n      });\n    }\n    /**\n     * Unmounts the protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this8 = this;\n\n      var _super = Object.create(null, {\n        stop: {\n          get: function get() {\n            return _get(_getPrototypeOf(BasicPubSub.prototype), \"stop\", _this8);\n          }\n        }\n      });\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return _super.stop.call(this);\n\n              case 2:\n                this.subscriptions = new Set();\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Subscribes to topics\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      var _this9 = this;\n\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      } // normalize input and remove existing subscriptions\n\n\n      topics = utils.ensureArray(topics);\n      var newTopics = topics.filter(function (topic) {\n        return !_this9.subscriptions.has(topic);\n      });\n\n      if (newTopics.length === 0) {\n        return;\n      }\n\n      this._subscribe(newTopics);\n    }\n    /**\n     * Subscribes to topics\n     *\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(topics) {\n      var _this10 = this;\n\n      // set subscriptions\n      topics.forEach(function (topic) {\n        _this10.subscriptions.add(topic);\n      }); // Broadcast SUBSCRIBE to all peers\n\n      this.peers.forEach(function (peer) {\n        return sendSubscriptionsOnceReady(peer);\n      }); // make sure that the protocol is already mounted\n\n      function sendSubscriptionsOnceReady(peer) {\n        if (peer && peer.isWritable) {\n          return peer.sendSubscriptions(topics);\n        }\n\n        var onConnection = function onConnection() {\n          peer.removeListener('connection', onConnection);\n          sendSubscriptionsOnceReady(peer);\n        };\n\n        peer.on('connection', onConnection);\n        peer.once('close', function () {\n          return peer.removeListener('connection', onConnection);\n        });\n      }\n    }\n    /**\n     * Leaves a topic\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      var _this11 = this;\n\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      } // normalize input and remove existing unsubscriptions\n\n\n      topics = utils.ensureArray(topics);\n      var unTopics = topics.filter(function (topic) {\n        return _this11.subscriptions.has(topic);\n      });\n\n      if (unTopics.length === 0) {\n        return;\n      }\n\n      this._unsubscribe(unTopics);\n    }\n    /**\n     * Unsubscribes to topics\n     *\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe(topics) {\n      var _this12 = this;\n\n      // delete subscriptions\n      topics.forEach(function (topic) {\n        _this12.subscriptions.delete(topic);\n      }); // Broadcast UNSUBSCRIBE to all peers ready\n\n      this.peers.forEach(function (peer) {\n        return sendUnsubscriptionsOnceReady(peer);\n      }); // make sure that the protocol is already mounted\n\n      function sendUnsubscriptionsOnceReady(peer) {\n        if (peer && peer.isWritable) {\n          return peer.sendUnsubscriptions(topics);\n        }\n\n        var onConnection = function onConnection() {\n          peer.removeListener('connection', onConnection);\n          sendUnsubscriptionsOnceReady(peer);\n        };\n\n        peer.on('connection', onConnection);\n        peer.once('close', function () {\n          return peer.removeListener('connection', onConnection);\n        });\n      }\n    }\n    /**\n     * Publishes messages to all subscribed peers\n     * @override\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @returns {void}\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this13 = this;\n\n        var from, buildMessage, msgObjects;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this.started) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Pubsub has not started');\n\n              case 2:\n                this.log('publish', topics, messages);\n                topics = utils.ensureArray(topics);\n                messages = utils.ensureArray(messages);\n                from = this.peerId.toB58String();\n\n                buildMessage = function buildMessage(msg, cb) {\n                  var seqno = utils.randomSeqno();\n                  var msgObj = {\n                    from: from,\n                    data: msg,\n                    seqno: seqno,\n                    topicIDs: topics\n                  }; // Emit to self if I'm interested and emitSelf enabled\n\n                  _this13._options.emitSelf && _this13._emitMessages(topics, [msgObj]);\n                  return _this13._buildMessage(msgObj);\n                };\n\n                _context7.next = 9;\n                return pMap(messages, buildMessage);\n\n              case 9:\n                msgObjects = _context7.sent;\n\n                // send to all the other peers\n                this._publish(utils.normalizeOutRpcMessages(msgObjects));\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     * @override\n     * @returns {Array<String>}\n     */\n\n  }, {\n    key: \"getTopics\",\n    value: function getTopics() {\n      if (!this.started) {\n        throw new Error('Pubsub is not started');\n      }\n\n      return Array.from(this.subscriptions);\n    }\n    /**\n     * Child class can override this.\n     * @param {RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n  }, {\n    key: \"getMsgId\",\n    value: function getMsgId(msg) {\n      return this.defaultMsgIdFn(msg);\n    }\n  }, {\n    key: \"_emitMessages\",\n    value: function _emitMessages(topics, messages) {\n      var _this14 = this;\n\n      topics.forEach(function (topic) {\n        if (!_this14.subscriptions.has(topic)) {\n          return;\n        }\n\n        messages.forEach(function (message) {\n          _this14.emit(topic, message);\n        });\n      });\n    }\n    /**\n     * Publish messages\n     *\n     * Note: this function assumes all messages are well-formed RPC objects\n     * @param {Array<Message>} msgs\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_publish\",\n    value: function _publish(msgs) {\n      throw errcode(new Error('_publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n  }]);\n\n  return BasicPubSub;\n}(Pubsub);\n\nmodule.exports = BasicPubSub;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-gossipsub/src/pubsub.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","settle","d","errcode","require","Buffer","PeerId","pipe","lp","pMap","Pubsub","utils","RPCCodec","BasicPubSub","debugName","multicodecs","peerId","registrar","options","isPeerId","Error","_options","Object","assign","emitSelf","subscriptions","Set","defaultMsgIdFn","msg","msgId","from","seqno","topicValidators","Map","conn","_super","create","_onPeerConnected","get","idB58Str","toB58String","peer","peers","isWritable","sendSubscriptions","decode","source","source_1","source_1_1","data","rpcMsgBuf","isBuffer","slice","rpcMsg","_decodeRpc","_processRpc","e_1","error","_a","return","_onPeerDisconnected","id","buf","rpc","log","subs","msgs","length","updateSubscriptions","forEach","subOpt","_processRpcSubOpt","emit","topics","message","normalizeInRpcMessage","validate","isValid","_processRpcMessage","topicIDs","every","topic","validatorFn","_processTopicValidatorResult","Boolean","t","topicID","topicSet","set","subscribe","add","delete","_emitMessage","has","stop","started","ensureArray","newTopics","filter","_subscribe","sendSubscriptionsOnceReady","onConnection","removeListener","on","once","unTopics","_unsubscribe","sendUnsubscriptionsOnceReady","sendUnsubscriptions","messages","buildMessage","cb","randomSeqno","msgObj","_emitMessages","_buildMessage","msgObjects","_publish","normalizeOutRpcMessages","Array","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nconst errcode = require('err-code');\nconst { Buffer } = require('buffer');\nconst PeerId = require('peer-id');\nconst pipe = require('it-pipe');\nconst lp = require('it-length-prefixed');\nconst pMap = require('p-map');\nconst Pubsub = require('libp2p-pubsub');\nconst { utils } = require('libp2p-pubsub');\nconst { RPCCodec } = require('./message');\nclass BasicPubSub extends Pubsub {\n    /**\n     * @param {Object} props\n     * @param {String} props.debugName log namespace\n     * @param {string[]} props.multicodecs protocol identifiers to connect\n     * @param {PeerId} props.peerId peer's peerId\n     * @param {Object} props.registrar registrar for libp2p protocols\n     * @param {function} props.registrar.handle\n     * @param {function} props.registrar.register\n     * @param {function} props.registrar.unregister\n     * @param {Object} [props.options]\n     * @param {boolean} [props.options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n     * @constructor\n     */\n    constructor({ debugName, multicodecs, peerId, registrar, options = {} }) {\n        if (!PeerId.isPeerId(peerId)) {\n            throw new Error('peerId must be an instance of `peer-id`');\n        }\n        const _options = Object.assign({ emitSelf: false }, options);\n        super(Object.assign({ debugName,\n            multicodecs,\n            peerId,\n            registrar }, _options));\n        /**\n         * A set of subscriptions\n         */\n        this.subscriptions = new Set();\n        /**\n         * Pubsub options\n         */\n        this._options = _options;\n        /**\n         * The default msgID implementation\n         * @param {RPC.Message} msg the message object\n         * @returns {string} message id as string\n         */\n        this.defaultMsgIdFn = (msg) => utils.msgId(msg.from, msg.seqno);\n        /**\n         * Topic validator function\n         * @typedef {function(string, Peer, RPC): boolean} validator\n         */\n        /**\n         * Topic validator map\n         *\n         * Keyed by topic\n         * Topic validators are functions with the following input:\n         * @type {Map<string, validator>}\n         */\n        this.topicValidators = new Map();\n    }\n    /**\n     * Peer connected successfully with pubsub protocol.\n     * @override\n     * @param {PeerId} peerId peer id\n     * @param {Connection} conn connection to the peer\n     * @returns {Promise<void>}\n     */\n    _onPeerConnected(peerId, conn) {\n        const _super = Object.create(null, {\n            _onPeerConnected: { get: () => super._onPeerConnected }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super._onPeerConnected.call(this, peerId, conn);\n            const idB58Str = peerId.toB58String();\n            const peer = this.peers.get(idB58Str);\n            if (peer && peer.isWritable) {\n                // Immediately send my own subscriptions to the newly established conn\n                peer.sendSubscriptions(this.subscriptions);\n            }\n        });\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @override\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {Peer} peer PubSub peer\n     * @returns {void}\n     *\n     */\n    _processMessages(idB58Str, conn, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield pipe(conn, lp.decode(), (source) => { var source_1, source_1_1; return __awaiter(this, void 0, void 0, function* () {\n                    var e_1, _a;\n                    try {\n                        for (source_1 = __asyncValues(source); source_1_1 = yield source_1.next(), !source_1_1.done;) {\n                            const data = source_1_1.value;\n                            const rpcMsgBuf = Buffer.isBuffer(data) ? data : data.slice();\n                            const rpcMsg = this._decodeRpc(rpcMsgBuf);\n                            this._processRpc(idB58Str, peer, rpcMsg);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield _a.call(source_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }); });\n            }\n            catch (err) {\n                this._onPeerDisconnected(peer.id, err);\n            }\n        });\n    }\n    /**\n     * Decode a buffer into an RPC object\n     *\n     * Override to use an extended protocol-specific protobuf decoder\n     *\n     * @param {Buffer} buf\n     * @returns {RPC}\n     */\n    _decodeRpc(buf) {\n        return RPCCodec.decode(buf);\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @param {String} idB58Str\n     * @param {Peer} peer\n     * @param {RPC} rpc\n     * @returns {void}\n     */\n    _processRpc(idB58Str, peer, rpc) {\n        this.log('rpc from', idB58Str);\n        const subs = rpc.subscriptions;\n        const msgs = rpc.msgs;\n        if (subs.length) {\n            // update peer subscriptions\n            peer.updateSubscriptions(subs);\n            subs.forEach((subOpt) => this._processRpcSubOpt(peer, subOpt));\n            this.emit('pubsub:subscription-change', peer.id, peer.topics, subs);\n        }\n        if (msgs.length) {\n            msgs.forEach((message) => __awaiter(this, void 0, void 0, function* () {\n                const msg = utils.normalizeInRpcMessage(message);\n                // Ensure the message is valid before processing it\n                try {\n                    const isValid = yield this.validate(message, peer);\n                    if (!isValid) {\n                        this.log('Message is invalid, dropping it.');\n                        return;\n                    }\n                }\n                catch (err) {\n                    this.log('Error in message validation, dropping it. %O', err);\n                    return;\n                }\n                this._processRpcMessage(peer, msg);\n            }));\n        }\n    }\n    /**\n     * Validates the given message.\n     * @param {RPC.Message} message\n     * @param {Peer} [peer]\n     * @returns {Promise<Boolean>}\n     */\n    validate(message, peer) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const isValid = yield _super.validate.call(this, message, peer);\n            if (!isValid) {\n                return false;\n            }\n            // only run topic validators if the peer is passed as an arg\n            if (!peer) {\n                return true;\n            }\n            return message.topicIDs.every(topic => {\n                const validatorFn = this.topicValidators.get(topic);\n                if (!validatorFn) {\n                    return true;\n                }\n                return this._processTopicValidatorResult(topic, peer, message, validatorFn(topic, peer, message));\n            });\n        });\n    }\n    /**\n     * Coerces topic validator result to determine message validity\n     *\n     * Defaults to true if truthy\n     *\n     * Override this method to provide custom topic validator result processing (eg: scoring)\n     *\n     * @param {String} topic\n     * @param {Peer} peer\n     * @param {RPC.Message} message\n     * @param {unknown} result\n     * @returns {Boolean}\n     */\n    _processTopicValidatorResult(topic, peer, message, result) {\n        return Boolean(result);\n    }\n    /**\n     * Handles an subscription change from a peer\n     *\n     * @param {Peer} peer\n     * @param {RPC.SubOpt} subOpt\n     */\n    _processRpcSubOpt(peer, subOpt) {\n        const t = subOpt.topicID;\n        let topicSet = this.topics.get(t);\n        if (!topicSet) {\n            topicSet = new Set();\n            this.topics.set(t, topicSet);\n        }\n        if (subOpt.subscribe) {\n            // subscribe peer to new topic\n            topicSet.add(peer);\n        }\n        else {\n            // unsubscribe from existing topic\n            topicSet.delete(peer);\n        }\n    }\n    /**\n     * Handles an message from a peer\n     *\n     * @param {Peer} peer\n     * @param {RPC.Message} msg\n     */\n    _processRpcMessage(peer, msg) {\n        if (this.peerId.toB58String() === msg.from && !this._options.emitSelf) {\n            return;\n        }\n        // Emit to self\n        this._emitMessage(msg.topicIDs, msg);\n    }\n    _emitMessage(topics, message) {\n        topics.forEach((topic) => {\n            if (this.subscriptions.has(topic)) {\n                this.emit(topic, message);\n            }\n        });\n    }\n    /**\n     * Unmounts the protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        const _super = Object.create(null, {\n            stop: { get: () => super.stop }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.stop.call(this);\n            this.subscriptions = new Set();\n        });\n    }\n    /**\n     * Subscribes to topics\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    subscribe(topics) {\n        if (!this.started) {\n            throw new Error('Pubsub has not started');\n        }\n        // normalize input and remove existing subscriptions\n        topics = utils.ensureArray(topics);\n        const newTopics = topics.filter((topic) => !this.subscriptions.has(topic));\n        if (newTopics.length === 0) {\n            return;\n        }\n        this._subscribe(newTopics);\n    }\n    /**\n     * Subscribes to topics\n     *\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _subscribe(topics) {\n        // set subscriptions\n        topics.forEach((topic) => {\n            this.subscriptions.add(topic);\n        });\n        // Broadcast SUBSCRIBE to all peers\n        this.peers.forEach((peer) => sendSubscriptionsOnceReady(peer));\n        // make sure that the protocol is already mounted\n        function sendSubscriptionsOnceReady(peer) {\n            if (peer && peer.isWritable) {\n                return peer.sendSubscriptions(topics);\n            }\n            const onConnection = () => {\n                peer.removeListener('connection', onConnection);\n                sendSubscriptionsOnceReady(peer);\n            };\n            peer.on('connection', onConnection);\n            peer.once('close', () => peer.removeListener('connection', onConnection));\n        }\n    }\n    /**\n     * Leaves a topic\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    unsubscribe(topics) {\n        if (!this.started) {\n            throw new Error('Pubsub has not started');\n        }\n        // normalize input and remove existing unsubscriptions\n        topics = utils.ensureArray(topics);\n        const unTopics = topics.filter((topic) => this.subscriptions.has(topic));\n        if (unTopics.length === 0) {\n            return;\n        }\n        this._unsubscribe(unTopics);\n    }\n    /**\n     * Unsubscribes to topics\n     *\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _unsubscribe(topics) {\n        // delete subscriptions\n        topics.forEach((topic) => {\n            this.subscriptions.delete(topic);\n        });\n        // Broadcast UNSUBSCRIBE to all peers ready\n        this.peers.forEach((peer) => sendUnsubscriptionsOnceReady(peer));\n        // make sure that the protocol is already mounted\n        function sendUnsubscriptionsOnceReady(peer) {\n            if (peer && peer.isWritable) {\n                return peer.sendUnsubscriptions(topics);\n            }\n            const onConnection = () => {\n                peer.removeListener('connection', onConnection);\n                sendUnsubscriptionsOnceReady(peer);\n            };\n            peer.on('connection', onConnection);\n            peer.once('close', () => peer.removeListener('connection', onConnection));\n        }\n    }\n    /**\n     * Publishes messages to all subscribed peers\n     * @override\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @returns {void}\n     */\n    publish(topics, messages) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.started) {\n                throw new Error('Pubsub has not started');\n            }\n            this.log('publish', topics, messages);\n            topics = utils.ensureArray(topics);\n            messages = utils.ensureArray(messages);\n            const from = this.peerId.toB58String();\n            const buildMessage = (msg, cb) => {\n                const seqno = utils.randomSeqno();\n                const msgObj = {\n                    from: from,\n                    data: msg,\n                    seqno: seqno,\n                    topicIDs: topics\n                };\n                // Emit to self if I'm interested and emitSelf enabled\n                this._options.emitSelf && this._emitMessages(topics, [msgObj]);\n                return this._buildMessage(msgObj);\n            };\n            const msgObjects = yield pMap(messages, buildMessage);\n            // send to all the other peers\n            this._publish(utils.normalizeOutRpcMessages(msgObjects));\n        });\n    }\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     * @override\n     * @returns {Array<String>}\n     */\n    getTopics() {\n        if (!this.started) {\n            throw new Error('Pubsub is not started');\n        }\n        return Array.from(this.subscriptions);\n    }\n    /**\n     * Child class can override this.\n     * @param {RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n    getMsgId(msg) {\n        return this.defaultMsgIdFn(msg);\n    }\n    _emitMessages(topics, messages) {\n        topics.forEach((topic) => {\n            if (!this.subscriptions.has(topic)) {\n                return;\n            }\n            messages.forEach((message) => {\n                this.emit(topic, message);\n            });\n        });\n    }\n    /**\n     * Publish messages\n     *\n     * Note: this function assumes all messages are well-formed RPC objects\n     * @param {Array<Message>} msgs\n     * @returns {void}\n     */\n    _publish(msgs) {\n        throw errcode(new Error('_publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n}\nmodule.exports = BasicPubSub;\n"]},"metadata":{},"sourceType":"script"}