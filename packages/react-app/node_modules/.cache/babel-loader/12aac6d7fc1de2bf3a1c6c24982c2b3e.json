{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar multiaddr = require('multiaddr');\n\nvar protons = require('protons');\n\nvar _require = require('libp2p-record'),\n    Record = _require.Record;\n\nvar _require2 = require('buffer'),\n    Buffer = _require2.Buffer;\n\nvar pbm = protons(require('./dht.proto'));\nvar MESSAGE_TYPE = pbm.Message.MessageType;\nvar CONNECTION_TYPE = pbm.Message.ConnectionType;\n/**\n * Represents a single DHT control message.\n */\n\nvar Message = /*#__PURE__*/function () {\n  /**\n   * @param {MessageType} type\n   * @param {Buffer} key\n   * @param {number} level\n   */\n  function Message(type, key, level) {\n    _classCallCheck(this, Message);\n\n    if (key && !Buffer.isBuffer(key)) {\n      throw new Error('Key must be a buffer');\n    }\n\n    this.type = type;\n    this.key = key;\n    this._clusterLevelRaw = level;\n    this.closerPeers = [];\n    this.providerPeers = [];\n    this.record = null;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  _createClass(Message, [{\n    key: \"serialize\",\n\n    /**\n     * Encode into protobuf\n     * @returns {Buffer}\n     */\n    value: function serialize() {\n      var obj = {\n        key: this.key,\n        type: this.type,\n        clusterLevelRaw: this._clusterLevelRaw,\n        closerPeers: this.closerPeers.map(toPbPeer),\n        providerPeers: this.providerPeers.map(toPbPeer)\n      };\n\n      if (this.record) {\n        if (Buffer.isBuffer(this.record)) {\n          obj.record = this.record;\n        } else {\n          obj.record = this.record.serialize();\n        }\n      }\n\n      return pbm.Message.encode(obj);\n    }\n    /**\n     * Decode from protobuf\n     *\n     * @param {Buffer} raw\n     * @returns {Message}\n     */\n\n  }, {\n    key: \"clusterLevel\",\n    get: function get() {\n      var level = this._clusterLevelRaw - 1;\n\n      if (level < 0) {\n        return 0;\n      }\n\n      return level;\n    },\n    set: function set(level) {\n      this._clusterLevelRaw = level;\n    }\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(raw) {\n      var dec = pbm.Message.decode(raw);\n      var msg = new Message(dec.type, dec.key, dec.clusterLevelRaw);\n      msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n      msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n      if (dec.record) {\n        msg.record = Record.deserialize(dec.record);\n      }\n\n      return msg;\n    }\n  }]);\n\n  return Message;\n}();\n\nMessage.TYPES = MESSAGE_TYPE;\nMessage.CONNECTION_TYPES = CONNECTION_TYPE;\n\nfunction toPbPeer(peer) {\n  return {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map(function (m) {\n      return m.buffer;\n    }),\n    connection: CONNECTION_TYPE.CONNECTED\n  };\n}\n\nfunction fromPbPeer(peer) {\n  return {\n    id: new PeerId(peer.id),\n    multiaddrs: peer.addrs.map(function (a) {\n      return multiaddr(a);\n    })\n  };\n}\n\nmodule.exports = Message;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/message/index.js"],"names":["PeerId","require","multiaddr","protons","Record","Buffer","pbm","MESSAGE_TYPE","Message","MessageType","CONNECTION_TYPE","ConnectionType","type","key","level","isBuffer","Error","_clusterLevelRaw","closerPeers","providerPeers","record","obj","clusterLevelRaw","map","toPbPeer","serialize","encode","raw","dec","decode","msg","fromPbPeer","deserialize","TYPES","CONNECTION_TYPES","peer","id","addrs","multiaddrs","m","buffer","connection","CONNECTED","a","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst protons = require('protons')\nconst { Record } = require('libp2p-record')\nconst { Buffer } = require('buffer')\nconst pbm = protons(require('./dht.proto'))\n\nconst MESSAGE_TYPE = pbm.Message.MessageType\nconst CONNECTION_TYPE = pbm.Message.ConnectionType\n\n/**\n * Represents a single DHT control message.\n */\nclass Message {\n  /**\n   * @param {MessageType} type\n   * @param {Buffer} key\n   * @param {number} level\n   */\n  constructor (type, key, level) {\n    if (key && !Buffer.isBuffer(key)) {\n      throw new Error('Key must be a buffer')\n    }\n\n    this.type = type\n    this.key = key\n    this._clusterLevelRaw = level\n    this.closerPeers = []\n    this.providerPeers = []\n    this.record = null\n  }\n\n  /**\n   * @type {number}\n   */\n  get clusterLevel () {\n    const level = this._clusterLevelRaw - 1\n    if (level < 0) {\n      return 0\n    }\n\n    return level\n  }\n\n  set clusterLevel (level) {\n    this._clusterLevelRaw = level\n  }\n\n  /**\n   * Encode into protobuf\n   * @returns {Buffer}\n   */\n  serialize () {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer)\n    }\n\n    if (this.record) {\n      if (Buffer.isBuffer(this.record)) {\n        obj.record = this.record\n      } else {\n        obj.record = this.record.serialize()\n      }\n    }\n\n    return pbm.Message.encode(obj)\n  }\n\n  /**\n   * Decode from protobuf\n   *\n   * @param {Buffer} raw\n   * @returns {Message}\n   */\n  static deserialize (raw) {\n    const dec = pbm.Message.decode(raw)\n\n    const msg = new Message(dec.type, dec.key, dec.clusterLevelRaw)\n\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer)\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer)\n    if (dec.record) {\n      msg.record = Record.deserialize(dec.record)\n    }\n\n    return msg\n  }\n}\n\nMessage.TYPES = MESSAGE_TYPE\nMessage.CONNECTION_TYPES = CONNECTION_TYPE\n\nfunction toPbPeer (peer) {\n  return {\n    id: peer.id.id,\n    addrs: (peer.multiaddrs || []).map((m) => m.buffer),\n    connection: CONNECTION_TYPE.CONNECTED\n  }\n}\n\nfunction fromPbPeer (peer) {\n  return {\n    id: new PeerId(peer.id),\n    multiaddrs: peer.addrs.map((a) => multiaddr(a))\n  }\n}\n\nmodule.exports = Message\n"]},"metadata":{},"sourceType":"script"}