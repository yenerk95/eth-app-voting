{"ast":null,"code":"'use strict';\n\nconst importer = require('ipfs-unixfs-importer');\n\nconst normaliseAddInput = require('ipfs-core-utils/src/files/normalise-input');\n\nconst {\n  parseChunkerString\n} = require('./utils');\n\nconst pipe = require('it-pipe');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nmodule.exports = ({\n  block,\n  gcLock,\n  preload,\n  pin,\n  options: constructorOptions\n}) => {\n  const isShardingEnabled = constructorOptions.EXPERIMENTAL && constructorOptions.EXPERIMENTAL.sharding;\n  return withTimeoutOption(async function* add(source, options) {\n    options = options || {};\n    const opts = {\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      ...options,\n      strategy: 'balanced',\n      ...parseChunkerString(options.chunker)\n    }; // CID v0 is for multihashes encoded with sha2-256\n\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle';\n    }\n\n    delete opts.trickle;\n\n    if (opts.progress) {\n      let total = 0;\n      const prog = opts.progress;\n\n      opts.progress = bytes => {\n        total += bytes;\n        prog(total);\n      };\n    }\n\n    const iterator = pipe(normaliseAddInput(source), source => importer(source, block, { ...opts,\n      pin: false\n    }), transformFile(opts), preloadFile(preload, opts), pinFile(pin, opts));\n    const releaseLock = await gcLock.readLock();\n\n    try {\n      yield* iterator;\n    } finally {\n      releaseLock();\n    }\n  });\n};\n\nfunction transformFile(opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      let cid = file.cid;\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      let path = file.path ? file.path : cid.toString();\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = '';\n      }\n\n      yield {\n        path,\n        cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      };\n    }\n  };\n}\n\nfunction preloadFile(preload, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n      if (shouldPreload) {\n        preload(file.cid);\n      }\n\n      yield file;\n    }\n  };\n}\n\nfunction pinFile(pin, opts) {\n  return async function* (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !file.path.includes('/');\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;\n\n      if (shouldPin) {\n        // Note: addAsyncIterator() has already taken a GC lock, so tell\n        // pin.add() not to take a (second) GC lock\n        await pin.add(file.cid, {\n          preload: false,\n          lock: false\n        });\n      }\n\n      yield file;\n    }\n  };\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/add/index.js"],"names":["importer","require","normaliseAddInput","parseChunkerString","pipe","withTimeoutOption","module","exports","block","gcLock","preload","pin","options","constructorOptions","isShardingEnabled","EXPERIMENTAL","sharding","add","source","opts","shardSplitThreshold","Infinity","strategy","chunker","hashAlg","cidVersion","trickle","progress","total","prog","bytes","iterator","transformFile","preloadFile","pinFile","releaseLock","readLock","file","cid","toV1","path","toString","wrapWithDirectory","size","mode","unixfs","mtime","isRootFile","includes","shouldPreload","onlyHash","isRootDir","shouldPin","lock"],"mappings":"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","sourcesContent":["'use strict'\n\nconst importer = require('ipfs-unixfs-importer')\nconst normaliseAddInput = require('ipfs-core-utils/src/files/normalise-input')\nconst { parseChunkerString } = require('./utils')\nconst pipe = require('it-pipe')\nconst { withTimeoutOption } = require('../../utils')\n\nmodule.exports = ({ block, gcLock, preload, pin, options: constructorOptions }) => {\n  const isShardingEnabled = constructorOptions.EXPERIMENTAL && constructorOptions.EXPERIMENTAL.sharding\n\n  return withTimeoutOption(async function * add (source, options) {\n    options = options || {}\n\n    const opts = {\n      shardSplitThreshold: isShardingEnabled ? 1000 : Infinity,\n      ...options,\n      strategy: 'balanced',\n      ...parseChunkerString(options.chunker)\n    }\n\n    // CID v0 is for multihashes encoded with sha2-256\n    if (opts.hashAlg && opts.hashAlg !== 'sha2-256' && opts.cidVersion !== 1) {\n      opts.cidVersion = 1\n    }\n\n    if (opts.trickle) {\n      opts.strategy = 'trickle'\n    }\n\n    delete opts.trickle\n\n    if (opts.progress) {\n      let total = 0\n      const prog = opts.progress\n\n      opts.progress = (bytes) => {\n        total += bytes\n        prog(total)\n      }\n    }\n\n    const iterator = pipe(\n      normaliseAddInput(source),\n      source => importer(source, block, {\n        ...opts,\n        pin: false\n      }),\n      transformFile(opts),\n      preloadFile(preload, opts),\n      pinFile(pin, opts)\n    )\n\n    const releaseLock = await gcLock.readLock()\n\n    try {\n      yield * iterator\n    } finally {\n      releaseLock()\n    }\n  })\n}\n\nfunction transformFile (opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      let cid = file.cid\n\n      if (opts.cidVersion === 1) {\n        cid = cid.toV1()\n      }\n\n      let path = file.path ? file.path : cid.toString()\n\n      if (opts.wrapWithDirectory && !file.path) {\n        path = ''\n      }\n\n      yield {\n        path,\n        cid,\n        size: file.size,\n        mode: file.unixfs && file.unixfs.mode,\n        mtime: file.unixfs && file.unixfs.mtime\n      }\n    }\n  }\n}\n\nfunction preloadFile (preload, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      const isRootFile = !file.path || opts.wrapWithDirectory\n        ? file.path === ''\n        : !file.path.includes('/')\n\n      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false\n\n      if (shouldPreload) {\n        preload(file.cid)\n      }\n\n      yield file\n    }\n  }\n}\n\nfunction pinFile (pin, opts) {\n  return async function * (source) {\n    for await (const file of source) {\n      // Pin a file if it is the root dir of a recursive add or the single file\n      // of a direct add.\n      const isRootDir = !file.path.includes('/')\n      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash\n\n      if (shouldPin) {\n        // Note: addAsyncIterator() has already taken a GC lock, so tell\n        // pin.add() not to take a (second) GC lock\n        await pin.add(file.cid, {\n          preload: false,\n          lock: false\n        })\n      }\n\n      yield file\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}