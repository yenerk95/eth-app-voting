{"ast":null,"code":"/*!\n * ecdh.js - ECDH for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://cr.yp.to/ecdh.html\n *   https://cr.yp.to/ecdh/curve25519-20060209.pdf\n *   https://tools.ietf.org/html/rfc7748\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('../internal/assert');\n\nvar elliptic = require('./elliptic');\n\nvar rng = require('../random');\n\nvar _require = require('../encoding/util'),\n    padRight = _require.padRight;\n/**\n * ECDH\n */\n\n\nvar ECDH = /*#__PURE__*/function () {\n  function ECDH(id, eid, pre) {\n    _classCallCheck(this, ECDH);\n\n    assert(typeof id === 'string');\n    assert(!eid || typeof eid === 'string');\n    this.id = id;\n    this.type = 'ecdh';\n    this.eid = eid || null;\n    this._pre = pre || null;\n    this._curve = null;\n    this._edwards = null;\n    this.native = 0;\n  }\n\n  _createClass(ECDH, [{\n    key: \"privateKeyGenerate\",\n    value: function privateKeyGenerate() {\n      var key = rng.randomBytes(this.curve.scalarSize);\n      return this.curve.clamp(key);\n    }\n  }, {\n    key: \"privateKeyVerify\",\n    value: function privateKeyVerify(key) {\n      assert(Buffer.isBuffer(key));\n      return key.length === this.curve.scalarSize;\n    }\n  }, {\n    key: \"privateKeyExport\",\n    value: function privateKeyExport(key, sign) {\n      var pub = this.publicKeyCreate(key);\n\n      var _this$publicKeyExport = this.publicKeyExport(pub, sign),\n          x = _this$publicKeyExport.x,\n          y = _this$publicKeyExport.y;\n\n      return {\n        d: Buffer.from(key),\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"privateKeyImport\",\n    value: function privateKeyImport(json) {\n      assert(json && typeof json === 'object');\n      return padRight(json.d, this.curve.scalarSize);\n    }\n  }, {\n    key: \"publicKeyCreate\",\n    value: function publicKeyCreate(key) {\n      var a = this.curve.decodeScalar(key);\n      var k = this.curve.reduce(a);\n\n      if (this.edwards && this.edwards.g.pre) {\n        var _A = this.edwards.g.mulBlind(k);\n\n        var P = this.curve.pointFromEdwards(_A);\n        return P.encode();\n      }\n\n      var G = this.curve.g.toX();\n      var A = G.mulBlind(k, rng);\n      return A.encode();\n    }\n  }, {\n    key: \"publicKeyConvert\",\n    value: function publicKeyConvert(key, sign) {\n      assert(sign == null || typeof sign === 'boolean');\n      if (!this.edwards) throw new Error('No equivalent edwards curve.');\n      var A = this.curve.decodePoint(key);\n      var P = this.edwards.pointFromMont(A);\n\n      if (sign != null) {\n        if (P.isOdd() !== sign) return P.neg().encode();\n      }\n\n      return P.encode();\n    }\n  }, {\n    key: \"publicKeyFromUniform\",\n    value: function publicKeyFromUniform(bytes) {\n      var u = this.curve.decodeUniform(bytes);\n      var A = this.curve.pointFromUniform(u);\n      return A.encode();\n    }\n  }, {\n    key: \"publicKeyToUniform\",\n    value: function publicKeyToUniform(key) {\n      var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n      var A = this.curve.decodePoint(key);\n      var u = this.curve.pointToUniform(A, hint);\n      return this.curve.encodeUniform(u, hint >>> 8);\n    }\n  }, {\n    key: \"publicKeyFromHash\",\n    value: function publicKeyFromHash(bytes) {\n      var pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var A = this.curve.pointFromHash(bytes, pake);\n      return A.encode();\n    }\n  }, {\n    key: \"publicKeyToHash\",\n    value: function publicKeyToHash(key) {\n      var subgroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n      var A = this.curve.decodePoint(key);\n      return this.curve.pointToHash(A, subgroup, rng);\n    }\n  }, {\n    key: \"publicKeyVerify\",\n    value: function publicKeyVerify(key) {\n      assert(Buffer.isBuffer(key));\n      var A;\n\n      try {\n        A = this.curve.decodeX(key);\n      } catch (e) {\n        return false;\n      }\n\n      return A.validate();\n    }\n  }, {\n    key: \"publicKeyIsSmall\",\n    value: function publicKeyIsSmall(key) {\n      assert(Buffer.isBuffer(key));\n      var A;\n\n      try {\n        A = this.curve.decodeX(key);\n      } catch (e) {\n        return false;\n      }\n\n      if (!A.validate()) return false;\n      return A.isSmall();\n    }\n  }, {\n    key: \"publicKeyHasTorsion\",\n    value: function publicKeyHasTorsion(key) {\n      assert(Buffer.isBuffer(key));\n      var A;\n\n      try {\n        A = this.curve.decodeX(key);\n      } catch (e) {\n        return false;\n      }\n\n      if (!A.validate()) return false;\n      return A.hasTorsion();\n    }\n  }, {\n    key: \"publicKeyExport\",\n    value: function publicKeyExport(key, sign) {\n      var _this$curve$decodePoi = this.curve.decodePoint(key, sign),\n          x = _this$curve$decodePoi.x,\n          y = _this$curve$decodePoi.y;\n\n      return {\n        x: this.curve.encodeField(x.fromRed()),\n        y: this.curve.encodeField(y.fromRed())\n      };\n    }\n  }, {\n    key: \"publicKeyImport\",\n    value: function publicKeyImport(json) {\n      assert(json && typeof json === 'object');\n      var x = padRight(json.x, this.curve.fieldSize);\n      var A = this.curve.decodeX(x);\n      if (!A.validate()) throw new Error('Invalid point.');\n      return A.encode();\n    }\n  }, {\n    key: \"derive\",\n    value: function derive(pub, priv) {\n      var A = this.curve.decodeX(pub);\n      var a = this.curve.decodeScalar(priv);\n      var k = this.curve.reduce(a);\n      var P = A.mulConst(k, rng);\n      return P.encode();\n    }\n  }, {\n    key: \"curve\",\n    get: function get() {\n      if (!this._curve) this._curve = elliptic.curve(this.id);\n      return this._curve;\n    }\n  }, {\n    key: \"edwards\",\n    get: function get() {\n      if (this.eid && !this._edwards) {\n        this._edwards = elliptic.curve(this.eid, this._pre);\n\n        this._edwards.precompute(rng);\n\n        this._pre = null;\n      }\n\n      return this._edwards;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.curve.fieldSize;\n    }\n  }, {\n    key: \"bits\",\n    get: function get() {\n      return this.curve.fieldBits;\n    }\n  }]);\n\n  return ECDH;\n}();\n/*\n * Expose\n */\n\n\nmodule.exports = ECDH;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/bcrypto/lib/js/ecdh.js"],"names":["assert","require","elliptic","rng","padRight","ECDH","id","eid","pre","type","_pre","_curve","_edwards","native","key","randomBytes","curve","scalarSize","clamp","Buffer","isBuffer","length","sign","pub","publicKeyCreate","publicKeyExport","x","y","d","from","json","a","decodeScalar","k","reduce","edwards","g","A","mulBlind","P","pointFromEdwards","encode","G","toX","Error","decodePoint","pointFromMont","isOdd","neg","bytes","u","decodeUniform","pointFromUniform","hint","randomInt","pointToUniform","encodeUniform","pake","pointFromHash","subgroup","pointToHash","decodeX","e","validate","isSmall","hasTorsion","encodeField","fromRed","fieldSize","priv","mulConst","precompute","fieldBits","module","exports"],"mappings":"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","sourcesContent":["/*!\n * ecdh.js - ECDH for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://cr.yp.to/ecdh.html\n *   https://cr.yp.to/ecdh/curve25519-20060209.pdf\n *   https://tools.ietf.org/html/rfc7748\n */\n\n'use strict';\n\nconst assert = require('../internal/assert');\nconst elliptic = require('./elliptic');\nconst rng = require('../random');\nconst {padRight} = require('../encoding/util');\n\n/**\n * ECDH\n */\n\nclass ECDH {\n  constructor(id, eid, pre) {\n    assert(typeof id === 'string');\n    assert(!eid || typeof eid === 'string');\n\n    this.id = id;\n    this.type = 'ecdh';\n    this.eid = eid || null;\n    this._pre = pre || null;\n    this._curve = null;\n    this._edwards = null;\n    this.native = 0;\n  }\n\n  get curve() {\n    if (!this._curve)\n      this._curve = elliptic.curve(this.id);\n    return this._curve;\n  }\n\n  get edwards() {\n    if (this.eid && !this._edwards) {\n      this._edwards = elliptic.curve(this.eid, this._pre);\n      this._edwards.precompute(rng);\n      this._pre = null;\n    }\n    return this._edwards;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  privateKeyGenerate() {\n    const key = rng.randomBytes(this.curve.scalarSize);\n    return this.curve.clamp(key);\n  }\n\n  privateKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    return key.length === this.curve.scalarSize;\n  }\n\n  privateKeyExport(key, sign) {\n    const pub = this.publicKeyCreate(key);\n    const {x, y} = this.publicKeyExport(pub, sign);\n\n    return {\n      d: Buffer.from(key),\n      x,\n      y\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n\n    return padRight(json.d, this.curve.scalarSize);\n  }\n\n  publicKeyCreate(key) {\n    const a = this.curve.decodeScalar(key);\n    const k = this.curve.reduce(a);\n\n    if (this.edwards && this.edwards.g.pre) {\n      const A = this.edwards.g.mulBlind(k);\n      const P = this.curve.pointFromEdwards(A);\n\n      return P.encode();\n    }\n\n    const G = this.curve.g.toX();\n    const A = G.mulBlind(k, rng);\n\n    return A.encode();\n  }\n\n  publicKeyConvert(key, sign) {\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!this.edwards)\n      throw new Error('No equivalent edwards curve.');\n\n    const A = this.curve.decodePoint(key);\n    const P = this.edwards.pointFromMont(A);\n\n    if (sign != null) {\n      if (P.isOdd() !== sign)\n        return P.neg().encode();\n    }\n\n    return P.encode();\n  }\n\n  publicKeyFromUniform(bytes) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u);\n\n    return A.encode();\n  }\n\n  publicKeyToUniform(key, hint = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    const u = this.curve.pointToUniform(A, hint);\n\n    return this.curve.encodeUniform(u, hint >>> 8);\n  }\n\n  publicKeyFromHash(bytes, pake = false) {\n    const A = this.curve.pointFromHash(bytes, pake);\n\n    return A.encode();\n  }\n\n  publicKeyToHash(key, subgroup = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    return this.curve.pointToHash(A, subgroup, rng);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n\n    let A;\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.validate();\n  }\n\n  publicKeyIsSmall(key) {\n    assert(Buffer.isBuffer(key));\n\n    let A;\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate())\n      return false;\n\n    return A.isSmall();\n  }\n\n  publicKeyHasTorsion(key) {\n    assert(Buffer.isBuffer(key));\n\n    let A;\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate())\n      return false;\n\n    return A.hasTorsion();\n  }\n\n  publicKeyExport(key, sign) {\n    const {x, y} = this.curve.decodePoint(key, sign);\n\n    return {\n      x: this.curve.encodeField(x.fromRed()),\n      y: this.curve.encodeField(y.fromRed())\n    };\n  }\n\n  publicKeyImport(json) {\n    assert(json && typeof json === 'object');\n\n    const x = padRight(json.x, this.curve.fieldSize);\n    const A = this.curve.decodeX(x);\n\n    if (!A.validate())\n      throw new Error('Invalid point.');\n\n    return A.encode();\n  }\n\n  derive(pub, priv) {\n    const A = this.curve.decodeX(pub);\n    const a = this.curve.decodeScalar(priv);\n    const k = this.curve.reduce(a);\n    const P = A.mulConst(k, rng);\n\n    return P.encode();\n  }\n}\n\n/*\n * Expose\n */\n\nmodule.exports = ECDH;\n"]},"metadata":{},"sourceType":"script"}