{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar toSources = require('./utils/to-sources');\n\nvar cp = require('./cp');\n\nvar rm = require('./rm');\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar defaultOptions = {\n  parents: false,\n  recursive: false,\n  flush: true,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  shardSplitThreshold: 1000,\n  signal: undefined\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsMv = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _len,\n          args,\n          _key,\n          _yield$toSources,\n          sources,\n          options,\n          cpArgs,\n          rmArgs,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = _args[_key];\n              }\n\n              _context.next = 3;\n              return toSources(context, args, defaultOptions);\n\n            case 3:\n              _yield$toSources = _context.sent;\n              sources = _yield$toSources.sources;\n              options = _yield$toSources.options;\n              cpArgs = sources.map(function (source) {\n                return source.path;\n              }).concat(options); // remove the last source as it'll be the destination\n\n              rmArgs = sources.slice(0, -1).map(function (source) {\n                return source.path;\n              }).concat(Object.assign(options, {\n                recursive: true\n              }));\n              _context.next = 10;\n              return cp(context).apply(null, cpArgs);\n\n            case 10:\n              _context.next = 12;\n              return rm(context).apply(null, rmArgs);\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function mfsMv() {\n      return _mfsMv.apply(this, arguments);\n    }\n\n    return mfsMv;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/mv.js"],"names":["toSources","require","cp","rm","withTimeoutOption","defaultOptions","parents","recursive","flush","cidVersion","hashAlg","shardSplitThreshold","signal","undefined","module","exports","context","args","sources","options","cpArgs","map","source","path","concat","rmArgs","slice","Object","assign","apply","mfsMv"],"mappings":"AAAA;;;;;;AAEA,IAAMA,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAME,EAAE,GAAGF,OAAO,CAAC,MAAD,CAAlB;;eAC8BA,OAAO,CAAC,aAAD,C;IAA7BG,iB,YAAAA,iB;;AAER,IAAMC,cAAc,GAAG;AACrBC,EAAAA,OAAO,EAAE,KADY;AAErBC,EAAAA,SAAS,EAAE,KAFU;AAGrBC,EAAAA,KAAK,EAAE,IAHc;AAIrBC,EAAAA,UAAU,EAAE,CAJS;AAKrBC,EAAAA,OAAO,EAAE,UALY;AAMrBC,EAAAA,mBAAmB,EAAE,IANA;AAOrBC,EAAAA,MAAM,EAAEC;AAPa,CAAvB;;AAUAC,MAAM,CAACC,OAAP,GAAiB,UAACC,OAAD,EAAa;AAC5B,SAAOZ,iBAAiB;AAAA,0EAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,wCAAyBa,IAAzB;AAAyBA,gBAAAA,IAAzB;AAAA;;AAAA;AAAA,qBAIbjB,SAAS,CAACgB,OAAD,EAAUC,IAAV,EAAgBZ,cAAhB,CAJI;;AAAA;AAAA;AAErBa,cAAAA,OAFqB,oBAErBA,OAFqB;AAGrBC,cAAAA,OAHqB,oBAGrBA,OAHqB;AAMjBC,cAAAA,MANiB,GAMRF,OAAO,CACnBG,GADY,CACR,UAAAC,MAAM;AAAA,uBAAIA,MAAM,CAACC,IAAX;AAAA,eADE,EACeC,MADf,CACsBL,OADtB,CANQ,EASvB;;AACMM,cAAAA,MAViB,GAURP,OAAO,CACnBQ,KADY,CACN,CADM,EACH,CAAC,CADE,EAEZL,GAFY,CAER,UAAAC,MAAM;AAAA,uBAAIA,MAAM,CAACC,IAAX;AAAA,eAFE,EAGZC,MAHY,CAGLG,MAAM,CAACC,MAAP,CAAcT,OAAd,EAAuB;AAC7BZ,gBAAAA,SAAS,EAAE;AADkB,eAAvB,CAHK,CAVQ;AAAA;AAAA,qBAiBjBL,EAAE,CAACc,OAAD,CAAF,CAAYa,KAAZ,CAAkB,IAAlB,EAAwBT,MAAxB,CAjBiB;;AAAA;AAAA;AAAA,qBAkBjBjB,EAAE,CAACa,OAAD,CAAF,CAAYa,KAAZ,CAAkB,IAAlB,EAAwBJ,MAAxB,CAlBiB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAD;;AAAA,aAAgBK,KAAhB;AAAA;AAAA;;AAAA,WAAgBA,KAAhB;AAAA,MAAxB;AAoBD,CArBD","sourcesContent":["'use strict'\n\nconst toSources = require('./utils/to-sources')\nconst cp = require('./cp')\nconst rm = require('./rm')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  parents: false,\n  recursive: false,\n  flush: true,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  shardSplitThreshold: 1000,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsMv (...args) {\n    const {\n      sources,\n      options\n    } = await toSources(context, args, defaultOptions)\n\n    const cpArgs = sources\n      .map(source => source.path).concat(options)\n\n    // remove the last source as it'll be the destination\n    const rmArgs = sources\n      .slice(0, -1)\n      .map(source => source.path)\n      .concat(Object.assign(options, {\n        recursive: true\n      }))\n\n    await cp(context).apply(null, cpArgs)\n    await rm(context).apply(null, rmArgs)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}