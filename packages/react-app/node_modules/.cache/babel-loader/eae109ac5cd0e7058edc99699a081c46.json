{"ast":null,"code":"'use strict';\n\nconst DirFlat = require('./dir-flat');\n\nconst flatToShard = require('./flat-to-shard');\n\nconst Dir = require('./dir');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst errCode = require('err-code');\n\nconst first = require('it-first');\n\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = null;\n    parent.size = null;\n\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n\n  return tree;\n}\n\nasync function* treeBuilder(source, block, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n\n    tree = await addToTree(entry, tree, options);\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n\n  if (!options.wrapWithDirectory) {\n    if (tree.childCount() > 1) {\n      throw errCode(new Error('detected more than one root'), 'ERR_MORE_THAN_ONE_ROOT');\n    }\n\n    const unwrapped = await first(tree.eachChildSeries());\n\n    if (!unwrapped) {\n      return;\n    }\n\n    tree = unwrapped.child;\n  }\n\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n\n    return;\n  }\n\n  yield* tree.flush(tree.path, block);\n}\n\nmodule.exports = treeBuilder;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs-importer/src/tree-builder.js"],"names":["DirFlat","require","flatToShard","Dir","toPathComponents","errCode","first","addToTree","elem","tree","options","pathElems","path","lastIndex","length","parent","currentPath","i","pathElem","last","dirty","cid","size","put","shardSplitThreshold","dir","get","parentKey","flat","mtime","unixfs","mode","treeBuilder","source","block","root","entry","isDirectory","wrapWithDirectory","childCount","Error","unwrapped","eachChildSeries","child","flush","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst DirFlat = require('./dir-flat')\nconst flatToShard = require('./flat-to-shard')\nconst Dir = require('./dir')\nconst toPathComponents = require('./utils/to-path-components')\nconst errCode = require('err-code')\nconst first = require('it-first')\n\nasync function addToTree (elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = null\n    parent.size = null\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\nasync function * treeBuilder (source, block, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options)\n\n  for await (const entry of source) {\n    if (!entry) {\n      continue\n    }\n\n    tree = await addToTree(entry, tree, options)\n\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry\n    }\n  }\n\n  if (!options.wrapWithDirectory) {\n    if (tree.childCount() > 1) {\n      throw errCode(new Error('detected more than one root'), 'ERR_MORE_THAN_ONE_ROOT')\n    }\n\n    const unwrapped = await first(tree.eachChildSeries())\n\n    if (!unwrapped) {\n      return\n    }\n\n    tree = unwrapped.child\n  }\n\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree\n    }\n\n    return\n  }\n\n  yield * tree.flush(tree.path, block)\n}\n\nmodule.exports = treeBuilder\n"]},"metadata":{},"sourceType":"script"}