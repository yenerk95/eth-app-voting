{"ast":null,"code":"'use strict';\n\nconst abortable = require('abortable-iterator');\n\nconst log = require('debug')('libp2p:stream:converter'); // Convert a duplex iterable into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\n\n\nmodule.exports = ({\n  stream,\n  remoteAddr,\n  localAddr\n}, options = {}) => {\n  const {\n    sink,\n    source\n  } = stream;\n  const maConn = {\n    async sink(source) {\n      if (options.signal) {\n        source = abortable(source, options.signal);\n      }\n\n      try {\n        await sink(source);\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err);\n        }\n      }\n\n      close();\n    },\n\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr,\n    remoteAddr,\n    timeline: {\n      open: Date.now()\n    },\n\n    close() {\n      sink([]);\n      close();\n    }\n\n  };\n\n  function close() {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now();\n    }\n  }\n\n  return maConn;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-utils/src/stream-to-ma-conn.js"],"names":["abortable","require","log","module","exports","stream","remoteAddr","localAddr","options","sink","source","maConn","signal","err","type","close","conn","timeline","open","Date","now"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAzB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAP,CAAiB,yBAAjB,CAAZ,C,CAEA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,MAAF;AAAUC,EAAAA,UAAV;AAAsBC,EAAAA;AAAtB,CAAD,EAAoCC,OAAO,GAAG,EAA9C,KAAqD;AACpE,QAAM;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAmBL,MAAzB;AACA,QAAMM,MAAM,GAAG;AACb,UAAMF,IAAN,CAAYC,MAAZ,EAAoB;AAClB,UAAIF,OAAO,CAACI,MAAZ,EAAoB;AAClBF,QAAAA,MAAM,GAAGV,SAAS,CAACU,MAAD,EAASF,OAAO,CAACI,MAAjB,CAAlB;AACD;;AAED,UAAI;AACF,cAAMH,IAAI,CAACC,MAAD,CAAV;AACD,OAFD,CAEE,OAAOG,GAAP,EAAY;AACZ;AACA,YAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1B;AACA;AACA;AACAZ,UAAAA,GAAG,CAACW,GAAD,CAAH;AACD;AACF;;AACDE,MAAAA,KAAK;AACN,KAlBY;;AAoBbL,IAAAA,MAAM,EAAEF,OAAO,CAACI,MAAR,GAAiBZ,SAAS,CAACU,MAAD,EAASF,OAAO,CAACI,MAAjB,CAA1B,GAAqDF,MApBhD;AAqBbM,IAAAA,IAAI,EAAEX,MArBO;AAsBbE,IAAAA,SAtBa;AAuBbD,IAAAA,UAvBa;AAwBbW,IAAAA,QAAQ,EAAE;AAAEC,MAAAA,IAAI,EAAEC,IAAI,CAACC,GAAL;AAAR,KAxBG;;AA0BbL,IAAAA,KAAK,GAAI;AACPN,MAAAA,IAAI,CAAC,EAAD,CAAJ;AACAM,MAAAA,KAAK;AACN;;AA7BY,GAAf;;AAgCA,WAASA,KAAT,GAAkB;AAChB,QAAI,CAACJ,MAAM,CAACM,QAAP,CAAgBF,KAArB,EAA4B;AAC1BJ,MAAAA,MAAM,CAACM,QAAP,CAAgBF,KAAhB,GAAwBI,IAAI,CAACC,GAAL,EAAxB;AACD;AACF;;AAED,SAAOT,MAAP;AACD,CAzCD","sourcesContent":["'use strict'\n\nconst abortable = require('abortable-iterator')\nconst log = require('debug')('libp2p:stream:converter')\n\n// Convert a duplex iterable into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nmodule.exports = ({ stream, remoteAddr, localAddr }, options = {}) => {\n  const { sink, source } = stream\n  const maConn = {\n    async sink (source) {\n      if (options.signal) {\n        source = abortable(source, options.signal)\n      }\n\n      try {\n        await sink(source)\n      } catch (err) {\n        // If aborted we can safely ignore\n        if (err.type !== 'aborted') {\n          // If the source errored the socket will already have been destroyed by\n          // toIterable.duplex(). If the socket errored it will already be\n          // destroyed. There's nothing to do here except log the error & return.\n          log(err)\n        }\n      }\n      close()\n    },\n\n    source: options.signal ? abortable(source, options.signal) : source,\n    conn: stream,\n    localAddr,\n    remoteAddr,\n    timeline: { open: Date.now() },\n\n    close () {\n      sink([])\n      close()\n    }\n  }\n\n  function close () {\n    if (!maConn.timeline.close) {\n      maConn.timeline.close = Date.now()\n    }\n  }\n\n  return maConn\n}\n"]},"metadata":{},"sourceType":"script"}