{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errCode = require('err-code');\n\nvar multibase = require('multibase');\n\nvar _require = require('streaming-iterables'),\n    parallelMap = _require.parallelMap,\n    collect = _require.collect;\n\nvar pipe = require('it-pipe');\n\nvar _require2 = require('../../utils'),\n    resolvePath = _require2.resolvePath,\n    withTimeoutOption = _require2.withTimeoutOption;\n\nvar _require3 = require('./pin-manager'),\n    PinTypes = _require3.PinTypes;\n\nvar PIN_RM_CONCURRENCY = 8;\n\nmodule.exports = function (_ref) {\n  var pinManager = _ref.pinManager,\n      gcLock = _ref.gcLock,\n      dag = _ref.dag;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _rm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths, options) {\n      var recursive, cids, release, results;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = options || {};\n              recursive = options.recursive !== false;\n\n              if (!(options.cidBase && !multibase.names.includes(options.cidBase))) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE');\n\n            case 4:\n              _context2.next = 6;\n              return resolvePath(dag, paths);\n\n            case 6:\n              cids = _context2.sent;\n              _context2.next = 9;\n              return gcLock.readLock();\n\n            case 9:\n              release = _context2.sent;\n              _context2.prev = 10;\n              _context2.next = 13;\n              return pipe(cids, parallelMap(PIN_RM_CONCURRENCY, /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid) {\n                  var _yield$pinManager$isP, pinned, reason;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return pinManager.isPinnedWithType(cid, PinTypes.all);\n\n                        case 2:\n                          _yield$pinManager$isP = _context.sent;\n                          pinned = _yield$pinManager$isP.pinned;\n                          reason = _yield$pinManager$isP.reason;\n\n                          if (pinned) {\n                            _context.next = 7;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" is not pinned\"));\n\n                        case 7:\n                          if (!(reason !== PinTypes.recursive && reason !== PinTypes.direct)) {\n                            _context.next = 9;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" is pinned indirectly under \").concat(reason));\n\n                        case 9:\n                          if (!(reason === PinTypes.recursive && !recursive)) {\n                            _context.next = 11;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" is pinned recursively\"));\n\n                        case 11:\n                          return _context.abrupt(\"return\", cid);\n\n                        case 12:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()), collect);\n\n            case 13:\n              results = _context2.sent;\n              // update the pin sets in memory\n              results.forEach(function (cid) {\n                if (recursive && pinManager.recursivePins.has(cid.toString())) {\n                  pinManager.recursivePins.delete(cid.toString());\n                } else {\n                  pinManager.directPins.delete(cid.toString());\n                }\n              }); // persist updated pin sets to datastore\n\n              _context2.next = 17;\n              return pinManager.flushPins();\n\n            case 17:\n              return _context2.abrupt(\"return\", results.map(function (cid) {\n                return {\n                  cid: cid\n                };\n              }));\n\n            case 18:\n              _context2.prev = 18;\n              release();\n              return _context2.finish(18);\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[10,, 18, 21]]);\n    }));\n\n    function rm(_x, _x2) {\n      return _rm.apply(this, arguments);\n    }\n\n    return rm;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/rm.js"],"names":["errCode","require","multibase","parallelMap","collect","pipe","resolvePath","withTimeoutOption","PinTypes","PIN_RM_CONCURRENCY","module","exports","pinManager","gcLock","dag","paths","options","recursive","cidBase","names","includes","Error","cids","readLock","release","cid","isPinnedWithType","all","pinned","reason","direct","results","forEach","recursivePins","has","toString","delete","directPins","flushPins","map","rm"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst multibase = require('multibase')\nconst { parallelMap, collect } = require('streaming-iterables')\nconst pipe = require('it-pipe')\nconst { resolvePath, withTimeoutOption } = require('../../utils')\nconst { PinTypes } = require('./pin-manager')\n\nconst PIN_RM_CONCURRENCY = 8\n\nmodule.exports = ({ pinManager, gcLock, dag }) => {\n  return withTimeoutOption(async function rm (paths, options) {\n    options = options || {}\n\n    const recursive = options.recursive !== false\n\n    if (options.cidBase && !multibase.names.includes(options.cidBase)) {\n      throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE')\n    }\n\n    const cids = await resolvePath(dag, paths)\n    const release = await gcLock.readLock()\n\n    try {\n      // verify that each hash can be unpinned\n      const results = await pipe(\n        cids,\n        parallelMap(PIN_RM_CONCURRENCY, async cid => {\n          const { pinned, reason } = await pinManager.isPinnedWithType(cid, PinTypes.all)\n\n          if (!pinned) {\n            throw new Error(`${cid} is not pinned`)\n          }\n          if (reason !== PinTypes.recursive && reason !== PinTypes.direct) {\n            throw new Error(`${cid} is pinned indirectly under ${reason}`)\n          }\n          if (reason === PinTypes.recursive && !recursive) {\n            throw new Error(`${cid} is pinned recursively`)\n          }\n\n          return cid\n        }),\n        collect\n      )\n\n      // update the pin sets in memory\n      results.forEach(cid => {\n        if (recursive && pinManager.recursivePins.has(cid.toString())) {\n          pinManager.recursivePins.delete(cid.toString())\n        } else {\n          pinManager.directPins.delete(cid.toString())\n        }\n      })\n\n      // persist updated pin sets to datastore\n      await pinManager.flushPins()\n\n      return results.map(cid => ({ cid }))\n    } finally {\n      release()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}