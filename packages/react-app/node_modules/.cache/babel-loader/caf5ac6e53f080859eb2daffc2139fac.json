{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errCode = require('err-code');\n\nvar log = require('debug')('ipfs:mfs:mkdir');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar createNode = require('./utils/create-node');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar updateTree = require('./utils/update-tree');\n\nvar addLink = require('./utils/add-link');\n\nvar withMfsRoot = require('./utils/with-mfs-root');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null,\n  signal: undefined\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsMkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, options) {\n      var pathComponents, root, parent, trail, emptyDir, i, subPathComponents, subPath, newRootCid;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n\n              if (path) {\n                _context.next = 3;\n                break;\n              }\n\n              throw new Error('no path given to Mkdir');\n\n            case 3:\n              path = path.trim();\n\n              if (!(path === '/')) {\n                _context.next = 8;\n                break;\n              }\n\n              if (!options.parents) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 7:\n              throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n\n            case 8:\n              if (!(path.substring(0, 1) !== '/')) {\n                _context.next = 10;\n                break;\n              }\n\n              throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n\n            case 10:\n              log(\"Creating \".concat(path));\n              pathComponents = toPathComponents(path);\n\n              if (!(pathComponents[0] === 'ipfs')) {\n                _context.next = 14;\n                break;\n              }\n\n              throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n\n            case 14:\n              _context.next = 16;\n              return withMfsRoot(context, options);\n\n            case 16:\n              root = _context.sent;\n              trail = [];\n              _context.next = 20;\n              return createNode(context, 'directory', options);\n\n            case 20:\n              emptyDir = _context.sent;\n              i = 0;\n\n            case 22:\n              if (!(i <= pathComponents.length)) {\n                _context.next = 51;\n                break;\n              }\n\n              subPathComponents = pathComponents.slice(0, i);\n              subPath = \"/ipfs/\".concat(root, \"/\").concat(subPathComponents.join('/'));\n              _context.prev = 25;\n              _context.next = 28;\n              return exporter(subPath, context.ipld);\n\n            case 28:\n              parent = _context.sent;\n              log(\"\".concat(subPath, \" existed\"));\n              log(\"\".concat(subPath, \" had children \").concat(parent.node.Links.map(function (link) {\n                return link.Name;\n              })));\n\n              if (!(i === pathComponents.length)) {\n                _context.next = 35;\n                break;\n              }\n\n              if (!options.parents) {\n                _context.next = 34;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 34:\n              throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n\n            case 35:\n              trail.push({\n                name: parent.name,\n                cid: parent.cid\n              });\n              _context.next = 48;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](25);\n\n              if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!(i < pathComponents.length && !options.parents)) {\n                _context.next = 43;\n                break;\n              }\n\n              throw errCode(new Error(\"Intermediate directory path \".concat(subPath, \" does not exist, use the -p flag to create it\")), 'ERR_NOT_FOUND');\n\n            case 43:\n              _context.next = 45;\n              return addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options);\n\n            case 45:\n              _context.next = 48;\n              break;\n\n            case 47:\n              throw _context.t0;\n\n            case 48:\n              i++;\n              _context.next = 22;\n              break;\n\n            case 51:\n              _context.next = 53;\n              return updateTree(context, trail, options);\n\n            case 53:\n              newRootCid = _context.sent;\n              _context.next = 56;\n              return updateMfsRoot(context, newRootCid, options);\n\n            case 56:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[25, 38]]);\n    }));\n\n    function mfsMkdir(_x, _x2) {\n      return _mfsMkdir.apply(this, arguments);\n    }\n\n    return mfsMkdir;\n  }());\n};\n\nvar addEmptyDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, childName, emptyDir, parent, trail, options) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            log(\"Adding empty dir called \".concat(childName, \" to \").concat(parent.cid));\n            _context2.next = 3;\n            return addLink(context, {\n              parent: parent.node,\n              parentCid: parent.cid,\n              size: emptyDir.node.size,\n              cid: emptyDir.cid,\n              name: childName,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            });\n\n          case 3:\n            result = _context2.sent;\n            trail[trail.length - 1].cid = result.cid;\n            trail.push({\n              name: childName,\n              cid: emptyDir.cid\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function addEmptyDir(_x3, _x4, _x5, _x6, _x7, _x8) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/mkdir.js"],"names":["errCode","require","log","exporter","createNode","toPathComponents","updateMfsRoot","updateTree","addLink","withMfsRoot","applyDefaultOptions","withTimeoutOption","defaultOptions","parents","hashAlg","cidVersion","shardSplitThreshold","flush","mode","mtime","signal","undefined","module","exports","context","path","options","Error","trim","substring","pathComponents","root","trail","emptyDir","i","length","subPathComponents","slice","subPath","join","ipld","parent","node","Links","map","link","Name","push","name","cid","code","addEmptyDir","newRootCid","mfsMkdir","childName","parentCid","size","result"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst log = require('debug')('ipfs:mfs:mkdir')\nconst exporter = require('ipfs-unixfs-exporter')\nconst createNode = require('./utils/create-node')\nconst toPathComponents = require('./utils/to-path-components')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst updateTree = require('./utils/update-tree')\nconst addLink = require('./utils/add-link')\nconst withMfsRoot = require('./utils/with-mfs-root')\nconst applyDefaultOptions = require('./utils/apply-default-options')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsMkdir (path, options) {\n    options = applyDefaultOptions(options, defaultOptions)\n\n    if (!path) {\n      throw new Error('no path given to Mkdir')\n    }\n\n    path = path.trim()\n\n    if (path === '/') {\n      if (options.parents) {\n        return\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    log(`Creating ${path}`)\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH')\n    }\n\n    const root = await withMfsRoot(context, options)\n    let parent\n    const trail = []\n    const emptyDir = await createNode(context, 'directory', options)\n\n    // make sure the containing folder exists, creating it if necessary\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i)\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`\n\n      try {\n        parent = await exporter(subPath, context.ipld)\n        log(`${subPath} existed`)\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`)\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS')\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        })\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND')\n          }\n\n          // add the intermediate directory\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options)\n        } else {\n          throw err\n        }\n      }\n    }\n\n    // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n\n    // update the tree from the leaf to the root\n    const newRootCid = await updateTree(context, trail, options)\n\n    // Update the MFS record with the new CID for the root of the tree\n    await updateMfsRoot(context, newRootCid, options)\n  })\n}\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`)\n\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  })\n\n  trail[trail.length - 1].cid = result.cid\n\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  })\n}\n"]},"metadata":{},"sourceType":"script"}