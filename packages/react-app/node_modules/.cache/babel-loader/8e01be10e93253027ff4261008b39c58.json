{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar protobuf = require('protons');\n\nvar keysPBM = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/asn1');\n\nrequire('node-forge/lib/pbe');\n\nvar forge = require('node-forge/lib/forge');\n\nvar errcode = require('err-code');\n\nexports = module.exports;\nvar supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))\n};\nexports.supportedKeys = supportedKeys;\nexports.keysPBM = keysPBM;\nvar ErrMissingSecp256K1 = {\n  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',\n  code: 'ERR_MISSING_PACKAGE'\n};\n\nfunction typeToKey(type) {\n  var key = supportedKeys[type.toLowerCase()];\n\n  if (!key) {\n    var supported = Object.keys(supportedKeys).join(' / ');\n    throw errcode(new Error(\"invalid or unsupported key type \".concat(type, \". Must be \").concat(supported)), 'ERR_UNSUPPORTED_KEY_TYPE');\n  }\n\n  return key;\n}\n\nexports.keyStretcher = require('./key-stretcher');\nexports.generateEphemeralKeyPair = require('./ephemeral-keys'); // Generates a keypair of the given type and bitsize\n\nexports.generateKeyPair = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, bits) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", typeToKey(type).generateKeyPair(bits));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\n\n\nexports.generateKeyPairFromSeed = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(type, seed, bits) {\n    var key;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // eslint-disable-line require-await\n            key = typeToKey(type);\n\n            if (!(type.toLowerCase() !== 'ed25519')) {\n              _context2.next = 3;\n              break;\n            }\n\n            throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n\n          case 3:\n            return _context2.abrupt(\"return\", key.generateKeyPairFromSeed(seed, bits));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // Converts a protobuf serialized public key into its\n// representative object\n\n\nexports.unmarshalPublicKey = function (buf) {\n  var decoded = keysPBM.PublicKey.decode(buf);\n  var data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n      }\n\n    default:\n      typeToKey(decoded.Type);\n    // throws because type is not supported\n  }\n}; // Converts a public key object into a protobuf serialized public key\n\n\nexports.marshalPublicKey = function (key, type) {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n}; // Converts a protobuf serialized private key into its\n// representative object\n\n\nexports.unmarshalPrivateKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(buf) {\n    var decoded, data;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // eslint-disable-line require-await\n            decoded = keysPBM.PrivateKey.decode(buf);\n            data = decoded.Data;\n            _context3.t0 = decoded.Type;\n            _context3.next = _context3.t0 === keysPBM.KeyType.RSA ? 5 : _context3.t0 === keysPBM.KeyType.Ed25519 ? 6 : _context3.t0 === keysPBM.KeyType.Secp256k1 ? 7 : 12;\n            break;\n\n          case 5:\n            return _context3.abrupt(\"return\", supportedKeys.rsa.unmarshalRsaPrivateKey(data));\n\n          case 6:\n            return _context3.abrupt(\"return\", supportedKeys.ed25519.unmarshalEd25519PrivateKey(data));\n\n          case 7:\n            if (!supportedKeys.secp256k1) {\n              _context3.next = 11;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data));\n\n          case 11:\n            throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n\n          case 12:\n            typeToKey(decoded.Type);\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x6) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Converts a private key object into a protobuf serialized private key\n\n\nexports.marshalPrivateKey = function (key, type) {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n};\n\nexports.import = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(pem, password) {\n    var key, der;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            // eslint-disable-line require-await\n            key = forge.pki.decryptRsaPrivateKey(pem, password);\n\n            if (!(key === null)) {\n              _context4.next = 3;\n              break;\n            }\n\n            throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM');\n\n          case 3:\n            der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n            der = Buffer.from(der.getBytes(), 'binary');\n            return _context4.abrupt(\"return\", supportedKeys.rsa.unmarshalRsaPrivateKey(der));\n\n          case 6:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x7, _x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/index.js"],"names":["require","Buffer","protobuf","keysPBM","forge","errcode","exports","module","supportedKeys","rsa","ed25519","secp256k1","ErrMissingSecp256K1","message","code","typeToKey","type","key","toLowerCase","supported","Object","keys","join","Error","keyStretcher","generateEphemeralKeyPair","generateKeyPair","bits","generateKeyPairFromSeed","seed","unmarshalPublicKey","buf","decoded","PublicKey","decode","data","Data","Type","KeyType","RSA","unmarshalRsaPublicKey","Ed25519","unmarshalEd25519PublicKey","Secp256k1","unmarshalSecp256k1PublicKey","marshalPublicKey","bytes","unmarshalPrivateKey","PrivateKey","unmarshalRsaPrivateKey","unmarshalEd25519PrivateKey","unmarshalSecp256k1PrivateKey","marshalPrivateKey","import","pem","password","pki","decryptRsaPrivateKey","der","asn1","toDer","privateKeyToAsn1","from","getBytes"],"mappings":"AAAA;;;;;;eAEmBA,OAAO,CAAC,QAAD,C;IAAlBC,M,YAAAA,M;;AACR,IAAMC,QAAQ,GAAGF,OAAO,CAAC,SAAD,CAAxB;;AACA,IAAMG,OAAO,GAAGD,QAAQ,CAACF,OAAO,CAAC,cAAD,CAAR,CAAxB;;AACAA,OAAO,CAAC,qBAAD,CAAP;;AACAA,OAAO,CAAC,oBAAD,CAAP;;AACA,IAAMI,KAAK,GAAGJ,OAAO,CAAC,sBAAD,CAArB;;AACA,IAAMK,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AAEAM,OAAO,GAAGC,MAAM,CAACD,OAAjB;AAEA,IAAME,aAAa,GAAG;AACpBC,EAAAA,GAAG,EAAET,OAAO,CAAC,aAAD,CADQ;AAEpBU,EAAAA,OAAO,EAAEV,OAAO,CAAC,iBAAD,CAFI;AAGpBW,EAAAA,SAAS,EAAEX,OAAO,CAAC,mBAAD,CAAP,CAA6BG,OAA7B,EAAsCH,OAAO,CAAC,iBAAD,CAA7C;AAHS,CAAtB;AAMAM,OAAO,CAACE,aAAR,GAAwBA,aAAxB;AACAF,OAAO,CAACH,OAAR,GAAkBA,OAAlB;AAEA,IAAMS,mBAAmB,GAAG;AAC1BC,EAAAA,OAAO,EAAE,4DADiB;AAE1BC,EAAAA,IAAI,EAAE;AAFoB,CAA5B;;AAKA,SAASC,SAAT,CAAoBC,IAApB,EAA0B;AACxB,MAAMC,GAAG,GAAGT,aAAa,CAACQ,IAAI,CAACE,WAAL,EAAD,CAAzB;;AACA,MAAI,CAACD,GAAL,EAAU;AACR,QAAME,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYb,aAAZ,EAA2Bc,IAA3B,CAAgC,KAAhC,CAAlB;AACA,UAAMjB,OAAO,CAAC,IAAIkB,KAAJ,2CAA6CP,IAA7C,uBAA8DG,SAA9D,EAAD,EAA6E,0BAA7E,CAAb;AACD;;AACD,SAAOF,GAAP;AACD;;AAEDX,OAAO,CAACkB,YAAR,GAAuBxB,OAAO,CAAC,iBAAD,CAA9B;AACAM,OAAO,CAACmB,wBAAR,GAAmCzB,OAAO,CAAC,kBAAD,CAA1C,C,CAEA;;AACAM,OAAO,CAACoB,eAAR;AAAA,sEAA0B,iBAAOV,IAAP,EAAaW,IAAb;AAAA;AAAA;AAAA;AAAA;AAAA,6CACjBZ,SAAS,CAACC,IAAD,CAAT,CAAgBU,eAAhB,CAAgCC,IAAhC,CADiB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAA1B;;AAAA;AAAA;AAAA;AAAA,I,CAIA;AACA;;;AACArB,OAAO,CAACsB,uBAAR;AAAA,uEAAkC,kBAAOZ,IAAP,EAAaa,IAAb,EAAmBF,IAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACxDV,YAAAA,GAD0B,GACpBF,SAAS,CAACC,IAAD,CADW;;AAAA,kBAE5BA,IAAI,CAACE,WAAL,OAAuB,SAFK;AAAA;AAAA;AAAA;;AAAA,kBAGxBb,OAAO,CAAC,IAAIkB,KAAJ,CAAU,2DAAV,CAAD,EAAyE,qCAAzE,CAHiB;;AAAA;AAAA,8CAKzBN,GAAG,CAACW,uBAAJ,CAA4BC,IAA5B,EAAkCF,IAAlC,CALyB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAlC;;AAAA;AAAA;AAAA;AAAA,I,CAQA;AACA;;;AACArB,OAAO,CAACwB,kBAAR,GAA6B,UAACC,GAAD,EAAS;AACpC,MAAMC,OAAO,GAAG7B,OAAO,CAAC8B,SAAR,CAAkBC,MAAlB,CAAyBH,GAAzB,CAAhB;AACA,MAAMI,IAAI,GAAGH,OAAO,CAACI,IAArB;;AAEA,UAAQJ,OAAO,CAACK,IAAhB;AACE,SAAKlC,OAAO,CAACmC,OAAR,CAAgBC,GAArB;AACE,aAAO/B,aAAa,CAACC,GAAd,CAAkB+B,qBAAlB,CAAwCL,IAAxC,CAAP;;AACF,SAAKhC,OAAO,CAACmC,OAAR,CAAgBG,OAArB;AACE,aAAOjC,aAAa,CAACE,OAAd,CAAsBgC,yBAAtB,CAAgDP,IAAhD,CAAP;;AACF,SAAKhC,OAAO,CAACmC,OAAR,CAAgBK,SAArB;AACE,UAAInC,aAAa,CAACG,SAAlB,EAA6B;AAC3B,eAAOH,aAAa,CAACG,SAAd,CAAwBiC,2BAAxB,CAAoDT,IAApD,CAAP;AACD,OAFD,MAEO;AACL,cAAM9B,OAAO,CAAC,IAAIkB,KAAJ,CAAUX,mBAAmB,CAACC,OAA9B,CAAD,EAAyCD,mBAAmB,CAACE,IAA7D,CAAb;AACD;;AACH;AACEC,MAAAA,SAAS,CAACiB,OAAO,CAACK,IAAT,CAAT;AAAwB;AAZ5B;AAcD,CAlBD,C,CAoBA;;;AACA/B,OAAO,CAACuC,gBAAR,GAA2B,UAAC5B,GAAD,EAAMD,IAAN,EAAe;AACxCA,EAAAA,IAAI,GAAG,CAACA,IAAI,IAAI,KAAT,EAAgBE,WAAhB,EAAP;AACAH,EAAAA,SAAS,CAACC,IAAD,CAAT,CAFwC,CAExB;;AAChB,SAAOC,GAAG,CAAC6B,KAAX;AACD,CAJD,C,CAMA;AACA;;;AACAxC,OAAO,CAACyC,mBAAR;AAAA,uEAA8B,kBAAOhB,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiB;AACvCC,YAAAA,OADsB,GACZ7B,OAAO,CAAC6C,UAAR,CAAmBd,MAAnB,CAA0BH,GAA1B,CADY;AAEtBI,YAAAA,IAFsB,GAEfH,OAAO,CAACI,IAFO;AAAA,2BAIpBJ,OAAO,CAACK,IAJY;AAAA,8CAKrBlC,OAAO,CAACmC,OAAR,CAAgBC,GALK,wBAOrBpC,OAAO,CAACmC,OAAR,CAAgBG,OAPK,wBASrBtC,OAAO,CAACmC,OAAR,CAAgBK,SATK;AAAA;;AAAA;AAAA,8CAMjBnC,aAAa,CAACC,GAAd,CAAkBwC,sBAAlB,CAAyCd,IAAzC,CANiB;;AAAA;AAAA,8CAQjB3B,aAAa,CAACE,OAAd,CAAsBwC,0BAAtB,CAAiDf,IAAjD,CARiB;;AAAA;AAAA,iBAUpB3B,aAAa,CAACG,SAVM;AAAA;AAAA;AAAA;;AAAA,8CAWfH,aAAa,CAACG,SAAd,CAAwBwC,4BAAxB,CAAqDhB,IAArD,CAXe;;AAAA;AAAA,kBAahB9B,OAAO,CAAC,IAAIkB,KAAJ,CAAUX,mBAAmB,CAACC,OAA9B,CAAD,EAAyCD,mBAAmB,CAACE,IAA7D,CAbS;;AAAA;AAgBxBC,YAAAA,SAAS,CAACiB,OAAO,CAACK,IAAT,CAAT;;AAhBwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAA9B;;AAAA;AAAA;AAAA;AAAA,I,CAoBA;;;AACA/B,OAAO,CAAC8C,iBAAR,GAA4B,UAACnC,GAAD,EAAMD,IAAN,EAAe;AACzCA,EAAAA,IAAI,GAAG,CAACA,IAAI,IAAI,KAAT,EAAgBE,WAAhB,EAAP;AACAH,EAAAA,SAAS,CAACC,IAAD,CAAT,CAFyC,CAEzB;;AAChB,SAAOC,GAAG,CAAC6B,KAAX;AACD,CAJD;;AAMAxC,OAAO,CAAC+C,MAAR;AAAA,uEAAiB,kBAAOC,GAAP,EAAYC,QAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2B;AACpCtC,YAAAA,GADS,GACHb,KAAK,CAACoD,GAAN,CAAUC,oBAAV,CAA+BH,GAA/B,EAAoCC,QAApC,CADG;;AAAA,kBAEXtC,GAAG,KAAK,IAFG;AAAA;AAAA;AAAA;;AAAA,kBAGPZ,OAAO,CAAC,IAAIkB,KAAJ,CAAU,yEAAV,CAAD,EAAuF,wBAAvF,CAHA;;AAAA;AAKXmC,YAAAA,GALW,GAKLtD,KAAK,CAACuD,IAAN,CAAWC,KAAX,CAAiBxD,KAAK,CAACoD,GAAN,CAAUK,gBAAV,CAA2B5C,GAA3B,CAAjB,CALK;AAMfyC,YAAAA,GAAG,GAAGzD,MAAM,CAAC6D,IAAP,CAAYJ,GAAG,CAACK,QAAJ,EAAZ,EAA4B,QAA5B,CAAN;AANe,8CAORvD,aAAa,CAACC,GAAd,CAAkBwC,sBAAlB,CAAyCS,GAAzC,CAPQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAjB;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst protobuf = require('protons')\nconst keysPBM = protobuf(require('./keys.proto'))\nrequire('node-forge/lib/asn1')\nrequire('node-forge/lib/pbe')\nconst forge = require('node-forge/lib/forge')\nconst errcode = require('err-code')\n\nexports = module.exports\n\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))\n}\n\nexports.supportedKeys = supportedKeys\nexports.keysPBM = keysPBM\n\nconst ErrMissingSecp256K1 = {\n  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',\n  code: 'ERR_MISSING_PACKAGE'\n}\n\nfunction typeToKey (type) {\n  const key = supportedKeys[type.toLowerCase()]\n  if (!key) {\n    const supported = Object.keys(supportedKeys).join(' / ')\n    throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), 'ERR_UNSUPPORTED_KEY_TYPE')\n  }\n  return key\n}\n\nexports.keyStretcher = require('./key-stretcher')\nexports.generateEphemeralKeyPair = require('./ephemeral-keys')\n\n// Generates a keypair of the given type and bitsize\nexports.generateKeyPair = async (type, bits) => { // eslint-disable-line require-await\n  return typeToKey(type).generateKeyPair(bits)\n}\n\n// Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\nexports.generateKeyPairFromSeed = async (type, seed, bits) => { // eslint-disable-line require-await\n  const key = typeToKey(type)\n  if (type.toLowerCase() !== 'ed25519') {\n    throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE')\n  }\n  return key.generateKeyPairFromSeed(seed, bits)\n}\n\n// Converts a protobuf serialized public key into its\n// representative object\nexports.unmarshalPublicKey = (buf) => {\n  const decoded = keysPBM.PublicKey.decode(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data)\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code)\n      }\n    default:\n      typeToKey(decoded.Type) // throws because type is not supported\n  }\n}\n\n// Converts a public key object into a protobuf serialized public key\nexports.marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\n// Converts a protobuf serialized private key into its\n// representative object\nexports.unmarshalPrivateKey = async (buf) => { // eslint-disable-line require-await\n  const decoded = keysPBM.PrivateKey.decode(buf)\n  const data = decoded.Data\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data)\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data)\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data)\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code)\n      }\n    default:\n      typeToKey(decoded.Type) // throws because type is not supported\n  }\n}\n\n// Converts a private key object into a protobuf serialized private key\nexports.marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase()\n  typeToKey(type) // check type\n  return key.bytes\n}\n\nexports.import = async (pem, password) => { // eslint-disable-line require-await\n  const key = forge.pki.decryptRsaPrivateKey(pem, password)\n  if (key === null) {\n    throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM')\n  }\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key))\n  der = Buffer.from(der.getBytes(), 'binary')\n  return supportedKeys.rsa.unmarshalRsaPrivateKey(der)\n}\n"]},"metadata":{},"sourceType":"script"}