{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar connect = require('it-ws/client');\n\nvar mafmt = require('mafmt');\n\nvar withIs = require('class-is');\n\nvar toUri = require('multiaddr-to-uri');\n\nvar _require = require('abortable-iterator'),\n    AbortError = _require.AbortError;\n\nvar log = require('debug')('libp2p:websockets');\n\nvar _createListener = require('./listener');\n\nvar toConnection = require('./socket-to-conn');\n\nvar _require2 = require('./constants'),\n    CODE_CIRCUIT = _require2.CODE_CIRCUIT,\n    CODE_P2P = _require2.CODE_P2P;\n/**\n * @class WebSockets\n */\n\n\nvar WebSockets = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  function WebSockets(_ref) {\n    var upgrader = _ref.upgrader;\n\n    _classCallCheck(this, WebSockets);\n\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  _createClass(WebSockets, [{\n    key: \"dial\",\n    value: function () {\n      var _dial = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ma) {\n        var options,\n            socket,\n            maConn,\n            conn,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                log('dialing %s', ma);\n                _context.next = 4;\n                return this._connect(ma, options);\n\n              case 4:\n                socket = _context.sent;\n                maConn = toConnection(socket, {\n                  remoteAddr: ma,\n                  signal: options.signal\n                });\n                log('new outbound connection %s', maConn.remoteAddr);\n                _context.next = 9;\n                return this._upgrader.upgradeOutbound(maConn);\n\n              case 9:\n                conn = _context.sent;\n                log('outbound connection %s upgraded', maConn.remoteAddr);\n                return _context.abrupt(\"return\", conn);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function dial(_x) {\n        return _dial.apply(this, arguments);\n      }\n\n      return dial;\n    }()\n    /**\n     * @private\n     * @param {Multiaddr} ma\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] Used to abort dial requests\n     * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ma) {\n        var options,\n            cOpts,\n            rawSocket,\n            onAbort,\n            abort,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n                if (!(options.signal && options.signal.aborted)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new AbortError();\n\n              case 3:\n                cOpts = ma.toOptions();\n                log('dialing %s:%s', cOpts.host, cOpts.port);\n                rawSocket = connect(toUri(ma), Object.assign({\n                  binary: true\n                }, options));\n\n                if (options.signal) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                _context2.next = 9;\n                return rawSocket.connected();\n\n              case 9:\n                log('connected %s', ma);\n                return _context2.abrupt(\"return\", rawSocket);\n\n              case 11:\n                abort = new Promise(function (resolve, reject) {\n                  onAbort = function onAbort() {\n                    reject(new AbortError());\n                    rawSocket.close();\n                  }; // Already aborted?\n\n\n                  if (options.signal.aborted) return onAbort();\n                  options.signal.addEventListener('abort', onAbort);\n                });\n                _context2.prev = 12;\n                _context2.next = 15;\n                return Promise.race([abort, rawSocket.connected()]);\n\n              case 15:\n                _context2.prev = 15;\n                options.signal.removeEventListener('abort', onAbort);\n                return _context2.finish(15);\n\n              case 18:\n                log('connected %s', ma);\n                return _context2.abrupt(\"return\", rawSocket);\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[12,, 15, 18]]);\n      }));\n\n      function _connect(_x2) {\n        return _connect2.apply(this, arguments);\n      }\n\n      return _connect;\n    }()\n    /**\n     * Creates a Websockets listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     * @param {object} [options]\n     * @param {http.Server} [options.server] A pre-created Node.js HTTP/S server.\n     * @param {function (Connection)} handler\n     * @returns {Listener} A Websockets listener\n     */\n\n  }, {\n    key: \"createListener\",\n    value: function createListener() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var handler = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      return _createListener({\n        handler: handler,\n        upgrader: this._upgrader\n      }, options);\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid Websockets addresses\n     * @param {Multiaddr[]} multiaddrs\n     * @returns {Multiaddr[]} Valid Websockets multiaddrs\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n      return multiaddrs.filter(function (ma) {\n        if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n          return false;\n        }\n\n        return mafmt.WebSockets.matches(ma.decapsulateCode(CODE_P2P)) || mafmt.WebSocketsSecure.matches(ma.decapsulateCode(CODE_P2P));\n      });\n    }\n  }]);\n\n  return WebSockets;\n}();\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-websockets/src/index.js"],"names":["connect","require","mafmt","withIs","toUri","AbortError","log","createListener","toConnection","CODE_CIRCUIT","CODE_P2P","WebSockets","upgrader","Error","_upgrader","ma","options","_connect","socket","maConn","remoteAddr","signal","upgradeOutbound","conn","aborted","cOpts","toOptions","host","port","rawSocket","Object","assign","binary","connected","abort","Promise","resolve","reject","onAbort","close","addEventListener","race","removeEventListener","handler","multiaddrs","Array","isArray","filter","protoCodes","includes","matches","decapsulateCode","WebSocketsSecure","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst connect = require('it-ws/client')\nconst mafmt = require('mafmt')\nconst withIs = require('class-is')\nconst toUri = require('multiaddr-to-uri')\nconst { AbortError } = require('abortable-iterator')\n\nconst log = require('debug')('libp2p:websockets')\n\nconst createListener = require('./listener')\nconst toConnection = require('./socket-to-conn')\nconst { CODE_CIRCUIT, CODE_P2P } = require('./constants')\n\n/**\n * @class WebSockets\n */\nclass WebSockets {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  constructor ({ upgrader }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')\n    }\n    this._upgrader = upgrader\n  }\n\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n  async dial (ma, options = {}) {\n    log('dialing %s', ma)\n\n    const socket = await this._connect(ma, options)\n    const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await this._upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n  async _connect (ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options))\n\n    if (!options.signal) {\n      await rawSocket.connected()\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        rawSocket.close()\n      }\n\n      // Already aborted?\n      if (options.signal.aborted) return onAbort()\n      options.signal.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, rawSocket.connected()])\n    } finally {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   * @param {object} [options]\n   * @param {http.Server} [options.server] A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n  createListener (options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    return createListener({ handler, upgrader: this._upgrader }, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false\n      }\n\n      return mafmt.WebSockets.matches(ma.decapsulateCode(CODE_P2P)) ||\n        mafmt.WebSocketsSecure.matches(ma.decapsulateCode(CODE_P2P))\n    })\n  }\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n})\n"]},"metadata":{},"sourceType":"script"}