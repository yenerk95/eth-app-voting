{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst AddressBook = require('./address-book');\n\nconst KeyBook = require('./key-book');\n\nconst MetadataBook = require('./metadata-book');\n\nconst ProtoBook = require('./proto-book');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors');\n/**\n * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\n\n\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Array<Address>} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {Array<string>} protocols peer's supported protocols.\n   */\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    super();\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n\n    this.addressBook = new AddressBook(this);\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n\n    this.keyBook = new KeyBook(this);\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n\n    this.metadataBook = new MetadataBook(this);\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n\n    this.protoBook = new ProtoBook(this);\n  }\n  /**\n   * Start the PeerStore.\n   */\n\n\n  start() {}\n  /**\n   * Stop the PeerStore.\n   */\n\n\n  stop() {}\n  /**\n   * Get all the stored information of every peer.\n   * @returns {Map<string, Peer>}\n   */\n\n\n  get peers() {\n    const storedPeers = new Set([...this.addressBook.data.keys(), ...this.keyBook.data.keys(), ...this.protoBook.data.keys(), ...this.metadataBook.data.keys()]);\n    const peersData = new Map();\n    storedPeers.forEach(idStr => {\n      peersData.set(idStr, this.get(PeerId.createFromCID(idStr)));\n    });\n    return peersData;\n  }\n  /**\n   * Delete the information of the given peer in every book.\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n\n\n  delete(peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId);\n    const keyDeleted = this.keyBook.delete(peerId);\n    const protocolsDeleted = this.protoBook.delete(peerId);\n    const metadataDeleted = this.metadataBook.delete(peerId);\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;\n  }\n  /**\n   * Get the stored information of a given peer.\n   * @param {PeerId} peerId\n   * @returns {Peer}\n   */\n\n\n  get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String());\n    const addresses = this.addressBook.get(peerId);\n    const metadata = this.metadataBook.get(peerId);\n    const protocols = this.protoBook.get(peerId);\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined;\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    };\n  }\n\n}\n\nmodule.exports = PeerStore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/peer-store/index.js"],"names":["errcode","require","debug","log","error","EventEmitter","PeerId","AddressBook","KeyBook","MetadataBook","ProtoBook","ERR_INVALID_PARAMETERS","PeerStore","constructor","addressBook","keyBook","metadataBook","protoBook","start","stop","peers","storedPeers","Set","data","keys","peersData","Map","forEach","idStr","set","get","createFromCID","delete","peerId","addressesDeleted","keyDeleted","protocolsDeleted","metadataDeleted","isPeerId","Error","id","toB58String","addresses","metadata","protocols","undefined","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('libp2p:peer-store')\nlog.error = debug('libp2p:peer-store:error')\n\nconst { EventEmitter } = require('events')\nconst PeerId = require('peer-id')\n\nconst AddressBook = require('./address-book')\nconst KeyBook = require('./key-book')\nconst MetadataBook = require('./metadata-book')\nconst ProtoBook = require('./proto-book')\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors')\n\n/**\n * Responsible for managing known peers, as well as their addresses, protocols and metadata.\n * @fires PeerStore#peer Emitted when a new peer is added.\n * @fires PeerStore#change:protocols Emitted when a known peer supports a different set of protocols.\n * @fires PeerStore#change:multiaddrs Emitted when a known peer has a different set of multiaddrs.\n * @fires PeerStore#change:pubkey Emitted emitted when a peer's public key is known.\n * @fires PeerStore#change:metadata Emitted when the known metadata of a peer change.\n */\nclass PeerStore extends EventEmitter {\n  /**\n   * Peer object\n   * @typedef {Object} Peer\n   * @property {PeerId} id peer's peer-id instance.\n   * @property {Array<Address>} addresses peer's addresses containing its multiaddrs and metadata.\n   * @property {Array<string>} protocols peer's supported protocols.\n   */\n\n  /**\n   * @constructor\n   */\n  constructor () {\n    super()\n\n    /**\n     * AddressBook containing a map of peerIdStr to Address.\n     */\n    this.addressBook = new AddressBook(this)\n\n    /**\n     * KeyBook containing a map of peerIdStr to their PeerId with public keys.\n     */\n    this.keyBook = new KeyBook(this)\n\n    /**\n     * MetadataBook containing a map of peerIdStr to their metadata Map.\n     */\n    this.metadataBook = new MetadataBook(this)\n\n    /**\n     * ProtoBook containing a map of peerIdStr to supported protocols.\n     */\n    this.protoBook = new ProtoBook(this)\n  }\n\n  /**\n   * Start the PeerStore.\n   */\n  start () {}\n\n  /**\n   * Stop the PeerStore.\n   */\n  stop () {}\n\n  /**\n   * Get all the stored information of every peer.\n   * @returns {Map<string, Peer>}\n   */\n  get peers () {\n    const storedPeers = new Set([\n      ...this.addressBook.data.keys(),\n      ...this.keyBook.data.keys(),\n      ...this.protoBook.data.keys(),\n      ...this.metadataBook.data.keys()\n    ])\n\n    const peersData = new Map()\n    storedPeers.forEach((idStr) => {\n      peersData.set(idStr, this.get(PeerId.createFromCID(idStr)))\n    })\n\n    return peersData\n  }\n\n  /**\n   * Delete the information of the given peer in every book.\n   * @param {PeerId} peerId\n   * @returns {boolean} true if found and removed\n   */\n  delete (peerId) {\n    const addressesDeleted = this.addressBook.delete(peerId)\n    const keyDeleted = this.keyBook.delete(peerId)\n    const protocolsDeleted = this.protoBook.delete(peerId)\n    const metadataDeleted = this.metadataBook.delete(peerId)\n\n    return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted\n  }\n\n  /**\n   * Get the stored information of a given peer.\n   * @param {PeerId} peerId\n   * @returns {Peer}\n   */\n  get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = this.keyBook.data.get(peerId.toB58String())\n    const addresses = this.addressBook.get(peerId)\n    const metadata = this.metadataBook.get(peerId)\n    const protocols = this.protoBook.get(peerId)\n\n    if (!id && !addresses && !metadata && !protocols) {\n      return undefined\n    }\n\n    return {\n      id: id || peerId,\n      addresses: addresses || [],\n      protocols: protocols || [],\n      metadata: metadata\n    }\n  }\n}\n\nmodule.exports = PeerStore\n"]},"metadata":{},"sourceType":"script"}