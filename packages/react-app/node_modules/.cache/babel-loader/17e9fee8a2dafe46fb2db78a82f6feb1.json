{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar errCode = require('err-code');\n\nvar _require = require('./errors'),\n    messages = _require.messages,\n    codes = _require.codes;\n\nvar all = require('it-all');\n\nvar pAny = require('p-any');\n\nmodule.exports = function (node) {\n  var routers = node._modules.contentRouting || [];\n  var dht = node._dht; // If we have the dht, make it first\n\n  if (dht) {\n    routers.unshift(dht);\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] How long the query should run\n     * @param {number} [options.maxNumProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findProviders: function findProviders(key, options) {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var result, _iterator, _step, peer;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (routers.length) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                _context2.next = 4;\n                return _awaitAsyncGenerator(pAny(routers.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(router) {\n                    var provs;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return all(router.findProviders(key, options));\n\n                          case 2:\n                            provs = _context.sent;\n\n                            if (!(!provs || !provs.length)) {\n                              _context.next = 5;\n                              break;\n                            }\n\n                            throw errCode(new Error('not found'), 'NOT_FOUND');\n\n                          case 5:\n                            return _context.abrupt(\"return\", provs);\n\n                          case 6:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }())));\n\n              case 4:\n                result = _context2.sent;\n                _iterator = _createForOfIteratorHelper(result);\n                _context2.prev = 6;\n\n                _iterator.s();\n\n              case 8:\n                if ((_step = _iterator.n()).done) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                peer = _step.value;\n                _context2.next = 12;\n                return peer;\n\n              case 12:\n                _context2.next = 8;\n                break;\n\n              case 14:\n                _context2.next = 19;\n                break;\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](6);\n\n                _iterator.e(_context2.t0);\n\n              case 19:\n                _context2.prev = 19;\n\n                _iterator.f();\n\n                return _context2.finish(19);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[6, 16, 19, 22]]);\n      }))();\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n    provide: function provide(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (routers.length) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                return _context3.abrupt(\"return\", Promise.all(routers.map(function (router) {\n                  return router.provide(key);\n                })));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Store the given key/value pair in the DHT.\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n    put: function put(key, value, options) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!node.isStarted() || !dht.isStarted)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context4.abrupt(\"return\", dht.put(key, value, options));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<{from: PeerId, val: Buffer}>}\n     */\n    get: function get(key, options) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(!node.isStarted() || !dht.isStarted)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context5.abrupt(\"return\", dht.get(key, options));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     * @param {Buffer} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    getMany: function getMany(key, nVals, options) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(!node.isStarted() || !dht.isStarted)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context6.abrupt(\"return\", dht.getMany(key, nVals, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/content-routing.js"],"names":["errCode","require","messages","codes","all","pAny","module","exports","node","routers","_modules","contentRouting","dht","_dht","unshift","findProviders","key","options","length","Error","map","router","provs","result","peer","provide","Promise","put","value","isStarted","NOT_STARTED_YET","DHT_NOT_STARTED","get","getMany","nVals"],"mappings":"AAAA;;;;;;;;;;;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;eAC4BA,OAAO,CAAC,UAAD,C;IAA3BC,Q,YAAAA,Q;IAAUC,K,YAAAA,K;;AAElB,IAAMC,GAAG,GAAGH,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAMI,IAAI,GAAGJ,OAAO,CAAC,OAAD,CAApB;;AAEAK,MAAM,CAACC,OAAP,GAAiB,UAACC,IAAD,EAAU;AACzB,MAAMC,OAAO,GAAGD,IAAI,CAACE,QAAL,CAAcC,cAAd,IAAgC,EAAhD;AACA,MAAMC,GAAG,GAAGJ,IAAI,CAACK,IAAjB,CAFyB,CAIzB;;AACA,MAAID,GAAJ,EAAS;AACPH,IAAAA,OAAO,CAACK,OAAR,CAAgBF,GAAhB;AACD;;AAED,SAAO;AACL;;;;;;;;;;AAUQG,IAAAA,aAXH,yBAWkBC,GAXlB,EAWuBC,OAXvB,EAWgC;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBAC9BR,OAAO,CAACS,MADsB;AAAA;AAAA;AAAA;;AAAA,sBAE3BlB,OAAO,CAAC,IAAImB,KAAJ,CAAU,8BAAV,CAAD,EAA4C,sBAA5C,CAFoB;;AAAA;AAAA;AAAA,4CAKdd,IAAI,CACvBI,OAAO,CAACW,GAAR;AAAA,sFAAY,iBAAOC,MAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCACUjB,GAAG,CAACiB,MAAM,CAACN,aAAP,CAAqBC,GAArB,EAA0BC,OAA1B,CAAD,CADb;;AAAA;AACJK,4BAAAA,KADI;;AAAA,kCAGN,CAACA,KAAD,IAAU,CAACA,KAAK,CAACJ,MAHX;AAAA;AAAA;AAAA;;AAAA,kCAIFlB,OAAO,CAAC,IAAImB,KAAJ,CAAU,WAAV,CAAD,EAAyB,WAAzB,CAJL;;AAAA;AAAA,6DAMHG,KANG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAZ;;AAAA;AAAA;AAAA;AAAA,oBADuB,CALU;;AAAA;AAK7BC,gBAAAA,MAL6B;AAAA,uDAgBhBA,MAhBgB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBxBC,gBAAAA,IAhBwB;AAAA;AAiBjC,uBAAMA,IAAN;;AAjBiC;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBpC,KA9BI;;AAgCL;;;;;;;AAOMC,IAAAA,OAvCD,mBAuCUT,GAvCV,EAuCe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACbP,OAAO,CAACS,MADK;AAAA;AAAA;AAAA;;AAAA,sBAEVlB,OAAO,CAAC,IAAImB,KAAJ,CAAU,8BAAV,CAAD,EAA4C,sBAA5C,CAFG;;AAAA;AAAA,kDAKXO,OAAO,CAACtB,GAAR,CAAYK,OAAO,CAACW,GAAR,CAAY,UAACC,MAAD;AAAA,yBAAYA,MAAM,CAACI,OAAP,CAAeT,GAAf,CAAZ;AAAA,iBAAZ,CAAZ,CALW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMnB,KA7CI;;AA+CL;;;;;;;;AAQMW,IAAAA,GAvDD,eAuDMX,GAvDN,EAuDWY,KAvDX,EAuDkBX,OAvDlB,EAuD2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAC1B,CAACT,IAAI,CAACqB,SAAL,EAAD,IAAqB,CAACjB,GAAG,CAACiB,SADA;AAAA;AAAA;AAAA;;AAAA,sBAEtB7B,OAAO,CAAC,IAAImB,KAAJ,CAAUjB,QAAQ,CAAC4B,eAAnB,CAAD,EAAsC3B,KAAK,CAAC4B,eAA5C,CAFe;;AAAA;AAAA,kDAKvBnB,GAAG,CAACe,GAAJ,CAAQX,GAAR,EAAaY,KAAb,EAAoBX,OAApB,CALuB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAM/B,KA7DI;;AA+DL;;;;;;;;AAQMe,IAAAA,GAvED,eAuEMhB,GAvEN,EAuEWC,OAvEX,EAuEoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACnB,CAACT,IAAI,CAACqB,SAAL,EAAD,IAAqB,CAACjB,GAAG,CAACiB,SADP;AAAA;AAAA;AAAA;;AAAA,sBAEf7B,OAAO,CAAC,IAAImB,KAAJ,CAAUjB,QAAQ,CAAC4B,eAAnB,CAAD,EAAsC3B,KAAK,CAAC4B,eAA5C,CAFQ;;AAAA;AAAA,kDAKhBnB,GAAG,CAACoB,GAAJ,CAAQhB,GAAR,EAAaC,OAAb,CALgB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMxB,KA7EI;;AA+EL;;;;;;;;AAQMgB,IAAAA,OAvFD,mBAuFUjB,GAvFV,EAuFekB,KAvFf,EAuFsBjB,OAvFtB,EAuF+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAC9B,CAACT,IAAI,CAACqB,SAAL,EAAD,IAAqB,CAACjB,GAAG,CAACiB,SADI;AAAA;AAAA;AAAA;;AAAA,sBAE1B7B,OAAO,CAAC,IAAImB,KAAJ,CAAUjB,QAAQ,CAAC4B,eAAnB,CAAD,EAAsC3B,KAAK,CAAC4B,eAA5C,CAFmB;;AAAA;AAAA,kDAK3BnB,GAAG,CAACqB,OAAJ,CAAYjB,GAAZ,EAAiBkB,KAAjB,EAAwBjB,OAAxB,CAL2B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMnC;AA7FI,GAAP;AA+FD,CAxGD","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { messages, codes } = require('./errors')\n\nconst all = require('it-all')\nconst pAny = require('p-any')\n\nmodule.exports = (node) => {\n  const routers = node._modules.contentRouting || []\n  const dht = node._dht\n\n  // If we have the dht, make it first\n  if (dht) {\n    routers.unshift(dht)\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] How long the query should run\n     * @param {number} [options.maxNumProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async * findProviders (key, options) {\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n      }\n\n      const result = await pAny(\n        routers.map(async (router) => {\n          const provs = await all(router.findProviders(key, options))\n\n          if (!provs || !provs.length) {\n            throw errCode(new Error('not found'), 'NOT_FOUND')\n          }\n          return provs\n        })\n      )\n\n      for (const peer of result) {\n        yield peer\n      }\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n    async provide (key) { // eslint-disable-line require-await\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')\n      }\n\n      return Promise.all(routers.map((router) => router.provide(key)))\n    },\n\n    /**\n     * Store the given key/value pair in the DHT.\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n    async put (key, value, options) { // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n      }\n\n      return dht.put(key, value, options)\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<{from: PeerId, val: Buffer}>}\n     */\n    async get (key, options) { // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n      }\n\n      return dht.get(key, options)\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     * @param {Buffer} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany (key, nVals, options) { // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED)\n      }\n\n      return dht.getMany(key, nVals, options)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}