{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst Message = require('../types/message');\n\nconst WantType = Message.WantType;\n\nconst Wantlist = require('../types/wantlist');\n\nconst Ledger = require('./ledger');\n\nconst RequestQueue = require('./req-queue');\n\nconst TaskMerger = require('./task-merger');\n\nconst {\n  logger\n} = require('../utils'); // The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\n\n\nconst TARGET_MESSAGE_SIZE = 16 * 1024; // If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\n\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\n\nclass DecisionEngine {\n  constructor(peerId, blockstore, network, stats, opts) {\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts); // A list of of ledgers by their partner id\n\n    this.ledgerMap = new Map();\n    this._running = false; // Queue of want-have / want-block per peer\n\n    this._requestQueue = new RequestQueue(TaskMerger);\n  }\n\n  _processOpts(opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    };\n  }\n\n  _scheduleProcessTasks() {\n    setTimeout(() => {\n      this._processTasks();\n    });\n  } // Pull tasks off the request queue and send a message to the corresponding\n  // peer\n\n\n  async _processTasks() {\n    if (!this._running) {\n      return;\n    }\n\n    const {\n      peerId,\n      tasks,\n      pendingSize\n    } = this._requestQueue.popTasks(this._opts.targetMessageSize);\n\n    if (tasks.length === 0) {\n      return;\n    } // Create a new message\n\n\n    const msg = new Message(false); // Amount of data in the request queue still waiting to be popped\n\n    msg.setPendingBytes(pendingSize); // Split out want-blocks, want-haves and DONT_HAVEs\n\n    const blockCids = [];\n    const blockTasks = new Map();\n\n    for (const task of tasks) {\n      const cid = new CID(task.topic);\n\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid);\n          blockTasks.set(task.topic, task.data);\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid);\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid);\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids);\n\n    for (const [topic, taskData] of blockTasks) {\n      const blk = blocks.get(topic); // If the block was found (it has not been removed)\n\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(blk);\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          const cid = new CID(topic);\n          msg.addDontHave(cid);\n        }\n      }\n    } // If there's nothing in the message, bail out\n\n\n    if (msg.empty) {\n      this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n\n      this._scheduleProcessTasks();\n\n      return;\n    }\n\n    try {\n      // Send the message\n      await this.network.sendMessage(peerId, msg); // Peform sent message accounting\n\n      for (const block of blocks.values()) {\n        this.messageSent(peerId, block);\n      }\n    } catch (err) {\n      this._log.error(err);\n    } // Free the tasks up from the request queue\n\n\n    this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n\n    this._scheduleProcessTasks();\n  }\n\n  wantlistForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n\n    if (!this.ledgerMap.has(peerIdStr)) {\n      return new Map();\n    }\n\n    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries();\n  }\n\n  ledgerForPeer(peerId) {\n    const peerIdStr = peerId.toB58String();\n    const ledger = this.ledgerMap.get(peerIdStr);\n\n    if (!ledger) {\n      return null;\n    }\n\n    return {\n      peer: ledger.partner.toPrint(),\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    };\n  }\n\n  peers() {\n    return Array.from(this.ledgerMap.values()).map(l => l.partner);\n  } // Receive blocks either from an incoming message from the network, or from\n  // blocks being added by the client on the localhost (eg IPFS add)\n\n\n  receivedBlocks(blocks) {\n    if (!blocks.length) {\n      return;\n    } // For each connected peer, check if it wants the block we received\n\n\n    this.ledgerMap.forEach(ledger => {\n      blocks.forEach(block => {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid);\n\n        if (!want) {\n          return;\n        } // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n\n\n        const blockSize = block.data.length;\n\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid);\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }]);\n      });\n    });\n\n    this._scheduleProcessTasks();\n  } // Handle incoming messages\n\n\n  async messageReceived(peerId, msg) {\n    const ledger = this._findOrCreate(peerId);\n\n    if (msg.empty) {\n      return;\n    } // If the message has a full wantlist, clear the current wantlist\n\n\n    if (msg.full) {\n      ledger.wantlist = new Wantlist();\n    } // Record the amount of block data received\n\n\n    this._updateBlockAccounting(msg.blocks, ledger);\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks();\n\n      return;\n    } // Clear cancelled wants and add new wants to the ledger\n\n\n    const cancels = [];\n    const wants = [];\n    msg.wantlist.forEach(entry => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid);\n        cancels.push(entry.cid);\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType);\n        wants.push(entry);\n      }\n    });\n\n    this._cancelWants(peerId, cancels);\n\n    await this._addWants(peerId, wants);\n\n    this._scheduleProcessTasks();\n  }\n\n  _cancelWants(peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(), peerId);\n    }\n  }\n\n  async _addWants(peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid));\n    const tasks = [];\n\n    for (const want of wants) {\n      const id = want.cid.toString();\n      const blockSize = blockSizes.get(id); // If the block was not found\n\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          });\n        }\n      } else {\n        // The block was found, add it to the queue\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize); // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n\n\n        let entrySize = blockSize;\n\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid);\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        });\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks);\n    }\n  }\n\n  _sendAsBlock(wantType, blockSize) {\n    return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n  }\n\n  async _getBlockSizes(cids) {\n    const blocks = await this._getBlocks(cids);\n    return new Map([...blocks].map(([k, v]) => [k, v.data.length]));\n  }\n\n  async _getBlocks(cids) {\n    const res = new Map();\n    await Promise.all(cids.map(async cid => {\n      try {\n        const block = await this.blockstore.get(cid);\n        res.set(cid.toString(), block);\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e);\n        }\n      }\n    }));\n    return res;\n  }\n\n  _updateBlockAccounting(blocksMap, ledger) {\n    blocksMap.forEach(b => {\n      this._log('got block (%s bytes)', b.data.length);\n\n      ledger.receivedBytes(b.data.length);\n    });\n  } // Clear up all accounting things after message was sent\n\n\n  messageSent(peerId, block) {\n    const ledger = this._findOrCreate(peerId);\n\n    ledger.sentBytes(block ? block.data.length : 0);\n\n    if (block && block.cid) {\n      ledger.wantlist.remove(block.cid);\n    }\n  }\n\n  numBytesSentTo(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent;\n  }\n\n  numBytesReceivedFrom(peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv;\n  }\n\n  peerDisconnected(peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  _findOrCreate(peerId) {\n    const peerIdStr = peerId.toB58String();\n\n    if (this.ledgerMap.has(peerIdStr)) {\n      return this.ledgerMap.get(peerIdStr);\n    }\n\n    const l = new Ledger(peerId);\n    this.ledgerMap.set(peerIdStr, l);\n\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1);\n    }\n\n    return l;\n  }\n\n  start() {\n    this._running = true;\n  }\n\n  stop() {\n    this._running = false;\n  }\n\n}\n\nmodule.exports = DecisionEngine;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"names":["CID","require","Message","WantType","Wantlist","Ledger","RequestQueue","TaskMerger","logger","TARGET_MESSAGE_SIZE","MAX_SIZE_REPLACE_HAS_WITH_BLOCK","DecisionEngine","constructor","peerId","blockstore","network","stats","opts","_log","_stats","_opts","_processOpts","ledgerMap","Map","_running","_requestQueue","maxSizeReplaceHasWithBlock","targetMessageSize","_scheduleProcessTasks","setTimeout","_processTasks","tasks","pendingSize","popTasks","length","msg","setPendingBytes","blockCids","blockTasks","task","cid","topic","data","haveBlock","isWantBlock","push","set","addHave","addDontHave","blocks","_getBlocks","taskData","blk","get","addBlock","sendDontHave","empty","tasksDone","sendMessage","block","values","messageSent","err","error","wantlistForPeer","peerIdStr","toB58String","has","wantlist","sortedEntries","ledgerForPeer","ledger","peer","partner","toPrint","value","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","peers","Array","from","map","l","receivedBlocks","forEach","want","wantlistContains","blockSize","_sendAsBlock","wantType","entrySize","blockPresenceSize","pushTasks","toString","priority","size","messageReceived","_findOrCreate","full","_updateBlockAccounting","cancels","wants","entry","cancel","cancelWant","_cancelWants","_addWants","cids","c","remove","blockSizes","_getBlockSizes","w","id","Block","k","v","res","Promise","all","e","code","blocksMap","b","receivedBytes","sentBytes","numBytesSentTo","numBytesReceivedFrom","peerDisconnected","start","stop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\n\nconst Message = require('../types/message')\nconst WantType = Message.WantType\nconst Wantlist = require('../types/wantlist')\nconst Ledger = require('./ledger')\nconst RequestQueue = require('./req-queue')\nconst TaskMerger = require('./task-merger')\nconst { logger } = require('../utils')\n\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024\n\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024\n\nclass DecisionEngine {\n  constructor (peerId, blockstore, network, stats, opts) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n    this._opts = this._processOpts(opts)\n\n    // A list of of ledgers by their partner id\n    this.ledgerMap = new Map()\n    this._running = false\n\n    // Queue of want-have / want-block per peer\n    this._requestQueue = new RequestQueue(TaskMerger)\n  }\n\n  _processOpts (opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    }\n  }\n\n  _scheduleProcessTasks () {\n    setTimeout(() => {\n      this._processTasks()\n    })\n  }\n\n  // Pull tasks off the request queue and send a message to the corresponding\n  // peer\n  async _processTasks () {\n    if (!this._running) {\n      return\n    }\n\n    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize)\n\n    if (tasks.length === 0) {\n      return\n    }\n\n    // Create a new message\n    const msg = new Message(false)\n\n    // Amount of data in the request queue still waiting to be popped\n    msg.setPendingBytes(pendingSize)\n\n    // Split out want-blocks, want-haves and DONT_HAVEs\n    const blockCids = []\n    const blockTasks = new Map()\n    for (const task of tasks) {\n      const cid = new CID(task.topic)\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid)\n          blockTasks.set(task.topic, task.data)\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid)\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid)\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids)\n    for (const [topic, taskData] of blockTasks) {\n      const blk = blocks.get(topic)\n      // If the block was found (it has not been removed)\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(blk)\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          const cid = new CID(topic)\n          msg.addDontHave(cid)\n        }\n      }\n    }\n\n    // If there's nothing in the message, bail out\n    if (msg.empty) {\n      this._requestQueue.tasksDone(peerId, tasks)\n\n      // Trigger the next round of task processing\n      this._scheduleProcessTasks()\n\n      return\n    }\n\n    try {\n      // Send the message\n      await this.network.sendMessage(peerId, msg)\n\n      // Peform sent message accounting\n      for (const block of blocks.values()) {\n        this.messageSent(peerId, block)\n      }\n    } catch (err) {\n      this._log.error(err)\n    }\n\n    // Free the tasks up from the request queue\n    this._requestQueue.tasksDone(peerId, tasks)\n\n    // Trigger the next round of task processing\n    this._scheduleProcessTasks()\n  }\n\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (!this.ledgerMap.has(peerIdStr)) {\n      return new Map()\n    }\n\n    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries()\n  }\n\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (!ledger) {\n      return null\n    }\n    return {\n      peer: ledger.partner.toPrint(),\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  // Receive blocks either from an incoming message from the network, or from\n  // blocks being added by the client on the localhost (eg IPFS add)\n  receivedBlocks (blocks) {\n    if (!blocks.length) {\n      return\n    }\n\n    // For each connected peer, check if it wants the block we received\n    this.ledgerMap.forEach((ledger) => {\n      blocks.forEach((block) => {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid)\n        if (!want) {\n          return\n        }\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const blockSize = block.data.length\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }])\n      })\n    })\n\n    this._scheduleProcessTasks()\n  }\n\n  // Handle incoming messages\n  async messageReceived (peerId, msg) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return\n    }\n\n    // If the message has a full wantlist, clear the current wantlist\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    // Record the amount of block data received\n    this._updateBlockAccounting(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks()\n      return\n    }\n\n    // Clear cancelled wants and add new wants to the ledger\n    const cancels = []\n    const wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry.cid)\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(peerId, cancels)\n    await this._addWants(peerId, wants)\n\n    this._scheduleProcessTasks()\n  }\n\n  _cancelWants (peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(), peerId)\n    }\n  }\n\n  async _addWants (peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid))\n\n    const tasks = []\n    for (const want of wants) {\n      const id = want.cid.toString()\n      const blockSize = blockSizes.get(id)\n\n      // If the block was not found\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          })\n        }\n      } else {\n        // The block was found, add it to the queue\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        })\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks)\n    }\n  }\n\n  _sendAsBlock (wantType, blockSize) {\n    return wantType === WantType.Block ||\n      blockSize <= this._opts.maxSizeReplaceHasWithBlock\n  }\n\n  async _getBlockSizes (cids) {\n    const blocks = await this._getBlocks(cids)\n    return new Map([...blocks].map(([k, v]) => [k, v.data.length]))\n  }\n\n  async _getBlocks (cids) {\n    const res = new Map()\n    await Promise.all(cids.map(async (cid) => {\n      try {\n        const block = await this.blockstore.get(cid)\n        res.set(cid.toString(), block)\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e)\n        }\n      }\n    }))\n    return res\n  }\n\n  _updateBlockAccounting (blocksMap, ledger) {\n    blocksMap.forEach(b => {\n      this._log('got block (%s bytes)', b.data.length)\n      ledger.receivedBytes(b.data.length)\n    })\n  }\n\n  // Clear up all accounting things after message was sent\n  messageSent (peerId, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block ? block.data.length : 0)\n    if (block && block.cid) {\n      ledger.wantlist.remove(block.cid)\n    }\n  }\n\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  peerDisconnected (peerId) {\n    // if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (this.ledgerMap.has(peerIdStr)) {\n      return this.ledgerMap.get(peerIdStr)\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start () {\n    this._running = true\n  }\n\n  stop () {\n    this._running = false\n  }\n}\n\nmodule.exports = DecisionEngine\n"]},"metadata":{},"sourceType":"script"}