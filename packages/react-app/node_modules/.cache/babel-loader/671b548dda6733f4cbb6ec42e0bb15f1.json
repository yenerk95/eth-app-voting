{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst errcode = require('err-code');\n\nconst Message = require('../../message');\n\nconst utils = require('../../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerId, 'rpc:get-providers');\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n\n  return async function getProviders(peerId, msg) {\n    let cid;\n\n    try {\n      cid = new CID(msg.key);\n    } catch (err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID');\n    }\n\n    log('%s', cid.toBaseEncodedString());\n    const dsKey = utils.bufferToKey(cid.buffer);\n    const [has, peers, closer] = await Promise.all([dht.datastore.has(dsKey), dht.providers.getProviders(cid), dht._betterPeersToQuery(msg, peerId)]);\n    const providerPeers = peers.map(peerId => ({\n      id: peerId\n    }));\n    const closerPeers = closer.map(c => ({\n      id: c.id\n    }));\n\n    if (has) {\n      providerPeers.push({\n        id: dht.peerId\n      });\n    }\n\n    const response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n    if (providerPeers.length > 0) {\n      response.providerPeers = providerPeers;\n    }\n\n    if (closerPeers.length > 0) {\n      response.closerPeers = closerPeers;\n    }\n\n    log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length);\n    return response;\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"],"names":["CID","require","errcode","Message","utils","module","exports","dht","log","logger","peerId","getProviders","msg","cid","key","err","Error","message","toBaseEncodedString","dsKey","bufferToKey","buffer","has","peers","closer","Promise","all","datastore","providers","_betterPeersToQuery","providerPeers","map","id","closerPeers","c","push","response","type","clusterLevel","length"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AAEA,MAAME,OAAO,GAAGF,OAAO,CAAC,eAAD,CAAvB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,aAAD,CAArB;;AAEAI,MAAM,CAACC,OAAP,GAAkBC,GAAD,IAAS;AACxB,QAAMC,GAAG,GAAGJ,KAAK,CAACK,MAAN,CAAaF,GAAG,CAACG,MAAjB,EAAyB,mBAAzB,CAAZ;AAEA;;;;;;;;AAOA,SAAO,eAAeC,YAAf,CAA6BD,MAA7B,EAAqCE,GAArC,EAA0C;AAC/C,QAAIC,GAAJ;;AACA,QAAI;AACFA,MAAAA,GAAG,GAAG,IAAIb,GAAJ,CAAQY,GAAG,CAACE,GAAZ,CAAN;AACD,KAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,YAAMb,OAAO,CAAC,IAAIc,KAAJ,CAAW,gBAAeD,GAAG,CAACE,OAAQ,EAAtC,CAAD,EAA2C,iBAA3C,CAAb;AACD;;AAEDT,IAAAA,GAAG,CAAC,IAAD,EAAOK,GAAG,CAACK,mBAAJ,EAAP,CAAH;AACA,UAAMC,KAAK,GAAGf,KAAK,CAACgB,WAAN,CAAkBP,GAAG,CAACQ,MAAtB,CAAd;AAEA,UAAM,CAACC,GAAD,EAAMC,KAAN,EAAaC,MAAb,IAAuB,MAAMC,OAAO,CAACC,GAAR,CAAY,CAC7CnB,GAAG,CAACoB,SAAJ,CAAcL,GAAd,CAAkBH,KAAlB,CAD6C,EAE7CZ,GAAG,CAACqB,SAAJ,CAAcjB,YAAd,CAA2BE,GAA3B,CAF6C,EAG7CN,GAAG,CAACsB,mBAAJ,CAAwBjB,GAAxB,EAA6BF,MAA7B,CAH6C,CAAZ,CAAnC;AAMA,UAAMoB,aAAa,GAAGP,KAAK,CAACQ,GAAN,CAAWrB,MAAD,KAAa;AAAEsB,MAAAA,EAAE,EAAEtB;AAAN,KAAb,CAAV,CAAtB;AACA,UAAMuB,WAAW,GAAGT,MAAM,CAACO,GAAP,CAAYG,CAAD,KAAQ;AAAEF,MAAAA,EAAE,EAAEE,CAAC,CAACF;AAAR,KAAR,CAAX,CAApB;;AAEA,QAAIV,GAAJ,EAAS;AACPQ,MAAAA,aAAa,CAACK,IAAd,CAAmB;AACjBH,QAAAA,EAAE,EAAEzB,GAAG,CAACG;AADS,OAAnB;AAGD;;AAED,UAAM0B,QAAQ,GAAG,IAAIjC,OAAJ,CAAYS,GAAG,CAACyB,IAAhB,EAAsBzB,GAAG,CAACE,GAA1B,EAA+BF,GAAG,CAAC0B,YAAnC,CAAjB;;AAEA,QAAIR,aAAa,CAACS,MAAd,GAAuB,CAA3B,EAA8B;AAC5BH,MAAAA,QAAQ,CAACN,aAAT,GAAyBA,aAAzB;AACD;;AAED,QAAIG,WAAW,CAACM,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BH,MAAAA,QAAQ,CAACH,WAAT,GAAuBA,WAAvB;AACD;;AAEDzB,IAAAA,GAAG,CAAC,iCAAD,EAAoCsB,aAAa,CAACS,MAAlD,EAA0DN,WAAW,CAACM,MAAtE,CAAH;AACA,WAAOH,QAAP;AACD,GAtCD;AAuCD,CAjDD","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst errcode = require('err-code')\n\nconst Message = require('../../message')\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerId, 'rpc:get-providers')\n\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n  return async function getProviders (peerId, msg) {\n    let cid\n    try {\n      cid = new CID(msg.key)\n    } catch (err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID')\n    }\n\n    log('%s', cid.toBaseEncodedString())\n    const dsKey = utils.bufferToKey(cid.buffer)\n\n    const [has, peers, closer] = await Promise.all([\n      dht.datastore.has(dsKey),\n      dht.providers.getProviders(cid),\n      dht._betterPeersToQuery(msg, peerId)\n    ])\n\n    const providerPeers = peers.map((peerId) => ({ id: peerId }))\n    const closerPeers = closer.map((c) => ({ id: c.id }))\n\n    if (has) {\n      providerPeers.push({\n        id: dht.peerId\n      })\n    }\n\n    const response = new Message(msg.type, msg.key, msg.clusterLevel)\n\n    if (providerPeers.length > 0) {\n      response.providerPeers = providerPeers\n    }\n\n    if (closerPeers.length > 0) {\n      response.closerPeers = closerPeers\n    }\n\n    log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length)\n    return response\n  }\n}\n"]},"metadata":{},"sourceType":"script"}