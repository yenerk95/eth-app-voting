{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar Block = require('ipld-block');\n\nvar CID = require('cids');\n\nvar mergeOptions = require('merge-options');\n\nvar ipldDagCbor = require('ipld-dag-cbor');\n\nvar ipldDagPb = require('ipld-dag-pb');\n\nvar ipldRaw = require('ipld-raw');\n\nvar multicodec = require('multicodec');\n\nvar typical = require('typical');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('./util'),\n    extendIterator = _require2.extendIterator;\n\nvar IPLDResolver = /*#__PURE__*/function () {\n  function IPLDResolver(userOptions) {\n    _classCallCheck(this, IPLDResolver);\n\n    var options = mergeOptions(IPLDResolver.defaultOptions, userOptions);\n\n    if (!options.blockService) {\n      throw new Error('Missing blockservice');\n    }\n\n    this.bs = options.blockService; // Object with current list of active resolvers\n\n    this.resolvers = {};\n\n    if (typeof options.loadFormat !== 'function') {\n      this.loadFormat = function (codec) {\n        var codecName = multicodec.print[codec];\n        throw new Error(\"No resolver found for codec \\\"\".concat(codecName, \"\\\"\"));\n      };\n    } else {\n      this.loadFormat = options.loadFormat;\n    } // Enable all supplied formats\n\n\n    var _iterator4 = _createForOfIteratorHelper(options.formats),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var format = _step4.value;\n        this.addFormat(format);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  /**\n   * Add support for an IPLD Format.\n   *\n   * @param {Object} format - The implementation of an IPLD Format.\n   * @returns {this}\n   */\n\n\n  _createClass(IPLDResolver, [{\n    key: \"addFormat\",\n    value: function addFormat(format) {\n      var codec = format.codec;\n\n      if (this.resolvers[format.format]) {\n        var codecName = multicodec.print[codec];\n        throw new Error(\"Resolver already exists for codec \\\"\".concat(codecName, \"\\\"\"));\n      }\n\n      this.resolvers[codec] = format;\n      return this;\n    }\n    /**\n     * Remove support for an IPLD Format.\n     *\n     * @param {number} codec - The codec of the IPLD Format to remove.\n     * @returns {this}\n     */\n\n  }, {\n    key: \"removeFormat\",\n    value: function removeFormat(codec) {\n      if (this.resolvers[codec]) {\n        delete this.resolvers[codec];\n      }\n\n      return this;\n    }\n    /**\n     * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n     *\n     * @param {CID} cid - the CID the resolving starts.\n     * @param {string} path - the path that should be resolved.\n     * @param {Object} [options] -  Options is an object with the following properties.\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @returns {Iterable.<Promise.<{remainderPath: string, value}>>} - Returns an async iterator of all the IPLD Nodes that were traversed during the path resolving. Every element is an object with these fields:\n     *   - `remainderPath`: the part of the path that wasn’t resolved yet.\n     *   - `value`: the value where the resolved path points to. If further traversing is possible, then the value is a CID object linking to another IPLD Node. If it was possible to fully resolve the path, value is the value the path points to. So if you need the CID of the IPLD Node you’re currently at, just take the value of the previously returned IPLD Node.\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(cid, path, options) {\n      if (!CID.isCID(cid)) {\n        throw new Error('`cid` argument must be a CID');\n      }\n\n      if (typeof path !== 'string') {\n        throw new Error('`path` argument must be a string');\n      }\n\n      var generator = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var format, block, result, value;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(cid !== null)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                _context.next = 3;\n                return _awaitAsyncGenerator(this._getFormat(cid.codec));\n\n              case 3:\n                format = _context.sent;\n                _context.next = 6;\n                return _awaitAsyncGenerator(this.bs.get(cid, options));\n\n              case 6:\n                block = _context.sent;\n                result = format.resolver.resolve(block.data, path); // Prepare for the next iteration if there is a `remainderPath`\n\n                path = result.remainderPath;\n                value = result.value; // NOTE vmx 2018-11-29: Not all IPLD Formats return links as\n                // CIDs yet. Hence try to convert old style links to CIDs\n\n                if (Object.keys(value).length === 1 && '/' in value) {\n                  try {\n                    value = new CID(value['/']);\n                  } catch (_error) {\n                    value = null;\n                  }\n                }\n\n                cid = CID.isCID(value) ? value : null;\n                _context.next = 14;\n                return {\n                  remainderPath: path,\n                  value: value\n                };\n\n              case 14:\n                _context.next = 0;\n                break;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      })).bind(this);\n\n      return extendIterator(generator());\n    }\n    /**\n     * Get a node by CID.\n     *\n     * @param {CID} cid - The CID of the IPLD Node that should be retrieved.\n     * @param {Object} [options] -  Options is an object with the following properties.\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @returns {Promise.<Object>} - Returns a Promise with the IPLD Node that correspond to the given `cid`.\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cid, options) {\n        var block, format, node;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.bs.get(cid, options);\n\n              case 2:\n                block = _context2.sent;\n                _context2.next = 5;\n                return this._getFormat(block.cid.codec);\n\n              case 5:\n                format = _context2.sent;\n                node = format.util.deserialize(block.data);\n                return _context2.abrupt(\"return\", node);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x, _x2) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Get multiple nodes back from an array of CIDs.\n     *\n     * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be retrieved.\n     * @param {Object} [options] -  Options is an object with the following properties.\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @returns {Iterable.<Promise.<Object>>} - Returns an async iterator with the IPLD Nodes that correspond to the given `cids`.\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, options) {\n      if (!typical.isIterable(cids) || typeof cids === 'string' || Buffer.isBuffer(cids)) {\n        throw new Error('`cids` must be an iterable of CIDs');\n      }\n\n      var generator = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context3.prev = 2;\n                _iterator = _asyncIterator(cids);\n\n              case 4:\n                _context3.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context3.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context3.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context3.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                cid = _value;\n                _context3.next = 15;\n                return this.get(cid, options);\n\n              case 15:\n                _iteratorNormalCompletion = true;\n                _context3.next = 4;\n                break;\n\n              case 18:\n                _context3.next = 24;\n                break;\n\n              case 20:\n                _context3.prev = 20;\n                _context3.t0 = _context3[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context3.t0;\n\n              case 24:\n                _context3.prev = 24;\n                _context3.prev = 25;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                _context3.next = 29;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 29:\n                _context3.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context3.finish(29);\n\n              case 33:\n                return _context3.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 20, 24, 34], [25,, 29, 33]]);\n      })).bind(this);\n\n      return extendIterator(generator());\n    }\n    /**\n     * Stores the given IPLD Node of a recognized IPLD Format.\n     *\n     * @param {Object} node - The deserialized IPLD node that should be inserted.\n     * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.\n     * @param {Object} [userOptions] -  Options is an object with the following properties.\n     * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.\n     * @param {number} [userOptions.cidVersion=1] - The CID version to use.\n     * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.\n     * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @returns {Promise.<CID>} - Returns the CID of the serialized IPLD Nodes.\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(node, format, userOptions) {\n        var formatImpl, defaultOptions, options, cidOptions, serialized, cid, block;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(format === undefined)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('`put` requires a format');\n\n              case 2:\n                if (!(typeof format !== 'number')) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new Error('`format` parameter must be number (multicodec)');\n\n              case 4:\n                _context4.next = 6;\n                return this._getFormat(format);\n\n              case 6:\n                formatImpl = _context4.sent;\n                defaultOptions = {\n                  hashAlg: formatImpl.defaultHashAlg,\n                  cidVersion: 1,\n                  onlyHash: false\n                };\n                options = mergeOptions(defaultOptions, userOptions);\n                cidOptions = {\n                  cidVersion: options.cidVersion,\n                  hashAlg: options.hashAlg,\n                  onlyHash: options.onlyHash\n                };\n                serialized = formatImpl.util.serialize(node);\n                _context4.next = 13;\n                return formatImpl.util.cid(serialized, cidOptions);\n\n              case 13:\n                cid = _context4.sent;\n\n                if (options.onlyHash) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                block = new Block(serialized, cid);\n                _context4.next = 18;\n                return this.bs.put(block, options);\n\n              case 18:\n                return _context4.abrupt(\"return\", cid);\n\n              case 19:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function put(_x3, _x4, _x5) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Stores the given IPLD Nodes of a recognized IPLD Format.\n     *\n     * @param {Iterable.<Object>} nodes - Deserialized IPLD nodes that should be inserted.\n     * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.\n     * @param {Object} [userOptions] -  Options are applied to any of the `nodes` and is an object with the following properties.\n     * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.\n     * @param {number} [userOptions.cidVersion=1] - The CID version to use.\n     * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.\n     * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @returns {Iterable.<Promise.<CID>>} - Returns an async iterator with the CIDs of the serialized IPLD Nodes.\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(nodes, format, userOptions) {\n      if (!typical.isIterable(nodes) || typeof nodes === 'string' || Buffer.isBuffer(nodes)) {\n        throw new Error('`nodes` must be an iterable');\n      }\n\n      if (format === undefined) {\n        throw new Error('`put` requires a format');\n      }\n\n      if (typeof format !== 'number') {\n        throw new Error('`format` parameter must be number (multicodec)');\n      }\n\n      var options;\n      var formatImpl;\n\n      var generator = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, node, defaultOptions;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context5.prev = 2;\n                _iterator2 = _asyncIterator(nodes);\n\n              case 4:\n                _context5.next = 6;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 6:\n                _step2 = _context5.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context5.next = 10;\n                return _awaitAsyncGenerator(_step2.value);\n\n              case 10:\n                _value2 = _context5.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                node = _value2;\n\n                if (!(options === undefined)) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                _context5.next = 16;\n                return _awaitAsyncGenerator(this._getFormat(format));\n\n              case 16:\n                formatImpl = _context5.sent;\n                defaultOptions = {\n                  hashAlg: formatImpl.defaultHashAlg,\n                  cidVersion: 1,\n                  onlyHash: false\n                };\n                options = mergeOptions(defaultOptions, userOptions);\n\n              case 19:\n                _context5.next = 21;\n                return this.put(node, format, options);\n\n              case 21:\n                _iteratorNormalCompletion2 = true;\n                _context5.next = 4;\n                break;\n\n              case 24:\n                _context5.next = 30;\n                break;\n\n              case 26:\n                _context5.prev = 26;\n                _context5.t0 = _context5[\"catch\"](2);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context5.t0;\n\n              case 30:\n                _context5.prev = 30;\n                _context5.prev = 31;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context5.next = 35;\n                  break;\n                }\n\n                _context5.next = 35;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 35:\n                _context5.prev = 35;\n\n                if (!_didIteratorError2) {\n                  _context5.next = 38;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 38:\n                return _context5.finish(35);\n\n              case 39:\n                return _context5.finish(30);\n\n              case 40:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 26, 30, 40], [31,, 35, 39]]);\n      })).bind(this);\n\n      return extendIterator(generator());\n    }\n    /**\n     * Remove an IPLD Node by the given CID.\n     *\n     * @param {CID} cid - The CID of the IPLD Node that should be removed.\n     * @param {Object} [options] -  Options is an object with the following properties.\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @return {Promise.<CID>} The CID of the removed IPLD Node.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.bs.delete(cid, options));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function remove(_x6, _x7) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Remove IPLD Nodes by the given CIDs.\n     *\n     * Throws an error if any of the Blocks can’t be removed. This operation is\n     * *not* atomic, some Blocks might have already been removed.\n     *\n     * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be removed.\n     * @param {Object} [options] -  Options is an object with the following properties.\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @return {Iterable.<Promise.<CID>>} Returns an async iterator with the CIDs of the removed IPLD Nodes.\n     */\n\n  }, {\n    key: \"removeMany\",\n    value: function removeMany(cids, options) {\n      if (!typical.isIterable(cids) || typeof cids === 'string' || Buffer.isBuffer(cids)) {\n        throw new Error('`cids` must be an iterable of CIDs');\n      }\n\n      var generator = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, cid;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _iteratorNormalCompletion3 = true;\n                _didIteratorError3 = false;\n                _context7.prev = 2;\n                _iterator3 = _asyncIterator(cids);\n\n              case 4:\n                _context7.next = 6;\n                return _awaitAsyncGenerator(_iterator3.next());\n\n              case 6:\n                _step3 = _context7.sent;\n                _iteratorNormalCompletion3 = _step3.done;\n                _context7.next = 10;\n                return _awaitAsyncGenerator(_step3.value);\n\n              case 10:\n                _value3 = _context7.sent;\n\n                if (_iteratorNormalCompletion3) {\n                  _context7.next = 18;\n                  break;\n                }\n\n                cid = _value3;\n                _context7.next = 15;\n                return this.remove(cid, options);\n\n              case 15:\n                _iteratorNormalCompletion3 = true;\n                _context7.next = 4;\n                break;\n\n              case 18:\n                _context7.next = 24;\n                break;\n\n              case 20:\n                _context7.prev = 20;\n                _context7.t0 = _context7[\"catch\"](2);\n                _didIteratorError3 = true;\n                _iteratorError3 = _context7.t0;\n\n              case 24:\n                _context7.prev = 24;\n                _context7.prev = 25;\n\n                if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n                  _context7.next = 29;\n                  break;\n                }\n\n                _context7.next = 29;\n                return _awaitAsyncGenerator(_iterator3.return());\n\n              case 29:\n                _context7.prev = 29;\n\n                if (!_didIteratorError3) {\n                  _context7.next = 32;\n                  break;\n                }\n\n                throw _iteratorError3;\n\n              case 32:\n                return _context7.finish(29);\n\n              case 33:\n                return _context7.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[2, 20, 24, 34], [25,, 29, 33]]);\n      })).bind(this);\n\n      return extendIterator(generator());\n    }\n    /**\n     * Returns all the paths that can be resolved into.\n     *\n     * @param {Object} cid - The ID to get the paths from\n     * @param {string} [offsetPath=''] - the path to start to retrieve the other paths from.\n     * @param {Object} [userOptions]\n     * @param {number} [userOptions.recursive=false] - whether to get the paths recursively or not. `false` resolves only the paths of the given CID.\n     * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n     * @returns {Iterable.<Promise.<String>>} - Returns an async iterator with paths that can be resolved into\n     */\n\n  }, {\n    key: \"tree\",\n    value: function tree(cid, offsetPath, userOptions) {\n      var _this = this;\n\n      if (typeof offsetPath === 'object') {\n        userOptions = offsetPath;\n        offsetPath = undefined;\n      }\n\n      offsetPath = offsetPath || '';\n      var defaultOptions = {\n        recursive: false\n      };\n      var options = mergeOptions(defaultOptions, userOptions); // If a path is a link then follow it and return its CID\n\n      var maybeRecurse = /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(block, treePath) {\n          var format, result;\n          return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  _context8.next = 2;\n                  return _this._getFormat(block.cid.codec);\n\n                case 2:\n                  format = _context8.sent;\n                  result = format.resolver.resolve(block.data, treePath); // Something to follow recusively, hence push it into the queue\n\n                  if (!CID.isCID(result.value)) {\n                    _context8.next = 8;\n                    break;\n                  }\n\n                  return _context8.abrupt(\"return\", result.value);\n\n                case 8:\n                  return _context8.abrupt(\"return\", null);\n\n                case 9:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8);\n        }));\n\n        return function maybeRecurse(_x8, _x9) {\n          return _ref6.apply(this, arguments);\n        };\n      }();\n\n      var generator = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var treePaths, block, queue, basePath, _queue$shift, format, paths, treePath, fullPath;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                // The list of paths that will get returned\n                treePaths = []; // The current block, needed to call `isLink()` on every interation\n\n                // The list of items we want to follow recursively. The items are\n                // an object consisting of the CID and the currently already resolved\n                // path\n                queue = [{\n                  cid: cid,\n                  basePath: ''\n                }]; // The path that was already traversed\n\n              case 2:\n                if (!(treePaths.length > 0 || queue.length > 0)) {\n                  _context9.next = 28;\n                  break;\n                }\n\n                if (!(treePaths.length === 0 && queue.length > 0)) {\n                  _context9.next = 15;\n                  break;\n                }\n\n                _queue$shift = queue.shift();\n                cid = _queue$shift.cid;\n                basePath = _queue$shift.basePath;\n                _context9.next = 9;\n                return _awaitAsyncGenerator(this._getFormat(cid.codec));\n\n              case 9:\n                format = _context9.sent;\n                _context9.next = 12;\n                return _awaitAsyncGenerator(this.bs.get(cid, options));\n\n              case 12:\n                block = _context9.sent;\n                paths = format.resolver.tree(block.data);\n                treePaths.push.apply(treePaths, _toConsumableArray(paths));\n\n              case 15:\n                treePath = treePaths.shift();\n                fullPath = basePath + treePath; // Only follow links if recursion is intended\n\n                if (!options.recursive) {\n                  _context9.next = 22;\n                  break;\n                }\n\n                _context9.next = 20;\n                return _awaitAsyncGenerator(maybeRecurse(block, treePath));\n\n              case 20:\n                cid = _context9.sent;\n\n                if (cid !== null) {\n                  queue.push({\n                    cid: cid,\n                    basePath: fullPath + '/'\n                  });\n                }\n\n              case 22:\n                if (!(fullPath.startsWith(offsetPath) && fullPath.length > offsetPath.length)) {\n                  _context9.next = 26;\n                  break;\n                }\n\n                if (offsetPath.length > 0) {\n                  fullPath = fullPath.slice(offsetPath.length + 1);\n                }\n\n                _context9.next = 26;\n                return fullPath;\n\n              case 26:\n                _context9.next = 2;\n                break;\n\n              case 28:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      })).bind(this);\n\n      return extendIterator(generator());\n    }\n    /*           */\n\n    /* internals */\n\n    /*           */\n\n  }, {\n    key: \"_getFormat\",\n    value: function () {\n      var _getFormat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(codec) {\n        var constantName, format;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                // TODO vmx 2019-01-24: Once all CIDs support accessing the codec code\n                // instead of the name, remove this part\n                if (typeof codec === 'string') {\n                  constantName = codec.toUpperCase().replace(/-/g, '_');\n                  codec = multicodec[constantName];\n                }\n\n                if (!this.resolvers[codec]) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.resolvers[codec]);\n\n              case 3:\n                _context10.next = 5;\n                return this.loadFormat(codec);\n\n              case 5:\n                format = _context10.sent;\n                this.addFormat(format);\n                return _context10.abrupt(\"return\", format);\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _getFormat(_x10) {\n        return _getFormat2.apply(this, arguments);\n      }\n\n      return _getFormat;\n    }()\n  }]);\n\n  return IPLDResolver;\n}();\n/**\n * Default options for IPLD.\n */\n\n\nIPLDResolver.defaultOptions = {\n  formats: [ipldDagCbor, ipldDagPb, ipldRaw]\n};\nmodule.exports = IPLDResolver;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipld/src/index.js"],"names":["Block","require","CID","mergeOptions","ipldDagCbor","ipldDagPb","ipldRaw","multicodec","typical","Buffer","extendIterator","IPLDResolver","userOptions","options","defaultOptions","blockService","Error","bs","resolvers","loadFormat","codec","codecName","print","formats","format","addFormat","cid","path","isCID","generator","_getFormat","get","block","result","resolver","resolve","data","remainderPath","value","Object","keys","length","_error","bind","node","util","deserialize","cids","isIterable","isBuffer","undefined","formatImpl","hashAlg","defaultHashAlg","cidVersion","onlyHash","cidOptions","serialized","serialize","put","nodes","delete","remove","offsetPath","recursive","maybeRecurse","treePath","treePaths","queue","basePath","shift","paths","tree","push","fullPath","startsWith","slice","constantName","toUpperCase","replace","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Block = require('ipld-block')\nconst CID = require('cids')\nconst mergeOptions = require('merge-options')\nconst ipldDagCbor = require('ipld-dag-cbor')\nconst ipldDagPb = require('ipld-dag-pb')\nconst ipldRaw = require('ipld-raw')\nconst multicodec = require('multicodec')\nconst typical = require('typical')\nconst { Buffer } = require('buffer')\nconst { extendIterator } = require('./util')\n\nclass IPLDResolver {\n  constructor (userOptions) {\n    const options = mergeOptions(IPLDResolver.defaultOptions, userOptions)\n\n    if (!options.blockService) {\n      throw new Error('Missing blockservice')\n    }\n    this.bs = options.blockService\n\n    // Object with current list of active resolvers\n    this.resolvers = {}\n\n    if (typeof options.loadFormat !== 'function') {\n      this.loadFormat = (codec) => {\n        const codecName = multicodec.print[codec]\n        throw new Error(`No resolver found for codec \"${codecName}\"`)\n      }\n    } else {\n      this.loadFormat = options.loadFormat\n    }\n\n    // Enable all supplied formats\n    for (const format of options.formats) {\n      this.addFormat(format)\n    }\n  }\n\n  /**\n   * Add support for an IPLD Format.\n   *\n   * @param {Object} format - The implementation of an IPLD Format.\n   * @returns {this}\n   */\n  addFormat (format) {\n    const codec = format.codec\n    if (this.resolvers[format.format]) {\n      const codecName = multicodec.print[codec]\n      throw new Error(`Resolver already exists for codec \"${codecName}\"`)\n    }\n\n    this.resolvers[codec] = format\n\n    return this\n  }\n\n  /**\n   * Remove support for an IPLD Format.\n   *\n   * @param {number} codec - The codec of the IPLD Format to remove.\n   * @returns {this}\n   */\n  removeFormat (codec) {\n    if (this.resolvers[codec]) {\n      delete this.resolvers[codec]\n    }\n\n    return this\n  }\n\n  /**\n   * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n   *\n   * @param {CID} cid - the CID the resolving starts.\n   * @param {string} path - the path that should be resolved.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<{remainderPath: string, value}>>} - Returns an async iterator of all the IPLD Nodes that were traversed during the path resolving. Every element is an object with these fields:\n   *   - `remainderPath`: the part of the path that wasn’t resolved yet.\n   *   - `value`: the value where the resolved path points to. If further traversing is possible, then the value is a CID object linking to another IPLD Node. If it was possible to fully resolve the path, value is the value the path points to. So if you need the CID of the IPLD Node you’re currently at, just take the value of the previously returned IPLD Node.\n   */\n  resolve (cid, path, options) {\n    if (!CID.isCID(cid)) {\n      throw new Error('`cid` argument must be a CID')\n    }\n    if (typeof path !== 'string') {\n      throw new Error('`path` argument must be a string')\n    }\n\n    const generator = async function * () {\n      // End iteration if there isn't a CID to follow anymore\n      while (cid !== null) {\n        const format = await this._getFormat(cid.codec)\n\n        // get block\n        // use local resolver\n        // update path value\n        const block = await this.bs.get(cid, options)\n        const result = format.resolver.resolve(block.data, path)\n\n        // Prepare for the next iteration if there is a `remainderPath`\n        path = result.remainderPath\n        let value = result.value\n        // NOTE vmx 2018-11-29: Not all IPLD Formats return links as\n        // CIDs yet. Hence try to convert old style links to CIDs\n        if (Object.keys(value).length === 1 && '/' in value) {\n          try {\n            value = new CID(value['/'])\n          } catch (_error) {\n            value = null\n          }\n        }\n        cid = CID.isCID(value) ? value : null\n\n        yield {\n          remainderPath: path,\n          value\n        }\n      }\n    }.bind(this)\n\n    return extendIterator(generator())\n  }\n\n  /**\n   * Get a node by CID.\n   *\n   * @param {CID} cid - The CID of the IPLD Node that should be retrieved.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Promise.<Object>} - Returns a Promise with the IPLD Node that correspond to the given `cid`.\n   */\n  async get (cid, options) {\n    const block = await this.bs.get(cid, options)\n    const format = await this._getFormat(block.cid.codec)\n    const node = format.util.deserialize(block.data)\n\n    return node\n  }\n\n  /**\n   * Get multiple nodes back from an array of CIDs.\n   *\n   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be retrieved.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<Object>>} - Returns an async iterator with the IPLD Nodes that correspond to the given `cids`.\n   */\n  getMany (cids, options) {\n    if (!typical.isIterable(cids) || typeof cids === 'string' ||\n        Buffer.isBuffer(cids)) {\n      throw new Error('`cids` must be an iterable of CIDs')\n    }\n\n    const generator = async function * () {\n      for await (const cid of cids) {\n        yield this.get(cid, options)\n      }\n    }.bind(this)\n\n    return extendIterator(generator())\n  }\n\n  /**\n   * Stores the given IPLD Node of a recognized IPLD Format.\n   *\n   * @param {Object} node - The deserialized IPLD node that should be inserted.\n   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.\n   * @param {Object} [userOptions] -  Options is an object with the following properties.\n   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.\n   * @param {number} [userOptions.cidVersion=1] - The CID version to use.\n   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.\n   * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Promise.<CID>} - Returns the CID of the serialized IPLD Nodes.\n   */\n  async put (node, format, userOptions) {\n    if (format === undefined) {\n      throw new Error('`put` requires a format')\n    }\n    if (typeof format !== 'number') {\n      throw new Error('`format` parameter must be number (multicodec)')\n    }\n\n    const formatImpl = await this._getFormat(format)\n    const defaultOptions = {\n      hashAlg: formatImpl.defaultHashAlg,\n      cidVersion: 1,\n      onlyHash: false\n    }\n    const options = mergeOptions(defaultOptions, userOptions)\n\n    const cidOptions = {\n      cidVersion: options.cidVersion,\n      hashAlg: options.hashAlg,\n      onlyHash: options.onlyHash\n    }\n    const serialized = formatImpl.util.serialize(node)\n    const cid = await formatImpl.util.cid(serialized, cidOptions)\n\n    if (!options.onlyHash) {\n      const block = new Block(serialized, cid)\n      await this.bs.put(block, options)\n    }\n\n    return cid\n  }\n\n  /**\n   * Stores the given IPLD Nodes of a recognized IPLD Format.\n   *\n   * @param {Iterable.<Object>} nodes - Deserialized IPLD nodes that should be inserted.\n   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.\n   * @param {Object} [userOptions] -  Options are applied to any of the `nodes` and is an object with the following properties.\n   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.\n   * @param {number} [userOptions.cidVersion=1] - The CID version to use.\n   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.\n   * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<CID>>} - Returns an async iterator with the CIDs of the serialized IPLD Nodes.\n   */\n  putMany (nodes, format, userOptions) {\n    if (!typical.isIterable(nodes) || typeof nodes === 'string' ||\n        Buffer.isBuffer(nodes)) {\n      throw new Error('`nodes` must be an iterable')\n    }\n    if (format === undefined) {\n      throw new Error('`put` requires a format')\n    }\n    if (typeof format !== 'number') {\n      throw new Error('`format` parameter must be number (multicodec)')\n    }\n\n    let options\n    let formatImpl\n\n    const generator = async function * () {\n      for await (const node of nodes) {\n        // Lazy load the options not when the iterator is initialized, but\n        // when we hit the first iteration. This way the constructor can be\n        // a synchronous function.\n        if (options === undefined) {\n          formatImpl = await this._getFormat(format)\n          const defaultOptions = {\n            hashAlg: formatImpl.defaultHashAlg,\n            cidVersion: 1,\n            onlyHash: false\n          }\n          options = mergeOptions(defaultOptions, userOptions)\n        }\n\n        yield this.put(node, format, options)\n      }\n    }.bind(this)\n\n    return extendIterator(generator())\n  }\n\n  /**\n   * Remove an IPLD Node by the given CID.\n   *\n   * @param {CID} cid - The CID of the IPLD Node that should be removed.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @return {Promise.<CID>} The CID of the removed IPLD Node.\n   */\n  async remove (cid, options) { // eslint-disable-line require-await\n    return this.bs.delete(cid, options)\n  }\n\n  /**\n   * Remove IPLD Nodes by the given CIDs.\n   *\n   * Throws an error if any of the Blocks can’t be removed. This operation is\n   * *not* atomic, some Blocks might have already been removed.\n   *\n   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be removed.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @return {Iterable.<Promise.<CID>>} Returns an async iterator with the CIDs of the removed IPLD Nodes.\n   */\n  removeMany (cids, options) {\n    if (!typical.isIterable(cids) || typeof cids === 'string' ||\n        Buffer.isBuffer(cids)) {\n      throw new Error('`cids` must be an iterable of CIDs')\n    }\n\n    const generator = async function * () {\n      for await (const cid of cids) {\n        yield this.remove(cid, options)\n      }\n    }.bind(this)\n\n    return extendIterator(generator())\n  }\n\n  /**\n   * Returns all the paths that can be resolved into.\n   *\n   * @param {Object} cid - The ID to get the paths from\n   * @param {string} [offsetPath=''] - the path to start to retrieve the other paths from.\n   * @param {Object} [userOptions]\n   * @param {number} [userOptions.recursive=false] - whether to get the paths recursively or not. `false` resolves only the paths of the given CID.\n   * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<String>>} - Returns an async iterator with paths that can be resolved into\n   */\n  tree (cid, offsetPath, userOptions) {\n    if (typeof offsetPath === 'object') {\n      userOptions = offsetPath\n      offsetPath = undefined\n    }\n    offsetPath = offsetPath || ''\n\n    const defaultOptions = {\n      recursive: false\n    }\n    const options = mergeOptions(defaultOptions, userOptions)\n\n    // If a path is a link then follow it and return its CID\n    const maybeRecurse = async (block, treePath) => {\n      // A treepath we might want to follow recursively\n      const format = await this._getFormat(block.cid.codec)\n      const result = format.resolver.resolve(block.data, treePath)\n      // Something to follow recusively, hence push it into the queue\n      if (CID.isCID(result.value)) {\n        return result.value\n      } else {\n        return null\n      }\n    }\n\n    const generator = async function * () {\n      // The list of paths that will get returned\n      const treePaths = []\n      // The current block, needed to call `isLink()` on every interation\n      let block\n      // The list of items we want to follow recursively. The items are\n      // an object consisting of the CID and the currently already resolved\n      // path\n      const queue = [{ cid, basePath: '' }]\n      // The path that was already traversed\n      let basePath\n\n      // End of iteration if there aren't any paths left to return or\n      // if we don't want to traverse recursively and have already\n      // returne the first level\n      while (treePaths.length > 0 || queue.length > 0) {\n        // There aren't any paths left, get them from the given CID\n        if (treePaths.length === 0 && queue.length > 0) {\n          ({ cid, basePath } = queue.shift())\n          const format = await this._getFormat(cid.codec)\n          block = await this.bs.get(cid, options)\n\n          const paths = format.resolver.tree(block.data)\n          treePaths.push(...paths)\n        }\n\n        const treePath = treePaths.shift()\n        let fullPath = basePath + treePath\n\n        // Only follow links if recursion is intended\n        if (options.recursive) {\n          cid = await maybeRecurse(block, treePath)\n          if (cid !== null) {\n            queue.push({ cid, basePath: fullPath + '/' })\n          }\n        }\n\n        // Return it if it matches the given offset path, but is not the\n        // offset path itself\n        if (fullPath.startsWith(offsetPath) &&\n            fullPath.length > offsetPath.length) {\n          if (offsetPath.length > 0) {\n            fullPath = fullPath.slice(offsetPath.length + 1)\n          }\n\n          yield fullPath\n        }\n      }\n    }.bind(this)\n\n    return extendIterator(generator())\n  }\n\n  /*           */\n  /* internals */\n  /*           */\n  async _getFormat (codec) {\n    // TODO vmx 2019-01-24: Once all CIDs support accessing the codec code\n    // instead of the name, remove this part\n    if (typeof codec === 'string') {\n      const constantName = codec.toUpperCase().replace(/-/g, '_')\n      codec = multicodec[constantName]\n    }\n\n    if (this.resolvers[codec]) {\n      return this.resolvers[codec]\n    }\n\n    // If not supported, attempt to dynamically load this format\n    const format = await this.loadFormat(codec)\n    this.addFormat(format)\n    return format\n  }\n}\n\n/**\n * Default options for IPLD.\n */\nIPLDResolver.defaultOptions = {\n  formats: [ipldDagCbor, ipldDagPb, ipldRaw]\n}\n\nmodule.exports = IPLDResolver\n"]},"metadata":{},"sourceType":"script"}