{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst BufferList = require('bl/BufferList');\n\nconst varintEncode = require('./varint-encode');\n\nconst MIN_POOL_SIZE = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n\nconst DEFAULT_POOL_SIZE = 10 * 1024;\n\nfunction encode(options) {\n  options = options || {};\n  const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);\n  const encodeLength = options.lengthEncoder || varintEncode;\n  return source => async function* () {\n    let pool = Buffer.alloc(poolSize);\n    let poolOffset = 0;\n\n    for await (const chunk of source) {\n      encodeLength(chunk.length, pool, poolOffset);\n      const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);\n      poolOffset += encodeLength.bytes;\n\n      if (pool.length - poolOffset < MIN_POOL_SIZE) {\n        pool = Buffer.alloc(poolSize);\n        poolOffset = 0;\n      }\n\n      yield new BufferList().append(encodedLength).append(chunk); // yield Buffer.concat([encodedLength, chunk])\n    }\n  }();\n}\n\nencode.single = (chunk, options) => {\n  options = options || {};\n  const encodeLength = options.lengthEncoder || varintEncode;\n  return new BufferList([encodeLength(chunk.length), chunk]);\n};\n\nmodule.exports = encode;\nmodule.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;\nmodule.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/it-length-prefixed/src/encode.js"],"names":["Buffer","require","BufferList","varintEncode","MIN_POOL_SIZE","DEFAULT_POOL_SIZE","encode","options","poolSize","Math","max","minPoolSize","encodeLength","lengthEncoder","source","pool","alloc","poolOffset","chunk","length","encodedLength","slice","bytes","append","single","module","exports"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AAEA,MAAMG,aAAa,GAAG,CAAtB,C,CAAwB;;AACxB,MAAMC,iBAAiB,GAAG,KAAK,IAA/B;;AAEA,SAASC,MAAT,CAAiBC,OAAjB,EAA0B;AACxBA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAMC,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASH,OAAO,CAACC,QAAR,IAAoBH,iBAA7B,EAAgDE,OAAO,CAACI,WAAR,IAAuBP,aAAvE,CAAjB;AACA,QAAMQ,YAAY,GAAGL,OAAO,CAACM,aAAR,IAAyBV,YAA9C;AAEA,SAAOW,MAAM,IAAK,mBAAoB;AACpC,QAAIC,IAAI,GAAGf,MAAM,CAACgB,KAAP,CAAaR,QAAb,CAAX;AACA,QAAIS,UAAU,GAAG,CAAjB;;AAEA,eAAW,MAAMC,KAAjB,IAA0BJ,MAA1B,EAAkC;AAChCF,MAAAA,YAAY,CAACM,KAAK,CAACC,MAAP,EAAeJ,IAAf,EAAqBE,UAArB,CAAZ;AACA,YAAMG,aAAa,GAAGL,IAAI,CAACM,KAAL,CAAWJ,UAAX,EAAuBA,UAAU,GAAGL,YAAY,CAACU,KAAjD,CAAtB;AACAL,MAAAA,UAAU,IAAIL,YAAY,CAACU,KAA3B;;AAEA,UAAIP,IAAI,CAACI,MAAL,GAAcF,UAAd,GAA2Bb,aAA/B,EAA8C;AAC5CW,QAAAA,IAAI,GAAGf,MAAM,CAACgB,KAAP,CAAaR,QAAb,CAAP;AACAS,QAAAA,UAAU,GAAG,CAAb;AACD;;AAED,YAAM,IAAIf,UAAJ,GAAiBqB,MAAjB,CAAwBH,aAAxB,EAAuCG,MAAvC,CAA8CL,KAA9C,CAAN,CAVgC,CAWhC;AACD;AACF,GAjBgB,EAAjB;AAkBD;;AAEDZ,MAAM,CAACkB,MAAP,GAAgB,CAACN,KAAD,EAAQX,OAAR,KAAoB;AAClCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAMK,YAAY,GAAGL,OAAO,CAACM,aAAR,IAAyBV,YAA9C;AACA,SAAO,IAAID,UAAJ,CAAe,CAACU,YAAY,CAACM,KAAK,CAACC,MAAP,CAAb,EAA6BD,KAA7B,CAAf,CAAP;AACD,CAJD;;AAMAO,MAAM,CAACC,OAAP,GAAiBpB,MAAjB;AACAmB,MAAM,CAACC,OAAP,CAAetB,aAAf,GAA+BA,aAA/B;AACAqB,MAAM,CAACC,OAAP,CAAerB,iBAAf,GAAmCA,iBAAnC","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst BufferList = require('bl/BufferList')\nconst varintEncode = require('./varint-encode')\n\nconst MIN_POOL_SIZE = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\nconst DEFAULT_POOL_SIZE = 10 * 1024\n\nfunction encode (options) {\n  options = options || {}\n\n  const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE)\n  const encodeLength = options.lengthEncoder || varintEncode\n\n  return source => (async function * () {\n    let pool = Buffer.alloc(poolSize)\n    let poolOffset = 0\n\n    for await (const chunk of source) {\n      encodeLength(chunk.length, pool, poolOffset)\n      const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes)\n      poolOffset += encodeLength.bytes\n\n      if (pool.length - poolOffset < MIN_POOL_SIZE) {\n        pool = Buffer.alloc(poolSize)\n        poolOffset = 0\n      }\n\n      yield new BufferList().append(encodedLength).append(chunk)\n      // yield Buffer.concat([encodedLength, chunk])\n    }\n  })()\n}\n\nencode.single = (chunk, options) => {\n  options = options || {}\n  const encodeLength = options.lengthEncoder || varintEncode\n  return new BufferList([encodeLength(chunk.length), chunk])\n}\n\nmodule.exports = encode\nmodule.exports.MIN_POOL_SIZE = MIN_POOL_SIZE\nmodule.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE\n"]},"metadata":{},"sourceType":"script"}