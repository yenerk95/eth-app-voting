{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('interface-datastore'),\n    Adapter = _require.Adapter,\n    Errors = _require.Errors;\n\nvar log = require('debug')('datastore:core:tiered');\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nvar TieredDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(TieredDatastore, _Adapter);\n\n  var _super = _createSuper(TieredDatastore);\n\n  function TieredDatastore(stores) {\n    var _this;\n\n    _classCallCheck(this, TieredDatastore);\n\n    _this = _super.call(this);\n    _this.stores = stores.slice();\n    return _this;\n  }\n\n  _createClass(TieredDatastore, [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return Promise.all(this.stores.map(function (store) {\n                  return store.open();\n                }));\n\n              case 3:\n                _context.next = 8;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context[\"catch\"](0);\n                throw Errors.dbOpenFailedError();\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key, value) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return Promise.all(this.stores.map(function (store) {\n                  return store.put(key, value);\n                }));\n\n              case 3:\n                _context2.next = 8;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n                throw Errors.dbWriteFailedError();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 5]]);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, options) {\n        var _iterator, _step, store, res;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(this.stores);\n                _context3.prev = 1;\n\n                _iterator.s();\n\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                store = _step.value;\n                _context3.prev = 5;\n                _context3.next = 8;\n                return store.get(key, options);\n\n              case 8:\n                res = _context3.sent;\n\n                if (!res) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", res);\n\n              case 11:\n                _context3.next = 16;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](5);\n                log(_context3.t0);\n\n              case 16:\n                _context3.next = 3;\n                break;\n\n              case 18:\n                _context3.next = 23;\n                break;\n\n              case 20:\n                _context3.prev = 20;\n                _context3.t1 = _context3[\"catch\"](1);\n\n                _iterator.e(_context3.t1);\n\n              case 23:\n                _context3.prev = 23;\n\n                _iterator.f();\n\n                return _context3.finish(23);\n\n              case 26:\n                throw Errors.notFoundError();\n\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 20, 23, 26], [5, 13]]);\n      }));\n\n      function get(_x3, _x4) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"has\",\n    value: function () {\n      var _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key, options) {\n        var _iterator2, _step2, s;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(this.stores);\n                _context4.prev = 1;\n\n                _iterator2.s();\n\n              case 3:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                s = _step2.value;\n                _context4.next = 7;\n                return s.has(key, options);\n\n              case 7:\n                if (!_context4.sent) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 9:\n                _context4.next = 3;\n                break;\n\n              case 11:\n                _context4.next = 16;\n                break;\n\n              case 13:\n                _context4.prev = 13;\n                _context4.t0 = _context4[\"catch\"](1);\n\n                _iterator2.e(_context4.t0);\n\n              case 16:\n                _context4.prev = 16;\n\n                _iterator2.f();\n\n                return _context4.finish(16);\n\n              case 19:\n                return _context4.abrupt(\"return\", false);\n\n              case 20:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 13, 16, 19]]);\n      }));\n\n      function has(_x5, _x6) {\n        return _has.apply(this, arguments);\n      }\n\n      return has;\n    }()\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key, options) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return Promise.all(this.stores.map(function (store) {\n                  return store.delete(key, options);\n                }));\n\n              case 3:\n                _context5.next = 8;\n                break;\n\n              case 5:\n                _context5.prev = 5;\n                _context5.t0 = _context5[\"catch\"](0);\n                throw Errors.dbDeleteFailedError();\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 5]]);\n      }));\n\n      function _delete(_x7, _x8) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return Promise.all(this.stores.map(function (store) {\n                  return store.close();\n                }));\n\n              case 2:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var batches = this.stores.map(function (store) {\n        return store.batch();\n      });\n      return {\n        put: function put(key, value) {\n          batches.forEach(function (b) {\n            return b.put(key, value);\n          });\n        },\n        delete: function _delete(key) {\n          batches.forEach(function (b) {\n            return b.delete(key);\n          });\n        },\n        commit: function () {\n          var _commit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(options) {\n            var _iterator3, _step3, batch;\n\n            return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    _iterator3 = _createForOfIteratorHelper(batches);\n                    _context7.prev = 1;\n\n                    _iterator3.s();\n\n                  case 3:\n                    if ((_step3 = _iterator3.n()).done) {\n                      _context7.next = 9;\n                      break;\n                    }\n\n                    batch = _step3.value;\n                    _context7.next = 7;\n                    return batch.commit(options);\n\n                  case 7:\n                    _context7.next = 3;\n                    break;\n\n                  case 9:\n                    _context7.next = 14;\n                    break;\n\n                  case 11:\n                    _context7.prev = 11;\n                    _context7.t0 = _context7[\"catch\"](1);\n\n                    _iterator3.e(_context7.t0);\n\n                  case 14:\n                    _context7.prev = 14;\n\n                    _iterator3.f();\n\n                    return _context7.finish(14);\n\n                  case 17:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _callee7, null, [[1, 11, 14, 17]]);\n          }));\n\n          function commit(_x9) {\n            return _commit.apply(this, arguments);\n          }\n\n          return commit;\n        }()\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q, options) {\n      return this.stores[this.stores.length - 1].query(q, options);\n    }\n  }]);\n\n  return TieredDatastore;\n}(Adapter);\n\nmodule.exports = TieredDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-core/src/tiered.js"],"names":["require","Adapter","Errors","log","TieredDatastore","stores","slice","Promise","all","map","store","open","dbOpenFailedError","key","value","put","dbWriteFailedError","options","get","res","notFoundError","s","has","delete","dbDeleteFailedError","close","batches","batch","forEach","b","commit","q","length","query","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Adapter, Errors } = require('interface-datastore')\nconst log = require('debug')('datastore:core:tiered')\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore extends Adapter {\n  constructor (stores) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async open () {\n    try {\n      await Promise.all(this.stores.map((store) => store.open()))\n    } catch (err) {\n      throw Errors.dbOpenFailedError()\n    }\n  }\n\n  async put (key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)))\n    } catch (err) {\n      throw Errors.dbWriteFailedError()\n    }\n  }\n\n  async get (key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n        if (res) return res\n      } catch (err) {\n        log(err)\n      }\n    }\n    throw Errors.notFoundError()\n  }\n\n  async has (key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  async delete (key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)))\n    } catch (err) {\n      throw Errors.dbDeleteFailedError()\n    }\n  }\n\n  async close () {\n    await Promise.all(this.stores.map(store => store.close()))\n  }\n\n  batch () {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key) => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: async (options) => {\n        for (const batch of batches) {\n          await batch.commit(options)\n        }\n      }\n    }\n  }\n\n  query (q, options) {\n    return this.stores[this.stores.length - 1].query(q, options)\n  }\n}\n\nmodule.exports = TieredDatastore\n"]},"metadata":{},"sourceType":"script"}