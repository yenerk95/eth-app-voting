{"ast":null,"code":"'use strict';\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst Message = require('./types/message');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nclass Network {\n  constructor(libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerId, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this.protocols.unshift(BITSWAP110);\n      this.protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n  }\n\n  start() {\n    this._running = true;\n    this.libp2p.handle(this.protocols, this._onConnection); // register protocol with topology\n\n    const topology = new MulticodecTopology({\n      multicodecs: this.protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    });\n    this._registrarId = this.libp2p.registrar.register(topology); // All existing connections are like new ones for us\n\n    for (const peer of this.libp2p.peerStore.peers.values()) {\n      const conn = this.libp2p.connectionManager.get(peer.id);\n      conn && this._onPeerConnect(conn);\n    }\n  }\n\n  stop() {\n    this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n    this.libp2p.unhandle(this.protocols); // unregister protocol and handlers\n\n    this.libp2p.registrar.unregister(this._registrarId);\n  }\n  /**\n   * Handles both types of incoming bitswap messages\n   * @private\n   * @param {object} param0\n   * @param {string} param0.protocol The protocol the stream is running\n   * @param {Stream} param0.stream A duplex iterable stream\n   * @param {Connection} param0.connection A libp2p Connection\n   * @returns {void}\n   */\n\n\n  async _onConnection({\n    protocol,\n    stream,\n    connection\n  }) {\n    if (!this._running) {\n      return;\n    }\n\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n    try {\n      await pipe(stream, lp.decode(), async source => {\n        for await (const data of source) {\n          try {\n            const message = await Message.deserialize(data.slice());\n            await this.bitswap._receiveMessage(connection.remotePeer, message);\n          } catch (err) {\n            this.bitswap._receiveError(err);\n\n            break;\n          }\n        }\n      });\n    } catch (err) {\n      this._log(err);\n    }\n  }\n\n  _onPeerConnect(peerId) {\n    this.bitswap._onPeerConnected(peerId);\n  }\n\n  _onPeerDisconnect(peerId) {\n    this.bitswap._onPeerDisconnected(peerId);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {AsyncIterable<PeerInfo>}\n   */\n\n\n  findProviders(cid, maxProviders, options = {}) {\n    return this.libp2p.contentRouting.findProviders(cid, {\n      maxTimeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders,\n      signal: options.signal\n    });\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {void}\n   */\n\n\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log('connecting to providers', provider.id.toB58String());\n\n      connectAttempts.push(this.connectTo(provider, options));\n    }\n\n    await Promise.all(connectAttempts);\n  }\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(cid, options) {\n    await this.libp2p.contentRouting.provide(cid, options);\n  } // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n\n\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toB58String();\n\n    this._log('sendMessage to %s', stringId, msg);\n\n    const {\n      stream,\n      protocol\n    } = await this._dialPeer(peer);\n    let serialized;\n\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110();\n        break;\n\n      default:\n        throw new Error('Unknown protocol: ' + protocol);\n    } // Note: Don't wait for writeMessage() to complete\n\n\n    writeMessage(stream, serialized, this._log);\n\n    this._updateSentStats(peer, msg.blocks);\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectTo(peer, options) {\n    // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n\n    return this.libp2p.dial(peer, options);\n  } // Dial to the peer and try to use the most recent Bitswap\n\n\n  _dialPeer(peer) {\n    return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100]);\n  }\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      blocks.forEach(block => this._stats.push(peerId, 'dataSent', block.data.length));\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n\nasync function writeMessage(stream, msg, log) {\n  try {\n    await pipe([msg], lp.encode(), stream);\n  } catch (err) {\n    log(err);\n  }\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/network.js"],"names":["lp","require","pipe","MulticodecTopology","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","BITSWAP120","Network","constructor","libp2p","bitswap","options","stats","_log","peerId","protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","start","handle","topology","multicodecs","handlers","onConnect","onDisconnect","_registrarId","registrar","register","peer","peerStore","peers","values","conn","connectionManager","get","id","stop","unhandle","unregister","protocol","stream","connection","remotePeer","toB58String","decode","source","data","message","deserialize","slice","_receiveMessage","err","_receiveError","_onPeerConnected","_onPeerDisconnected","findProviders","cid","maxProviders","contentRouting","maxTimeout","providerRequestTimeout","maxNumProviders","signal","findAndConnect","connectAttempts","provider","maxProvidersPerRequest","push","connectTo","Promise","all","provide","sendMessage","msg","Error","stringId","_dialPeer","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","dial","dialProtocol","forEach","block","length","size","log","encode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nclass Network {\n  constructor (libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerId, 'network')\n    options = options || {}\n    this.libp2p = libp2p\n    this.bitswap = bitswap\n    this.protocols = [BITSWAP100]\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this.protocols.unshift(BITSWAP110)\n      this.protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n  }\n\n  start () {\n    this._running = true\n    this.libp2p.handle(this.protocols, this._onConnection)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this.protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    })\n    this._registrarId = this.libp2p.registrar.register(topology)\n\n    // All existing connections are like new ones for us\n    for (const peer of this.libp2p.peerStore.peers.values()) {\n      const conn = this.libp2p.connectionManager.get(peer.id)\n\n      conn && this._onPeerConnect(conn)\n    }\n  }\n\n  stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    this.libp2p.unhandle(this.protocols)\n\n    // unregister protocol and handlers\n    this.libp2p.registrar.unregister(this._registrarId)\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   * @private\n   * @param {object} param0\n   * @param {string} param0.protocol The protocol the stream is running\n   * @param {Stream} param0.stream A duplex iterable stream\n   * @param {Connection} param0.connection A libp2p Connection\n   * @returns {void}\n   */\n  async _onConnection ({ protocol, stream, connection }) {\n    if (!this._running) { return }\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String())\n\n    try {\n      await pipe(\n        stream,\n        lp.decode(),\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.slice())\n              await this.bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (err) {\n              this.bitswap._receiveError(err)\n              break\n            }\n          }\n        }\n      )\n    } catch (err) {\n      this._log(err)\n    }\n  }\n\n  _onPeerConnect (peerId) {\n    this.bitswap._onPeerConnected(peerId)\n  }\n\n  _onPeerDisconnect (peerId) {\n    this.bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {AsyncIterable<PeerInfo>}\n   */\n  findProviders (cid, maxProviders, options = {}) {\n    return this.libp2p.contentRouting.findProviders(\n      cid,\n      {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders,\n        signal: options.signal\n      }\n    )\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {void}\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log('connecting to providers', provider.id.toB58String())\n      connectAttempts.push(this.connectTo(provider, options))\n    }\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<void>}\n   */\n  async provide (cid, options) {\n    await this.libp2p.contentRouting.provide(cid, options)\n  }\n\n  // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const { stream, protocol } = await this._dialPeer(peer)\n\n    let serialized\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + protocol)\n    }\n\n    // Note: Don't wait for writeMessage() to complete\n    writeMessage(stream, serialized, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this.libp2p.dial(peer, options)\n  }\n\n  // Dial to the peer and try to use the most recent Bitswap\n  _dialPeer (peer) {\n    return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100])\n  }\n\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n\n    if (this._stats) {\n      blocks.forEach((block) => this._stats.push(peerId, 'dataSent', block.data.length))\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\nasync function writeMessage (stream, msg, log) {\n  try {\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  }\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}