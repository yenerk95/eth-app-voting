{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar cache = require('hashlru');\n\nvar varint = require('varint');\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _require3 = require('buffer'),\n    Buffer = _require3.Buffer;\n\nvar c = require('./constants');\n\nvar utils = require('./utils');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nvar Providers = /*#__PURE__*/function () {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  function Providers(datastore, self, cacheSize) {\n    _classCallCheck(this, Providers);\n\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;\n    this.providers = cache(this.lruCacheSize);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Start the provider cleanup service\n   * @returns {void}\n   */\n\n\n  _createClass(Providers, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      this._cleaner = setInterval(function () {\n        return _this._cleanup();\n      }, this.cleanupInterval);\n    }\n    /**\n     * Release any resources.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearInterval(this._cleaner);\n      this._cleaner = null;\n    }\n    /**\n     * Check all providers if they are still valid, and if not delete them.\n     *\n     * @returns {Promise<void>}\n     * @private\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var _this2 = this;\n\n      return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var start, count, deleteCount, deleted, batch, query, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, entry, _parseProviderKey, cid, peerId, time, now, delta, expired, peers, _iterator3, _step3, _step3$value, _cid, _peers, key, provs, _iterator4, _step4, _peerId;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this2._log('start cleanup');\n\n                start = Date.now();\n                count = 0;\n                deleteCount = 0;\n                deleted = new Map();\n                batch = _this2.datastore.batch(); // Get all provider entries from the datastore\n\n                query = _this2.datastore.query({\n                  prefix: c.PROVIDERS_KEY_PREFIX\n                });\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 9;\n                _iterator = _asyncIterator(query);\n\n              case 11:\n                _context.next = 13;\n                return _iterator.next();\n\n              case 13:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 17;\n                return _step.value;\n\n              case 17:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 24;\n                  break;\n                }\n\n                entry = _value;\n\n                try {\n                  // Add a delete to the batch for each expired entry\n                  _parseProviderKey = parseProviderKey(entry.key), cid = _parseProviderKey.cid, peerId = _parseProviderKey.peerId;\n                  time = readTime(entry.value);\n                  now = Date.now();\n                  delta = now - time;\n                  expired = delta > _this2.provideValidity;\n\n                  _this2._log('comparing: %d - %d = %d > %d %s', now, time, delta, _this2.provideValidity, expired ? '(expired)' : '');\n\n                  if (expired) {\n                    deleteCount++;\n                    batch.delete(entry.key);\n                    peers = deleted.get(cid) || new Set();\n                    peers.add(peerId);\n                    deleted.set(cid, peers);\n                  }\n\n                  count++;\n                } catch (err) {\n                  _this2._log.error(err.message);\n                }\n\n              case 21:\n                _iteratorNormalCompletion = true;\n                _context.next = 11;\n                break;\n\n              case 24:\n                _context.next = 30;\n                break;\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](9);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 30:\n                _context.prev = 30;\n                _context.prev = 31;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                _context.next = 35;\n                return _iterator.return();\n\n              case 35:\n                _context.prev = 35;\n\n                if (!_didIteratorError) {\n                  _context.next = 38;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 38:\n                return _context.finish(35);\n\n              case 39:\n                return _context.finish(30);\n\n              case 40:\n                _this2._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore\n\n\n                if (!deleted.size) {\n                  _context.next = 44;\n                  break;\n                }\n\n                _context.next = 44;\n                return batch.commit();\n\n              case 44:\n                // Clear expired entries from the cache\n                _iterator3 = _createForOfIteratorHelper(deleted);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), _cid = _step3$value[0], _peers = _step3$value[1];\n                    key = makeProviderKey(_cid);\n                    provs = _this2.providers.get(key);\n\n                    if (provs) {\n                      _iterator4 = _createForOfIteratorHelper(_peers);\n\n                      try {\n                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                          _peerId = _step4.value;\n                          provs.delete(_peerId);\n                        }\n                      } catch (err) {\n                        _iterator4.e(err);\n                      } finally {\n                        _iterator4.f();\n                      }\n\n                      if (provs.size === 0) {\n                        _this2.providers.remove(key);\n                      } else {\n                        _this2.providers.set(key, provs);\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _this2._log('Cleanup successful (%dms)', Date.now() - start);\n\n              case 47:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[9, 26, 30, 40], [31,, 35, 39]]);\n      })));\n    }\n    /**\n     * Get the currently known provider peer ids for a given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Map<String, Date>>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getProvidersMap\",\n    value: function () {\n      var _getProvidersMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cid) {\n        var cacheKey, provs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cacheKey = makeProviderKey(cid);\n                provs = this.providers.get(cacheKey);\n\n                if (provs) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 5;\n                return loadProviders(this.datastore, cid);\n\n              case 5:\n                provs = _context2.sent;\n                this.providers.set(cacheKey, provs);\n\n              case 7:\n                return _context2.abrupt(\"return\", provs);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getProvidersMap(_x) {\n        return _getProvidersMap2.apply(this, arguments);\n      }\n\n      return _getProvidersMap;\n    }()\n    /**\n     * Add a new provider for the given CID.\n     *\n     * @param {CID} cid\n     * @param {PeerId} provider\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"addProvider\",\n    value: function () {\n      var _addProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, provider) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                  var provs, now, dsKey;\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _this3._log('addProvider %s', cid.toBaseEncodedString());\n\n                          _context3.next = 3;\n                          return _this3._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context3.sent;\n\n                          _this3._log('loaded %s provs', provs.size);\n\n                          now = Date.now();\n                          provs.set(utils.encodeBase32(provider.id), now);\n                          dsKey = makeProviderKey(cid);\n\n                          _this3.providers.set(dsKey, provs);\n\n                          return _context3.abrupt(\"return\", writeProviderEntry(_this3.datastore, cid, provider, now));\n\n                        case 10:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function addProvider(_x2, _x3) {\n        return _addProvider.apply(this, arguments);\n      }\n\n      return addProvider;\n    }()\n    /**\n     * Get a list of providers for the given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Array<PeerId>>}\n     */\n\n  }, {\n    key: \"getProviders\",\n    value: function () {\n      var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(cid) {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                  var provs;\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _this4._log('getProviders %s', cid.toBaseEncodedString());\n\n                          _context5.next = 3;\n                          return _this4._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context5.sent;\n                          return _context5.abrupt(\"return\", _toConsumableArray(provs.keys()).map(function (base32PeerId) {\n                            return new PeerId(utils.decodeBase32(base32PeerId));\n                          }));\n\n                        case 5:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getProviders(_x4) {\n        return _getProviders.apply(this, arguments);\n      }\n\n      return getProviders;\n    }()\n  }]);\n\n  return Providers;\n}();\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer);\n  return c.PROVIDERS_KEY_PREFIX + cid;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @returns {Promise<void>}\n *\n * @private\n */\n\n\nfunction writeProviderEntry(_x5, _x6, _x7, _x8) {\n  return _writeProviderEntry.apply(this, arguments);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {DKey} key\n * @returns {Object} object with peer id and cid\n *\n * @private\n */\n\n\nfunction _writeProviderEntry() {\n  _writeProviderEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(store, cid, peer, time) {\n    var dsKey, key, buffer;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            // eslint-disable-line require-await\n            dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n            key = new Key(dsKey);\n            buffer = Buffer.from(varint.encode(time));\n            return _context7.abrupt(\"return\", store.put(key, buffer));\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _writeProviderEntry.apply(this, arguments);\n}\n\nfunction parseProviderKey(key) {\n  var parts = key.toString().split('/');\n\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nfunction loadProviders(_x9, _x10) {\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction _loadProviders() {\n  _loadProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(store, cid) {\n    var providers, query, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, entry, _parseProviderKey2, peerId;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            providers = new Map();\n            query = store.query({\n              prefix: makeProviderKey(cid)\n            });\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context8.prev = 4;\n            _iterator2 = _asyncIterator(query);\n\n          case 6:\n            _context8.next = 8;\n            return _iterator2.next();\n\n          case 8:\n            _step2 = _context8.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context8.next = 12;\n            return _step2.value;\n\n          case 12:\n            _value2 = _context8.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context8.next = 20;\n              break;\n            }\n\n            entry = _value2;\n            _parseProviderKey2 = parseProviderKey(entry.key), peerId = _parseProviderKey2.peerId;\n            providers.set(peerId, readTime(entry.value));\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context8.next = 6;\n            break;\n\n          case 20:\n            _context8.next = 26;\n            break;\n\n          case 22:\n            _context8.prev = 22;\n            _context8.t0 = _context8[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context8.t0;\n\n          case 26:\n            _context8.prev = 26;\n            _context8.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context8.next = 31;\n              break;\n            }\n\n            _context8.next = 31;\n            return _iterator2.return();\n\n          case 31:\n            _context8.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context8.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context8.finish(31);\n\n          case 35:\n            return _context8.finish(26);\n\n          case 36:\n            return _context8.abrupt(\"return\", providers);\n\n          case 37:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }));\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/providers.js"],"names":["cache","require","varint","PeerId","Key","Queue","default","Buffer","c","utils","Providers","datastore","self","cacheSize","_log","logger","cleanupInterval","PROVIDERS_CLEANUP_INTERVAL","provideValidity","PROVIDERS_VALIDITY","lruCacheSize","PROVIDERS_LRU_CACHE_SIZE","providers","syncQueue","concurrency","_cleaner","setInterval","_cleanup","clearInterval","add","start","Date","now","count","deleteCount","deleted","Map","batch","query","prefix","PROVIDERS_KEY_PREFIX","entry","parseProviderKey","key","cid","peerId","time","readTime","value","delta","expired","delete","peers","get","Set","set","err","error","message","size","commit","makeProviderKey","provs","remove","cacheKey","loadProviders","provider","toBaseEncodedString","_getProvidersMap","encodeBase32","id","dsKey","writeProviderEntry","keys","map","base32PeerId","decodeBase32","buffer","store","peer","join","from","encode","put","parts","toString","split","length","Error","buf","decode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst cache = require('hashlru')\nconst varint = require('varint')\nconst PeerId = require('peer-id')\nconst { Key } = require('interface-datastore')\nconst { default: Queue } = require('p-queue')\nconst { Buffer } = require('buffer')\nconst c = require('./constants')\nconst utils = require('./utils')\n\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\nclass Providers {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  constructor (datastore, self, cacheSize) {\n    this.datastore = datastore\n\n    this._log = utils.logger(self, 'providers')\n\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL\n\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n    this.provideValidity = c.PROVIDERS_VALIDITY\n\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE\n\n    this.providers = cache(this.lruCacheSize)\n\n    this.syncQueue = new Queue({ concurrency: 1 })\n  }\n\n  /**\n   * Start the provider cleanup service\n   * @returns {void}\n   */\n  start () {\n    this._cleaner = setInterval(\n      () => this._cleanup(),\n      this.cleanupInterval\n    )\n  }\n\n  /**\n   * Release any resources.\n   * @returns {void}\n   */\n  stop () {\n    clearInterval(this._cleaner)\n    this._cleaner = null\n  }\n\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n  _cleanup () {\n    return this.syncQueue.add(async () => {\n      this._log('start cleanup')\n      const start = Date.now()\n\n      let count = 0\n      let deleteCount = 0\n      const deleted = new Map()\n      const batch = this.datastore.batch()\n\n      // Get all provider entries from the datastore\n      const query = this.datastore.query({ prefix: c.PROVIDERS_KEY_PREFIX })\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const { cid, peerId } = parseProviderKey(entry.key)\n          const time = readTime(entry.value)\n          const now = Date.now()\n          const delta = now - time\n          const expired = delta > this.provideValidity\n          this._log('comparing: %d - %d = %d > %d %s',\n            now, time, delta, this.provideValidity, expired ? '(expired)' : '')\n          if (expired) {\n            deleteCount++\n            batch.delete(entry.key)\n            const peers = deleted.get(cid) || new Set()\n            peers.add(peerId)\n            deleted.set(cid, peers)\n          }\n          count++\n        } catch (err) {\n          this._log.error(err.message)\n        }\n      }\n      this._log('deleting %d / %d entries', deleteCount, count)\n\n      // Commit the deletes to the datastore\n      if (deleted.size) {\n        await batch.commit()\n      }\n\n      // Clear expired entries from the cache\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid)\n        const provs = this.providers.get(key)\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId)\n          }\n          if (provs.size === 0) {\n            this.providers.remove(key)\n          } else {\n            this.providers.set(key, provs)\n          }\n        }\n      }\n\n      this._log('Cleanup successful (%dms)', Date.now() - start)\n    })\n  }\n\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<String, Date>>}\n   *\n   * @private\n   */\n  async _getProvidersMap (cid) {\n    const cacheKey = makeProviderKey(cid)\n    let provs = this.providers.get(cacheKey)\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid)\n      this.providers.set(cacheKey, provs)\n    }\n    return provs\n  }\n\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n  async addProvider (cid, provider) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('addProvider %s', cid.toBaseEncodedString())\n      const provs = await this._getProvidersMap(cid)\n\n      this._log('loaded %s provs', provs.size)\n      const now = Date.now()\n      provs.set(utils.encodeBase32(provider.id), now)\n\n      const dsKey = makeProviderKey(cid)\n      this.providers.set(dsKey, provs)\n      return writeProviderEntry(this.datastore, cid, provider, now)\n    })\n  }\n\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n  async getProviders (cid) { // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('getProviders %s', cid.toBaseEncodedString())\n      const provs = await this._getProvidersMap(cid)\n      return [...provs.keys()].map((base32PeerId) => {\n        return new PeerId(utils.decodeBase32(base32PeerId))\n      })\n    })\n  }\n}\n\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\nfunction makeProviderKey (cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer)\n  return c.PROVIDERS_KEY_PREFIX + cid\n}\n\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @returns {Promise<void>}\n *\n * @private\n */\nasync function writeProviderEntry (store, cid, peer, time) { // eslint-disable-line require-await\n  const dsKey = [\n    makeProviderKey(cid),\n    '/',\n    utils.encodeBase32(peer.id)\n  ].join('')\n\n  const key = new Key(dsKey)\n  const buffer = Buffer.from(varint.encode(time))\n  return store.put(key, buffer)\n}\n\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {DKey} key\n * @returns {Object} object with peer id and cid\n *\n * @private\n */\nfunction parseProviderKey (key) {\n  const parts = key.toString().split('/')\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key)\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  }\n}\n\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\nasync function loadProviders (store, cid) {\n  const providers = new Map()\n  const query = store.query({ prefix: makeProviderKey(cid) })\n  for await (const entry of query) {\n    const { peerId } = parseProviderKey(entry.key)\n    providers.set(peerId, readTime(entry.value))\n  }\n  return providers\n}\n\nfunction readTime (buf) {\n  return varint.decode(buf)\n}\n\nmodule.exports = Providers\n"]},"metadata":{},"sourceType":"script"}