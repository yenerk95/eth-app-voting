{"ast":null,"code":"'use strict';\n\nconst _get = require('just-safe-get');\n\nconst debug = require('debug');\n\nconst Big = require('bignumber.js');\n\nconst errcode = require('err-code');\n\nconst migrator = require('ipfs-repo-migrations');\n\nconst bytes = require('bytes');\n\nconst pathJoin = require('ipfs-utils/src/path-join');\n\nconst constants = require('./constants');\n\nconst backends = require('./backends');\n\nconst version = require('./version');\n\nconst config = require('./config');\n\nconst spec = require('./spec');\n\nconst apiAddr = require('./api-addr');\n\nconst blockstore = require('./blockstore');\n\nconst defaultOptions = require('./default-options');\n\nconst defaultDatastore = require('./default-datastore');\n\nconst ERRORS = require('./errors');\n\nconst log = debug('repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor(repoPath, options) {\n    if (typeof repoPath !== 'string') {\n      throw new Error('missing repoPath');\n    }\n\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  async init(config) {\n    log('initializing at: %s', this.path);\n    await this._openRoot();\n    await this.config.set(buildConfig(config));\n    await this.spec.set(buildDatastoreSpec(config));\n    await this.version.set(constants.repoVersion);\n  }\n  /**\n   * Check if the repo is already initialized.\n   * @returns {Promise<Boolean>}\n   */\n\n\n  async isInitialized() {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true;\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot();\n      await this._checkInitialized();\n      await this.root.close();\n      return true;\n    } catch (err) {\n      // FIXME: do not use exceptions for flow control\n      return false;\n    }\n  }\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async open() {\n    if (!this.closed) {\n      throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n    }\n\n    log('opening at: %s', this.path); // check if the repo is already initialized\n\n    try {\n      await this._openRoot();\n      await this._checkInitialized();\n      this.lockfile = await this._openLock(this.path);\n      log('acquired repo.lock');\n      log('creating datastore');\n      this.datastore = backends.create('datastore', pathJoin(this.path, 'datastore'), this.options);\n      await this.datastore.open();\n      log('creating blocks');\n      const blocksBaseStore = backends.create('blocks', pathJoin(this.path, 'blocks'), this.options);\n      await blocksBaseStore.open();\n      this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks);\n      log('creating keystore');\n      this.keys = backends.create('keys', pathJoin(this.path, 'keys'), this.options);\n      await this.keys.open();\n      const isCompatible = await this.version.check(constants.repoVersion);\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion);\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n        }\n      }\n\n      this.closed = false;\n      log('all opened');\n    } catch (err) {\n      if (this.lockfile) {\n        try {\n          await this._closeLock();\n          this.lockfile = null;\n        } catch (err2) {\n          log('error removing lock', err2);\n        }\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n\n\n  _getLocker() {\n    if (typeof this.options.lock === 'string') {\n      if (!lockers[this.options.lock]) {\n        throw new Error('Unknown lock type: ' + this.options.lock);\n      }\n\n      return lockers[this.options.lock];\n    }\n\n    if (!this.options.lock) {\n      throw new Error('No lock provided');\n    }\n\n    return this.options.lock;\n  }\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   * @returns {Promise}\n   */\n\n\n  async _openRoot() {\n    try {\n      await this.root.open();\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @returns {Promise<lockfile>}\n   */\n\n\n  async _openLock(path) {\n    const lockfile = await this._locker.lock(path);\n\n    if (typeof lockfile.close !== 'function') {\n      throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n    }\n\n    return lockfile;\n  }\n  /**\n   * Closes the lock on the repo\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  _closeLock() {\n    return this.lockfile.close();\n  }\n  /**\n   * Check if the repo is already initialized.\n   * @private\n   * @returns {Promise}\n   */\n\n\n  async _checkInitialized() {\n    log('init check');\n    let config;\n\n    try {\n      [config] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        });\n      }\n\n      throw err;\n    }\n\n    if (!config) {\n      throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      });\n    }\n  }\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async close() {\n    if (this.closed) {\n      throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n    }\n\n    log('closing at: %s', this.path);\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete();\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err;\n      }\n    }\n\n    await Promise.all([this.root, this.blocks, this.keys, this.datastore].map(store => store.close()));\n    log('unlocking');\n    this.closed = true;\n    await this._closeLock();\n    this.lockfile = null;\n  }\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<bool>}\n   */\n\n\n  async exists() {\n    // eslint-disable-line require-await\n    return this.version.exists();\n  }\n  /**\n   * Get repo status.\n   *\n   * @returns {Object}\n   */\n\n\n  async stat() {\n    const [storageMax, blocks, version, datastore, keys] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n    const size = blocks.size.plus(datastore).plus(keys);\n    return {\n      repoPath: this.path,\n      storageMax,\n      version: version,\n      numObjects: blocks.count,\n      repoSize: size\n    };\n  }\n\n  async _isAutoMigrationEnabled() {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate;\n    }\n\n    let autoMigrateConfig;\n\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true; // Config's default value is True\n      } else {\n        throw e;\n      }\n    }\n\n    return autoMigrateConfig;\n  }\n\n  async _migrate(toVersion) {\n    const currentRepoVersion = await this.version.get();\n\n    if (currentRepoVersion > toVersion) {\n      log('reverting to version ' + toVersion);\n      return migrator.revert(this.path, toVersion, {\n        ignoreLock: true,\n        repoOptions: this.options\n      });\n    } else {\n      log('migrating to version ' + toVersion);\n      return migrator.migrate(this.path, toVersion, {\n        ignoreLock: true,\n        repoOptions: this.options\n      });\n    }\n  }\n\n  async _storageMaxStat() {\n    try {\n      const max = await this.config.get('Datastore.StorageMax');\n      return new Big(bytes(max));\n    } catch (err) {\n      return new Big(noLimit);\n    }\n  }\n\n  async _blockStat() {\n    let count = new Big(0);\n    let size = new Big(0);\n\n    for await (const block of this.blocks.query({})) {\n      count = count.plus(1);\n      size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n    }\n\n    return {\n      count,\n      size\n    };\n  }\n\n}\n\nasync function getSize(queryFn) {\n  const sum = new Big(0);\n\n  for await (const block of queryFn.query({})) {\n    sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n  }\n\n  return sum;\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.utils = {\n  blockstore: require('./blockstore-utils')\n};\nmodule.exports.repoVersion = constants.repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction buildOptions(_options) {\n  const options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo/src/index.js"],"names":["_get","require","debug","Big","errcode","migrator","bytes","pathJoin","constants","backends","version","config","spec","apiAddr","blockstore","defaultOptions","defaultDatastore","ERRORS","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","lockers","memory","fs","IpfsRepo","constructor","repoPath","options","Error","buildOptions","closed","path","_locker","_getLocker","root","create","init","_openRoot","set","buildConfig","buildDatastoreSpec","repoVersion","isInitialized","_checkInitialized","close","err","open","ERR_REPO_ALREADY_OPEN","lockfile","_openLock","datastore","blocksBaseStore","blocks","storageBackendOptions","keys","isCompatible","check","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","_closeLock","err2","lock","message","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","stat","storageMax","_storageMaxStat","_blockStat","get","getSize","size","plus","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","e","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","repoOptions","migrate","max","block","query","value","byteLength","key","_buf","queryFn","sum","module","exports","utils","errors","_options","Object","assign","storageBackends","_config","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"mappings":"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","sourcesContent":["'use strict'\n\nconst _get = require('just-safe-get')\nconst debug = require('debug')\nconst Big = require('bignumber.js')\nconst errcode = require('err-code')\nconst migrator = require('ipfs-repo-migrations')\nconst bytes = require('bytes')\nconst pathJoin = require('ipfs-utils/src/path-join')\n\nconst constants = require('./constants')\nconst backends = require('./backends')\nconst version = require('./version')\nconst config = require('./config')\nconst spec = require('./spec')\nconst apiAddr = require('./api-addr')\nconst blockstore = require('./blockstore')\nconst defaultOptions = require('./default-options')\nconst defaultDatastore = require('./default-datastore')\nconst ERRORS = require('./errors')\n\nconst log = debug('repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n}\n\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor (repoPath, options) {\n    if (typeof repoPath !== 'string') {\n      throw new Error('missing repoPath')\n    }\n\n    this.options = buildOptions(options)\n    this.closed = true\n    this.path = repoPath\n\n    this._locker = this._getLocker()\n\n    this.root = backends.create('root', this.path, this.options)\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.set(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(constants.repoVersion)\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   * @returns {Promise<Boolean>}\n   */\n  async isInitialized () {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot()\n      await this._checkInitialized()\n      await this.root.close()\n\n      return true\n    } catch (err) {\n      // FIXME: do not use exceptions for flow control\n      return false\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n      this.lockfile = await this._openLock(this.path)\n      log('acquired repo.lock')\n      log('creating datastore')\n      this.datastore = backends.create('datastore', pathJoin(this.path, 'datastore'), this.options)\n      await this.datastore.open()\n      log('creating blocks')\n      const blocksBaseStore = backends.create('blocks', pathJoin(this.path, 'blocks'), this.options)\n      await blocksBaseStore.open()\n      this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks)\n      log('creating keystore')\n      this.keys = backends.create('keys', pathJoin(this.path, 'keys'), this.options)\n      await this.keys.open()\n      const isCompatible = await this.version.check(constants.repoVersion)\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion)\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      this.closed = false\n      log('all opened')\n    } catch (err) {\n      if (this.lockfile) {\n        try {\n          await this._closeLock()\n          this.lockfile = null\n        } catch (err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n  _getLocker () {\n    if (typeof this.options.lock === 'string') {\n      if (!lockers[this.options.lock]) {\n        throw new Error('Unknown lock type: ' + this.options.lock)\n      }\n      return lockers[this.options.lock]\n    }\n\n    if (!this.options.lock) {\n      throw new Error('No lock provided')\n    }\n    return this.options.lock\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   * @returns {Promise}\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @returns {Promise<lockfile>}\n   */\n  async _openLock (path) {\n    const lockfile = await this._locker.lock(path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @returns {Promise<void>}\n   */\n  _closeLock () {\n    return this.lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   * @private\n   * @returns {Promise}\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([\n      this.root,\n      this.blocks,\n      this.keys,\n      this.datastore\n    ].map((store) => store.close()))\n\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n    this.lockfile = null\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<bool>}\n   */\n  async exists () { // eslint-disable-line require-await\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Object}\n   */\n  async stat () {\n    const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n      this._storageMaxStat(),\n      this._blockStat(),\n      this.version.get(),\n      getSize(this.datastore),\n      getSize(this.keys)\n    ])\n    const size = blocks.size\n      .plus(datastore)\n      .plus(keys)\n\n    return {\n      repoPath: this.path,\n      storageMax,\n      version: version,\n      numObjects: blocks.count,\n      repoSize: size\n    }\n  }\n\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  async _migrate (toVersion) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log('reverting to version ' + toVersion)\n      return migrator.revert(this.path, toVersion, { ignoreLock: true, repoOptions: this.options })\n    } else {\n      log('migrating to version ' + toVersion)\n      return migrator.migrate(this.path, toVersion, { ignoreLock: true, repoOptions: this.options })\n    }\n  }\n\n  async _storageMaxStat () {\n    try {\n      const max = await this.config.get('Datastore.StorageMax')\n      return new Big(bytes(max))\n    } catch (err) {\n      return new Big(noLimit)\n    }\n  }\n\n  async _blockStat () {\n    let count = new Big(0)\n    let size = new Big(0)\n\n    for await (const block of this.blocks.query({})) {\n      count = count.plus(1)\n      size = size\n        .plus(block.value.byteLength)\n        .plus(block.key._buf.byteLength)\n    }\n\n    return { count, size }\n  }\n}\n\nasync function getSize (queryFn) {\n  const sum = new Big(0)\n  for await (const block of queryFn.query({})) {\n    sum.plus(block.value.byteLength)\n      .plus(block.key._buf.byteLength)\n  }\n  return sum\n}\n\nmodule.exports = IpfsRepo\nmodule.exports.utils = { blockstore: require('./blockstore-utils') }\nmodule.exports.repoVersion = constants.repoVersion\nmodule.exports.errors = ERRORS\n\nfunction buildOptions (_options) {\n  const options = Object.assign({}, defaultOptions, _options)\n\n  options.storageBackends = Object.assign(\n    {},\n    defaultOptions.storageBackends,\n    options.storageBackends)\n\n  options.storageBackendOptions = Object.assign(\n    {},\n    defaultOptions.storageBackendOptions,\n    options.storageBackendOptions)\n\n  return options\n}\n\n// TODO this should come from js-ipfs instead\nfunction buildConfig (_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}))\n\n  return _config\n}\n\nfunction buildDatastoreSpec (_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}))\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}