{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  openDB,\n  deleteDB\n} = require('idb');\n\nconst {\n  Key,\n  Errors,\n  utils,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  filter,\n  sortAll\n} = utils;\n\nconst isStrictTypedArray = arr => {\n  return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;\n};\n\nconst typedarrayToBuffer = arr => {\n  if (isStrictTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    let buf = Buffer.from(arr.buffer);\n\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n    }\n\n    return buf;\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr);\n  }\n};\n\nconst str2ab = str => {\n  const buf = new ArrayBuffer(str.length);\n  const bufView = new Uint8Array(buf);\n\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n};\n\nconst queryIt = async function* (q, store, location) {\n  const range = q.prefix ? self.IDBKeyRange.bound(str2ab(q.prefix), str2ab(q.prefix + '\\xFF'), false, true) : undefined;\n  let cursor = await store.transaction(location).store.openCursor(range);\n  let limit = 0;\n\n  if (cursor && q.offset && q.offset > 0) {\n    cursor = await cursor.advance(q.offset);\n  }\n\n  while (cursor) {\n    // limit\n    if (q.limit !== undefined && q.limit === limit) {\n      return;\n    }\n\n    limit++;\n    const key = new Key(Buffer.from(cursor.key));\n\n    if (q.keysOnly) {\n      yield {\n        key\n      };\n    } else {\n      const value = Buffer.from(cursor.value);\n      yield {\n        key,\n        value\n      };\n    }\n\n    cursor = await cursor.continue();\n  }\n};\n\nclass IdbDatastore extends Adapter {\n  constructor(location, options = {}) {\n    super();\n    this.store = null;\n    this.options = options;\n    this.location = options.prefix + location;\n    this.version = options.version || 1;\n  }\n\n  async open() {\n    if (this.store !== null) {\n      return;\n    }\n\n    const location = this.location;\n\n    try {\n      this.store = await openDB(this.location, this.version, {\n        upgrade(db) {\n          db.createObjectStore(location);\n        }\n\n      });\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n\n  async put(key, val) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    try {\n      await this.store.put(this.location, val, key.toBuffer());\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n\n  async get(key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    let value;\n\n    try {\n      value = await this.store.get(this.location, key.toBuffer());\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n\n    if (!value) {\n      throw Errors.notFoundError();\n    }\n\n    return typedarrayToBuffer(value);\n  }\n\n  async has(key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    try {\n      await this.get(key);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') return false;\n      throw err;\n    }\n\n    return true;\n  }\n\n  async delete(key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    try {\n      await this.store.delete(this.location, key.toBuffer());\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  batch() {\n    const puts = [];\n    const dels = [];\n    return {\n      put(key, value) {\n        puts.push([key.toBuffer(), value]);\n      },\n\n      delete(key) {\n        dels.push(key.toBuffer());\n      },\n\n      commit: async () => {\n        if (this.store === null) {\n          throw new Error('Datastore needs to be opened.');\n        }\n\n        const tx = this.store.transaction(this.location, 'readwrite');\n        const store = tx.store;\n        await Promise.all(puts.map(p => store.put(p[1], p[0])));\n        await Promise.all(dels.map(p => store.delete(p)));\n        await tx.done;\n      }\n    };\n  }\n\n  query(q) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    let it = queryIt(q, this.store, this.location);\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    return it;\n  }\n\n  close() {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    this.store.close();\n    this.store = null;\n  }\n\n  destroy() {\n    return deleteDB(this.location);\n  }\n\n}\n\nmodule.exports = IdbDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-idb/src/index.js"],"names":["Buffer","require","openDB","deleteDB","Key","Errors","utils","Adapter","filter","sortAll","isStrictTypedArray","arr","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Float32Array","Float64Array","typedarrayToBuffer","buf","from","buffer","byteLength","slice","byteOffset","str2ab","str","ArrayBuffer","length","bufView","i","strLen","charCodeAt","queryIt","q","store","location","range","prefix","self","IDBKeyRange","bound","undefined","cursor","transaction","openCursor","limit","offset","advance","key","keysOnly","value","continue","IdbDatastore","constructor","options","version","open","upgrade","db","createObjectStore","err","dbOpenFailedError","put","val","Error","toBuffer","dbWriteFailedError","get","notFoundError","has","code","delete","dbDeleteFailedError","batch","puts","dels","push","commit","tx","Promise","all","map","p","done","query","it","Array","isArray","filters","reduce","f","orders","close","destroy","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst { openDB, deleteDB } = require('idb')\nconst { Key, Errors, utils, Adapter } = require('interface-datastore')\nconst { filter, sortAll } = utils\n\nconst isStrictTypedArray = (arr) => {\n  return (\n    arr instanceof Int8Array ||\n    arr instanceof Int16Array ||\n    arr instanceof Int32Array ||\n    arr instanceof Uint8Array ||\n    arr instanceof Uint8ClampedArray ||\n    arr instanceof Uint16Array ||\n    arr instanceof Uint32Array ||\n    arr instanceof Float32Array ||\n    arr instanceof Float64Array\n  )\n}\n\nconst typedarrayToBuffer = (arr) => {\n  if (isStrictTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    let buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n\nconst str2ab = (str) => {\n  const buf = new ArrayBuffer(str.length)\n  const bufView = new Uint8Array(buf)\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i)\n  }\n  return buf\n}\n\nconst queryIt = async function * (q, store, location) {\n  const range = q.prefix ? self.IDBKeyRange.bound(str2ab(q.prefix), str2ab(q.prefix + '\\xFF'), false, true) : undefined\n  let cursor = await store.transaction(location).store.openCursor(range)\n  let limit = 0\n\n  if (cursor && q.offset && q.offset > 0) {\n    cursor = await cursor.advance(q.offset)\n  }\n\n  while (cursor) {\n    // limit\n    if (q.limit !== undefined && q.limit === limit) {\n      return\n    }\n    limit++\n\n    const key = new Key(Buffer.from(cursor.key))\n    if (q.keysOnly) {\n      yield { key }\n    } else {\n      const value = Buffer.from(cursor.value)\n      yield { key, value }\n    }\n    cursor = await cursor.continue()\n  }\n}\n\nclass IdbDatastore extends Adapter {\n  constructor (location, options = {}) {\n    super()\n\n    this.store = null\n    this.options = options\n    this.location = options.prefix + location\n    this.version = options.version || 1\n  }\n\n  async open () {\n    if (this.store !== null) {\n      return\n    }\n\n    const location = this.location\n    try {\n      this.store = await openDB(this.location, this.version, {\n        upgrade (db) {\n          db.createObjectStore(location)\n        }\n      })\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err)\n    }\n  }\n\n  async put (key, val) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    try {\n      await this.store.put(this.location, val, key.toBuffer())\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n  }\n\n  async get (key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    let value\n    try {\n      value = await this.store.get(this.location, key.toBuffer())\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err)\n    }\n\n    if (!value) {\n      throw Errors.notFoundError()\n    }\n\n    return typedarrayToBuffer(value)\n  }\n\n  async has (key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    try {\n      await this.get(key)\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') return false\n      throw err\n    }\n    return true\n  }\n\n  async delete (key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    try {\n      await this.store.delete(this.location, key.toBuffer())\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err)\n    }\n  }\n\n  batch () {\n    const puts = []\n    const dels = []\n\n    return {\n      put (key, value) {\n        puts.push([key.toBuffer(), value])\n      },\n      delete (key) {\n        dels.push(key.toBuffer())\n      },\n      commit: async () => {\n        if (this.store === null) {\n          throw new Error('Datastore needs to be opened.')\n        }\n        const tx = this.store.transaction(this.location, 'readwrite')\n        const store = tx.store\n        await Promise.all(puts.map(p => store.put(p[1], p[0])))\n        await Promise.all(dels.map(p => store.delete(p)))\n        await tx.done\n      }\n    }\n  }\n\n  query (q) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    let it = queryIt(q, this.store, this.location)\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    return it\n  }\n\n  close () {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.')\n    }\n    this.store.close()\n    this.store = null\n  }\n\n  destroy () {\n    return deleteDB(this.location)\n  }\n}\n\nmodule.exports = IdbDatastore\n"]},"metadata":{},"sourceType":"script"}