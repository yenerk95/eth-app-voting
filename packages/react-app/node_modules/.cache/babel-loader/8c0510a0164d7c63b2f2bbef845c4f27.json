{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:publisher');\nlog.error = debug('ipfs:ipns:publisher:error');\n\nconst ipns = require('ipns');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nclass IpnsPublisher {\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  } // publish record with a eol\n\n\n  async publishWithEOL(privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes);\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n    return this._putRecordToRouting(record, peerId);\n  } // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n\n\n  async publish(privKey, value) {\n    // eslint-disable-line require-await\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n\n  async _putRecordToRouting(record, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const publicKey = peerId._pubKey;\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record);\n    const keys = ipns.getIdKeys(peerId.toBytes());\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId); // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n\n    await this._publishPublicKey(keys.routingPubKey, publicKey);\n    return embedPublicKeyRecord || record;\n  }\n\n  async _publishEntry(key, entry) {\n    if (!Key.isKey(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    let entryData;\n\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // Add record to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(key.toBuffer(), entryData);\n      log(`ipns record for ${key.toString('base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `ipns record for ${key.toString('base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n\n  async _publishPublicKey(key, publicKey) {\n    if (!Key.isKey(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER');\n    } // Add public key to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(key.toBuffer(), publicKey.bytes);\n      log(`public key for ${key.toString('base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `public key for ${key.toString('base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  } // Returns the record this node has published corresponding to the given peer ID.\n  // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n\n\n  async _getPublished(peerId, options) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    options = options || {};\n    const checkRouting = options.checkRouting !== false;\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id)); // unmarshal data\n\n      return this._unmarshalData(dsVal);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n\n      if (!checkRouting) {\n        throw errcode(err);\n      } // Try to get from routing\n\n\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes());\n        const res = await this._routing.get(keys.routingKey.toBuffer()); // unmarshal data\n\n        return this._unmarshalData(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n\n  async _updateOrCreateRecord(privKey, value, validity, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n    let record;\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    } // Determinate the record sequence number\n\n\n    let seqNumber = 0;\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;\n    }\n\n    let entryData;\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, validity);\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData); // Store the new record\n\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data);\n      log(`ipns record for ${value} was stored in the datastore`);\n      return entryData;\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/ipns/publisher.js"],"names":["PeerId","require","Key","Errors","errcode","debug","log","error","ipns","ERR_NOT_FOUND","notFoundError","code","defaultRecordLifetime","IpnsPublisher","constructor","routing","datastore","_routing","_datastore","publishWithEOL","privKey","value","lifetime","bytes","Error","peerId","createFromPrivKey","record","_updateOrCreateRecord","_putRecordToRouting","publish","isPeerId","errMsg","publicKey","_pubKey","embedPublicKeyRecord","embedPublicKey","keys","getIdKeys","toBytes","_publishEntry","routingKey","_publishPublicKey","routingPubKey","key","entry","isKey","entryData","marshal","err","res","put","toBuffer","toString","_getPublished","options","checkRouting","dsVal","get","getLocalKey","id","_unmarshalData","data","unmarshal","validity","getPublishedOptions","seqNumber","sequence","undefined","create","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst { Key, Errors } = require('interface-datastore')\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('ipfs:ipns:publisher')\nlog.error = debug('ipfs:ipns:publisher:error')\n\nconst ipns = require('ipns')\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst defaultRecordLifetime = 60 * 60 * 1000\n\n// IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\nclass IpnsPublisher {\n  constructor (routing, datastore) {\n    this._routing = routing\n    this._datastore = datastore\n  }\n\n  // publish record with a eol\n  async publishWithEOL (privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY')\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes)\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId)\n\n    return this._putRecordToRouting(record, peerId)\n  }\n\n  // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n  async publish (privKey, value) { // eslint-disable-line require-await\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime)\n  }\n\n  async _putRecordToRouting (record, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const publicKey = peerId._pubKey\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record)\n    const keys = ipns.getIdKeys(peerId.toBytes())\n\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId)\n\n    // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n    await this._publishPublicKey(keys.routingPubKey, publicKey)\n\n    return embedPublicKeyRecord || record\n  }\n\n  async _publishEntry (key, entry) {\n    if (!(Key.isKey(key))) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    let entryData\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry)\n    } catch (err) {\n      log.error(err)\n\n      throw err\n    }\n\n    // Add record to routing (buffer key)\n    try {\n      const res = await this._routing.put(key.toBuffer(), entryData)\n      log(`ipns record for ${key.toString('base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `ipns record for ${key.toString('base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  async _publishPublicKey (key, publicKey) {\n    if ((!Key.isKey(key))) {\n      const errMsg = 'datastore key does not have a valid format'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER')\n    }\n\n    // Add public key to routing (buffer key)\n    try {\n      const res = await this._routing.put(key.toBuffer(), publicKey.bytes)\n      log(`public key for ${key.toString('base64')} was stored in the routing`)\n\n      return res\n    } catch (err) {\n      const errMsg = `public key for ${key.toString('base64')} could not be stored in the routing`\n      log.error(errMsg)\n      log.error(err)\n\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING')\n    }\n  }\n\n  // Returns the record this node has published corresponding to the given peer ID.\n  // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n  async _getPublished (peerId, options) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    options = options || {}\n    const checkRouting = options.checkRouting !== false\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id))\n\n      // unmarshal data\n      return this._unmarshalData(dsVal)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE')\n      }\n\n      if (!checkRouting) {\n        throw errcode(err)\n      }\n\n      // Try to get from routing\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes())\n        const res = await this._routing.get(keys.routingKey.toBuffer())\n\n        // unmarshal data\n        return this._unmarshalData(res)\n      } catch (err) {\n        log.error(err)\n\n        throw err\n      }\n    }\n  }\n\n  _unmarshalData (data) {\n    try {\n      return ipns.unmarshal(data)\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA')\n    }\n  }\n\n  async _updateOrCreateRecord (privKey, value, validity, peerId) {\n    if (!(PeerId.isPeerId(peerId))) {\n      const errMsg = 'peerId received is not valid'\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID')\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    }\n\n    let record\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions)\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id}`\n        log.error(errMsg)\n\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD')\n      }\n    }\n\n    // Determinate the record sequence number\n    let seqNumber = 0\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence\n    }\n\n    let entryData\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, validity)\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`\n\n      log.error(err)\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD')\n    }\n\n    // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData)\n\n      // Store the new record\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data)\n\n      log(`ipns record for ${value} was stored in the datastore`)\n\n      return entryData\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`\n      log.error(errMsg)\n\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE')\n    }\n  }\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime\nexports = module.exports = IpnsPublisher\n"]},"metadata":{},"sourceType":"script"}