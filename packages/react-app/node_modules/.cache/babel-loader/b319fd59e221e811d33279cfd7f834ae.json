{"ast":null,"code":"'use strict';\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst {\n  MFS_FILE_TYPES,\n  withTimeoutOption\n} = require('../../utils');\n\nconst toOutput = fsEntry => {\n  let type = 0;\n  let size = fsEntry.node.size || fsEntry.node.length;\n  let mode;\n  let mtime;\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize();\n    type = MFS_FILE_TYPES[fsEntry.unixfs.type];\n    mode = fsEntry.unixfs.mode;\n    mtime = fsEntry.unixfs.mtime;\n  }\n\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  };\n\n  if (mtime !== undefined) {\n    output.mtime = mtime;\n  }\n\n  if (mode !== undefined) {\n    output.mode = mode;\n  }\n\n  return output;\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function* mfsLs(path = '/', options = {}) {\n    if (typeof path === 'object' && !(path instanceof String)) {\n      options = path;\n      path = '/';\n    }\n\n    const mfsPath = await toMfsPath(context, path, options);\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld); // single file/node\n\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir);\n      return;\n    } // directory, perhaps sharded\n\n\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry);\n    }\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/ls.js"],"names":["exporter","require","toMfsPath","MFS_FILE_TYPES","withTimeoutOption","toOutput","fsEntry","type","size","node","length","mode","mtime","unixfs","fileSize","output","cid","name","undefined","module","exports","context","mfsLs","path","options","String","mfsPath","fsDir","ipld","includes","content"],"mappings":"AAAA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,qBAAD,CAAzB;;AACA,MAAM;AACJE,EAAAA,cADI;AAEJC,EAAAA;AAFI,IAGFH,OAAO,CAAC,aAAD,CAHX;;AAKA,MAAMI,QAAQ,GAAIC,OAAD,IAAa;AAC5B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAGF,OAAO,CAACG,IAAR,CAAaD,IAAb,IAAqBF,OAAO,CAACG,IAAR,CAAaC,MAA7C;AACA,MAAIC,IAAJ;AACA,MAAIC,KAAJ;;AAEA,MAAIN,OAAO,CAACO,MAAZ,EAAoB;AAClBL,IAAAA,IAAI,GAAGF,OAAO,CAACO,MAAR,CAAeC,QAAf,EAAP;AACAP,IAAAA,IAAI,GAAGJ,cAAc,CAACG,OAAO,CAACO,MAAR,CAAeN,IAAhB,CAArB;AACAI,IAAAA,IAAI,GAAGL,OAAO,CAACO,MAAR,CAAeF,IAAtB;AACAC,IAAAA,KAAK,GAAGN,OAAO,CAACO,MAAR,CAAeD,KAAvB;AACD;;AAED,QAAMG,MAAM,GAAG;AACbC,IAAAA,GAAG,EAAEV,OAAO,CAACU,GADA;AAEbC,IAAAA,IAAI,EAAEX,OAAO,CAACW,IAFD;AAGbV,IAAAA,IAHa;AAIbC,IAAAA;AAJa,GAAf;;AAOA,MAAII,KAAK,KAAKM,SAAd,EAAyB;AACvBH,IAAAA,MAAM,CAACH,KAAP,GAAeA,KAAf;AACD;;AAED,MAAID,IAAI,KAAKO,SAAb,EAAwB;AACtBH,IAAAA,MAAM,CAACJ,IAAP,GAAcA,IAAd;AACD;;AAED,SAAOI,MAAP;AACD,CA7BD;;AA+BAI,MAAM,CAACC,OAAP,GAAkBC,OAAD,IAAa;AAC5B,SAAOjB,iBAAiB,CAAC,gBAAiBkB,KAAjB,CAAwBC,IAAI,GAAG,GAA/B,EAAoCC,OAAO,GAAG,EAA9C,EAAkD;AACzE,QAAI,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,EAAEA,IAAI,YAAYE,MAAlB,CAAhC,EAA2D;AACzDD,MAAAA,OAAO,GAAGD,IAAV;AACAA,MAAAA,IAAI,GAAG,GAAP;AACD;;AAED,UAAMG,OAAO,GAAG,MAAMxB,SAAS,CAACmB,OAAD,EAAUE,IAAV,EAAgBC,OAAhB,CAA/B;AACA,UAAMG,KAAK,GAAG,MAAM3B,QAAQ,CAAC0B,OAAO,CAACA,OAAT,EAAkBL,OAAO,CAACO,IAA1B,CAA5B,CAPyE,CASzE;;AACA,QAAI,CAACD,KAAK,CAACd,MAAP,IAAiB,CAACc,KAAK,CAACd,MAAN,CAAaN,IAAb,CAAkBsB,QAAlB,CAA2B,WAA3B,CAAtB,EAA+D;AAC7D,YAAMxB,QAAQ,CAACsB,KAAD,CAAd;AAEA;AACD,KAdwE,CAgBzE;;;AACA,eAAW,MAAMrB,OAAjB,IAA4BqB,KAAK,CAACG,OAAN,CAAcN,OAAd,CAA5B,EAAoD;AAClD,YAAMnB,QAAQ,CAACC,OAAD,CAAd;AACD;AACF,GApBuB,CAAxB;AAqBD,CAtBD","sourcesContent":["'use strict'\n\nconst exporter = require('ipfs-unixfs-exporter')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst {\n  MFS_FILE_TYPES,\n  withTimeoutOption\n} = require('../../utils')\n\nconst toOutput = (fsEntry) => {\n  let type = 0\n  let size = fsEntry.node.size || fsEntry.node.length\n  let mode\n  let mtime\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize()\n    type = MFS_FILE_TYPES[fsEntry.unixfs.type]\n    mode = fsEntry.unixfs.mode\n    mtime = fsEntry.unixfs.mtime\n  }\n\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  }\n\n  if (mtime !== undefined) {\n    output.mtime = mtime\n  }\n\n  if (mode !== undefined) {\n    output.mode = mode\n  }\n\n  return output\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function * mfsLs (path = '/', options = {}) {\n    if (typeof path === 'object' && !(path instanceof String)) {\n      options = path\n      path = '/'\n    }\n\n    const mfsPath = await toMfsPath(context, path, options)\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld)\n\n    // single file/node\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir)\n\n      return\n    }\n\n    // directory, perhaps sharded\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}