{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar debug = require('debug');\n\nvar errcode = require('err-code');\n\nvar mergeOptions = require('merge-options');\n\nvar CID = require('cids');\n\nvar isDomain = require('is-domain-name');\n\nvar log = debug('ipfs:name:resolve');\nlog.error = debug('ipfs:name:resolve:error');\n\nvar _require = require('../../utils'),\n    OFFLINE_ERROR = _require.OFFLINE_ERROR,\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar appendRemainder = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(result, remainder) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return result;\n\n          case 2:\n            result = _context.sent;\n\n            if (!remainder.length) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", result + '/' + remainder.join('/'));\n\n          case 5:\n            return _context.abrupt(\"return\", result);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function appendRemainder(_x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = function (_ref2) {\n  var dns = _ref2.dns,\n      ipns = _ref2.ipns,\n      peerId = _ref2.peerId,\n      isOnline = _ref2.isOnline,\n      constructorOptions = _ref2.options;\n\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n   * @param {Object} options ipfs resolve options.\n   * @param {boolean} options.nocache do not use cached entries.\n   * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n   * @param {function(Error)} [callback]\n   * @returns {Promise|void}\n   */\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _resolve = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, options) {\n      var offline, _name$slice$split, _name$slice$split2, namespace, hash, remainder;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // eslint-disable-line require-await\n              options = mergeOptions({\n                nocache: false,\n                recursive: true\n              }, options || {});\n              offline = constructorOptions.offline; // TODO: params related logic should be in the core implementation\n\n              if (!(offline && options.nocache)) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n\n            case 4:\n              // Set node id as name for being resolved, if it is not received\n              if (!name) {\n                name = peerId.toB58String();\n              }\n\n              if (!name.startsWith('/ipns/')) {\n                name = \"/ipns/\".concat(name);\n              }\n\n              _name$slice$split = name.slice(1).split('/'), _name$slice$split2 = _toArray(_name$slice$split), namespace = _name$slice$split2[0], hash = _name$slice$split2[1], remainder = _name$slice$split2.slice(2);\n              _context2.prev = 7;\n              new CID(hash); // eslint-disable-line no-new\n\n              _context2.next = 19;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](7);\n\n              if (!isDomain(hash)) {\n                _context2.next = 17;\n                break;\n              }\n\n              _context2.next = 16;\n              return appendRemainder(dns(hash, options), remainder);\n\n            case 16:\n              return _context2.abrupt(\"return\");\n\n            case 17:\n              log.error(_context2.t0);\n              throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n\n            case 19:\n              if (!(!isOnline() && !offline)) {\n                _context2.next = 21;\n                break;\n              }\n\n              throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n\n            case 21:\n              _context2.next = 23;\n              return appendRemainder(ipns.resolve(\"/\".concat(namespace, \"/\").concat(hash), options), remainder);\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[7, 11]]);\n    }));\n\n    function resolve(_x, _x2) {\n      return _resolve.apply(this, arguments);\n    }\n\n    return resolve;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/name/resolve.js"],"names":["debug","require","errcode","mergeOptions","CID","isDomain","log","error","OFFLINE_ERROR","withTimeoutOption","appendRemainder","result","remainder","length","join","module","exports","dns","ipns","peerId","isOnline","constructorOptions","options","name","nocache","recursive","offline","Error","toB58String","startsWith","slice","split","namespace","hash","resolve"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst CID = require('cids')\nconst isDomain = require('is-domain-name')\n\nconst log = debug('ipfs:name:resolve')\nlog.error = debug('ipfs:name:resolve:error')\n\nconst { OFFLINE_ERROR, withTimeoutOption } = require('../../utils')\n\nconst appendRemainder = async (result, remainder) => {\n  result = await result\n\n  if (remainder.length) {\n    return result + '/' + remainder.join('/')\n  }\n\n  return result\n}\n\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\nmodule.exports = ({ dns, ipns, peerId, isOnline, options: constructorOptions }) => {\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n   * @param {Object} options ipfs resolve options.\n   * @param {boolean} options.nocache do not use cached entries.\n   * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n   * @param {function(Error)} [callback]\n   * @returns {Promise|void}\n   */\n  return withTimeoutOption(async function * resolve (name, options) { // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options || {})\n\n    const { offline } = constructorOptions\n\n    // TODO: params related logic should be in the core implementation\n    if (offline && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE')\n    }\n\n    // Set node id as name for being resolved, if it is not received\n    if (!name) {\n      name = peerId.toB58String()\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/')\n    try {\n      new CID(hash) // eslint-disable-line no-new\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(dns(hash, options), remainder)\n        return\n      }\n\n      log.error(err)\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME')\n    }\n\n    // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR')\n    }\n\n    // TODO: convert ipns.resolve to return an iterator\n    yield appendRemainder(ipns.resolve(`/${namespace}/${hash}`, options), remainder)\n  })\n}\n"]},"metadata":{},"sourceType":"script"}