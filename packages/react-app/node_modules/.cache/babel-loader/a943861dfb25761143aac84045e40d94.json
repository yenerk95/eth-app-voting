{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n\nconst {\n  Buffer\n} = require('buffer');\n\nmodule.exports = ({\n  libp2p,\n  repo\n}) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Buffer>}\n     */\n    get: withTimeoutOption(async (key, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return libp2p._dht.get(key, options);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption(async (key, value) => {\n      // eslint-disable-line require-await\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return libp2p._dht.put(key, value);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption(async function* (key, options) {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders;\n      }\n\n      for await (const peer of libp2p._dht.findProviders(key, options)) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        };\n      }\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption(async peerId => {\n      // eslint-disable-line require-await\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      const peer = await libp2p._dht.findPeer(peerId);\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.addrs\n      };\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} keys - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption(async (keys, options) => {\n      keys = Array.isArray(keys) ? keys : [keys];\n      options = options || {};\n\n      for (var i in keys) {\n        if (typeof keys[i] === 'string') {\n          try {\n            keys[i] = new CID(keys[i]);\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID');\n          }\n        }\n      } // ensure blocks are actually local\n\n\n      const hasKeys = await Promise.all(keys.map(k => repo.blocks.has(k)));\n      const hasAll = hasKeys.every(has => has);\n\n      if (!hasAll) {\n        throw errCode('block(s) not found locally, cannot provide', 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET');\n      } else {\n        await Promise.all(keys.map(k => libp2p._dht.provide(k)));\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption(async function* (peerId) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n\n        };\n      }\n    })\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/dht.js"],"names":["PeerId","require","CID","errCode","withTimeoutOption","Buffer","module","exports","libp2p","repo","get","key","options","isBuffer","buffer","err","_dht","put","value","findProvs","numProviders","maxNumProviders","peer","findProviders","id","toB58String","addrs","findPeer","peerId","createFromCID","provide","keys","Array","isArray","i","hasKeys","Promise","all","map","k","blocks","has","hasAll","every","recursive","query","closerPeerId","getClosestPeers","toBytes"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAwBH,OAAO,CAAC,UAAD,CAArC;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAaJ,OAAO,CAAC,QAAD,CAA1B;;AAEAK,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,MAAF;AAAUC,EAAAA;AAAV,CAAD,KAAsB;AACrC,SAAO;AACL;;;;;;;;AAQAC,IAAAA,GAAG,EAAEN,iBAAiB,CAAC,OAAOO,GAAP,EAAYC,OAAZ,KAAwB;AAAE;AAC/CA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,UAAI,CAACP,MAAM,CAACQ,QAAP,CAAgBF,GAAhB,CAAL,EAA2B;AACzB,YAAI;AACFA,UAAAA,GAAG,GAAI,IAAIT,GAAJ,CAAQS,GAAR,CAAD,CAAeG,MAArB;AACD,SAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,gBAAMZ,OAAO,CAACY,GAAD,EAAM,iBAAN,CAAb;AACD;AACF;;AAED,aAAOP,MAAM,CAACQ,IAAP,CAAYN,GAAZ,CAAgBC,GAAhB,EAAqBC,OAArB,CAAP;AACD,KAZqB,CATjB;;AAuBL;;;;;;;;;;;AAWAK,IAAAA,GAAG,EAAEb,iBAAiB,CAAC,OAAOO,GAAP,EAAYO,KAAZ,KAAsB;AAAE;AAC7C,UAAI,CAACb,MAAM,CAACQ,QAAP,CAAgBF,GAAhB,CAAL,EAA2B;AACzB,YAAI;AACFA,UAAAA,GAAG,GAAI,IAAIT,GAAJ,CAAQS,GAAR,CAAD,CAAeG,MAArB;AACD,SAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,gBAAMZ,OAAO,CAACY,GAAD,EAAM,iBAAN,CAAb;AACD;AACF;;AAED,aAAOP,MAAM,CAACQ,IAAP,CAAYC,GAAZ,CAAgBN,GAAhB,EAAqBO,KAArB,CAAP;AACD,KAVqB,CAlCjB;;AA8CL;;;;;;;;;AASAC,IAAAA,SAAS,EAAEf,iBAAiB,CAAC,iBAAkBO,GAAlB,EAAuBC,OAAvB,EAAgC;AAAE;AAC7DA,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,UAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAI;AACFA,UAAAA,GAAG,GAAG,IAAIT,GAAJ,CAAQS,GAAR,CAAN;AACD,SAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,gBAAMZ,OAAO,CAACY,GAAD,EAAM,iBAAN,CAAb;AACD;AACF;;AAED,UAAIH,OAAO,CAACQ,YAAZ,EAA0B;AACxBR,QAAAA,OAAO,CAACS,eAAR,GAA0BT,OAAO,CAACQ,YAAlC;AACD;;AAED,iBAAW,MAAME,IAAjB,IAAyBd,MAAM,CAACQ,IAAP,CAAYO,aAAZ,CAA0BZ,GAA1B,EAA+BC,OAA/B,CAAzB,EAAkE;AAChE,cAAM;AACJY,UAAAA,EAAE,EAAEF,IAAI,CAACE,EAAL,CAAQC,WAAR,EADA;AAEJC,UAAAA,KAAK,EAAEJ,IAAI,CAACI;AAFR,SAAN;AAID;AACF,KArB2B,CAvDvB;;AA8EL;;;;;;AAMAC,IAAAA,QAAQ,EAAEvB,iBAAiB,CAAC,MAAMwB,MAAN,IAAgB;AAAE;AAC5C,UAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,QAAAA,MAAM,GAAG5B,MAAM,CAAC6B,aAAP,CAAqBD,MAArB,CAAT;AACD;;AAED,YAAMN,IAAI,GAAG,MAAMd,MAAM,CAACQ,IAAP,CAAYW,QAAZ,CAAqBC,MAArB,CAAnB;AAEA,aAAO;AACLJ,QAAAA,EAAE,EAAEF,IAAI,CAACE,EAAL,CAAQC,WAAR,EADC;AAELC,QAAAA,KAAK,EAAEJ,IAAI,CAACI;AAFP,OAAP;AAID,KAX0B,CApFtB;;AAiGL;;;;;;;;AAQAI,IAAAA,OAAO,EAAE1B,iBAAiB,CAAC,OAAO2B,IAAP,EAAanB,OAAb,KAAyB;AAClDmB,MAAAA,IAAI,GAAGC,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAApC;AACAnB,MAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,WAAK,IAAIsB,CAAT,IAAcH,IAAd,EAAoB;AAClB,YAAI,OAAOA,IAAI,CAACG,CAAD,CAAX,KAAmB,QAAvB,EAAiC;AAC/B,cAAI;AACFH,YAAAA,IAAI,CAACG,CAAD,CAAJ,GAAU,IAAIhC,GAAJ,CAAQ6B,IAAI,CAACG,CAAD,CAAZ,CAAV;AACD,WAFD,CAEE,OAAOnB,GAAP,EAAY;AACZ,kBAAMZ,OAAO,CAACY,GAAD,EAAM,iBAAN,CAAb;AACD;AACF;AACF,OAZiD,CAclD;;;AACA,YAAMoB,OAAO,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYN,IAAI,CAACO,GAAL,CAASC,CAAC,IAAI9B,IAAI,CAAC+B,MAAL,CAAYC,GAAZ,CAAgBF,CAAhB,CAAd,CAAZ,CAAtB;AACA,YAAMG,MAAM,GAAGP,OAAO,CAACQ,KAAR,CAAcF,GAAG,IAAIA,GAArB,CAAf;;AAEA,UAAI,CAACC,MAAL,EAAa;AACX,cAAMvC,OAAO,CAAC,4CAAD,EAA+C,qBAA/C,CAAb;AACD;;AAED,UAAIS,OAAO,CAACgC,SAAZ,EAAuB;AACrB;AACA,cAAMzC,OAAO,CAAC,qBAAD,EAAwB,yBAAxB,CAAb;AACD,OAHD,MAGO;AACL,cAAMiC,OAAO,CAACC,GAAR,CAAYN,IAAI,CAACO,GAAL,CAASC,CAAC,IAAI/B,MAAM,CAACQ,IAAP,CAAYc,OAAZ,CAAoBS,CAApB,CAAd,CAAZ,CAAN;AACD;AACF,KA5ByB,CAzGrB;;AAuIL;;;;;;AAMAM,IAAAA,KAAK,EAAEzC,iBAAiB,CAAC,iBAAkBwB,MAAlB,EAA0B;AACjD,UAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,QAAAA,MAAM,GAAG5B,MAAM,CAAC6B,aAAP,CAAqBD,MAArB,CAAT;AACD;;AAED,iBAAW,MAAMkB,YAAjB,IAAiCtC,MAAM,CAACQ,IAAP,CAAY+B,eAAZ,CAA4BnB,MAAM,CAACoB,OAAP,EAA5B,CAAjC,EAAgF;AAC9E,cAAM;AACJxB,UAAAA,EAAE,EAAEsB,YAAY,CAACrB,WAAb,EADA;AAEJC,UAAAA,KAAK,EAAE,EAFH,CAEM;;AAFN,SAAN;AAID;AACF,KAXuB;AA7InB,GAAP;AA0JD,CA3JD","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst CID = require('cids')\nconst errCode = require('err-code')\nconst { withTimeoutOption } = require('../utils')\nconst { Buffer } = require('buffer')\n\nmodule.exports = ({ libp2p, repo }) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Buffer>}\n     */\n    get: withTimeoutOption(async (key, options) => { // eslint-disable-line require-await\n      options = options || {}\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return libp2p._dht.get(key, options)\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption(async (key, value) => { // eslint-disable-line require-await\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = (new CID(key)).buffer\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      return libp2p._dht.put(key, value)\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption(async function * (key, options) { // eslint-disable-line require-await\n      options = options || {}\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key)\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID')\n        }\n      }\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders\n      }\n\n      for await (const peer of libp2p._dht.findProviders(key, options)) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        }\n      }\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption(async peerId => { // eslint-disable-line require-await\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId)\n      }\n\n      const peer = await libp2p._dht.findPeer(peerId)\n\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.addrs\n      }\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} keys - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption(async (keys, options) => {\n      keys = Array.isArray(keys) ? keys : [keys]\n      options = options || {}\n\n      for (var i in keys) {\n        if (typeof keys[i] === 'string') {\n          try {\n            keys[i] = new CID(keys[i])\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID')\n          }\n        }\n      }\n\n      // ensure blocks are actually local\n      const hasKeys = await Promise.all(keys.map(k => repo.blocks.has(k)))\n      const hasAll = hasKeys.every(has => has)\n\n      if (!hasAll) {\n        throw errCode('block(s) not found locally, cannot provide', 'ERR_BLOCK_NOT_FOUND')\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET')\n      } else {\n        await Promise.all(keys.map(k => libp2p._dht.provide(k)))\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption(async function * (peerId) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId)\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n        }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}