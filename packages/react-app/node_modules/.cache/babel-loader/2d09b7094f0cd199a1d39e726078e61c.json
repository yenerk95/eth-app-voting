{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar PeerId = require('peer-id');\n\nvar crypto = require('libp2p-crypto');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nvar pbm = require('./secio.proto');\n\nvar support = require('../support');\n\nvar _require2 = require('libp2p-interfaces/src/crypto/errors'),\n    UnexpectedPeerError = _require2.UnexpectedPeerError; // nonceSize is the size of our nonces (in bytes)\n\n\nvar nonceSize = 16;\n\nexports.createProposal = function (state) {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(state) {\n    var res, selectionOut, sig;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT);\n\n          case 2:\n            res = _context.sent;\n            state.ephemeralKey.local = res.key;\n            state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n            selectionOut = Buffer.concat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n            _context.next = 8;\n            return state.key.local.sign(selectionOut);\n\n          case 8:\n            sig = _context.sent;\n            state.exchange.out = {\n              epubkey: state.ephemeralKey.local,\n              signature: sig\n            };\n            return _context.abrupt(\"return\", pbm.Exchange.encode(state.exchange.out));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.identify = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(state, msg) {\n    var pubkey, remoteId;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            log('1.1 identify');\n            state.proposalEncoded.in = msg;\n            state.proposal.in = pbm.Propose.decode(msg);\n            pubkey = state.proposal.in.pubkey;\n            state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n            _context2.next = 7;\n            return PeerId.createFromPubKey(pubkey.toString('base64'));\n\n          case 7:\n            remoteId = _context2.sent;\n\n            if (!state.id.remote) {\n              _context2.next = 14;\n              break;\n            }\n\n            if (!(state.id.remote.toString() !== remoteId.toString())) {\n              _context2.next = 11;\n              break;\n            }\n\n            throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!');\n\n          case 11:\n            state.id.remote.pubKey = state.key.remote;\n            _context2.next = 15;\n            break;\n\n          case 14:\n            state.id.remote = remoteId;\n\n          case 15:\n            log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.selectProtocols = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(state) {\n    var local, remote, selected;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            log('1.2 selection');\n            local = {\n              pubKeyBytes: state.key.local.public.bytes,\n              exchanges: support.exchanges,\n              hashes: support.hashes,\n              ciphers: support.ciphers,\n              nonce: state.proposal.out.rand\n            };\n            remote = {\n              pubKeyBytes: state.proposal.in.pubkey,\n              exchanges: state.proposal.in.exchanges.split(','),\n              hashes: state.proposal.in.hashes.split(','),\n              ciphers: state.proposal.in.ciphers.split(','),\n              nonce: state.proposal.in.rand\n            };\n            _context3.next = 5;\n            return support.selectBest(local, remote);\n\n          case 5:\n            selected = _context3.sent;\n            // we use the same params for both directions (must choose same curve)\n            // WARNING: if they dont SelectBest the same way, this won't work...\n            state.protocols.remote = {\n              order: selected.order,\n              curveT: selected.curveT,\n              cipherT: selected.cipherT,\n              hashT: selected.hashT\n            };\n            state.protocols.local = {\n              order: selected.order,\n              curveT: selected.curveT,\n              cipherT: selected.cipherT,\n              hashT: selected.hashT\n            };\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.verify = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(state, msg) {\n    var selectionIn, sigOk;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            log('2.1. verify');\n            state.exchange.in = pbm.Exchange.decode(msg);\n            state.ephemeralKey.remote = state.exchange.in.epubkey;\n            selectionIn = Buffer.concat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n            _context4.next = 6;\n            return state.key.remote.verify(selectionIn, state.exchange.in.signature);\n\n          case 6:\n            sigOk = _context4.sent;\n\n            if (sigOk) {\n              _context4.next = 9;\n              break;\n            }\n\n            throw new Error('Bad signature');\n\n          case 9:\n            log('2.1. verify - signature verified');\n\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x5, _x6) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.generateKeys = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(state) {\n    var secret, keys;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            log('2.2. keys');\n            _context5.next = 3;\n            return state.shared.generate(state.exchange.in.epubkey);\n\n          case 3:\n            secret = _context5.sent;\n            state.shared.secret = secret;\n            _context5.next = 7;\n            return crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret);\n\n          case 7:\n            keys = _context5.sent;\n\n            if (!(state.protocols.local.order > 0)) {\n              _context5.next = 13;\n              break;\n            }\n\n            state.protocols.local.keys = keys.k1;\n            state.protocols.remote.keys = keys.k2;\n            _context5.next = 19;\n            break;\n\n          case 13:\n            if (!(state.protocols.local.order < 0)) {\n              _context5.next = 18;\n              break;\n            }\n\n            // swap\n            state.protocols.local.keys = keys.k2;\n            state.protocols.remote.keys = keys.k1;\n            _context5.next = 19;\n            break;\n\n          case 18:\n            throw new Error('you are trying to talk to yourself');\n\n          case 19:\n            log('2.3. mac + cipher');\n            _context5.next = 22;\n            return Promise.all([state.protocols.local, state.protocols.remote].map(function (data) {\n              return support.makeMacAndCipher(data);\n            }));\n\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function (_x7) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.verifyNonce = function (state, n2) {\n  var n1 = state.proposal.out.rand;\n  if (n1.equals(n2)) return;\n  throw new Error(\"Failed to read our encrypted nonce: \".concat(n1.toString('hex'), \" != \").concat(n2.toString('hex')));\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-secio/src/handshake/crypto.js"],"names":["require","Buffer","PeerId","crypto","debug","log","error","pbm","support","UnexpectedPeerError","nonceSize","exports","createProposal","state","proposal","out","rand","randomBytes","pubkey","key","local","public","bytes","exchanges","join","ciphers","hashes","proposalEncoded","Propose","encode","createExchange","keys","generateEphemeralKeyPair","protocols","curveT","res","ephemeralKey","shared","generate","genSharedKey","selectionOut","concat","in","sign","sig","exchange","epubkey","signature","Exchange","identify","msg","decode","remote","unmarshalPublicKey","createFromPubKey","toString","remoteId","id","pubKey","toB58String","selectProtocols","pubKeyBytes","nonce","split","selectBest","selected","order","cipherT","hashT","verify","selectionIn","sigOk","Error","generateKeys","secret","keyStretcher","k1","k2","Promise","all","map","data","makeMacAndCipher","verifyNonce","n2","n1","equals"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst debug = require('debug')\nconst log = debug('libp2p:secio')\nlog.error = debug('libp2p:secio:error')\n\nconst pbm = require('./secio.proto')\n\nconst support = require('../support')\n\nconst { UnexpectedPeerError } = require('libp2p-interfaces/src/crypto/errors')\n\n// nonceSize is the size of our nonces (in bytes)\nconst nonceSize = 16\n\nexports.createProposal = (state) => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  }\n\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out)\n  return state.proposalEncoded.out\n}\n\nexports.createExchange = async (state) => {\n  const res = await crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT)\n\n  state.ephemeralKey.local = res.key\n  state.shared.generate = res.genSharedKey\n\n  // Gather corpus to sign.\n  const selectionOut = Buffer.concat([\n    state.proposalEncoded.out,\n    state.proposalEncoded.in,\n    state.ephemeralKey.local\n  ])\n\n  const sig = await state.key.local.sign(selectionOut)\n\n  state.exchange.out = {\n    epubkey: state.ephemeralKey.local,\n    signature: sig\n  }\n\n  return pbm.Exchange.encode(state.exchange.out)\n}\n\nexports.identify = async (state, msg) => {\n  log('1.1 identify')\n\n  state.proposalEncoded.in = msg\n  state.proposal.in = pbm.Propose.decode(msg)\n  const pubkey = state.proposal.in.pubkey\n\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey)\n\n  const remoteId = await PeerId.createFromPubKey(pubkey.toString('base64'))\n\n  // If we know who we are dialing to, double check\n  if (state.id.remote) {\n    if (state.id.remote.toString() !== remoteId.toString()) {\n      throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!')\n    }\n    state.id.remote.pubKey = state.key.remote\n  } else {\n    state.id.remote = remoteId\n  }\n\n  log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String())\n}\n\nexports.selectProtocols = async (state) => {\n  log('1.2 selection')\n\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  }\n\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  }\n\n  const selected = await support.selectBest(local, remote)\n\n  // we use the same params for both directions (must choose same curve)\n  // WARNING: if they dont SelectBest the same way, this won't work...\n  state.protocols.remote = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  }\n\n  state.protocols.local = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  }\n}\n\nexports.verify = async (state, msg) => {\n  log('2.1. verify')\n\n  state.exchange.in = pbm.Exchange.decode(msg)\n  state.ephemeralKey.remote = state.exchange.in.epubkey\n\n  const selectionIn = Buffer.concat([\n    state.proposalEncoded.in,\n    state.proposalEncoded.out,\n    state.ephemeralKey.remote\n  ])\n\n  const sigOk = await state.key.remote.verify(selectionIn, state.exchange.in.signature)\n\n  if (!sigOk) {\n    throw new Error('Bad signature')\n  }\n\n  log('2.1. verify - signature verified')\n}\n\nexports.generateKeys = async (state) => {\n  log('2.2. keys')\n\n  const secret = await state.shared.generate(state.exchange.in.epubkey)\n\n  state.shared.secret = secret\n\n  const keys = await crypto.keys.keyStretcher(\n    state.protocols.local.cipherT,\n    state.protocols.local.hashT,\n    state.shared.secret)\n\n  // use random nonces to decide order.\n  if (state.protocols.local.order > 0) {\n    state.protocols.local.keys = keys.k1\n    state.protocols.remote.keys = keys.k2\n  } else if (state.protocols.local.order < 0) {\n    // swap\n    state.protocols.local.keys = keys.k2\n    state.protocols.remote.keys = keys.k1\n  } else {\n    // we should've bailed before state. but if not, bail here.\n    throw new Error('you are trying to talk to yourself')\n  }\n\n  log('2.3. mac + cipher')\n\n  await Promise.all([state.protocols.local, state.protocols.remote].map(data => support.makeMacAndCipher(data)))\n}\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand\n\n  if (n1.equals(n2)) return\n\n  throw new Error(\n    `Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`\n  )\n}\n"]},"metadata":{},"sourceType":"script"}