{"ast":null,"code":"'use strict';\n\nconst multihashes = require('multihashing-async').multihash;\n\nconst CID = require('cids');\n\nconst protobuf = require('protons');\n\nconst fnv1a = require('fnv1a');\n\nconst varint = require('varint');\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst multicodec = require('multicodec');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst dagCborLinks = require('dag-cbor-links');\n\nconst log = require('debug')('ipfs:pin:pin-set');\n\nconst pbSchema = require('./pin.proto');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n';\nconst emptyKey = multihashes.fromB58String(emptyKeyHash);\nconst defaultFanout = 256;\nconst maxItems = 8192;\nconst pb = protobuf(pbSchema);\nconst HAS_DESCENDANT_CONCURRENCY = 100;\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data;\n  const hdrLength = varint.decode(rootData);\n  const vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  const header = pb.Set.decode(hdrSlice);\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`);\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32LE(seed, 0);\n  const data = Buffer.concat([buf, Buffer.from(toB58String(key))]);\n  return fnv1a(data.toString('binary'));\n}\n\nfunction* cborCids(node) {\n  for (const [_, cid] of dagCborLinks(node)) {\n    // eslint-disable-line no-unused-vars\n    yield cid;\n  }\n}\n\nexports = module.exports = function (dag) {\n  const pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: async (parentCid, childhash) => {\n      if (parentCid.codec !== 'dag-pb' && parentCid.codec !== 'dag-cbor') {\n        return false;\n      }\n\n      const {\n        value: root\n      } = await dag.get(parentCid, {\n        preload: false\n      });\n      const queue = new Queue({\n        concurrency: HAS_DESCENDANT_CONCURRENCY\n      });\n\n      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n        childhash = toB58String(childhash);\n      }\n\n      let found = false;\n      const seen = {};\n\n      function searchChild(linkCid) {\n        return async () => {\n          if (found) {\n            return;\n          }\n\n          try {\n            const {\n              value: childNode\n            } = await dag.get(linkCid, {\n              preload: false\n            });\n            searchChildren(linkCid, childNode);\n          } catch (err) {\n            log(err);\n          }\n        };\n      }\n\n      function searchChildren(cid, node) {\n        let links = [];\n\n        if (cid.codec === 'dag-pb') {\n          links = node.Links;\n        } else if (cid.codec === 'dag-cbor') {\n          links = cborCids(node);\n        }\n\n        for (const link of links) {\n          const linkCid = cid.codec === 'dag-pb' ? link.Hash : link[1];\n          const bs58Link = toB58String(linkCid);\n\n          if (bs58Link === childhash) {\n            queue.clear();\n            found = true;\n            return;\n          }\n\n          if (seen[bs58Link]) {\n            continue;\n          }\n\n          seen[bs58Link] = true;\n\n          if (linkCid.codec !== 'dag-pb' && linkCid.codec !== 'dag-cbor') {\n            continue;\n          }\n\n          queue.add(searchChild(linkCid));\n        }\n      }\n\n      searchChildren(parentCid, root);\n      await queue.onIdle();\n      return found;\n    },\n    storeSet: async keys => {\n      const pins = keys.map(key => {\n        if (typeof key === 'string' || Buffer.isBuffer(key)) {\n          key = new CID(key);\n        }\n\n        return {\n          key: key,\n          data: null\n        };\n      });\n      const rootNode = await pinSet.storeItems(pins);\n      const cid = await dag.put(rootNode, {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      });\n      return {\n        node: rootNode,\n        cid\n      };\n    },\n    storeItems: async items => {\n      // eslint-disable-line require-await\n      return storePins(items, 0);\n\n      async function storePins(pins, depth) {\n        const pbHeader = pb.Set.encode({\n          version: 1,\n          fanout: defaultFanout,\n          seed: depth\n        });\n        const headerBuf = Buffer.concat([Buffer.from(varint.encode(pbHeader.length)), pbHeader]);\n        const fanoutLinks = [];\n\n        for (let i = 0; i < defaultFanout; i++) {\n          fanoutLinks.push(new DAGLink('', 1, emptyKey));\n        }\n\n        if (pins.length <= maxItems) {\n          const nodes = pins.map(item => {\n            return {\n              link: new DAGLink('', 1, item.key),\n              data: item.data || Buffer.alloc(0)\n            };\n          }) // sorting makes any ordering of `pins` produce the same DAGNode\n          .sort((a, b) => Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer));\n          const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));\n          const rootData = Buffer.concat([headerBuf].concat(nodes.map(item => item.data)));\n          return new DAGNode(rootData, rootLinks);\n        } else {\n          // If the array of pins is > maxItems, we:\n          //  - distribute the pins among `defaultFanout` bins\n          //    - create a DAGNode for each bin\n          //      - add each pin as a DAGLink to that bin\n          //  - create a root DAGNode\n          //    - add each bin as a DAGLink\n          //  - send that root DAGNode via callback\n          // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n          const bins = pins.reduce((bins, pin) => {\n            const n = hash(depth, pin.key) % defaultFanout;\n            bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n            return bins;\n          }, []);\n          let idx = 0;\n\n          for (const bin of bins) {\n            const child = await storePins(bin, depth + 1);\n            await storeChild(child, idx);\n            idx++;\n          }\n\n          return new DAGNode(headerBuf, fanoutLinks);\n        }\n\n        async function storeChild(child, binIdx) {\n          const opts = {\n            version: 0,\n            format: multicodec.DAG_PB,\n            hashAlg: multicodec.SHA2_256,\n            preload: false\n          };\n          const cid = await dag.put(child, opts);\n          fanoutLinks[binIdx] = new DAGLink('', child.size, cid);\n        }\n      }\n    },\n    loadSet: async (rootNode, name) => {\n      const link = rootNode.Links.find(l => l.Name === name);\n\n      if (!link) {\n        throw new Error('No link found with name ' + name);\n      }\n\n      const res = await dag.get(link.Hash, '', {\n        preload: false\n      });\n      const keys = [];\n\n      const stepPin = link => keys.push(link.Hash);\n\n      await pinSet.walkItems(res.value, {\n        stepPin\n      });\n      return keys;\n    },\n    walkItems: async (node, {\n      stepPin = () => {},\n      stepBin = () => {}\n    }) => {\n      const pbh = readHeader(node);\n      let idx = 0;\n\n      for (const link of node.Links) {\n        if (idx < pbh.header.fanout) {\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          const linkHash = link.Hash.buffer;\n\n          if (!emptyKey.equals(linkHash)) {\n            stepBin(link, idx, pbh.data); // walk the links of this fanout bin\n\n            const res = await dag.get(linkHash, '', {\n              preload: false\n            });\n            await pinSet.walkItems(res.value, {\n              stepPin,\n              stepBin\n            });\n          }\n        } else {\n          // otherwise, the link is a pin\n          stepPin(link, idx, pbh.data);\n        }\n\n        idx++;\n      }\n    },\n    getInternalCids: async rootNode => {\n      // \"Empty block\" used by the pinner\n      const cids = [new CID(emptyKey)];\n\n      const stepBin = link => cids.push(link.Hash);\n\n      for (const topLevelLink of rootNode.Links) {\n        cids.push(topLevelLink.Hash);\n        const res = await dag.get(topLevelLink.Hash, '', {\n          preload: false\n        });\n        await pinSet.walkItems(res.value, {\n          stepBin\n        });\n      }\n\n      return cids;\n    }\n  };\n  return pinSet;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/pin-set.js"],"names":["multihashes","require","multihash","CID","protobuf","fnv1a","varint","DAGNode","DAGLink","multicodec","default","Queue","dagCborLinks","log","pbSchema","Buffer","emptyKeyHash","emptyKey","fromB58String","defaultFanout","maxItems","pb","HAS_DESCENDANT_CONCURRENCY","toB58String","hash","toBaseEncodedString","readHeader","rootNode","rootData","Data","hdrLength","decode","vBytes","bytes","Error","length","hdrSlice","slice","header","Set","version","fanout","Links","data","seed","key","buf","alloc","writeUInt32LE","concat","from","toString","cborCids","node","_","cid","exports","module","dag","pinSet","hasDescendant","parentCid","childhash","codec","value","root","get","preload","queue","concurrency","isCID","isBuffer","found","seen","searchChild","linkCid","childNode","searchChildren","err","links","link","Hash","bs58Link","clear","add","onIdle","storeSet","keys","pins","map","storeItems","put","format","DAG_PB","hashAlg","SHA2_256","items","storePins","depth","pbHeader","encode","headerBuf","fanoutLinks","i","push","nodes","item","sort","a","b","compare","buffer","rootLinks","bins","reduce","pin","n","idx","bin","child","storeChild","binIdx","opts","size","loadSet","name","find","l","Name","res","stepPin","walkItems","stepBin","pbh","linkHash","equals","getInternalCids","cids","topLevelLink"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multihashes = require('multihashing-async').multihash\nconst CID = require('cids')\nconst protobuf = require('protons')\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst { DAGNode, DAGLink } = require('ipld-dag-pb')\nconst multicodec = require('multicodec')\nconst { default: Queue } = require('p-queue')\nconst dagCborLinks = require('dag-cbor-links')\nconst log = require('debug')('ipfs:pin:pin-set')\nconst pbSchema = require('./pin.proto')\nconst { Buffer } = require('buffer')\n\nconst emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\nconst emptyKey = multihashes.fromB58String(emptyKeyHash)\nconst defaultFanout = 256\nconst maxItems = 8192\nconst pb = protobuf(pbSchema)\n\nconst HAS_DESCENDANT_CONCURRENCY = 100\n\nfunction toB58String (hash) {\n  return new CID(hash).toBaseEncodedString()\n}\n\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = pb.Set.decode(hdrSlice)\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\nfunction hash (seed, key) {\n  const buf = Buffer.alloc(4)\n  buf.writeUInt32LE(seed, 0)\n  const data = Buffer.concat([\n    buf, Buffer.from(toB58String(key))\n  ])\n  return fnv1a(data.toString('binary'))\n}\n\nfunction * cborCids (node) {\n  for (const [_, cid] of dagCborLinks(node)) { // eslint-disable-line no-unused-vars\n    yield cid\n  }\n}\n\nexports = module.exports = function (dag) {\n  const pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: async (parentCid, childhash) => {\n      if (parentCid.codec !== 'dag-pb' && parentCid.codec !== 'dag-cbor') {\n        return false\n      }\n\n      const { value: root } = await dag.get(parentCid, { preload: false })\n      const queue = new Queue({\n        concurrency: HAS_DESCENDANT_CONCURRENCY\n      })\n\n      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n        childhash = toB58String(childhash)\n      }\n\n      let found = false\n      const seen = {}\n\n      function searchChild (linkCid) {\n        return async () => {\n          if (found) {\n            return\n          }\n\n          try {\n            const { value: childNode } = await dag.get(linkCid, { preload: false })\n\n            searchChildren(linkCid, childNode)\n          } catch (err) {\n            log(err)\n          }\n        }\n      }\n\n      function searchChildren (cid, node) {\n        let links = []\n\n        if (cid.codec === 'dag-pb') {\n          links = node.Links\n        } else if (cid.codec === 'dag-cbor') {\n          links = cborCids(node)\n        }\n\n        for (const link of links) {\n          const linkCid = cid.codec === 'dag-pb' ? link.Hash : link[1]\n          const bs58Link = toB58String(linkCid)\n\n          if (bs58Link === childhash) {\n            queue.clear()\n            found = true\n\n            return\n          }\n\n          if (seen[bs58Link]) {\n            continue\n          }\n\n          seen[bs58Link] = true\n\n          if (linkCid.codec !== 'dag-pb' && linkCid.codec !== 'dag-cbor') {\n            continue\n          }\n\n          queue.add(searchChild(linkCid))\n        }\n      }\n\n      searchChildren(parentCid, root)\n\n      await queue.onIdle()\n\n      return found\n    },\n\n    storeSet: async (keys) => {\n      const pins = keys.map(key => {\n        if (typeof key === 'string' || Buffer.isBuffer(key)) {\n          key = new CID(key)\n        }\n\n        return {\n          key: key,\n          data: null\n        }\n      })\n\n      const rootNode = await pinSet.storeItems(pins)\n      const cid = await dag.put(rootNode, {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      })\n\n      return {\n        node: rootNode,\n        cid\n      }\n    },\n\n    storeItems: async (items) => { // eslint-disable-line require-await\n      return storePins(items, 0)\n\n      async function storePins (pins, depth) {\n        const pbHeader = pb.Set.encode({\n          version: 1,\n          fanout: defaultFanout,\n          seed: depth\n        })\n        const headerBuf = Buffer.concat([\n          Buffer.from(varint.encode(pbHeader.length)), pbHeader\n        ])\n        const fanoutLinks = []\n\n        for (let i = 0; i < defaultFanout; i++) {\n          fanoutLinks.push(new DAGLink('', 1, emptyKey))\n        }\n\n        if (pins.length <= maxItems) {\n          const nodes = pins\n            .map(item => {\n              return ({\n                link: new DAGLink('', 1, item.key),\n                data: item.data || Buffer.alloc(0)\n              })\n            })\n            // sorting makes any ordering of `pins` produce the same DAGNode\n            .sort((a, b) => Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer))\n\n          const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n          const rootData = Buffer.concat(\n            [headerBuf].concat(nodes.map(item => item.data))\n          )\n\n          return new DAGNode(rootData, rootLinks)\n        } else {\n          // If the array of pins is > maxItems, we:\n          //  - distribute the pins among `defaultFanout` bins\n          //    - create a DAGNode for each bin\n          //      - add each pin as a DAGLink to that bin\n          //  - create a root DAGNode\n          //    - add each bin as a DAGLink\n          //  - send that root DAGNode via callback\n          // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n          const bins = pins.reduce((bins, pin) => {\n            const n = hash(depth, pin.key) % defaultFanout\n            bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n            return bins\n          }, [])\n\n          let idx = 0\n          for (const bin of bins) {\n            const child = await storePins(bin, depth + 1)\n\n            await storeChild(child, idx)\n\n            idx++\n          }\n\n          return new DAGNode(headerBuf, fanoutLinks)\n        }\n\n        async function storeChild (child, binIdx) {\n          const opts = {\n            version: 0,\n            format: multicodec.DAG_PB,\n            hashAlg: multicodec.SHA2_256,\n            preload: false\n          }\n\n          const cid = await dag.put(child, opts)\n\n          fanoutLinks[binIdx] = new DAGLink('', child.size, cid)\n        }\n      }\n    },\n\n    loadSet: async (rootNode, name) => {\n      const link = rootNode.Links.find(l => l.Name === name)\n\n      if (!link) {\n        throw new Error('No link found with name ' + name)\n      }\n\n      const res = await dag.get(link.Hash, '', { preload: false })\n      const keys = []\n      const stepPin = link => keys.push(link.Hash)\n\n      await pinSet.walkItems(res.value, { stepPin })\n\n      return keys\n    },\n\n    walkItems: async (node, { stepPin = () => {}, stepBin = () => {} }) => {\n      const pbh = readHeader(node)\n      let idx = 0\n\n      for (const link of node.Links) {\n        if (idx < pbh.header.fanout) {\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          const linkHash = link.Hash.buffer\n\n          if (!emptyKey.equals(linkHash)) {\n            stepBin(link, idx, pbh.data)\n\n            // walk the links of this fanout bin\n            const res = await dag.get(linkHash, '', { preload: false })\n\n            await pinSet.walkItems(res.value, { stepPin, stepBin })\n          }\n        } else {\n          // otherwise, the link is a pin\n          stepPin(link, idx, pbh.data)\n        }\n\n        idx++\n      }\n    },\n\n    getInternalCids: async (rootNode) => {\n      // \"Empty block\" used by the pinner\n      const cids = [new CID(emptyKey)]\n      const stepBin = link => cids.push(link.Hash)\n\n      for (const topLevelLink of rootNode.Links) {\n        cids.push(topLevelLink.Hash)\n\n        const res = await dag.get(topLevelLink.Hash, '', { preload: false })\n\n        await pinSet.walkItems(res.value, { stepBin })\n      }\n\n      return cids\n    }\n  }\n\n  return pinSet\n}\n"]},"metadata":{},"sourceType":"script"}