{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar multiaddr = require('multiaddr');\n\nvar withIs = require('class-is');\n\nvar errCode = require('err-code');\n\nvar Status = require('./status');\n\nfunction validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n}\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\n\n\nvar Connection = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Connection.\n   * @param {object} properties properties of the connection.\n   * @param {multiaddr} [properties.localAddr] local multiaddr of the connection if known.\n   * @param {multiaddr} [properties.remoteAddr] remote multiaddr of the connection.\n   * @param {PeerId} properties.localPeer local peer-id.\n   * @param {PeerId} properties.remotePeer remote peer-id.\n   * @param {function} properties.newStream new stream muxer function.\n   * @param {function} properties.close close raw connection function.\n   * @param {function} properties.getStreams get streams from muxer function.\n   * @param {object} properties.stat metadata of the connection.\n   * @param {string} properties.stat.direction connection establishment direction (\"inbound\" or \"outbound\").\n   * @param {object} properties.stat.timeline connection relevant events timestamp.\n   * @param {string} properties.stat.timeline.open connection opening timestamp.\n   * @param {string} properties.stat.timeline.upgraded connection upgraded timestamp.\n   * @param {string} [properties.stat.multiplexer] connection multiplexing identifier.\n   * @param {string} [properties.stat.encryption] connection encryption method identifier.\n   */\n  function Connection(_ref) {\n    var localAddr = _ref.localAddr,\n        remoteAddr = _ref.remoteAddr,\n        localPeer = _ref.localPeer,\n        remotePeer = _ref.remotePeer,\n        newStream = _ref.newStream,\n        close = _ref.close,\n        getStreams = _ref.getStreams,\n        stat = _ref.stat;\n\n    _classCallCheck(this, Connection);\n\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);\n    /**\n     * Connection identifier.\n     */\n\n    this.id = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n    /**\n     * Observed multiaddr of the local peer\n     */\n\n    this.localAddr = localAddr;\n    /**\n     * Observed multiaddr of the remote peer\n     */\n\n    this.remoteAddr = remoteAddr;\n    /**\n     * Local peer id.\n     */\n\n    this.localPeer = localPeer;\n    /**\n     * Remote peer id.\n     */\n\n    this.remotePeer = remotePeer;\n    /**\n     * Connection metadata.\n     */\n\n    this._stat = _objectSpread(_objectSpread({}, stat), {}, {\n      status: Status.OPEN\n    });\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n\n    this._newStream = newStream;\n    /**\n     * Reference to the close function of the raw connection\n     */\n\n    this._close = close;\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n\n    this._getStreams = getStreams;\n    /**\n     * Connection streams registry\n     */\n\n    this.registry = new Map();\n    /**\n     * User provided tags\n     */\n\n    this.tags = [];\n  }\n  /**\n   * Get connection metadata\n   * @return {Object}\n   */\n\n\n  _createClass(Connection, [{\n    key: \"newStream\",\n\n    /**\n     * Create a new stream from this connection\n     * @param {string[]} protocols intended protocol for the stream\n     * @return {Promise<object>} with muxed+multistream-selected stream and selected protocol\n     */\n    value: function () {\n      var _newStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(protocols) {\n        var _yield$this$_newStrea, stream, protocol;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.stat.status === Status.CLOSING)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');\n\n              case 2:\n                if (!(this.stat.status === Status.CLOSED)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');\n\n              case 4:\n                if (!Array.isArray(protocols)) protocols = [protocols];\n                _context.next = 7;\n                return this._newStream(protocols);\n\n              case 7:\n                _yield$this$_newStrea = _context.sent;\n                stream = _yield$this$_newStrea.stream;\n                protocol = _yield$this$_newStrea.protocol;\n                this.addStream(stream, {\n                  protocol: protocol\n                });\n                return _context.abrupt(\"return\", {\n                  stream: stream,\n                  protocol: protocol\n                });\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function newStream(_x) {\n        return _newStream.apply(this, arguments);\n      }\n\n      return newStream;\n    }()\n    /**\n     * Add a stream when it is opened to the registry.\n     * @param {*} muxedStream a muxed stream\n     * @param {object} properties the stream properties to be registered\n     * @param {string} properties.protocol the protocol used by the stream\n     * @param {object} properties.metadata metadata of the stream\n     * @return {void}\n     */\n\n  }, {\n    key: \"addStream\",\n    value: function addStream(muxedStream, _ref2) {\n      var protocol = _ref2.protocol,\n          _ref2$metadata = _ref2.metadata,\n          metadata = _ref2$metadata === void 0 ? {} : _ref2$metadata;\n      // Add metadata for the stream\n      this.registry.set(muxedStream.id, _objectSpread({\n        protocol: protocol\n      }, metadata));\n    }\n    /**\n     * Remove stream registry after it is closed.\n     * @param {string} id identifier of the stream\n     */\n\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(id) {\n      this.registry.delete(id);\n    }\n    /**\n     * Close the connection.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.stat.status === Status.CLOSED)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                if (!this._closing) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._closing);\n\n              case 4:\n                this.stat.status = Status.CLOSING; // Close raw connection\n\n                _context2.next = 7;\n                return this._close();\n\n              case 7:\n                this._closing = _context2.sent;\n                this._stat.timeline.close = Date.now();\n                this.stat.status = Status.CLOSED;\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"stat\",\n    get: function get() {\n      return this._stat;\n    }\n    /**\n     * Get all the streams of the muxer.\n     * @return {Array<*>}\n     */\n\n  }, {\n    key: \"streams\",\n    get: function get() {\n      return this._getStreams();\n    }\n  }]);\n\n  return Connection;\n}();\n\nmodule.exports = withIs(Connection, {\n  className: 'Connection',\n  symbolName: '@libp2p/interface-connection/connection'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-interfaces/src/connection/connection.js"],"names":["PeerId","require","multiaddr","withIs","errCode","Status","validateArgs","localAddr","localPeer","remotePeer","newStream","close","getStreams","stat","isMultiaddr","Error","isPeerId","direction","timeline","open","upgraded","Connection","remoteAddr","id","parseInt","Math","random","toString","Date","now","_stat","status","OPEN","_newStream","_close","_getStreams","registry","Map","tags","protocols","CLOSING","CLOSED","Array","isArray","stream","protocol","addStream","muxedStream","metadata","set","delete","_closing","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst withIs = require('class-is')\nconst errCode = require('err-code')\nconst Status = require('./status')\n\nfunction validateArgs (localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nclass Connection {\n  /**\n   * Creates an instance of Connection.\n   * @param {object} properties properties of the connection.\n   * @param {multiaddr} [properties.localAddr] local multiaddr of the connection if known.\n   * @param {multiaddr} [properties.remoteAddr] remote multiaddr of the connection.\n   * @param {PeerId} properties.localPeer local peer-id.\n   * @param {PeerId} properties.remotePeer remote peer-id.\n   * @param {function} properties.newStream new stream muxer function.\n   * @param {function} properties.close close raw connection function.\n   * @param {function} properties.getStreams get streams from muxer function.\n   * @param {object} properties.stat metadata of the connection.\n   * @param {string} properties.stat.direction connection establishment direction (\"inbound\" or \"outbound\").\n   * @param {object} properties.stat.timeline connection relevant events timestamp.\n   * @param {string} properties.stat.timeline.open connection opening timestamp.\n   * @param {string} properties.stat.timeline.upgraded connection upgraded timestamp.\n   * @param {string} [properties.stat.multiplexer] connection multiplexing identifier.\n   * @param {string} [properties.stat.encryption] connection encryption method identifier.\n   */\n  constructor ({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat)\n\n    /**\n     * Connection identifier.\n     */\n    this.id = (parseInt(Math.random() * 1e9)).toString(36) + Date.now()\n\n    /**\n     * Observed multiaddr of the local peer\n     */\n    this.localAddr = localAddr\n\n    /**\n     * Observed multiaddr of the remote peer\n     */\n    this.remoteAddr = remoteAddr\n\n    /**\n     * Local peer id.\n     */\n    this.localPeer = localPeer\n\n    /**\n     * Remote peer id.\n     */\n    this.remotePeer = remotePeer\n\n    /**\n     * Connection metadata.\n     */\n    this._stat = {\n      ...stat,\n      status: Status.OPEN\n    }\n\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n    this._newStream = newStream\n\n    /**\n     * Reference to the close function of the raw connection\n     */\n    this._close = close\n\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n    this._getStreams = getStreams\n\n    /**\n     * Connection streams registry\n     */\n    this.registry = new Map()\n\n    /**\n     * User provided tags\n     */\n    this.tags = []\n  }\n\n  /**\n   * Get connection metadata\n   * @return {Object}\n   */\n  get stat () {\n    return this._stat\n  }\n\n  /**\n   * Get all the streams of the muxer.\n   * @return {Array<*>}\n   */\n  get streams () {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   * @param {string[]} protocols intended protocol for the stream\n   * @return {Promise<object>} with muxed+multistream-selected stream and selected protocol\n   */\n  async newStream (protocols) {\n    if (this.stat.status === Status.CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.stat.status === Status.CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) protocols = [protocols]\n\n    const { stream, protocol } = await this._newStream(protocols)\n\n    this.addStream(stream, { protocol })\n\n    return {\n      stream,\n      protocol\n    }\n  }\n\n  /**\n   * Add a stream when it is opened to the registry.\n   * @param {*} muxedStream a muxed stream\n   * @param {object} properties the stream properties to be registered\n   * @param {string} properties.protocol the protocol used by the stream\n   * @param {object} properties.metadata metadata of the stream\n   * @return {void}\n   */\n  addStream (muxedStream, { protocol, metadata = {} }) {\n    // Add metadata for the stream\n    this.registry.set(muxedStream.id, {\n      protocol,\n      ...metadata\n    })\n  }\n\n  /**\n   * Remove stream registry after it is closed.\n   * @param {string} id identifier of the stream\n   */\n  removeStream (id) {\n    this.registry.delete(id)\n  }\n\n  /**\n   * Close the connection.\n   * @return {Promise}\n   */\n  async close () {\n    if (this.stat.status === Status.CLOSED) {\n      return\n    }\n\n    if (this._closing) {\n      return this._closing\n    }\n\n    this.stat.status = Status.CLOSING\n\n    // Close raw connection\n    this._closing = await this._close()\n\n    this._stat.timeline.close = Date.now()\n    this.stat.status = Status.CLOSED\n  }\n}\n\nmodule.exports = withIs(Connection, { className: 'Connection', symbolName: '@libp2p/interface-connection/connection' })\n"]},"metadata":{},"sourceType":"script"}