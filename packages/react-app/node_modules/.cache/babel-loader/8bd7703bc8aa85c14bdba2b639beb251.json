{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst mh = require('multihashes');\n\nconst CID = require('cids');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst withIs = require('class-is');\n\nconst {\n  PeerIdProto\n} = require('./proto');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    if (!Buffer.isBuffer(id)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !privKey.public.bytes.equals(pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    try {\n      const decoded = mh.decode(this.id);\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      }\n    } catch (_) {// Ignore, there is no valid public key\n    }\n\n    return this._pubKey;\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  } // Return the protobuf version of the peer-id\n\n\n  marshal(excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    });\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  } // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n\n  toString() {\n    if (!this._idCIDString) {\n      const cid = new CID(1, 'libp2p-key', this.id, 'base32');\n      this._idCIDString = cid.toBaseEncodedString('base32');\n    }\n\n    return this._idCIDString;\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @param {Buffer|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  equals(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @deprecated Use `.equals`\n   * @param {Buffer|PeerId} id\n   * @returns {boolean}\n   */\n\n\n  isEqual(id) {\n    return this.equals(id);\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid() {\n    // TODO: needs better checking\n    return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes));\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = pubKey => {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity');\n  } else {\n    return pubKey.hash();\n  }\n};\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey);\n  return new PeerIdWithIs(digest, privKey, pubKey);\n}; // generation\n\n\nexports.create = async opts => {\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n  return computePeerId(key, key.public);\n};\n\nexports.createFromHexString = str => {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = buf => {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = str => {\n  return exports.createFromCID(str); // B58String is CIDv0\n};\n\nconst validMulticodec = cid => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb';\n};\n\nexports.createFromCID = cid => {\n  cid = CID.isCID(cid) ? cid : new CID(cid);\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec);\n  return new PeerIdWithIs(cid.multihash);\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = async key => {\n  let buf = key;\n\n  if (typeof buf === 'string') {\n    buf = Buffer.from(key, 'base64');\n  }\n\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Supplied key is neither a base64 string nor a buffer');\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf);\n  return computePeerId(null, pubKey);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = async key => {\n  let buf = key;\n\n  if (typeof buf === 'string') {\n    buf = Buffer.from(key, 'base64');\n  }\n\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Supplied key is neither a base64 string nor a buffer');\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(buf);\n  return computePeerId(privKey, privKey.public);\n};\n\nexports.createFromJSON = async obj => {\n  const id = mh.fromB58String(obj.id);\n  const rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n  const rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n  const pub = rawPubKey && (await cryptoKeys.unmarshalPublicKey(rawPubKey));\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, null, pub);\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n  const privDigest = await computeDigest(privKey.public);\n  let pubDigest;\n\n  if (pub) {\n    pubDigest = await computeDigest(pub);\n  }\n\n  if (pub && !privDigest.equals(pubDigest)) {\n    throw new Error('Public and private key do not match');\n  }\n\n  if (id && !privDigest.equals(id)) {\n    throw new Error('Id and private key do not match');\n  }\n\n  return new PeerIdWithIs(id, privKey, pub);\n};\n\nexports.createFromProtobuf = async buf => {\n  if (typeof buf === 'string') {\n    buf = Buffer.from(buf, 'hex');\n  }\n\n  let {\n    id,\n    privKey,\n    pubKey\n  } = PeerIdProto.decode(buf);\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;\n  let pubDigest;\n  let privDigest;\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public);\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey);\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!privDigest.equals(pubDigest)) {\n        throw new Error('Public and private key do not match');\n      }\n    }\n\n    return new PeerIdWithIs(privDigest, privKey, privKey.public);\n  } // TODO: val id and pubDigest\n\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, null, pubKey);\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id);\n  }\n\n  throw new Error('Protobuf did not contain any usable key material');\n};\n\nexports.isPeerId = peerId => {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/peer-id/src/index.js"],"names":["Buffer","require","mh","CID","cryptoKeys","withIs","PeerIdProto","PeerId","constructor","id","privKey","pubKey","isBuffer","Error","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","decoded","decode","name","unmarshalPublicKey","digest","_","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","marshal","excludePriv","encode","toBytes","toPrint","pid","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","toString","_idCIDString","cid","toBaseEncodedString","isEqual","isValid","Boolean","PeerIdWithIs","className","symbolName","exports","module","computeDigest","hash","computePeerId","create","opts","bits","keyType","key","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","createFromCID","validMulticodec","codec","isCID","multihash","createFromPubKey","from","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","fromB58String","rawPrivKey","rawPubKey","pub","privDigest","pubDigest","createFromProtobuf","isPeerId","peerId"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst mh = require('multihashes')\nconst CID = require('cids')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst withIs = require('class-is')\nconst { PeerIdProto } = require('./proto')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    if (!Buffer.isBuffer(id)) {\n      throw new Error('invalid id provided')\n    }\n\n    if (privKey && pubKey && !privKey.public.bytes.equals(pubKey.bytes)) {\n      throw new Error('inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    try {\n      const decoded = mh.decode(this.id)\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return this._pubKey\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // Return the protobuf version of the peer-id\n  marshal (excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    })\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toString () {\n    if (!this._idCIDString) {\n      const cid = new CID(1, 'libp2p-key', this.id, 'base32')\n      this._idCIDString = cid.toBaseEncodedString('base32')\n    }\n    return this._idCIDString\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @param {Buffer|PeerId} id\n   * @returns {boolean}\n   */\n  equals (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @deprecated Use `.equals`\n   * @param {Buffer|PeerId} id\n   * @returns {boolean}\n   */\n  isEqual (id) {\n    return this.equals(id)\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid () {\n    // TODO: needs better checking\n    return Boolean(this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes))\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n})\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity')\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey)\n  return new PeerIdWithIs(digest, privKey, pubKey)\n}\n\n// generation\nexports.create = async (opts) => {\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits)\n  return computePeerId(key, key.public)\n}\n\nexports.createFromHexString = (str) => {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = (buf) => {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = (str) => {\n  return exports.createFromCID(str) // B58String is CIDv0\n}\n\nconst validMulticodec = (cid) => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb'\n}\n\nexports.createFromCID = (cid) => {\n  cid = CID.isCID(cid) ? cid : new CID(cid)\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec)\n  return new PeerIdWithIs(cid.multihash)\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = Buffer.from(key, 'base64')\n  }\n\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Supplied key is neither a base64 string nor a buffer')\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf)\n  return computePeerId(null, pubKey)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = Buffer.from(key, 'base64')\n  }\n\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Supplied key is neither a base64 string nor a buffer')\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(buf)\n  return computePeerId(privKey, privKey.public)\n}\n\nexports.createFromJSON = async (obj) => {\n  const id = mh.fromB58String(obj.id)\n  const rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n  const rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n  const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey)\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, null, pub)\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey)\n  const privDigest = await computeDigest(privKey.public)\n\n  let pubDigest\n\n  if (pub) {\n    pubDigest = await computeDigest(pub)\n  }\n\n  if (pub && !privDigest.equals(pubDigest)) {\n    throw new Error('Public and private key do not match')\n  }\n\n  if (id && !privDigest.equals(id)) {\n    throw new Error('Id and private key do not match')\n  }\n\n  return new PeerIdWithIs(id, privKey, pub)\n}\n\nexports.createFromProtobuf = async (buf) => {\n  if (typeof buf === 'string') {\n    buf = Buffer.from(buf, 'hex')\n  }\n\n  let { id, privKey, pubKey } = PeerIdProto.decode(buf)\n\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false\n\n  let pubDigest\n  let privDigest\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public)\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey)\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!privDigest.equals(pubDigest)) {\n        throw new Error('Public and private key do not match')\n      }\n    }\n    return new PeerIdWithIs(privDigest, privKey, privKey.public)\n  }\n\n  // TODO: val id and pubDigest\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, null, pubKey)\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id)\n  }\n\n  throw new Error('Protobuf did not contain any usable key material')\n}\n\nexports.isPeerId = (peerId) => {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}