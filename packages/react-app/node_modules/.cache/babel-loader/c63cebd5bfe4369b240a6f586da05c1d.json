{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:persistent-peer-store');\nlog.error = debug('libp2p:persistent-peer-store:error');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst PeerStore = require('..');\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts');\n\nconst Addresses = require('./pb/address-book.proto');\n\nconst Protocols = require('./pb/proto-book.proto');\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @constructor\n   * @param {Object} properties\n   * @param {Datastore} properties.datastore Datastore to persist data.\n   * @param {number} [properties.threshold = 5] Number of dirty peers allowed before commit data.\n   */\n  constructor({\n    datastore,\n    threshold = 5\n  }) {\n    super();\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     * @type {Map<string, Set<string>>}\n     */\n\n    this._dirtyMetadata = new Map();\n    this.threshold = threshold;\n    this._addDirtyPeer = this._addDirtyPeer.bind(this);\n  }\n  /**\n   * Start Persistent PeerStore.\n   * @return {Promise<void>}\n   */\n\n\n  async start() {\n    log('PeerStore is starting'); // Handlers for dirty peers\n\n    this.on('change:protocols', this._addDirtyPeer);\n    this.on('change:multiaddrs', this._addDirtyPeer);\n    this.on('change:pubkey', this._addDirtyPeer);\n    this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n    for await (const entry of this._datastore.query({\n      prefix: NAMESPACE_COMMON\n    })) {\n      await this._processDatastoreEntry(entry);\n    }\n\n    log('PeerStore started');\n  }\n\n  async stop() {\n    log('PeerStore is stopping');\n    this.removeAllListeners();\n    await this._commitData();\n    log('PeerStore stopped');\n  }\n  /**\n   * Add modified peer to the dirty set\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeer({\n    peerId\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified metadata peer to the set.\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n\n\n  _addDirtyPeerMetadata({\n    peerId,\n    metadata\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty metadata peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n    mData.add(metadata);\n\n    this._dirtyMetadata.set(peerIdstr, mData);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   * @private\n   * @param {Array<string>} peers\n   * @return {Promise<void>}\n   */\n\n\n  async _commitData() {\n    const commitPeers = Array.from(this._dirtyPeers);\n\n    if (!commitPeers.length) {\n      return;\n    } // Clear Dirty Peers set\n\n\n    this._dirtyPeers.clear();\n\n    log('create batch commit');\n\n    const batch = this._datastore.batch();\n\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr); // Address Book\n\n      this._batchAddressBook(peerId, batch); // Key Book\n\n\n      this._batchKeyBook(peerId, batch); // Metadata Book\n\n\n      this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n      this._batchProtoBook(peerId, batch);\n    }\n\n    await batch.commit();\n    log('batch committed');\n  }\n  /**\n   * Add address book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchAddressBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`);\n    const addresses = this.addressBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!addresses) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: addresses.map(address => ({\n          multiaddr: address.multiaddr.buffer\n        }))\n      });\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add Key book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchKeyBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`);\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = peerId.marshalPubKey();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add metadata book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchMetadataBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n    try {\n      dirtyMetada.forEach(dirtyKey => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue);\n        } else {\n          batch.delete(key);\n        }\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add proto book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchProtoBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`);\n    const protocols = this.protoBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Protocols.encode({\n        protocols\n      });\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Process datastore entry and add its data to the correct book.\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key datastore key\n   * @param {Buffer} params.value datastore value stored\n   * @return {Promise<void>}\n   */\n\n\n  async _processDatastoreEntry({\n    key,\n    value\n  }) {\n    try {\n      const keyParts = key.toString().split('/');\n      const peerId = PeerId.createFromCID(keyParts[3]);\n      let decoded;\n\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value);\n\n          this.addressBook._setData(peerId, decoded.addrs.map(address => ({\n            multiaddr: multiaddr(address.multiaddr)\n          })), {\n            emit: false\n          });\n\n          break;\n\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value);\n\n          this.keyBook._setData(decoded, decoded, {\n            emit: false\n          });\n\n          break;\n\n        case 'metadata':\n          this.metadataBook._setValue(peerId, keyParts[4], value, {\n            emit: false\n          });\n\n          break;\n\n        case 'protos':\n          decoded = Protocols.decode(value);\n\n          this.protoBook._setData(peerId, new Set(decoded.protocols), {\n            emit: false\n          });\n\n          break;\n\n        default:\n          log('invalid data persisted for: ', key.toString());\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = PersistentPeerStore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/peer-store/persistent/index.js"],"names":["debug","require","log","error","Key","multiaddr","PeerId","PeerStore","NAMESPACE_ADDRESS","NAMESPACE_COMMON","NAMESPACE_KEYS","NAMESPACE_METADATA","NAMESPACE_PROTOCOL","Addresses","Protocols","PersistentPeerStore","constructor","datastore","threshold","_datastore","_dirtyPeers","Set","_dirtyMetadata","Map","_addDirtyPeer","bind","start","on","_addDirtyPeerMetadata","entry","query","prefix","_processDatastoreEntry","stop","removeAllListeners","_commitData","peerId","peerIdstr","toB58String","add","size","catch","err","metadata","mData","get","set","commitPeers","Array","from","length","clear","batch","peerIdStr","keyBook","data","createFromCID","_batchAddressBook","_batchKeyBook","_batchMetadataBook","_batchProtoBook","commit","b32key","toString","key","addresses","addressBook","delete","encodedData","encode","addrs","map","address","buffer","put","pubKey","marshalPubKey","dirtyMetada","forEach","dirtyKey","dirtyValue","metadataBook","getValue","protocols","protoBook","value","keyParts","split","decoded","decode","_setData","emit","createFromPubKey","_setValue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:persistent-peer-store')\nlog.error = debug('libp2p:persistent-peer-store:error')\n\nconst { Key } = require('interface-datastore')\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst PeerStore = require('..')\n\nconst {\n  NAMESPACE_ADDRESS,\n  NAMESPACE_COMMON,\n  NAMESPACE_KEYS,\n  NAMESPACE_METADATA,\n  NAMESPACE_PROTOCOL\n} = require('./consts')\n\nconst Addresses = require('./pb/address-book.proto')\nconst Protocols = require('./pb/proto-book.proto')\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @constructor\n   * @param {Object} properties\n   * @param {Datastore} properties.datastore Datastore to persist data.\n   * @param {number} [properties.threshold = 5] Number of dirty peers allowed before commit data.\n   */\n  constructor ({ datastore, threshold = 5 }) {\n    super()\n\n    /**\n     * Backend datastore used to persist data.\n     */\n    this._datastore = datastore\n\n    /**\n     * Peers modified after the latest data persisted.\n     */\n    this._dirtyPeers = new Set()\n\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     * @type {Map<string, Set<string>>}\n     */\n    this._dirtyMetadata = new Map()\n\n    this.threshold = threshold\n    this._addDirtyPeer = this._addDirtyPeer.bind(this)\n  }\n\n  /**\n   * Start Persistent PeerStore.\n   * @return {Promise<void>}\n   */\n  async start () {\n    log('PeerStore is starting')\n\n    // Handlers for dirty peers\n    this.on('change:protocols', this._addDirtyPeer)\n    this.on('change:multiaddrs', this._addDirtyPeer)\n    this.on('change:pubkey', this._addDirtyPeer)\n    this.on('change:metadata', this._addDirtyPeerMetadata)\n\n    // Load data\n    for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {\n      await this._processDatastoreEntry(entry)\n    }\n\n    log('PeerStore started')\n  }\n\n  async stop () {\n    log('PeerStore is stopping')\n    this.removeAllListeners()\n    await this._commitData()\n    log('PeerStore stopped')\n  }\n\n  /**\n   * Add modified peer to the dirty set\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n  _addDirtyPeer ({ peerId }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add modified metadata peer to the set.\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n  _addDirtyPeerMetadata ({ peerId, metadata }) {\n    const peerIdstr = peerId.toB58String()\n\n    log('add dirty metadata peer', peerIdstr)\n    this._dirtyPeers.add(peerIdstr)\n\n    // Add dirty metadata key\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set()\n    mData.add(metadata)\n    this._dirtyMetadata.set(peerIdstr, mData)\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err)\n      })\n    }\n  }\n\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   * @private\n   * @param {Array<string>} peers\n   * @return {Promise<void>}\n   */\n  async _commitData () {\n    const commitPeers = Array.from(this._dirtyPeers)\n\n    if (!commitPeers.length) {\n      return\n    }\n\n    // Clear Dirty Peers set\n    this._dirtyPeers.clear()\n\n    log('create batch commit')\n    const batch = this._datastore.batch()\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr)\n\n      // Address Book\n      this._batchAddressBook(peerId, batch)\n\n      // Key Book\n      this._batchKeyBook(peerId, batch)\n\n      // Metadata Book\n      this._batchMetadataBook(peerId, batch)\n\n      // Proto Book\n      this._batchProtoBook(peerId, batch)\n    }\n\n    await batch.commit()\n    log('batch committed')\n  }\n\n  /**\n   * Add address book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchAddressBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`)\n\n    const addresses = this.addressBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!addresses) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: addresses.map((address) => ({\n          multiaddr: address.multiaddr.buffer\n        }))\n      })\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add Key book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchKeyBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_KEYS}${b32key}`)\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = peerId.marshalPubKey()\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add metadata book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchMetadataBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || []\n\n    try {\n      dirtyMetada.forEach((dirtyKey) => {\n        const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`)\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey)\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue)\n        } else {\n          batch.delete(key)\n        }\n      })\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Add proto book data of the peer to the batch.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n  _batchProtoBook (peerId, batch) {\n    const b32key = peerId.toString()\n    const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`)\n\n    const protocols = this.protoBook.get(peerId)\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key)\n        return\n      }\n\n      const encodedData = Protocols.encode({ protocols })\n\n      batch.put(key, encodedData)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Process datastore entry and add its data to the correct book.\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key datastore key\n   * @param {Buffer} params.value datastore value stored\n   * @return {Promise<void>}\n   */\n  async _processDatastoreEntry ({ key, value }) {\n    try {\n      const keyParts = key.toString().split('/')\n      const peerId = PeerId.createFromCID(keyParts[3])\n\n      let decoded\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value)\n\n          this.addressBook._setData(\n            peerId,\n            decoded.addrs.map((address) => ({\n              multiaddr: multiaddr(address.multiaddr)\n            })),\n            { emit: false })\n          break\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value)\n\n          this.keyBook._setData(\n            decoded,\n            decoded,\n            { emit: false })\n          break\n        case 'metadata':\n          this.metadataBook._setValue(\n            peerId,\n            keyParts[4],\n            value,\n            { emit: false })\n          break\n        case 'protos':\n          decoded = Protocols.decode(value)\n\n          this.protoBook._setData(\n            peerId,\n            new Set(decoded.protocols),\n            { emit: false })\n          break\n        default:\n          log('invalid data persisted for: ', key.toString())\n      }\n    } catch (err) {\n      log.error(err)\n    }\n  }\n}\n\nmodule.exports = PersistentPeerStore\n"]},"metadata":{},"sourceType":"script"}