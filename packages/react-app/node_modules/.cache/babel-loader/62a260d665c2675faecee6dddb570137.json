{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _require3 = require('interface-datastore'),\n    Key = _require3.Key;\n\nvar errCode = require('err-code');\n\nvar multicodec = require('multicodec');\n\nvar dagCborLinks = require('dag-cbor-links');\n\nvar debug = require('debug');\n\nvar _require4 = require('buffer'),\n    Buffer = _require4.Buffer;\n\nvar _require5 = require('../../../utils/cid'),\n    cidToString = _require5.cidToString;\n\nvar createPinSet = require('./pin-set');\n\nvar _require6 = require('interface-datastore'),\n    Errors = _require6.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code; // arbitrary limit to the number of concurrent dag operations\n\nvar WALK_DAG_CONCURRENCY_LIMIT = 300;\nvar IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300;\nvar PIN_DS_KEY = new Key('/local/pins');\n\nfunction invalidPinTypeErr(type) {\n  var errMsg = \"Invalid type '\".concat(type, \"', must be one of {direct, indirect, recursive, all}\");\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nvar PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n};\n\nvar PinManager = /*#__PURE__*/function () {\n  function PinManager(repo, dag) {\n    _classCallCheck(this, PinManager);\n\n    this.repo = repo;\n    this.dag = dag;\n    this.log = debug('ipfs:pin');\n    this.pinset = createPinSet(dag);\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  _createClass(PinManager, [{\n    key: \"_walkDag\",\n    value: function () {\n      var _walkDag2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n        var _this = this;\n\n        var cid, _ref$preload, preload, _ref$onCid, onCid, walk, queue;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cid = _ref.cid, _ref$preload = _ref.preload, preload = _ref$preload === void 0 ? false : _ref$preload, _ref$onCid = _ref.onCid, onCid = _ref$onCid === void 0 ? function () {} : _ref$onCid;\n\n                if (!CID.isCID(cid)) {\n                  cid = new CID(cid);\n                }\n\n                walk = function walk(cid) {\n                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var _yield$_this$dag$get, node, _iterator, _step, _step$value, _, childCid;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return _this.dag.get(cid, {\n                              preload: preload\n                            });\n\n                          case 2:\n                            _yield$_this$dag$get = _context.sent;\n                            node = _yield$_this$dag$get.value;\n                            onCid(cid);\n\n                            if (cid.codec === 'dag-pb') {\n                              queue.addAll(node.Links.map(function (link) {\n                                return walk(link.Hash);\n                              }));\n                            } else if (cid.codec === 'dag-cbor') {\n                              _iterator = _createForOfIteratorHelper(dagCborLinks(node));\n\n                              try {\n                                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                                  _step$value = _slicedToArray(_step.value, 2), _ = _step$value[0], childCid = _step$value[1];\n                                  // eslint-disable-line no-unused-vars\n                                  queue.add(walk(childCid));\n                                }\n                              } catch (err) {\n                                _iterator.e(err);\n                              } finally {\n                                _iterator.f();\n                              }\n                            }\n\n                          case 6:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n                };\n\n                queue = new Queue({\n                  concurrency: WALK_DAG_CONCURRENCY_LIMIT\n                });\n                queue.add(walk(cid));\n                _context2.next = 7;\n                return queue.onIdle();\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function _walkDag(_x) {\n        return _walkDag2.apply(this, arguments);\n      }\n\n      return _walkDag;\n    }()\n  }, {\n    key: \"directKeys\",\n    value: function directKeys() {\n      return Array.from(this.directPins, function (key) {\n        return new CID(key).buffer;\n      });\n    }\n  }, {\n    key: \"recursiveKeys\",\n    value: function recursiveKeys() {\n      return Array.from(this.recursivePins, function (key) {\n        return new CID(key).buffer;\n      });\n    }\n  }, {\n    key: \"getIndirectKeys\",\n    value: function () {\n      var _getIndirectKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n        var _this2 = this;\n\n        var preload, indirectKeys, _iterator2, _step2, multihash;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                preload = _ref3.preload;\n                indirectKeys = new Set();\n                _iterator2 = _createForOfIteratorHelper(this.recursiveKeys());\n                _context3.prev = 3;\n\n                _iterator2.s();\n\n              case 5:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                multihash = _step2.value;\n                _context3.next = 9;\n                return this._walkDag({\n                  cid: new CID(multihash),\n                  preload: preload || false,\n                  onCid: function onCid(cid) {\n                    cid = cid.toString(); // recursive pins pre-empt indirect pins\n\n                    if (!_this2.recursivePins.has(cid)) {\n                      indirectKeys.add(cid);\n                    }\n                  }\n                });\n\n              case 9:\n                _context3.next = 5;\n                break;\n\n              case 11:\n                _context3.next = 16;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                _iterator2.e(_context3.t0);\n\n              case 16:\n                _context3.prev = 16;\n\n                _iterator2.f();\n\n                return _context3.finish(16);\n\n              case 19:\n                return _context3.abrupt(\"return\", Array.from(indirectKeys));\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 13, 16, 19]]);\n      }));\n\n      function getIndirectKeys(_x2) {\n        return _getIndirectKeys.apply(this, arguments);\n      }\n\n      return getIndirectKeys;\n    }() // Encode and write pin key sets to the datastore:\n    // a DAGLink for each of the recursive and direct pinsets\n    // a DAGNode holding those as DAGLinks, a kind of root pin\n\n  }, {\n    key: \"flushPins\",\n    value: function () {\n      var _flushPins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _yield$Promise$all, _yield$Promise$all2, dLink, rLink, rootNode, rootCid;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.all([// create a DAGLink to the node with direct pins\n                this.pinset.storeSet(this.directKeys()).then(function (result) {\n                  return new DAGLink(PinTypes.direct, result.node.size, result.cid);\n                }), // create a DAGLink to the node with recursive pins\n                this.pinset.storeSet(this.recursiveKeys()).then(function (result) {\n                  return new DAGLink(PinTypes.recursive, result.node.size, result.cid);\n                }), // the pin-set nodes link to a special 'empty' node, so make sure it exists\n                this.dag.put(new DAGNode(Buffer.alloc(0)), {\n                  version: 0,\n                  format: multicodec.DAG_PB,\n                  hashAlg: multicodec.SHA2_256,\n                  preload: false\n                })]);\n\n              case 2:\n                _yield$Promise$all = _context4.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                dLink = _yield$Promise$all2[0];\n                rLink = _yield$Promise$all2[1];\n                // create a root node with DAGLinks to the direct and recursive DAGs\n                rootNode = new DAGNode(Buffer.alloc(0), [dLink, rLink]);\n                _context4.next = 9;\n                return this.dag.put(rootNode, {\n                  version: 0,\n                  format: multicodec.DAG_PB,\n                  hashAlg: multicodec.SHA2_256,\n                  preload: false\n                });\n\n              case 9:\n                rootCid = _context4.sent;\n                _context4.next = 12;\n                return this.repo.datastore.put(PIN_DS_KEY, rootCid.buffer);\n\n              case 12:\n                this.log(\"Flushed pins with root: \".concat(rootCid));\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function flushPins() {\n        return _flushPins.apply(this, arguments);\n      }\n\n      return flushPins;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var has, mh, pinRoot, _yield$Promise$all3, _yield$Promise$all4, rKeys, dKeys;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.repo.datastore.has(PIN_DS_KEY);\n\n              case 2:\n                has = _context5.sent;\n\n                if (has) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 5:\n                _context5.next = 7;\n                return this.repo.datastore.get(PIN_DS_KEY);\n\n              case 7:\n                mh = _context5.sent;\n                _context5.next = 10;\n                return this.dag.get(new CID(mh), '', {\n                  preload: false\n                });\n\n              case 10:\n                pinRoot = _context5.sent;\n                _context5.next = 13;\n                return Promise.all([this.pinset.loadSet(pinRoot.value, PinTypes.recursive), this.pinset.loadSet(pinRoot.value, PinTypes.direct)]);\n\n              case 13:\n                _yield$Promise$all3 = _context5.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n                rKeys = _yield$Promise$all4[0];\n                dKeys = _yield$Promise$all4[1];\n                this.directPins = new Set(dKeys.map(function (k) {\n                  return cidToString(k);\n                }));\n                this.recursivePins = new Set(rKeys.map(function (k) {\n                  return cidToString(k);\n                }));\n                this.log('Loaded pins from the datastore');\n\n              case 20:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"isPinnedWithType\",\n    value: function () {\n      var _isPinnedWithType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(multihash, type) {\n        var _this3 = this;\n\n        var key, recursive, direct, all, queue, cid;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                key = cidToString(multihash);\n                recursive = PinTypes.recursive, direct = PinTypes.direct, all = PinTypes.all; // recursive\n\n                if (!((type === recursive || type === all) && this.recursivePins.has(key))) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: true,\n                  reason: recursive\n                });\n\n              case 4:\n                if (!(type === recursive)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: false\n                });\n\n              case 6:\n                if (!((type === direct || type === all) && this.directPins.has(key))) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: true,\n                  reason: direct\n                });\n\n              case 8:\n                if (!(type === direct)) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: false\n                });\n\n              case 10:\n                // indirect (default)\n                // check each recursive key to see if multihash is under it\n                // arbitrary limit, enables handling 1000s of pins.\n                queue = new Queue({\n                  concurrency: IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT\n                });\n                queue.addAll(this.recursiveKeys().map(function (childKey) {\n                  childKey = new CID(childKey);\n                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                    var has;\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.next = 2;\n                            return _this3.pinset.hasDescendant(childKey, key);\n\n                          case 2:\n                            has = _context6.sent;\n\n                            if (has) {\n                              cid = childKey;\n                              queue.clear();\n                            }\n\n                          case 4:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n                }));\n                _context7.next = 14;\n                return queue.onIdle();\n\n              case 14:\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: Boolean(cid),\n                  reason: cid\n                });\n\n              case 15:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function isPinnedWithType(_x3, _x4) {\n        return _isPinnedWithType.apply(this, arguments);\n      }\n\n      return isPinnedWithType;\n    }() // Gets CIDs of blocks used internally by the pinner\n\n  }, {\n    key: \"getInternalBlocks\",\n    value: function () {\n      var _getInternalBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var mh, cid, obj, cids;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this.repo.datastore.get(PIN_DS_KEY);\n\n              case 3:\n                mh = _context8.sent;\n                _context8.next = 12;\n                break;\n\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!(_context8.t0.code === ERR_NOT_FOUND)) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                this.log('No pinned blocks');\n                return _context8.abrupt(\"return\", []);\n\n              case 11:\n                throw new Error(\"Could not get pin sets root from datastore: \".concat(_context8.t0.message));\n\n              case 12:\n                cid = new CID(mh);\n                _context8.next = 15;\n                return this.dag.get(cid, '', {\n                  preload: false\n                });\n\n              case 15:\n                obj = _context8.sent;\n                _context8.next = 18;\n                return this.pinset.getInternalCids(obj.value);\n\n              case 18:\n                cids = _context8.sent;\n                return _context8.abrupt(\"return\", cids.concat(cid));\n\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 6]]);\n      }));\n\n      function getInternalBlocks() {\n        return _getInternalBlocks.apply(this, arguments);\n      }\n\n      return getInternalBlocks;\n    }()\n  }, {\n    key: \"fetchCompleteDag\",\n    value: function () {\n      var _fetchCompleteDag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._walkDag({\n                  cid: cid,\n                  preload: options.preload\n                });\n\n              case 2:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function fetchCompleteDag(_x5, _x6) {\n        return _fetchCompleteDag.apply(this, arguments);\n      }\n\n      return fetchCompleteDag;\n    }() // Returns an error if the pin type is invalid\n\n  }], [{\n    key: \"checkPinType\",\n    value: function checkPinType(type) {\n      if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n        return invalidPinTypeErr(type);\n      }\n    }\n  }]);\n\n  return PinManager;\n}();\n\nPinManager.PinTypes = PinTypes;\nmodule.exports = PinManager;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/pin-manager.js"],"names":["require","DAGNode","DAGLink","CID","Queue","default","Key","errCode","multicodec","dagCborLinks","debug","Buffer","cidToString","createPinSet","Errors","ERR_NOT_FOUND","notFoundError","code","WALK_DAG_CONCURRENCY_LIMIT","IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT","PIN_DS_KEY","invalidPinTypeErr","type","errMsg","Error","PinTypes","direct","recursive","indirect","all","PinManager","repo","dag","log","pinset","directPins","Set","recursivePins","cid","preload","onCid","isCID","walk","get","node","value","codec","queue","addAll","Links","map","link","Hash","_","childCid","add","concurrency","onIdle","Array","from","key","buffer","indirectKeys","recursiveKeys","multihash","_walkDag","toString","has","Promise","storeSet","directKeys","then","result","size","put","alloc","version","format","DAG_PB","hashAlg","SHA2_256","dLink","rLink","rootNode","rootCid","datastore","mh","pinRoot","loadSet","rKeys","dKeys","k","pinned","reason","childKey","hasDescendant","clear","Boolean","message","obj","getInternalCids","cids","concat","options","Object","keys","includes","module","exports"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;eAE6BA,OAAO,CAAC,aAAD,C;IAA5BC,O,YAAAA,O;IAASC,O,YAAAA,O;;AACjB,IAAMC,GAAG,GAAGH,OAAO,CAAC,MAAD,CAAnB;;gBAC2BA,OAAO,CAAC,SAAD,C;IAAjBI,K,aAATC,O;;gBACQL,OAAO,CAAC,qBAAD,C;IAAfM,G,aAAAA,G;;AACR,IAAMC,OAAO,GAAGP,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMQ,UAAU,GAAGR,OAAO,CAAC,YAAD,CAA1B;;AACA,IAAMS,YAAY,GAAGT,OAAO,CAAC,gBAAD,CAA5B;;AACA,IAAMU,KAAK,GAAGV,OAAO,CAAC,OAAD,CAArB;;gBACmBA,OAAO,CAAC,QAAD,C;IAAlBW,M,aAAAA,M;;gBACgBX,OAAO,CAAC,oBAAD,C;IAAvBY,W,aAAAA,W;;AAER,IAAMC,YAAY,GAAGb,OAAO,CAAC,WAAD,CAA5B;;gBAEmBA,OAAO,CAAC,qBAAD,C;IAAlBc,M,aAAAA,M;;AACR,IAAMC,aAAa,GAAGD,MAAM,CAACE,aAAP,GAAuBC,IAA7C,C,CAEA;;AACA,IAAMC,0BAA0B,GAAG,GAAnC;AACA,IAAMC,qCAAqC,GAAG,GAA9C;AACA,IAAMC,UAAU,GAAG,IAAId,GAAJ,CAAQ,aAAR,CAAnB;;AAEA,SAASe,iBAAT,CAA4BC,IAA5B,EAAkC;AAChC,MAAMC,MAAM,2BAAoBD,IAApB,yDAAZ;AACA,SAAOf,OAAO,CAAC,IAAIiB,KAAJ,CAAUD,MAAV,CAAD,EAAoB,sBAApB,CAAd;AACD;;AAED,IAAME,QAAQ,GAAG;AACfC,EAAAA,MAAM,EAAE,QADO;AAEfC,EAAAA,SAAS,EAAE,WAFI;AAGfC,EAAAA,QAAQ,EAAE,UAHK;AAIfC,EAAAA,GAAG,EAAE;AAJU,CAAjB;;IAOMC,U;AACJ,sBAAaC,IAAb,EAAmBC,GAAnB,EAAwB;AAAA;;AACtB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,GAAL,GAAWvB,KAAK,CAAC,UAAD,CAAhB;AACA,SAAKwB,MAAL,GAAcrB,YAAY,CAACmB,GAAD,CAA1B;AACA,SAAKG,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACA,SAAKC,aAAL,GAAqB,IAAID,GAAJ,EAArB;AACD;;;;;;;;;;;;;;AAEiBE,gBAAAA,G,QAAAA,G,sBAAKC,O,EAAAA,O,6BAAU,K,mCAAOC,K,EAAAA,K,2BAAQ,YAAM,CAAE,C;;AACtD,oBAAI,CAACrC,GAAG,CAACsC,KAAJ,CAAUH,GAAV,CAAL,EAAqB;AACnBA,kBAAAA,GAAG,GAAG,IAAInC,GAAJ,CAAQmC,GAAR,CAAN;AACD;;AAEKI,gBAAAA,I,GAAO,SAAPA,IAAO,CAACJ,GAAD,EAAS;AACpB,+FAAO;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCACyB,KAAI,CAACN,GAAL,CAASW,GAAT,CAAaL,GAAb,EAAkB;AAAEC,8BAAAA,OAAO,EAAPA;AAAF,6BAAlB,CADzB;;AAAA;AAAA;AACUK,4BAAAA,IADV,wBACGC,KADH;AAGLL,4BAAAA,KAAK,CAACF,GAAD,CAAL;;AAEA,gCAAIA,GAAG,CAACQ,KAAJ,KAAc,QAAlB,EAA4B;AAC1BC,8BAAAA,KAAK,CAACC,MAAN,CACEJ,IAAI,CAACK,KAAL,CAAWC,GAAX,CAAe,UAAAC,IAAI;AAAA,uCAAIT,IAAI,CAACS,IAAI,CAACC,IAAN,CAAR;AAAA,+BAAnB,CADF;AAGD,6BAJD,MAIO,IAAId,GAAG,CAACQ,KAAJ,KAAc,UAAlB,EAA8B;AAAA,qEACPrC,YAAY,CAACmC,IAAD,CADL;;AAAA;AACnC,oFAAgD;AAAA,gFAApCS,CAAoC,mBAAjCC,QAAiC;AAAE;AAChDP,kCAAAA,KAAK,CAACQ,GAAN,CAAUb,IAAI,CAACY,QAAD,CAAd;AACD;AAHkC;AAAA;AAAA;AAAA;AAAA;AAIpC;;AAbI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAP;AAeD,iB;;AAEKP,gBAAAA,K,GAAQ,IAAI3C,KAAJ,CAAU;AACtBoD,kBAAAA,WAAW,EAAEtC;AADS,iBAAV,C;AAGd6B,gBAAAA,KAAK,CAACQ,GAAN,CAAUb,IAAI,CAACJ,GAAD,CAAd;;uBAEMS,KAAK,CAACU,MAAN,E;;;;;;;;;;;;;;;;;;iCAGM;AACZ,aAAOC,KAAK,CAACC,IAAN,CAAW,KAAKxB,UAAhB,EAA4B,UAAAyB,GAAG;AAAA,eAAI,IAAIzD,GAAJ,CAAQyD,GAAR,EAAaC,MAAjB;AAAA,OAA/B,CAAP;AACD;;;oCAEgB;AACf,aAAOH,KAAK,CAACC,IAAN,CAAW,KAAKtB,aAAhB,EAA+B,UAAAuB,GAAG;AAAA,eAAI,IAAIzD,GAAJ,CAAQyD,GAAR,EAAaC,MAAjB;AAAA,OAAlC,CAAP;AACD;;;;;;;;;;;;;AAEwBtB,gBAAAA,O,SAAAA,O;AACjBuB,gBAAAA,Y,GAAe,IAAI1B,GAAJ,E;wDAEG,KAAK2B,aAAL,E;;;;;;;;;;;AAAbC,gBAAAA,S;;uBACH,KAAKC,QAAL,CAAc;AAClB3B,kBAAAA,GAAG,EAAE,IAAInC,GAAJ,CAAQ6D,SAAR,CADa;AAElBzB,kBAAAA,OAAO,EAAEA,OAAO,IAAI,KAFF;AAGlBC,kBAAAA,KAAK,EAAE,eAACF,GAAD,EAAS;AACdA,oBAAAA,GAAG,GAAGA,GAAG,CAAC4B,QAAJ,EAAN,CADc,CAGd;;AACA,wBAAI,CAAC,MAAI,CAAC7B,aAAL,CAAmB8B,GAAnB,CAAuB7B,GAAvB,CAAL,EAAkC;AAChCwB,sBAAAA,YAAY,CAACP,GAAb,CAAiBjB,GAAjB;AACD;AACF;AAViB,iBAAd,C;;;;;;;;;;;;;;;;;;;;;;;;kDAcDoB,KAAK,CAACC,IAAN,CAAWG,YAAX,C;;;;;;;;;;;;;;;QAGT;AACA;AACA;;;;;;;;;;;;;uBAKYM,OAAO,CAACvC,GAAR,CAAY,CACpB;AACA,qBAAKK,MAAL,CAAYmC,QAAZ,CAAqB,KAAKC,UAAL,EAArB,EACGC,IADH,CACQ,UAACC,MAAD,EAAY;AAChB,yBAAO,IAAItE,OAAJ,CAAYuB,QAAQ,CAACC,MAArB,EAA6B8C,MAAM,CAAC5B,IAAP,CAAY6B,IAAzC,EAA+CD,MAAM,CAAClC,GAAtD,CAAP;AACD,iBAHH,CAFoB,EAMpB;AACA,qBAAKJ,MAAL,CAAYmC,QAAZ,CAAqB,KAAKN,aAAL,EAArB,EACGQ,IADH,CACQ,UAACC,MAAD,EAAY;AAChB,yBAAO,IAAItE,OAAJ,CAAYuB,QAAQ,CAACE,SAArB,EAAgC6C,MAAM,CAAC5B,IAAP,CAAY6B,IAA5C,EAAkDD,MAAM,CAAClC,GAAzD,CAAP;AACD,iBAHH,CAPoB,EAWpB;AACA,qBAAKN,GAAL,CAAS0C,GAAT,CAAa,IAAIzE,OAAJ,CAAYU,MAAM,CAACgE,KAAP,CAAa,CAAb,CAAZ,CAAb,EAA2C;AACzCC,kBAAAA,OAAO,EAAE,CADgC;AAEzCC,kBAAAA,MAAM,EAAErE,UAAU,CAACsE,MAFsB;AAGzCC,kBAAAA,OAAO,EAAEvE,UAAU,CAACwE,QAHqB;AAIzCzC,kBAAAA,OAAO,EAAE;AAJgC,iBAA3C,CAZoB,CAAZ,C;;;;;AAFR0C,gBAAAA,K;AACAC,gBAAAA,K;AAqBF;AACMC,gBAAAA,Q,GAAW,IAAIlF,OAAJ,CAAYU,MAAM,CAACgE,KAAP,CAAa,CAAb,CAAZ,EAA6B,CAACM,KAAD,EAAQC,KAAR,CAA7B,C;;uBACK,KAAKlD,GAAL,CAAS0C,GAAT,CAAaS,QAAb,EAAuB;AAC3CP,kBAAAA,OAAO,EAAE,CADkC;AAE3CC,kBAAAA,MAAM,EAAErE,UAAU,CAACsE,MAFwB;AAG3CC,kBAAAA,OAAO,EAAEvE,UAAU,CAACwE,QAHuB;AAI3CzC,kBAAAA,OAAO,EAAE;AAJkC,iBAAvB,C;;;AAAhB6C,gBAAAA,O;;uBAQA,KAAKrD,IAAL,CAAUsD,SAAV,CAAoBX,GAApB,CAAwBtD,UAAxB,EAAoCgE,OAAO,CAACvB,MAA5C,C;;;AAEN,qBAAK5B,GAAL,mCAAoCmD,OAApC;;;;;;;;;;;;;;;;;;;;;;;;;;;uBAIkB,KAAKrD,IAAL,CAAUsD,SAAV,CAAoBlB,GAApB,CAAwB/C,UAAxB,C;;;AAAZ+C,gBAAAA,G;;oBAEDA,G;;;;;;;;;uBAIY,KAAKpC,IAAL,CAAUsD,SAAV,CAAoB1C,GAApB,CAAwBvB,UAAxB,C;;;AAAXkE,gBAAAA,E;;uBACgB,KAAKtD,GAAL,CAASW,GAAT,CAAa,IAAIxC,GAAJ,CAAQmF,EAAR,CAAb,EAA0B,EAA1B,EAA8B;AAAE/C,kBAAAA,OAAO,EAAE;AAAX,iBAA9B,C;;;AAAhBgD,gBAAAA,O;;uBAIInB,OAAO,CAACvC,GAAR,CAAY,CACpB,KAAKK,MAAL,CAAYsD,OAAZ,CAAoBD,OAAO,CAAC1C,KAA5B,EAAmCpB,QAAQ,CAACE,SAA5C,CADoB,EAEpB,KAAKO,MAAL,CAAYsD,OAAZ,CAAoBD,OAAO,CAAC1C,KAA5B,EAAmCpB,QAAQ,CAACC,MAA5C,CAFoB,CAAZ,C;;;;;AADR+D,gBAAAA,K;AAAOC,gBAAAA,K;AAMT,qBAAKvD,UAAL,GAAkB,IAAIC,GAAJ,CAAQsD,KAAK,CAACxC,GAAN,CAAU,UAAAyC,CAAC;AAAA,yBAAI/E,WAAW,CAAC+E,CAAD,CAAf;AAAA,iBAAX,CAAR,CAAlB;AACA,qBAAKtD,aAAL,GAAqB,IAAID,GAAJ,CAAQqD,KAAK,CAACvC,GAAN,CAAU,UAAAyC,CAAC;AAAA,yBAAI/E,WAAW,CAAC+E,CAAD,CAAf;AAAA,iBAAX,CAAR,CAArB;AAEA,qBAAK1D,GAAL,CAAS,gCAAT;;;;;;;;;;;;;;;;;;;yGAGsB+B,S,EAAW1C,I;;;;;;;;AAC3BsC,gBAAAA,G,GAAMhD,WAAW,CAACoD,SAAD,C;AACfrC,gBAAAA,S,GAA2BF,Q,CAA3BE,S,EAAWD,M,GAAgBD,Q,CAAhBC,M,EAAQG,G,GAAQJ,Q,CAARI,G,EAE3B;;sBACI,CAACP,IAAI,KAAKK,SAAT,IAAsBL,IAAI,KAAKO,GAAhC,KAAwC,KAAKQ,aAAL,CAAmB8B,GAAnB,CAAuBP,GAAvB,C;;;;;kDACnC;AACLA,kBAAAA,GAAG,EAAHA,GADK;AAELgC,kBAAAA,MAAM,EAAE,IAFH;AAGLC,kBAAAA,MAAM,EAAElE;AAHH,iB;;;sBAOLL,IAAI,KAAKK,S;;;;;kDACJ;AACLiC,kBAAAA,GAAG,EAAHA,GADK;AAELgC,kBAAAA,MAAM,EAAE;AAFH,iB;;;sBAOL,CAACtE,IAAI,KAAKI,MAAT,IAAmBJ,IAAI,KAAKO,GAA7B,KAAqC,KAAKM,UAAL,CAAgBgC,GAAhB,CAAoBP,GAApB,C;;;;;kDAChC;AACLA,kBAAAA,GAAG,EAAHA,GADK;AAELgC,kBAAAA,MAAM,EAAE,IAFH;AAGLC,kBAAAA,MAAM,EAAEnE;AAHH,iB;;;sBAOLJ,IAAI,KAAKI,M;;;;;kDACJ;AACLkC,kBAAAA,GAAG,EAAHA,GADK;AAELgC,kBAAAA,MAAM,EAAE;AAFH,iB;;;AAMT;AACA;AACA;AACM7C,gBAAAA,K,GAAQ,IAAI3C,KAAJ,CAAU;AACtBoD,kBAAAA,WAAW,EAAErC;AADS,iBAAV,C;AAKd4B,gBAAAA,KAAK,CAACC,MAAN,CACE,KAAKe,aAAL,GACGb,GADH,CACO,UAAA4C,QAAQ,EAAI;AACfA,kBAAAA,QAAQ,GAAG,IAAI3F,GAAJ,CAAQ2F,QAAR,CAAX;AAEA,+FAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCACa,MAAI,CAAC5D,MAAL,CAAY6D,aAAZ,CAA0BD,QAA1B,EAAoClC,GAApC,CADb;;AAAA;AACCO,4BAAAA,GADD;;AAGL,gCAAIA,GAAJ,EAAS;AACP7B,8BAAAA,GAAG,GAAGwD,QAAN;AACA/C,8BAAAA,KAAK,CAACiD,KAAN;AACD;;AANI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAP;AAQD,iBAZH,CADF;;uBAgBMjD,KAAK,CAACU,MAAN,E;;;kDAEC;AACLG,kBAAAA,GAAG,EAAHA,GADK;AAELgC,kBAAAA,MAAM,EAAEK,OAAO,CAAC3D,GAAD,CAFV;AAGLuD,kBAAAA,MAAM,EAAEvD;AAHH,iB;;;;;;;;;;;;;;;QAOT;;;;;;;;;;;;;uBAKe,KAAKP,IAAL,CAAUsD,SAAV,CAAoB1C,GAApB,CAAwBvB,UAAxB,C;;;AAAXkE,gBAAAA,E;;;;;;;;sBAEI,aAAIrE,IAAJ,KAAaF,a;;;;;AACf,qBAAKkB,GAAL,CAAS,kBAAT;kDAEO,E;;;sBAGH,IAAIT,KAAJ,uDAAyD,aAAI0E,OAA7D,E;;;AAGF5D,gBAAAA,G,GAAM,IAAInC,GAAJ,CAAQmF,EAAR,C;;uBACM,KAAKtD,GAAL,CAASW,GAAT,CAAaL,GAAb,EAAkB,EAAlB,EAAsB;AAAEC,kBAAAA,OAAO,EAAE;AAAX,iBAAtB,C;;;AAAZ4D,gBAAAA,G;;uBAOa,KAAKjE,MAAL,CAAYkE,eAAZ,CAA4BD,GAAG,CAACtD,KAAhC,C;;;AAAbwD,gBAAAA,I;kDAECA,IAAI,CAACC,MAAL,CAAYhE,GAAZ,C;;;;;;;;;;;;;;;;;;;yGAGeA,G,EAAKiE,O;;;;;;uBACrB,KAAKtC,QAAL,CAAc;AAClB3B,kBAAAA,GAAG,EAAHA,GADkB;AAElBC,kBAAAA,OAAO,EAAEgE,OAAO,CAAChE;AAFC,iBAAd,C;;;;;;;;;;;;;;;QAMR;;;;iCACqBjB,I,EAAM;AACzB,UAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,CAACkF,MAAM,CAACC,IAAP,CAAYhF,QAAZ,EAAsBiF,QAAtB,CAA+BpF,IAA/B,CAAjC,EAAuE;AACrE,eAAOD,iBAAiB,CAACC,IAAD,CAAxB;AACD;AACF;;;;;;AAGHQ,UAAU,CAACL,QAAX,GAAsBA,QAAtB;AAEAkF,MAAM,CAACC,OAAP,GAAiB9E,UAAjB","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { DAGNode, DAGLink } = require('ipld-dag-pb')\nconst CID = require('cids')\nconst { default: Queue } = require('p-queue')\nconst { Key } = require('interface-datastore')\nconst errCode = require('err-code')\nconst multicodec = require('multicodec')\nconst dagCborLinks = require('dag-cbor-links')\nconst debug = require('debug')\nconst { Buffer } = require('buffer')\nconst { cidToString } = require('../../../utils/cid')\n\nconst createPinSet = require('./pin-set')\n\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\n\n// arbitrary limit to the number of concurrent dag operations\nconst WALK_DAG_CONCURRENCY_LIMIT = 300\nconst IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300\nconst PIN_DS_KEY = new Key('/local/pins')\n\nfunction invalidPinTypeErr (type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE')\n}\n\nconst PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n}\n\nclass PinManager {\n  constructor (repo, dag) {\n    this.repo = repo\n    this.dag = dag\n    this.log = debug('ipfs:pin')\n    this.pinset = createPinSet(dag)\n    this.directPins = new Set()\n    this.recursivePins = new Set()\n  }\n\n  async _walkDag ({ cid, preload = false, onCid = () => {} }) {\n    if (!CID.isCID(cid)) {\n      cid = new CID(cid)\n    }\n\n    const walk = (cid) => {\n      return async () => {\n        const { value: node } = await this.dag.get(cid, { preload })\n\n        onCid(cid)\n\n        if (cid.codec === 'dag-pb') {\n          queue.addAll(\n            node.Links.map(link => walk(link.Hash))\n          )\n        } else if (cid.codec === 'dag-cbor') {\n          for (const [_, childCid] of dagCborLinks(node)) { // eslint-disable-line no-unused-vars\n            queue.add(walk(childCid))\n          }\n        }\n      }\n    }\n\n    const queue = new Queue({\n      concurrency: WALK_DAG_CONCURRENCY_LIMIT\n    })\n    queue.add(walk(cid))\n\n    await queue.onIdle()\n  }\n\n  directKeys () {\n    return Array.from(this.directPins, key => new CID(key).buffer)\n  }\n\n  recursiveKeys () {\n    return Array.from(this.recursivePins, key => new CID(key).buffer)\n  }\n\n  async getIndirectKeys ({ preload }) {\n    const indirectKeys = new Set()\n\n    for (const multihash of this.recursiveKeys()) {\n      await this._walkDag({\n        cid: new CID(multihash),\n        preload: preload || false,\n        onCid: (cid) => {\n          cid = cid.toString()\n\n          // recursive pins pre-empt indirect pins\n          if (!this.recursivePins.has(cid)) {\n            indirectKeys.add(cid)\n          }\n        }\n      })\n    }\n\n    return Array.from(indirectKeys)\n  }\n\n  // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n  async flushPins () {\n    const [\n      dLink,\n      rLink\n    ] = await Promise.all([\n      // create a DAGLink to the node with direct pins\n      this.pinset.storeSet(this.directKeys())\n        .then((result) => {\n          return new DAGLink(PinTypes.direct, result.node.size, result.cid)\n        }),\n      // create a DAGLink to the node with recursive pins\n      this.pinset.storeSet(this.recursiveKeys())\n        .then((result) => {\n          return new DAGLink(PinTypes.recursive, result.node.size, result.cid)\n        }),\n      // the pin-set nodes link to a special 'empty' node, so make sure it exists\n      this.dag.put(new DAGNode(Buffer.alloc(0)), {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      })\n    ])\n\n    // create a root node with DAGLinks to the direct and recursive DAGs\n    const rootNode = new DAGNode(Buffer.alloc(0), [dLink, rLink])\n    const rootCid = await this.dag.put(rootNode, {\n      version: 0,\n      format: multicodec.DAG_PB,\n      hashAlg: multicodec.SHA2_256,\n      preload: false\n    })\n\n    // save root to datastore under a consistent key\n    await this.repo.datastore.put(PIN_DS_KEY, rootCid.buffer)\n\n    this.log(`Flushed pins with root: ${rootCid}`)\n  }\n\n  async load () {\n    const has = await this.repo.datastore.has(PIN_DS_KEY)\n\n    if (!has) {\n      return\n    }\n\n    const mh = await this.repo.datastore.get(PIN_DS_KEY)\n    const pinRoot = await this.dag.get(new CID(mh), '', { preload: false })\n\n    const [\n      rKeys, dKeys\n    ] = await Promise.all([\n      this.pinset.loadSet(pinRoot.value, PinTypes.recursive),\n      this.pinset.loadSet(pinRoot.value, PinTypes.direct)\n    ])\n\n    this.directPins = new Set(dKeys.map(k => cidToString(k)))\n    this.recursivePins = new Set(rKeys.map(k => cidToString(k)))\n\n    this.log('Loaded pins from the datastore')\n  }\n\n  async isPinnedWithType (multihash, type) {\n    const key = cidToString(multihash)\n    const { recursive, direct, all } = PinTypes\n\n    // recursive\n    if ((type === recursive || type === all) && this.recursivePins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: recursive\n      }\n    }\n\n    if (type === recursive) {\n      return {\n        key,\n        pinned: false\n      }\n    }\n\n    // direct\n    if ((type === direct || type === all) && this.directPins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: direct\n      }\n    }\n\n    if (type === direct) {\n      return {\n        key,\n        pinned: false\n      }\n    }\n\n    // indirect (default)\n    // check each recursive key to see if multihash is under it\n    // arbitrary limit, enables handling 1000s of pins.\n    const queue = new Queue({\n      concurrency: IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT\n    })\n    let cid\n\n    queue.addAll(\n      this.recursiveKeys()\n        .map(childKey => {\n          childKey = new CID(childKey)\n\n          return async () => {\n            const has = await this.pinset.hasDescendant(childKey, key)\n\n            if (has) {\n              cid = childKey\n              queue.clear()\n            }\n          }\n        })\n    )\n\n    await queue.onIdle()\n\n    return {\n      key,\n      pinned: Boolean(cid),\n      reason: cid\n    }\n  }\n\n  // Gets CIDs of blocks used internally by the pinner\n  async getInternalBlocks () {\n    let mh\n\n    try {\n      mh = await this.repo.datastore.get(PIN_DS_KEY)\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        this.log('No pinned blocks')\n\n        return []\n      }\n\n      throw new Error(`Could not get pin sets root from datastore: ${err.message}`)\n    }\n\n    const cid = new CID(mh)\n    const obj = await this.dag.get(cid, '', { preload: false })\n\n    // The pinner stores an object that has two links to pin sets:\n    // 1. The directly pinned CIDs\n    // 2. The recursively pinned CIDs\n    // If large enough, these pin sets may have links to buckets to hold\n    // the pins\n    const cids = await this.pinset.getInternalCids(obj.value)\n\n    return cids.concat(cid)\n  }\n\n  async fetchCompleteDag (cid, options) {\n    await this._walkDag({\n      cid,\n      preload: options.preload\n    })\n  }\n\n  // Returns an error if the pin type is invalid\n  static checkPinType (type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      return invalidPinTypeErr(type)\n    }\n  }\n}\n\nPinManager.PinTypes = PinTypes\n\nmodule.exports = PinManager\n"]},"metadata":{},"sourceType":"script"}