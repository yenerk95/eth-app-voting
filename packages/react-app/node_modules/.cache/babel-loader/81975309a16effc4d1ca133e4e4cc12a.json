{"ast":null,"code":"'use strict';\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nconst errcode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst PeerId = require('peer-id');\n\nconst pipe = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst pMap = require('p-map');\n\nconst Pubsub = require('libp2p-pubsub');\n\nconst {\n  utils\n} = require('libp2p-pubsub');\n\nconst {\n  RPCCodec\n} = require('./message');\n\nclass BasicPubSub extends Pubsub {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {string[]} props.multicodecs protocol identifiers to connect\n   * @param {PeerId} props.peerId peer's peerId\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {Object} [props.options]\n   * @param {boolean} [props.options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @constructor\n   */\n  constructor({\n    debugName,\n    multicodecs,\n    peerId,\n    registrar,\n    options = {}\n  }) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw new Error('peerId must be an instance of `peer-id`');\n    }\n\n    const _options = Object.assign({\n      emitSelf: false\n    }, options);\n\n    super(Object.assign({\n      debugName,\n      multicodecs,\n      peerId,\n      registrar\n    }, _options));\n    /**\n     * A set of subscriptions\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Pubsub options\n     */\n\n    this._options = _options;\n    /**\n     * The default msgID implementation\n     * @param {RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n    this.defaultMsgIdFn = msg => utils.msgId(msg.from, msg.seqno);\n    /**\n     * Topic validator function\n     * @typedef {function(string, Peer, RPC): boolean} validator\n     */\n\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     * @type {Map<string, validator>}\n     */\n\n\n    this.topicValidators = new Map();\n  }\n  /**\n   * Peer connected successfully with pubsub protocol.\n   * @override\n   * @param {PeerId} peerId peer id\n   * @param {Connection} conn connection to the peer\n   * @returns {Promise<void>}\n   */\n\n\n  _onPeerConnected(peerId, conn) {\n    const _super = Object.create(null, {\n      _onPeerConnected: {\n        get: () => super._onPeerConnected\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super._onPeerConnected.call(this, peerId, conn);\n      const idB58Str = peerId.toB58String();\n      const peer = this.peers.get(idB58Str);\n\n      if (peer && peer.isWritable) {\n        // Immediately send my own subscriptions to the newly established conn\n        peer.sendSubscriptions(this.subscriptions);\n      }\n    });\n  }\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @override\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {Peer} peer PubSub peer\n   * @returns {void}\n   *\n   */\n\n\n  _processMessages(idB58Str, conn, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield pipe(conn, lp.decode(), source => {\n          var source_1, source_1_1;\n          return __awaiter(this, void 0, void 0, function* () {\n            var e_1, _a;\n\n            try {\n              for (source_1 = __asyncValues(source); source_1_1 = yield source_1.next(), !source_1_1.done;) {\n                const data = source_1_1.value;\n                const rpcMsgBuf = Buffer.isBuffer(data) ? data : data.slice();\n\n                const rpcMsg = this._decodeRpc(rpcMsgBuf);\n\n                this._processRpc(idB58Str, peer, rpcMsg);\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield _a.call(source_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n          });\n        });\n      } catch (err) {\n        this._onPeerDisconnected(peer.id, err);\n      }\n    });\n  }\n  /**\n   * Decode a buffer into an RPC object\n   *\n   * Override to use an extended protocol-specific protobuf decoder\n   *\n   * @param {Buffer} buf\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(buf) {\n    return RPCCodec.decode(buf);\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {String} idB58Str\n   * @param {Peer} peer\n   * @param {RPC} rpc\n   * @returns {void}\n   */\n\n\n  _processRpc(idB58Str, peer, rpc) {\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (subs.length) {\n      // update peer subscriptions\n      peer.updateSubscriptions(subs);\n      subs.forEach(subOpt => this._processRpcSubOpt(peer, subOpt));\n      this.emit('pubsub:subscription-change', peer.id, peer.topics, subs);\n    }\n\n    if (msgs.length) {\n      msgs.forEach(message => __awaiter(this, void 0, void 0, function* () {\n        const msg = utils.normalizeInRpcMessage(message); // Ensure the message is valid before processing it\n\n        try {\n          const isValid = yield this.validate(message, peer);\n\n          if (!isValid) {\n            this.log('Message is invalid, dropping it.');\n            return;\n          }\n        } catch (err) {\n          this.log('Error in message validation, dropping it. %O', err);\n          return;\n        }\n\n        this._processRpcMessage(peer, msg);\n      }));\n    }\n  }\n  /**\n   * Validates the given message.\n   * @param {RPC.Message} message\n   * @param {Peer} [peer]\n   * @returns {Promise<Boolean>}\n   */\n\n\n  validate(message, peer) {\n    const _super = Object.create(null, {\n      validate: {\n        get: () => super.validate\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const isValid = yield _super.validate.call(this, message, peer);\n\n      if (!isValid) {\n        return false;\n      } // only run topic validators if the peer is passed as an arg\n\n\n      if (!peer) {\n        return true;\n      }\n\n      return message.topicIDs.every(topic => {\n        const validatorFn = this.topicValidators.get(topic);\n\n        if (!validatorFn) {\n          return true;\n        }\n\n        return this._processTopicValidatorResult(topic, peer, message, validatorFn(topic, peer, message));\n      });\n    });\n  }\n  /**\n   * Coerces topic validator result to determine message validity\n   *\n   * Defaults to true if truthy\n   *\n   * Override this method to provide custom topic validator result processing (eg: scoring)\n   *\n   * @param {String} topic\n   * @param {Peer} peer\n   * @param {RPC.Message} message\n   * @param {unknown} result\n   * @returns {Boolean}\n   */\n\n\n  _processTopicValidatorResult(topic, peer, message, result) {\n    return Boolean(result);\n  }\n  /**\n   * Handles an subscription change from a peer\n   *\n   * @param {Peer} peer\n   * @param {RPC.SubOpt} subOpt\n   */\n\n\n  _processRpcSubOpt(peer, subOpt) {\n    const t = subOpt.topicID;\n    let topicSet = this.topics.get(t);\n\n    if (!topicSet) {\n      topicSet = new Set();\n      this.topics.set(t, topicSet);\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(peer);\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(peer);\n    }\n  }\n  /**\n   * Handles an message from a peer\n   *\n   * @param {Peer} peer\n   * @param {RPC.Message} msg\n   */\n\n\n  _processRpcMessage(peer, msg) {\n    if (this.peerId.toB58String() === msg.from && !this._options.emitSelf) {\n      return;\n    } // Emit to self\n\n\n    this._emitMessage(msg.topicIDs, msg);\n  }\n\n  _emitMessage(topics, message) {\n    topics.forEach(topic => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message);\n      }\n    });\n  }\n  /**\n   * Unmounts the protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    const _super = Object.create(null, {\n      stop: {\n        get: () => super.stop\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.stop.call(this);\n      this.subscriptions = new Set();\n    });\n  }\n  /**\n   * Subscribes to topics\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  subscribe(topics) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    } // normalize input and remove existing subscriptions\n\n\n    topics = utils.ensureArray(topics);\n    const newTopics = topics.filter(topic => !this.subscriptions.has(topic));\n\n    if (newTopics.length === 0) {\n      return;\n    }\n\n    this._subscribe(newTopics);\n  }\n  /**\n   * Subscribes to topics\n   *\n   * @param {Array<string>} topics\n   * @returns {void}\n   */\n\n\n  _subscribe(topics) {\n    // set subscriptions\n    topics.forEach(topic => {\n      this.subscriptions.add(topic);\n    }); // Broadcast SUBSCRIBE to all peers\n\n    this.peers.forEach(peer => sendSubscriptionsOnceReady(peer)); // make sure that the protocol is already mounted\n\n    function sendSubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendSubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n  }\n  /**\n   * Leaves a topic\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  unsubscribe(topics) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    } // normalize input and remove existing unsubscriptions\n\n\n    topics = utils.ensureArray(topics);\n    const unTopics = topics.filter(topic => this.subscriptions.has(topic));\n\n    if (unTopics.length === 0) {\n      return;\n    }\n\n    this._unsubscribe(unTopics);\n  }\n  /**\n   * Unsubscribes to topics\n   *\n   * @param {Array<string>} topics\n   * @returns {void}\n   */\n\n\n  _unsubscribe(topics) {\n    // delete subscriptions\n    topics.forEach(topic => {\n      this.subscriptions.delete(topic);\n    }); // Broadcast UNSUBSCRIBE to all peers ready\n\n    this.peers.forEach(peer => sendUnsubscriptionsOnceReady(peer)); // make sure that the protocol is already mounted\n\n    function sendUnsubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendUnsubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendUnsubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n  }\n  /**\n   * Publishes messages to all subscribed peers\n   * @override\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @returns {void}\n   */\n\n\n  publish(topics, messages) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      }\n\n      this.log('publish', topics, messages);\n      topics = utils.ensureArray(topics);\n      messages = utils.ensureArray(messages);\n      const from = this.peerId.toB58String();\n\n      const buildMessage = (msg, cb) => {\n        const seqno = utils.randomSeqno();\n        const msgObj = {\n          from: from,\n          data: msg,\n          seqno: seqno,\n          topicIDs: topics\n        }; // Emit to self if I'm interested and emitSelf enabled\n\n        this._options.emitSelf && this._emitMessages(topics, [msgObj]);\n        return this._buildMessage(msgObj);\n      };\n\n      const msgObjects = yield pMap(messages, buildMessage); // send to all the other peers\n\n      this._publish(utils.normalizeOutRpcMessages(msgObjects));\n    });\n  }\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   * @override\n   * @returns {Array<String>}\n   */\n\n\n  getTopics() {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    return Array.from(this.subscriptions);\n  }\n  /**\n   * Child class can override this.\n   * @param {RPC.Message} msg the message object\n   * @returns {string} message id as string\n   */\n\n\n  getMsgId(msg) {\n    return this.defaultMsgIdFn(msg);\n  }\n\n  _emitMessages(topics, messages) {\n    topics.forEach(topic => {\n      if (!this.subscriptions.has(topic)) {\n        return;\n      }\n\n      messages.forEach(message => {\n        this.emit(topic, message);\n      });\n    });\n  }\n  /**\n   * Publish messages\n   *\n   * Note: this function assumes all messages are well-formed RPC objects\n   * @param {Array<Message>} msgs\n   * @returns {void}\n   */\n\n\n  _publish(msgs) {\n    throw errcode(new Error('_publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n\n}\n\nmodule.exports = BasicPubSub;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-gossipsub/src/pubsub.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","settle","d","errcode","require","Buffer","PeerId","pipe","lp","pMap","Pubsub","utils","RPCCodec","BasicPubSub","constructor","debugName","multicodecs","peerId","registrar","options","isPeerId","Error","_options","Object","assign","emitSelf","subscriptions","Set","defaultMsgIdFn","msg","msgId","from","seqno","topicValidators","Map","_onPeerConnected","conn","_super","create","get","idB58Str","toB58String","peer","peers","isWritable","sendSubscriptions","_processMessages","decode","source","source_1","source_1_1","e_1","_a","data","rpcMsgBuf","isBuffer","slice","rpcMsg","_decodeRpc","_processRpc","e_1_1","error","return","err","_onPeerDisconnected","id","buf","rpc","log","subs","msgs","length","updateSubscriptions","forEach","subOpt","_processRpcSubOpt","emit","topics","message","normalizeInRpcMessage","isValid","validate","_processRpcMessage","topicIDs","every","topic","validatorFn","_processTopicValidatorResult","Boolean","t","topicID","topicSet","set","subscribe","add","delete","_emitMessage","has","stop","started","ensureArray","newTopics","filter","_subscribe","sendSubscriptionsOnceReady","onConnection","removeListener","on","once","unsubscribe","unTopics","_unsubscribe","sendUnsubscriptionsOnceReady","sendUnsubscriptions","publish","messages","buildMessage","cb","randomSeqno","msgObj","_emitMessages","_buildMessage","msgObjects","_publish","normalizeOutRpcMessages","getTopics","Array","getMsgId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nconst errcode = require('err-code');\nconst { Buffer } = require('buffer');\nconst PeerId = require('peer-id');\nconst pipe = require('it-pipe');\nconst lp = require('it-length-prefixed');\nconst pMap = require('p-map');\nconst Pubsub = require('libp2p-pubsub');\nconst { utils } = require('libp2p-pubsub');\nconst { RPCCodec } = require('./message');\nclass BasicPubSub extends Pubsub {\n    /**\n     * @param {Object} props\n     * @param {String} props.debugName log namespace\n     * @param {string[]} props.multicodecs protocol identifiers to connect\n     * @param {PeerId} props.peerId peer's peerId\n     * @param {Object} props.registrar registrar for libp2p protocols\n     * @param {function} props.registrar.handle\n     * @param {function} props.registrar.register\n     * @param {function} props.registrar.unregister\n     * @param {Object} [props.options]\n     * @param {boolean} [props.options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n     * @constructor\n     */\n    constructor({ debugName, multicodecs, peerId, registrar, options = {} }) {\n        if (!PeerId.isPeerId(peerId)) {\n            throw new Error('peerId must be an instance of `peer-id`');\n        }\n        const _options = Object.assign({ emitSelf: false }, options);\n        super(Object.assign({ debugName,\n            multicodecs,\n            peerId,\n            registrar }, _options));\n        /**\n         * A set of subscriptions\n         */\n        this.subscriptions = new Set();\n        /**\n         * Pubsub options\n         */\n        this._options = _options;\n        /**\n         * The default msgID implementation\n         * @param {RPC.Message} msg the message object\n         * @returns {string} message id as string\n         */\n        this.defaultMsgIdFn = (msg) => utils.msgId(msg.from, msg.seqno);\n        /**\n         * Topic validator function\n         * @typedef {function(string, Peer, RPC): boolean} validator\n         */\n        /**\n         * Topic validator map\n         *\n         * Keyed by topic\n         * Topic validators are functions with the following input:\n         * @type {Map<string, validator>}\n         */\n        this.topicValidators = new Map();\n    }\n    /**\n     * Peer connected successfully with pubsub protocol.\n     * @override\n     * @param {PeerId} peerId peer id\n     * @param {Connection} conn connection to the peer\n     * @returns {Promise<void>}\n     */\n    _onPeerConnected(peerId, conn) {\n        const _super = Object.create(null, {\n            _onPeerConnected: { get: () => super._onPeerConnected }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super._onPeerConnected.call(this, peerId, conn);\n            const idB58Str = peerId.toB58String();\n            const peer = this.peers.get(idB58Str);\n            if (peer && peer.isWritable) {\n                // Immediately send my own subscriptions to the newly established conn\n                peer.sendSubscriptions(this.subscriptions);\n            }\n        });\n    }\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @override\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {Peer} peer PubSub peer\n     * @returns {void}\n     *\n     */\n    _processMessages(idB58Str, conn, peer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield pipe(conn, lp.decode(), (source) => { var source_1, source_1_1; return __awaiter(this, void 0, void 0, function* () {\n                    var e_1, _a;\n                    try {\n                        for (source_1 = __asyncValues(source); source_1_1 = yield source_1.next(), !source_1_1.done;) {\n                            const data = source_1_1.value;\n                            const rpcMsgBuf = Buffer.isBuffer(data) ? data : data.slice();\n                            const rpcMsg = this._decodeRpc(rpcMsgBuf);\n                            this._processRpc(idB58Str, peer, rpcMsg);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield _a.call(source_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }); });\n            }\n            catch (err) {\n                this._onPeerDisconnected(peer.id, err);\n            }\n        });\n    }\n    /**\n     * Decode a buffer into an RPC object\n     *\n     * Override to use an extended protocol-specific protobuf decoder\n     *\n     * @param {Buffer} buf\n     * @returns {RPC}\n     */\n    _decodeRpc(buf) {\n        return RPCCodec.decode(buf);\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @param {String} idB58Str\n     * @param {Peer} peer\n     * @param {RPC} rpc\n     * @returns {void}\n     */\n    _processRpc(idB58Str, peer, rpc) {\n        this.log('rpc from', idB58Str);\n        const subs = rpc.subscriptions;\n        const msgs = rpc.msgs;\n        if (subs.length) {\n            // update peer subscriptions\n            peer.updateSubscriptions(subs);\n            subs.forEach((subOpt) => this._processRpcSubOpt(peer, subOpt));\n            this.emit('pubsub:subscription-change', peer.id, peer.topics, subs);\n        }\n        if (msgs.length) {\n            msgs.forEach((message) => __awaiter(this, void 0, void 0, function* () {\n                const msg = utils.normalizeInRpcMessage(message);\n                // Ensure the message is valid before processing it\n                try {\n                    const isValid = yield this.validate(message, peer);\n                    if (!isValid) {\n                        this.log('Message is invalid, dropping it.');\n                        return;\n                    }\n                }\n                catch (err) {\n                    this.log('Error in message validation, dropping it. %O', err);\n                    return;\n                }\n                this._processRpcMessage(peer, msg);\n            }));\n        }\n    }\n    /**\n     * Validates the given message.\n     * @param {RPC.Message} message\n     * @param {Peer} [peer]\n     * @returns {Promise<Boolean>}\n     */\n    validate(message, peer) {\n        const _super = Object.create(null, {\n            validate: { get: () => super.validate }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const isValid = yield _super.validate.call(this, message, peer);\n            if (!isValid) {\n                return false;\n            }\n            // only run topic validators if the peer is passed as an arg\n            if (!peer) {\n                return true;\n            }\n            return message.topicIDs.every(topic => {\n                const validatorFn = this.topicValidators.get(topic);\n                if (!validatorFn) {\n                    return true;\n                }\n                return this._processTopicValidatorResult(topic, peer, message, validatorFn(topic, peer, message));\n            });\n        });\n    }\n    /**\n     * Coerces topic validator result to determine message validity\n     *\n     * Defaults to true if truthy\n     *\n     * Override this method to provide custom topic validator result processing (eg: scoring)\n     *\n     * @param {String} topic\n     * @param {Peer} peer\n     * @param {RPC.Message} message\n     * @param {unknown} result\n     * @returns {Boolean}\n     */\n    _processTopicValidatorResult(topic, peer, message, result) {\n        return Boolean(result);\n    }\n    /**\n     * Handles an subscription change from a peer\n     *\n     * @param {Peer} peer\n     * @param {RPC.SubOpt} subOpt\n     */\n    _processRpcSubOpt(peer, subOpt) {\n        const t = subOpt.topicID;\n        let topicSet = this.topics.get(t);\n        if (!topicSet) {\n            topicSet = new Set();\n            this.topics.set(t, topicSet);\n        }\n        if (subOpt.subscribe) {\n            // subscribe peer to new topic\n            topicSet.add(peer);\n        }\n        else {\n            // unsubscribe from existing topic\n            topicSet.delete(peer);\n        }\n    }\n    /**\n     * Handles an message from a peer\n     *\n     * @param {Peer} peer\n     * @param {RPC.Message} msg\n     */\n    _processRpcMessage(peer, msg) {\n        if (this.peerId.toB58String() === msg.from && !this._options.emitSelf) {\n            return;\n        }\n        // Emit to self\n        this._emitMessage(msg.topicIDs, msg);\n    }\n    _emitMessage(topics, message) {\n        topics.forEach((topic) => {\n            if (this.subscriptions.has(topic)) {\n                this.emit(topic, message);\n            }\n        });\n    }\n    /**\n     * Unmounts the protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        const _super = Object.create(null, {\n            stop: { get: () => super.stop }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.stop.call(this);\n            this.subscriptions = new Set();\n        });\n    }\n    /**\n     * Subscribes to topics\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    subscribe(topics) {\n        if (!this.started) {\n            throw new Error('Pubsub has not started');\n        }\n        // normalize input and remove existing subscriptions\n        topics = utils.ensureArray(topics);\n        const newTopics = topics.filter((topic) => !this.subscriptions.has(topic));\n        if (newTopics.length === 0) {\n            return;\n        }\n        this._subscribe(newTopics);\n    }\n    /**\n     * Subscribes to topics\n     *\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _subscribe(topics) {\n        // set subscriptions\n        topics.forEach((topic) => {\n            this.subscriptions.add(topic);\n        });\n        // Broadcast SUBSCRIBE to all peers\n        this.peers.forEach((peer) => sendSubscriptionsOnceReady(peer));\n        // make sure that the protocol is already mounted\n        function sendSubscriptionsOnceReady(peer) {\n            if (peer && peer.isWritable) {\n                return peer.sendSubscriptions(topics);\n            }\n            const onConnection = () => {\n                peer.removeListener('connection', onConnection);\n                sendSubscriptionsOnceReady(peer);\n            };\n            peer.on('connection', onConnection);\n            peer.once('close', () => peer.removeListener('connection', onConnection));\n        }\n    }\n    /**\n     * Leaves a topic\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    unsubscribe(topics) {\n        if (!this.started) {\n            throw new Error('Pubsub has not started');\n        }\n        // normalize input and remove existing unsubscriptions\n        topics = utils.ensureArray(topics);\n        const unTopics = topics.filter((topic) => this.subscriptions.has(topic));\n        if (unTopics.length === 0) {\n            return;\n        }\n        this._unsubscribe(unTopics);\n    }\n    /**\n     * Unsubscribes to topics\n     *\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _unsubscribe(topics) {\n        // delete subscriptions\n        topics.forEach((topic) => {\n            this.subscriptions.delete(topic);\n        });\n        // Broadcast UNSUBSCRIBE to all peers ready\n        this.peers.forEach((peer) => sendUnsubscriptionsOnceReady(peer));\n        // make sure that the protocol is already mounted\n        function sendUnsubscriptionsOnceReady(peer) {\n            if (peer && peer.isWritable) {\n                return peer.sendUnsubscriptions(topics);\n            }\n            const onConnection = () => {\n                peer.removeListener('connection', onConnection);\n                sendUnsubscriptionsOnceReady(peer);\n            };\n            peer.on('connection', onConnection);\n            peer.once('close', () => peer.removeListener('connection', onConnection));\n        }\n    }\n    /**\n     * Publishes messages to all subscribed peers\n     * @override\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @returns {void}\n     */\n    publish(topics, messages) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.started) {\n                throw new Error('Pubsub has not started');\n            }\n            this.log('publish', topics, messages);\n            topics = utils.ensureArray(topics);\n            messages = utils.ensureArray(messages);\n            const from = this.peerId.toB58String();\n            const buildMessage = (msg, cb) => {\n                const seqno = utils.randomSeqno();\n                const msgObj = {\n                    from: from,\n                    data: msg,\n                    seqno: seqno,\n                    topicIDs: topics\n                };\n                // Emit to self if I'm interested and emitSelf enabled\n                this._options.emitSelf && this._emitMessages(topics, [msgObj]);\n                return this._buildMessage(msgObj);\n            };\n            const msgObjects = yield pMap(messages, buildMessage);\n            // send to all the other peers\n            this._publish(utils.normalizeOutRpcMessages(msgObjects));\n        });\n    }\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     * @override\n     * @returns {Array<String>}\n     */\n    getTopics() {\n        if (!this.started) {\n            throw new Error('Pubsub is not started');\n        }\n        return Array.from(this.subscriptions);\n    }\n    /**\n     * Child class can override this.\n     * @param {RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n    getMsgId(msg) {\n        return this.defaultMsgIdFn(msg);\n    }\n    _emitMessages(topics, messages) {\n        topics.forEach((topic) => {\n            if (!this.subscriptions.has(topic)) {\n                return;\n            }\n            messages.forEach((message) => {\n                this.emit(topic, message);\n            });\n        });\n    }\n    /**\n     * Publish messages\n     *\n     * Note: this function assumes all messages are well-formed RPC objects\n     * @param {Array<Message>} msgs\n     * @returns {void}\n     */\n    _publish(msgs) {\n        throw errcode(new Error('_publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n}\nmodule.exports = BasicPubSub;\n"]},"metadata":{},"sourceType":"script"}