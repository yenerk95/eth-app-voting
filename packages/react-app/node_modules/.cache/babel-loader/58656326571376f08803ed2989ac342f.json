{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar mh = require('multihashing-async');\n\nvar crypto = require('libp2p-crypto');\n\nvar _require2 = require('libp2p-interfaces/src/crypto/errors'),\n    InvalidCryptoExchangeError = _require2.InvalidCryptoExchangeError;\n\nexports.exchanges = ['P-256', 'P-384', 'P-521'];\nexports.ciphers = ['AES-256', 'AES-128'];\nexports.hashes = ['SHA256', 'SHA512']; // Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\n\nexports.theBest = function (order, p1, p2) {\n  var first;\n  var second;\n\n  if (order < 0) {\n    first = p2;\n    second = p1;\n  } else if (order > 0) {\n    first = p1;\n    second = p2;\n  } else {\n    return p1[0];\n  }\n\n  var _iterator = _createForOfIteratorHelper(first),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var firstCandidate = _step.value;\n\n      var _iterator2 = _createForOfIteratorHelper(second),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var secondCandidate = _step2.value;\n\n          if (firstCandidate === secondCandidate) {\n            return firstCandidate;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  throw new InvalidCryptoExchangeError('No algorithms in common!');\n};\n\nexports.makeMacAndCipher = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(target) {\n    var _yield$Promise$all, _yield$Promise$all2;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.all([makeMac(target.hashT, target.keys.macKey), makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey)]);\n\n          case 2:\n            _yield$Promise$all = _context.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            target.mac = _yield$Promise$all2[0];\n            target.cipher = _yield$Promise$all2[1];\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction makeMac(hash, key) {\n  return crypto.hmac.create(hash, key);\n}\n\nfunction makeCipher(cipherType, iv, key) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv);\n  } // TODO: figure out if Blowfish is needed and if so find a library for it.\n\n\n  throw new InvalidCryptoExchangeError(\"unrecognized cipher type: \".concat(cipherType));\n}\n\nexports.selectBest = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(local, remote) {\n    var oh1, oh2, order;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return exports.digest(Buffer.concat([remote.pubKeyBytes, local.nonce]));\n\n          case 2:\n            oh1 = _context2.sent;\n            _context2.next = 5;\n            return exports.digest(Buffer.concat([local.pubKeyBytes, remote.nonce]));\n\n          case 5:\n            oh2 = _context2.sent;\n            order = Buffer.compare(oh1, oh2);\n\n            if (!(order === 0)) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new InvalidCryptoExchangeError('you are trying to talk to yourself');\n\n          case 9:\n            return _context2.abrupt(\"return\", {\n              curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n              cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n              hashT: exports.theBest(order, local.hashes, remote.hashes),\n              order: order\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.digest = function (buf) {\n  return mh.digest(buf, 'sha2-256', buf.length);\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-secio/src/support.js"],"names":["require","Buffer","mh","crypto","InvalidCryptoExchangeError","exports","exchanges","ciphers","hashes","theBest","order","p1","p2","first","second","firstCandidate","secondCandidate","makeMacAndCipher","target","Promise","all","makeMac","hashT","keys","macKey","makeCipher","cipherT","iv","cipherKey","mac","cipher","hash","key","hmac","create","cipherType","aes","selectBest","local","remote","digest","concat","pubKeyBytes","nonce","oh1","oh2","compare","curveT","buf","length"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst mh = require('multihashing-async')\nconst crypto = require('libp2p-crypto')\n\nconst { InvalidCryptoExchangeError } = require('libp2p-interfaces/src/crypto/errors')\n\nexports.exchanges = [\n  'P-256',\n  'P-384',\n  'P-521'\n]\n\nexports.ciphers = [\n  'AES-256',\n  'AES-128'\n]\n\nexports.hashes = [\n  'SHA256',\n  'SHA512'\n]\n\n// Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\nexports.theBest = (order, p1, p2) => {\n  let first\n  let second\n\n  if (order < 0) {\n    first = p2\n    second = p1\n  } else if (order > 0) {\n    first = p1\n    second = p2\n  } else {\n    return p1[0]\n  }\n\n  for (const firstCandidate of first) {\n    for (const secondCandidate of second) {\n      if (firstCandidate === secondCandidate) {\n        return firstCandidate\n      }\n    }\n  }\n\n  throw new InvalidCryptoExchangeError('No algorithms in common!')\n}\n\nexports.makeMacAndCipher = async (target) => {\n  [target.mac, target.cipher] = await Promise.all([\n    makeMac(target.hashT, target.keys.macKey),\n    makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey)\n  ])\n}\n\nfunction makeMac (hash, key) {\n  return crypto.hmac.create(hash, key)\n}\n\nfunction makeCipher (cipherType, iv, key) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv)\n  }\n\n  // TODO: figure out if Blowfish is needed and if so find a library for it.\n  throw new InvalidCryptoExchangeError(`unrecognized cipher type: ${cipherType}`)\n}\n\nexports.selectBest = async (local, remote) => {\n  const oh1 = await exports.digest(Buffer.concat([\n    remote.pubKeyBytes,\n    local.nonce\n  ]))\n  const oh2 = await exports.digest(Buffer.concat([\n    local.pubKeyBytes,\n    remote.nonce\n  ]))\n\n  const order = Buffer.compare(oh1, oh2)\n\n  if (order === 0) {\n    throw new InvalidCryptoExchangeError('you are trying to talk to yourself')\n  }\n\n  return {\n    curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n    cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n    hashT: exports.theBest(order, local.hashes, remote.hashes),\n    order\n  }\n}\n\nexports.digest = (buf) => {\n  return mh.digest(buf, 'sha2-256', buf.length)\n}\n"]},"metadata":{},"sourceType":"script"}