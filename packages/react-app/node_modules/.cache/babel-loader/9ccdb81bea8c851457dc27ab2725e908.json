{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar Bucket = require('hamt-sharding/src/bucket');\n\nvar multihashing = require('multihashing-async'); // FIXME: this is copy/pasted from ipfs-unixfs-importer/src/dir-sharded.js\n\n\nvar hashFn = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n    var hash, justHash, length, result, i;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return multihashing(Buffer.from(value, 'utf8'), 'murmur3-128');\n\n          case 2:\n            hash = _context.sent;\n            // Multihashing inserts preamble of 2 bytes. Remove it.\n            // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n            // implementation only uses the first 64, so we must do the same\n            // for parity..\n            justHash = hash.slice(2, 10);\n            length = justHash.length;\n            result = Buffer.alloc(length); // TODO: invert buffer because that's how Go impl does it\n\n            for (i = 0; i < length; i++) {\n              result[length - i - 1] = justHash[i];\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function hashFn(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nhashFn.code = 0x22; // TODO: get this from multihashing-async?\n\nvar addLinksToHamtBucket = function addLinksToHamtBucket(links, bucket, rootBucket) {\n  return Promise.all(links.map(function (link) {\n    if (link.Name.length === 2) {\n      var pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hashFn: hashFn\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nvar toPrefix = function toPrefix(position) {\n  return position.toString('16').toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nvar toBucketPath = function toBucketPath(position) {\n  var bucket = position.bucket;\n  var path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nvar findShardCid = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node, name, ipld, context, options) {\n    var position, prefix, bucketPath, link;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!context) {\n              context = {\n                rootBucket: new Bucket({\n                  hashFn: hashFn\n                }),\n                hamtDepth: 1\n              };\n              context.lastBucket = context.rootBucket;\n            }\n\n            _context2.next = 3;\n            return addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n\n          case 3:\n            _context2.next = 5;\n            return context.rootBucket._findNewBucketAndPos(name);\n\n          case 5:\n            position = _context2.sent;\n            prefix = toPrefix(position.pos);\n            bucketPath = toBucketPath(position);\n\n            if (bucketPath.length > context.hamtDepth) {\n              context.lastBucket = bucketPath[context.hamtDepth];\n              prefix = toPrefix(context.lastBucket._posAtParent);\n            }\n\n            link = node.Links.find(function (link) {\n              var entryPrefix = link.Name.substring(0, 2);\n              var entryName = link.Name.substring(2);\n\n              if (entryPrefix !== prefix) {\n                // not the entry or subshard we're looking for\n                return;\n              }\n\n              if (entryName && entryName !== name) {\n                // not the entry we're looking for\n                return;\n              }\n\n              return true;\n            });\n\n            if (link) {\n              _context2.next = 12;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 12:\n            if (!(link.Name.substring(2) === name)) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", link.Hash);\n\n          case 14:\n            context.hamtDepth++;\n            _context2.next = 17;\n            return ipld.get(link.Hash, options);\n\n          case 17:\n            node = _context2.sent;\n            return _context2.abrupt(\"return\", findShardCid(node, name, ipld, context, options));\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function findShardCid(_x2, _x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports = findShardCid;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js"],"names":["require","Buffer","Bucket","multihashing","hashFn","value","from","hash","justHash","slice","length","result","alloc","i","code","addLinksToHamtBucket","links","bucket","rootBucket","Promise","all","map","link","Name","pos","parseInt","_putObjectAt","put","substring","toPrefix","position","toString","toUpperCase","padStart","toBucketPath","path","_parent","push","reverse","findShardCid","node","name","ipld","context","options","hamtDepth","lastBucket","Links","_findNewBucketAndPos","prefix","bucketPath","_posAtParent","find","entryPrefix","entryName","Hash","get","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Bucket = require('hamt-sharding/src/bucket')\nconst multihashing = require('multihashing-async')\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/dir-sharded.js\nconst hashFn = async function (value) {\n  const hash = await multihashing(Buffer.from(value, 'utf8'), 'murmur3-128')\n\n  // Multihashing inserts preamble of 2 bytes. Remove it.\n  // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n  // implementation only uses the first 64, so we must do the same\n  // for parity..\n  const justHash = hash.slice(2, 10)\n  const length = justHash.length\n  const result = Buffer.alloc(length)\n  // TODO: invert buffer because that's how Go impl does it\n  for (let i = 0; i < length; i++) {\n    result[length - i - 1] = justHash[i]\n  }\n\n  return result\n}\nhashFn.code = 0x22 // TODO: get this from multihashing-async?\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(\n    links.map(link => {\n      if (link.Name.length === 2) {\n        const pos = parseInt(link.Name, 16)\n\n        return bucket._putObjectAt(pos, new Bucket({\n          hashFn\n        }, bucket, pos))\n      }\n\n      return rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position) => {\n  return position\n    .toString('16')\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nconst toBucketPath = (position) => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node, name, ipld, context, options) => {\n  if (!context) {\n    context = {\n      rootBucket: new Bucket({\n        hashFn\n      }),\n      hamtDepth: 1\n    }\n\n    context.lastBucket = context.rootBucket\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > (context.hamtDepth)) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent)\n  }\n\n  const link = node.Links.find(link => {\n    const entryPrefix = link.Name.substring(0, 2)\n    const entryName = link.Name.substring(2)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return\n    }\n\n    return true\n  })\n\n  if (!link) {\n    return null\n  }\n\n  if (link.Name.substring(2) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  node = await ipld.get(link.Hash, options)\n\n  return findShardCid(node, name, ipld, context, options)\n}\n\nmodule.exports = findShardCid\n"]},"metadata":{},"sourceType":"script"}