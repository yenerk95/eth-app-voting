{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst EventEmitter = require('events');\n\nconst errcode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst message = require('./message');\n\nconst Peer = require('./peer');\n\nconst utils = require('./utils');\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign');\n\nfunction validateRegistrar(registrar) {\n  // registrar handling\n  if (typeof registrar !== 'object') {\n    throw new Error('a registrar object is required');\n  }\n\n  if (typeof registrar.handle !== 'function') {\n    throw new Error('a handle function must be provided in registrar');\n  }\n\n  if (typeof registrar.register !== 'function') {\n    throw new Error('a register function must be provided in registrar');\n  }\n\n  if (typeof registrar.unregister !== 'function') {\n    throw new Error('a unregister function must be provided in registrar');\n  }\n}\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {PeerId} props.peerId peer's peerId\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {boolean} [props.signMessages] if messages should be signed, defaults to true\n   * @param {boolean} [props.strictSigning] if message signing should be required, defaults to true\n   * @abstract\n   */\n  constructor({\n    debugName,\n    multicodecs,\n    peerId,\n    registrar,\n    signMessages = true,\n    strictSigning = true\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!PeerId.isPeerId(peerId)) {\n      throw new Error('peerId must be an instance of `peer-id`');\n    }\n\n    validateRegistrar(registrar);\n    super();\n    this.log = debug(debugName);\n    this.log.err = debug(`${debugName}:error`);\n    this.multicodecs = utils.ensureArray(multicodecs);\n    this.registrar = registrar;\n    this.started = false;\n    this.peerId = peerId;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    this.topics = new Map();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    this.peers = new Map(); // Message signing\n\n    this.signMessages = signMessages;\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n\n    this.strictSigning = strictSigning;\n    this._registrarId = undefined;\n    this._onIncomingStream = this._onIncomingStream.bind(this);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n  }\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    if (this.started) {\n      return;\n    }\n\n    this.log('starting'); // Incoming streams\n\n    this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    });\n    this._registrarId = await this.registrar.register(topology);\n    this.log('started');\n    this.started = true;\n  }\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   * @returns {Promise}\n   */\n\n\n  async stop() {\n    if (!this.started) {\n      return;\n    } // unregister protocol and handlers\n\n\n    await this.registrar.unregister(this._registrarId);\n    this.log('stopping');\n    this.peers.forEach(peer => peer.close());\n    this.peers = new Map();\n    this.started = false;\n    this.log('stopped');\n  }\n  /**\n   * On an incoming stream event.\n   * @private\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {DuplexStream} props.strean\n   * @param {Connection} props.connection connection\n   */\n\n\n  _onIncomingStream({\n    protocol,\n    stream,\n    connection\n  }) {\n    const peerId = connection.remotePeer;\n    const idB58Str = peerId.toB58String();\n\n    const peer = this._addPeer(peerId, [protocol]);\n\n    this._processMessages(idB58Str, stream, peer);\n  }\n  /**\n   * Registrar notifies a connection successfully with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId remote peer-id\n   * @param {Connection} conn connection to the peer\n   */\n\n\n  async _onPeerConnected(peerId, conn) {\n    const idB58Str = peerId.toB58String();\n    this.log('connected', idB58Str);\n\n    const peer = this._addPeer(peerId, this.multicodecs);\n\n    try {\n      const {\n        stream\n      } = await conn.newStream(this.multicodecs);\n      peer.attachConnection(stream);\n    } catch (err) {\n      this.log.err(err);\n    }\n  }\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId peerId\n   * @param {Error} err error for connection end\n   */\n\n\n  _onPeerDisconnected(peerId, err) {\n    const idB58Str = peerId.toB58String();\n    const peer = this.peers.get(idB58Str);\n    this.log('connection ended', idB58Str, err ? err.message : '');\n\n    this._removePeer(peer);\n  }\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Array<string>} protocols\n   * @returns {Peer}\n   */\n\n\n  _addPeer(peerId, protocols) {\n    const id = peerId.toB58String();\n    let existing = this.peers.get(id);\n\n    if (!existing) {\n      this.log('new peer', id);\n      const peer = new Peer({\n        id: peerId,\n        protocols\n      });\n      this.peers.set(id, peer);\n      existing = peer;\n      peer.once('close', () => this._removePeer(peer));\n    }\n\n    return existing;\n  }\n  /**\n   * Remove a peer from the peers map.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {Peer}\n   */\n\n\n  _removePeer(peer) {\n    if (!peer) return;\n    const id = peer.id.toB58String();\n    this.log('delete peer', id);\n    this.peers.delete(id);\n    return peer;\n  }\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * @param {rpc.RPC.Message} message\n   * @returns {Promise<Boolean>}\n   */\n\n\n  async validate(message) {\n    // eslint-disable-line require-await\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      this.log('Signing required and no signature was present, dropping message:', message);\n      return false;\n    } // Check the message signature if present\n\n\n    if (message.signature) {\n      return verifySignature(message);\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   * @private\n   * @param {Message} message\n   * @returns {Promise<Message>}\n   */\n\n\n  _buildMessage(message) {\n    const msg = utils.normalizeOutRpcMessage(message);\n\n    if (this.signMessages) {\n      return signMessage(this.peerId, msg);\n    } else {\n      return message;\n    }\n  }\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n\n\n  getSubscribers(topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n    }\n\n    return Array.from(this.peers.values()).filter(peer => peer.topics.has(topic)).map(peer => peer.id.toB58String());\n  }\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @returns {Promise}\n   *\n   */\n\n\n  publish(topics, messages) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  subscribe(topics) {\n    throw errcode(new Error('subscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  unsubscribe(topics) {\n    throw errcode(new Error('unsubscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of getTopics should handle the appropriate algorithms for the publish/subscriber implementation.\n   * Get the list of subscriptions the peer is subscribed to.\n   * @abstract\n   * @returns {Array<string>}\n   */\n\n\n  getTopics() {\n    throw errcode(new Error('getTopics must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of _processMessages should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {Peer} peer A Pubsub Peer\n   * @returns {void}\n   *\n   */\n\n\n  _processMessages(idB58Str, conn, peer) {\n    throw errcode(new Error('_processMessages must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n\n}\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-pubsub/src/index.js"],"names":["debug","require","EventEmitter","errcode","PeerId","MulticodecTopology","message","Peer","utils","signMessage","verifySignature","validateRegistrar","registrar","Error","handle","register","unregister","PubsubBaseProtocol","constructor","debugName","multicodecs","peerId","signMessages","strictSigning","isPeerId","log","err","ensureArray","started","topics","Map","peers","_registrarId","undefined","_onIncomingStream","bind","_onPeerConnected","_onPeerDisconnected","start","topology","handlers","onConnect","onDisconnect","stop","forEach","peer","close","protocol","stream","connection","remotePeer","idB58Str","toB58String","_addPeer","_processMessages","conn","newStream","attachConnection","get","_removePeer","protocols","id","existing","set","once","delete","validate","signature","_buildMessage","msg","normalizeOutRpcMessage","getSubscribers","topic","Array","from","values","filter","has","map","publish","messages","subscribe","unsubscribe","getTopics","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst EventEmitter = require('events')\nconst errcode = require('err-code')\n\nconst PeerId = require('peer-id')\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst message = require('./message')\nconst Peer = require('./peer')\nconst utils = require('./utils')\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign')\n\nfunction validateRegistrar (registrar) {\n  // registrar handling\n  if (typeof registrar !== 'object') {\n    throw new Error('a registrar object is required')\n  }\n\n  if (typeof registrar.handle !== 'function') {\n    throw new Error('a handle function must be provided in registrar')\n  }\n\n  if (typeof registrar.register !== 'function') {\n    throw new Error('a register function must be provided in registrar')\n  }\n\n  if (typeof registrar.unregister !== 'function') {\n    throw new Error('a unregister function must be provided in registrar')\n  }\n}\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {PeerId} props.peerId peer's peerId\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {boolean} [props.signMessages] if messages should be signed, defaults to true\n   * @param {boolean} [props.strictSigning] if message signing should be required, defaults to true\n   * @abstract\n   */\n  constructor ({\n    debugName,\n    multicodecs,\n    peerId,\n    registrar,\n    signMessages = true,\n    strictSigning = true\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required')\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required')\n    }\n\n    if (!PeerId.isPeerId(peerId)) {\n      throw new Error('peerId must be an instance of `peer-id`')\n    }\n\n    validateRegistrar(registrar)\n\n    super()\n\n    this.log = debug(debugName)\n    this.log.err = debug(`${debugName}:error`)\n\n    this.multicodecs = utils.ensureArray(multicodecs)\n    this.registrar = registrar\n\n    this.started = false\n\n    this.peerId = peerId\n\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.topics = new Map()\n\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n    this.peers = new Map()\n\n    // Message signing\n    this.signMessages = signMessages\n\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n    this.strictSigning = strictSigning\n\n    this._registrarId = undefined\n    this._onIncomingStream = this._onIncomingStream.bind(this)\n    this._onPeerConnected = this._onPeerConnected.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n  }\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {Promise<void>}\n   */\n  async start () {\n    if (this.started) {\n      return\n    }\n    this.log('starting')\n\n    // Incoming streams\n    this.registrar.handle(this.multicodecs, this._onIncomingStream)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    })\n    this._registrarId = await this.registrar.register(topology)\n\n    this.log('started')\n    this.started = true\n  }\n\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   * @returns {Promise}\n   */\n  async stop () {\n    if (!this.started) {\n      return\n    }\n\n    // unregister protocol and handlers\n    await this.registrar.unregister(this._registrarId)\n\n    this.log('stopping')\n    this.peers.forEach((peer) => peer.close())\n\n    this.peers = new Map()\n    this.started = false\n    this.log('stopped')\n  }\n\n  /**\n   * On an incoming stream event.\n   * @private\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {DuplexStream} props.strean\n   * @param {Connection} props.connection connection\n   */\n  _onIncomingStream ({ protocol, stream, connection }) {\n    const peerId = connection.remotePeer\n    const idB58Str = peerId.toB58String()\n    const peer = this._addPeer(peerId, [protocol])\n\n    this._processMessages(idB58Str, stream, peer)\n  }\n\n  /**\n   * Registrar notifies a connection successfully with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId remote peer-id\n   * @param {Connection} conn connection to the peer\n   */\n  async _onPeerConnected (peerId, conn) {\n    const idB58Str = peerId.toB58String()\n    this.log('connected', idB58Str)\n\n    const peer = this._addPeer(peerId, this.multicodecs)\n\n    try {\n      const { stream } = await conn.newStream(this.multicodecs)\n      peer.attachConnection(stream)\n    } catch (err) {\n      this.log.err(err)\n    }\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   * @private\n   * @param {PeerId} peerId peerId\n   * @param {Error} err error for connection end\n   */\n  _onPeerDisconnected (peerId, err) {\n    const idB58Str = peerId.toB58String()\n    const peer = this.peers.get(idB58Str)\n\n    this.log('connection ended', idB58Str, err ? err.message : '')\n    this._removePeer(peer)\n  }\n\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerId} peerId\n   * @param {Array<string>} protocols\n   * @returns {Peer}\n   */\n  _addPeer (peerId, protocols) {\n    const id = peerId.toB58String()\n    let existing = this.peers.get(id)\n\n    if (!existing) {\n      this.log('new peer', id)\n\n      const peer = new Peer({\n        id: peerId,\n        protocols\n      })\n\n      this.peers.set(id, peer)\n      existing = peer\n\n      peer.once('close', () => this._removePeer(peer))\n    }\n\n    return existing\n  }\n\n  /**\n   * Remove a peer from the peers map.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {Peer}\n   */\n  _removePeer (peer) {\n    if (!peer) return\n    const id = peer.id.toB58String()\n\n    this.log('delete peer', id)\n    this.peers.delete(id)\n\n    return peer\n  }\n\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * @param {rpc.RPC.Message} message\n   * @returns {Promise<Boolean>}\n   */\n  async validate (message) { // eslint-disable-line require-await\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      this.log('Signing required and no signature was present, dropping message:', message)\n      return false\n    }\n\n    // Check the message signature if present\n    if (message.signature) {\n      return verifySignature(message)\n    } else {\n      return true\n    }\n  }\n\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   * @private\n   * @param {Message} message\n   * @returns {Promise<Message>}\n   */\n  _buildMessage (message) {\n    const msg = utils.normalizeOutRpcMessage(message)\n    if (this.signMessages) {\n      return signMessage(this.peerId, msg)\n    } else {\n      return message\n    }\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n  getSubscribers (topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET')\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC')\n    }\n\n    return Array.from(this.peers.values())\n      .filter((peer) => peer.topics.has(topic))\n      .map((peer) => peer.id.toB58String())\n  }\n\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @returns {Promise}\n   *\n   */\n  publish (topics, messages) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  subscribe (topics) {\n    throw errcode(new Error('subscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n  unsubscribe (topics) {\n    throw errcode(new Error('unsubscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of getTopics should handle the appropriate algorithms for the publish/subscriber implementation.\n   * Get the list of subscriptions the peer is subscribed to.\n   * @abstract\n   * @returns {Array<string>}\n   */\n  getTopics () {\n    throw errcode(new Error('getTopics must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n\n  /**\n   * Overriding the implementation of _processMessages should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {Peer} peer A Pubsub Peer\n   * @returns {void}\n   *\n   */\n  _processMessages (idB58Str, conn, peer) {\n    throw errcode(new Error('_processMessages must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')\n  }\n}\n\nmodule.exports = PubsubBaseProtocol\nmodule.exports.message = message\nmodule.exports.utils = utils\n"]},"metadata":{},"sourceType":"script"}