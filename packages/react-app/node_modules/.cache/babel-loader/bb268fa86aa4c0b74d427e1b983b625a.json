{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst extractDataFromBlock = require('../utils/extract-data-from-block');\n\nconst validateOffsetAndLength = require('../utils/validate-offset-and-length');\n\nconst mh = require('multihashing-async').multihash;\n\nconst rawContent = node => {\n  return function* (options = {}) {\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(node.length, options.offset, options.length);\n    yield extractDataFromBlock(node, 0, offset, offset + length);\n  };\n};\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, ipld, options) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), 'ERR_NOT_FOUND');\n  }\n\n  const buf = await mh.decode(cid.multihash);\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node: buf,\n      content: rawContent(buf.digest),\n      depth\n    }\n  };\n};\n\nmodule.exports = resolve;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs-exporter/src/resolvers/identity.js"],"names":["errCode","require","extractDataFromBlock","validateOffsetAndLength","mh","multihash","rawContent","node","options","offset","length","resolve","cid","name","path","toResolve","depth","ipld","Error","toBaseEncodedString","buf","decode","entry","content","digest","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,kCAAD,CAApC;;AACA,MAAME,uBAAuB,GAAGF,OAAO,CAAC,qCAAD,CAAvC;;AACA,MAAMG,EAAE,GAAGH,OAAO,CAAC,oBAAD,CAAP,CAA8BI,SAAzC;;AAEA,MAAMC,UAAU,GAAIC,IAAD,IAAU;AAC3B,SAAO,WAAYC,OAAO,GAAG,EAAtB,EAA0B;AAC/B,UAAM;AACJC,MAAAA,MADI;AAEJC,MAAAA;AAFI,QAGFP,uBAAuB,CAACI,IAAI,CAACG,MAAN,EAAcF,OAAO,CAACC,MAAtB,EAA8BD,OAAO,CAACE,MAAtC,CAH3B;AAKA,UAAMR,oBAAoB,CAACK,IAAD,EAAO,CAAP,EAAUE,MAAV,EAAkBA,MAAM,GAAGC,MAA3B,CAA1B;AACD,GAPD;AAQD,CATD;;AAWA,MAAMC,OAAO,GAAG,OAAOC,GAAP,EAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCJ,OAAnC,EAA4CK,KAA5C,EAAmDC,IAAnD,EAAyDT,OAAzD,KAAqE;AACnF,MAAIO,SAAS,CAACL,MAAd,EAAsB;AACpB,UAAMV,OAAO,CAAC,IAAIkB,KAAJ,CAAW,iBAAgBJ,IAAK,sBAAqBF,GAAG,CAACO,mBAAJ,EAA0B,EAA/E,CAAD,EAAoF,eAApF,CAAb;AACD;;AAED,QAAMC,GAAG,GAAG,MAAMhB,EAAE,CAACiB,MAAH,CAAUT,GAAG,CAACP,SAAd,CAAlB;AAEA,SAAO;AACLiB,IAAAA,KAAK,EAAE;AACLT,MAAAA,IADK;AAELC,MAAAA,IAFK;AAGLF,MAAAA,GAHK;AAILL,MAAAA,IAAI,EAAEa,GAJD;AAKLG,MAAAA,OAAO,EAAEjB,UAAU,CAACc,GAAG,CAACI,MAAL,CALd;AAMLR,MAAAA;AANK;AADF,GAAP;AAUD,CAjBD;;AAmBAS,MAAM,CAACC,OAAP,GAAiBf,OAAjB","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst extractDataFromBlock = require('../utils/extract-data-from-block')\nconst validateOffsetAndLength = require('../utils/validate-offset-and-length')\nconst mh = require('multihashing-async').multihash\n\nconst rawContent = (node) => {\n  return function * (options = {}) {\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    yield extractDataFromBlock(node, 0, offset, offset + length)\n  }\n}\n\nconst resolve = async (cid, name, path, toResolve, resolve, depth, ipld, options) => {\n  if (toResolve.length) {\n    throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), 'ERR_NOT_FOUND')\n  }\n\n  const buf = await mh.decode(cid.multihash)\n\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node: buf,\n      content: rawContent(buf.digest),\n      depth\n    }\n  }\n}\n\nmodule.exports = resolve\n"]},"metadata":{},"sourceType":"script"}