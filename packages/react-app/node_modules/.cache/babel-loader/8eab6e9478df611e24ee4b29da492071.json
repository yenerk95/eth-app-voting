{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar Key = require('interface-datastore').Key;\n\nvar debug = require('debug');\n\nvar log = debug('repo:version');\nvar versionKey = new Key('version');\n\nmodule.exports = function (store) {\n  return {\n    /**\n     * Check if a version file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    exists: function exists() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", store.has(versionKey));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n\n    /**\n     * Get the current version.\n     *\n     * @returns {Promise<Integer>}\n     */\n    get: function get() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buf;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return store.get(versionKey);\n\n              case 2:\n                buf = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(buf.toString().trim(), 10));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n\n    /**\n     * Set the version of the repo, writing it to the underlying store.\n     *\n     * @param {number} version\n     * @returns {Promise<void>}\n     */\n    set: function set(version) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", store.put(versionKey, Buffer.from(String(version))));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Check the current version, and returns true if versions matches\n     * @param {number} expected\n     * @returns {boolean}\n     */\n    check: function check(expected) {\n      var _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var version, compatibleVersion;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return _this.get();\n\n              case 2:\n                version = _context4.sent;\n                log('comparing version: %s and %s', version, expected); // Version 6 and 7 are the same\n                // TODO: Clean up the compatibility logic. Repo feature detection would be ideal, or a better version schema\n\n                compatibleVersion = version === 6 && expected === 7 || expected === 6 && version === 7;\n                return _context4.abrupt(\"return\", version === expected || compatibleVersion);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo/src/version.js"],"names":["require","Buffer","Key","debug","log","versionKey","module","exports","store","exists","has","get","buf","parseInt","toString","trim","set","version","put","from","String","check","expected","compatibleVersion"],"mappings":"AAAA;;;;;;eAEmBA,OAAO,CAAC,QAAD,C;IAAlBC,M,YAAAA,M;;AACR,IAAMC,GAAG,GAAGF,OAAO,CAAC,qBAAD,CAAP,CAA+BE,GAA3C;;AACA,IAAMC,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,IAAMI,GAAG,GAAGD,KAAK,CAAC,cAAD,CAAjB;AAEA,IAAME,UAAU,GAAG,IAAIH,GAAJ,CAAQ,SAAR,CAAnB;;AAEAI,MAAM,CAACC,OAAP,GAAiB,UAACC,KAAD,EAAW;AAC1B,SAAO;AACL;;;;;AAKMC,IAAAA,MAND,oBAMW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iDACPD,KAAK,CAACE,GAAN,CAAUL,UAAV,CADO;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEf,KARI;;AASL;;;;;AAKMM,IAAAA,GAdD,iBAcQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACOH,KAAK,CAACG,GAAN,CAAUN,UAAV,CADP;;AAAA;AACLO,gBAAAA,GADK;AAAA,kDAEJC,QAAQ,CAACD,GAAG,CAACE,QAAJ,GAAeC,IAAf,EAAD,EAAwB,EAAxB,CAFJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGZ,KAjBI;;AAkBL;;;;;;AAMMC,IAAAA,GAxBD,eAwBMC,OAxBN,EAwBe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kDACXT,KAAK,CAACU,GAAN,CAAUb,UAAV,EAAsBJ,MAAM,CAACkB,IAAP,CAAYC,MAAM,CAACH,OAAD,CAAlB,CAAtB,CADW;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEnB,KA1BI;;AA2BL;;;;;AAKMI,IAAAA,KAhCD,iBAgCQC,QAhCR,EAgCkB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACC,KAAI,CAACX,GAAL,EADD;;AAAA;AACfM,gBAAAA,OADe;AAErBb,gBAAAA,GAAG,CAAC,8BAAD,EAAiCa,OAAjC,EAA0CK,QAA1C,CAAH,CAFqB,CAGrB;AACA;;AACMC,gBAAAA,iBALe,GAKMN,OAAO,KAAK,CAAZ,IAAiBK,QAAQ,KAAK,CAA/B,IAAsCA,QAAQ,KAAK,CAAb,IAAkBL,OAAO,KAAK,CALzE;AAAA,kDAOdA,OAAO,KAAKK,QAAZ,IAAwBC,iBAPV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQtB;AAxCI,GAAP;AA0CD,CA3CD","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Key = require('interface-datastore').Key\nconst debug = require('debug')\nconst log = debug('repo:version')\n\nconst versionKey = new Key('version')\n\nmodule.exports = (store) => {\n  return {\n    /**\n     * Check if a version file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    async exists () { // eslint-disable-line require-await\n      return store.has(versionKey)\n    },\n    /**\n     * Get the current version.\n     *\n     * @returns {Promise<Integer>}\n     */\n    async get () {\n      const buf = await store.get(versionKey)\n      return parseInt(buf.toString().trim(), 10)\n    },\n    /**\n     * Set the version of the repo, writing it to the underlying store.\n     *\n     * @param {number} version\n     * @returns {Promise<void>}\n     */\n    async set (version) { // eslint-disable-line require-await\n      return store.put(versionKey, Buffer.from(String(version)))\n    },\n    /**\n     * Check the current version, and returns true if versions matches\n     * @param {number} expected\n     * @returns {boolean}\n     */\n    async check (expected) {\n      const version = await this.get()\n      log('comparing version: %s and %s', version, expected)\n      // Version 6 and 7 are the same\n      // TODO: Clean up the compatibility logic. Repo feature detection would be ideal, or a better version schema\n      const compatibleVersion = (version === 6 && expected === 7) || (expected === 6 && version === 7)\n\n      return version === expected || compatibleVersion\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}