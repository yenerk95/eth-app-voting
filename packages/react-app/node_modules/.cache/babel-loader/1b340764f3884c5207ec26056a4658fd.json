{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst multiaddr = require('multiaddr');\n\nconst withIs = require('class-is');\n\nconst errCode = require('err-code');\n\nconst Status = require('./status');\n\nfunction validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n}\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\n\n\nclass Connection {\n  /**\n   * Creates an instance of Connection.\n   * @param {object} properties properties of the connection.\n   * @param {multiaddr} [properties.localAddr] local multiaddr of the connection if known.\n   * @param {multiaddr} [properties.remoteAddr] remote multiaddr of the connection.\n   * @param {PeerId} properties.localPeer local peer-id.\n   * @param {PeerId} properties.remotePeer remote peer-id.\n   * @param {function} properties.newStream new stream muxer function.\n   * @param {function} properties.close close raw connection function.\n   * @param {function} properties.getStreams get streams from muxer function.\n   * @param {object} properties.stat metadata of the connection.\n   * @param {string} properties.stat.direction connection establishment direction (\"inbound\" or \"outbound\").\n   * @param {object} properties.stat.timeline connection relevant events timestamp.\n   * @param {string} properties.stat.timeline.open connection opening timestamp.\n   * @param {string} properties.stat.timeline.upgraded connection upgraded timestamp.\n   * @param {string} [properties.stat.multiplexer] connection multiplexing identifier.\n   * @param {string} [properties.stat.encryption] connection encryption method identifier.\n   */\n  constructor({\n    localAddr,\n    remoteAddr,\n    localPeer,\n    remotePeer,\n    newStream,\n    close,\n    getStreams,\n    stat\n  }) {\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);\n    /**\n     * Connection identifier.\n     */\n\n    this.id = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n    /**\n     * Observed multiaddr of the local peer\n     */\n\n    this.localAddr = localAddr;\n    /**\n     * Observed multiaddr of the remote peer\n     */\n\n    this.remoteAddr = remoteAddr;\n    /**\n     * Local peer id.\n     */\n\n    this.localPeer = localPeer;\n    /**\n     * Remote peer id.\n     */\n\n    this.remotePeer = remotePeer;\n    /**\n     * Connection metadata.\n     */\n\n    this._stat = { ...stat,\n      status: Status.OPEN\n    };\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n\n    this._newStream = newStream;\n    /**\n     * Reference to the close function of the raw connection\n     */\n\n    this._close = close;\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n\n    this._getStreams = getStreams;\n    /**\n     * Connection streams registry\n     */\n\n    this.registry = new Map();\n    /**\n     * User provided tags\n     */\n\n    this.tags = [];\n  }\n  /**\n   * Get connection metadata\n   * @return {Object}\n   */\n\n\n  get stat() {\n    return this._stat;\n  }\n  /**\n   * Get all the streams of the muxer.\n   * @return {Array<*>}\n   */\n\n\n  get streams() {\n    return this._getStreams();\n  }\n  /**\n   * Create a new stream from this connection\n   * @param {string[]} protocols intended protocol for the stream\n   * @return {Promise<object>} with muxed+multistream-selected stream and selected protocol\n   */\n\n\n  async newStream(protocols) {\n    if (this.stat.status === Status.CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');\n    }\n\n    if (this.stat.status === Status.CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');\n    }\n\n    if (!Array.isArray(protocols)) protocols = [protocols];\n    const {\n      stream,\n      protocol\n    } = await this._newStream(protocols);\n    this.addStream(stream, {\n      protocol\n    });\n    return {\n      stream,\n      protocol\n    };\n  }\n  /**\n   * Add a stream when it is opened to the registry.\n   * @param {*} muxedStream a muxed stream\n   * @param {object} properties the stream properties to be registered\n   * @param {string} properties.protocol the protocol used by the stream\n   * @param {object} properties.metadata metadata of the stream\n   * @return {void}\n   */\n\n\n  addStream(muxedStream, {\n    protocol,\n    metadata = {}\n  }) {\n    // Add metadata for the stream\n    this.registry.set(muxedStream.id, {\n      protocol,\n      ...metadata\n    });\n  }\n  /**\n   * Remove stream registry after it is closed.\n   * @param {string} id identifier of the stream\n   */\n\n\n  removeStream(id) {\n    this.registry.delete(id);\n  }\n  /**\n   * Close the connection.\n   * @return {Promise}\n   */\n\n\n  async close() {\n    if (this.stat.status === Status.CLOSED) {\n      return;\n    }\n\n    if (this._closing) {\n      return this._closing;\n    }\n\n    this.stat.status = Status.CLOSING; // Close raw connection\n\n    this._closing = await this._close();\n    this._stat.timeline.close = Date.now();\n    this.stat.status = Status.CLOSED;\n  }\n\n}\n\nmodule.exports = withIs(Connection, {\n  className: 'Connection',\n  symbolName: '@libp2p/interface-connection/connection'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-interfaces/src/connection/connection.js"],"names":["PeerId","require","multiaddr","withIs","errCode","Status","validateArgs","localAddr","localPeer","remotePeer","newStream","close","getStreams","stat","isMultiaddr","Error","isPeerId","direction","timeline","open","upgraded","Connection","constructor","remoteAddr","id","parseInt","Math","random","toString","Date","now","_stat","status","OPEN","_newStream","_close","_getStreams","registry","Map","tags","streams","protocols","CLOSING","CLOSED","Array","isArray","stream","protocol","addStream","muxedStream","metadata","set","removeStream","delete","_closing","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst withIs = require('class-is')\nconst errCode = require('err-code')\nconst Status = require('./status')\n\nfunction validateArgs (localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS')\n  }\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nclass Connection {\n  /**\n   * Creates an instance of Connection.\n   * @param {object} properties properties of the connection.\n   * @param {multiaddr} [properties.localAddr] local multiaddr of the connection if known.\n   * @param {multiaddr} [properties.remoteAddr] remote multiaddr of the connection.\n   * @param {PeerId} properties.localPeer local peer-id.\n   * @param {PeerId} properties.remotePeer remote peer-id.\n   * @param {function} properties.newStream new stream muxer function.\n   * @param {function} properties.close close raw connection function.\n   * @param {function} properties.getStreams get streams from muxer function.\n   * @param {object} properties.stat metadata of the connection.\n   * @param {string} properties.stat.direction connection establishment direction (\"inbound\" or \"outbound\").\n   * @param {object} properties.stat.timeline connection relevant events timestamp.\n   * @param {string} properties.stat.timeline.open connection opening timestamp.\n   * @param {string} properties.stat.timeline.upgraded connection upgraded timestamp.\n   * @param {string} [properties.stat.multiplexer] connection multiplexing identifier.\n   * @param {string} [properties.stat.encryption] connection encryption method identifier.\n   */\n  constructor ({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat)\n\n    /**\n     * Connection identifier.\n     */\n    this.id = (parseInt(Math.random() * 1e9)).toString(36) + Date.now()\n\n    /**\n     * Observed multiaddr of the local peer\n     */\n    this.localAddr = localAddr\n\n    /**\n     * Observed multiaddr of the remote peer\n     */\n    this.remoteAddr = remoteAddr\n\n    /**\n     * Local peer id.\n     */\n    this.localPeer = localPeer\n\n    /**\n     * Remote peer id.\n     */\n    this.remotePeer = remotePeer\n\n    /**\n     * Connection metadata.\n     */\n    this._stat = {\n      ...stat,\n      status: Status.OPEN\n    }\n\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n    this._newStream = newStream\n\n    /**\n     * Reference to the close function of the raw connection\n     */\n    this._close = close\n\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n    this._getStreams = getStreams\n\n    /**\n     * Connection streams registry\n     */\n    this.registry = new Map()\n\n    /**\n     * User provided tags\n     */\n    this.tags = []\n  }\n\n  /**\n   * Get connection metadata\n   * @return {Object}\n   */\n  get stat () {\n    return this._stat\n  }\n\n  /**\n   * Get all the streams of the muxer.\n   * @return {Array<*>}\n   */\n  get streams () {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   * @param {string[]} protocols intended protocol for the stream\n   * @return {Promise<object>} with muxed+multistream-selected stream and selected protocol\n   */\n  async newStream (protocols) {\n    if (this.stat.status === Status.CLOSING) {\n      throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.stat.status === Status.CLOSED) {\n      throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) protocols = [protocols]\n\n    const { stream, protocol } = await this._newStream(protocols)\n\n    this.addStream(stream, { protocol })\n\n    return {\n      stream,\n      protocol\n    }\n  }\n\n  /**\n   * Add a stream when it is opened to the registry.\n   * @param {*} muxedStream a muxed stream\n   * @param {object} properties the stream properties to be registered\n   * @param {string} properties.protocol the protocol used by the stream\n   * @param {object} properties.metadata metadata of the stream\n   * @return {void}\n   */\n  addStream (muxedStream, { protocol, metadata = {} }) {\n    // Add metadata for the stream\n    this.registry.set(muxedStream.id, {\n      protocol,\n      ...metadata\n    })\n  }\n\n  /**\n   * Remove stream registry after it is closed.\n   * @param {string} id identifier of the stream\n   */\n  removeStream (id) {\n    this.registry.delete(id)\n  }\n\n  /**\n   * Close the connection.\n   * @return {Promise}\n   */\n  async close () {\n    if (this.stat.status === Status.CLOSED) {\n      return\n    }\n\n    if (this._closing) {\n      return this._closing\n    }\n\n    this.stat.status = Status.CLOSING\n\n    // Close raw connection\n    this._closing = await this._close()\n\n    this._stat.timeline.close = Date.now()\n    this.stat.status = Status.CLOSED\n  }\n}\n\nmodule.exports = withIs(Connection, { className: 'Connection', symbolName: '@libp2p/interface-connection/connection' })\n"]},"metadata":{},"sourceType":"script"}