{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _get = require('just-safe-get');\n\nvar debug = require('debug');\n\nvar Big = require('bignumber.js');\n\nvar errcode = require('err-code');\n\nvar migrator = require('ipfs-repo-migrations');\n\nvar bytes = require('bytes');\n\nvar pathJoin = require('ipfs-utils/src/path-join');\n\nvar constants = require('./constants');\n\nvar backends = require('./backends');\n\nvar version = require('./version');\n\nvar config = require('./config');\n\nvar spec = require('./spec');\n\nvar apiAddr = require('./api-addr');\n\nvar blockstore = require('./blockstore');\n\nvar defaultOptions = require('./default-options');\n\nvar defaultDatastore = require('./default-datastore');\n\nvar ERRORS = require('./errors');\n\nvar log = debug('repo');\nvar noLimit = Number.MAX_SAFE_INTEGER;\nvar AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\nvar lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\nvar IpfsRepo = /*#__PURE__*/function () {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  function IpfsRepo(repoPath, options) {\n    _classCallCheck(this, IpfsRepo);\n\n    if (typeof repoPath !== 'string') {\n      throw new Error('missing repoPath');\n    }\n\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(IpfsRepo, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(config) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('initializing at: %s', this.path);\n                _context.next = 3;\n                return this._openRoot();\n\n              case 3:\n                _context.next = 5;\n                return this.config.set(buildConfig(config));\n\n              case 5:\n                _context.next = 7;\n                return this.spec.set(buildDatastoreSpec(config));\n\n              case 7:\n                _context.next = 9;\n                return this.version.set(constants.repoVersion);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * Check if the repo is already initialized.\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"isInitialized\",\n    value: function () {\n      var _isInitialized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.closed) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", true);\n\n              case 2:\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this._openRoot();\n\n              case 5:\n                _context2.next = 7;\n                return this._checkInitialized();\n\n              case 7:\n                _context2.next = 9;\n                return this.root.close();\n\n              case 9:\n                return _context2.abrupt(\"return\", true);\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](2);\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 12]]);\n      }));\n\n      function isInitialized() {\n        return _isInitialized.apply(this, arguments);\n      }\n\n      return isInitialized;\n    }()\n    /**\n     * Open the repo. If the repo is already open an error will be thrown.\n     * If the repo is not initialized it will throw an error.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var blocksBaseStore, isCompatible;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n\n              case 2:\n                log('opening at: %s', this.path); // check if the repo is already initialized\n\n                _context3.prev = 3;\n                _context3.next = 6;\n                return this._openRoot();\n\n              case 6:\n                _context3.next = 8;\n                return this._checkInitialized();\n\n              case 8:\n                _context3.next = 10;\n                return this._openLock(this.path);\n\n              case 10:\n                this.lockfile = _context3.sent;\n                log('acquired repo.lock');\n                log('creating datastore');\n                this.datastore = backends.create('datastore', pathJoin(this.path, 'datastore'), this.options);\n                _context3.next = 16;\n                return this.datastore.open();\n\n              case 16:\n                log('creating blocks');\n                blocksBaseStore = backends.create('blocks', pathJoin(this.path, 'blocks'), this.options);\n                _context3.next = 20;\n                return blocksBaseStore.open();\n\n              case 20:\n                _context3.next = 22;\n                return blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks);\n\n              case 22:\n                this.blocks = _context3.sent;\n                log('creating keystore');\n                this.keys = backends.create('keys', pathJoin(this.path, 'keys'), this.options);\n                _context3.next = 27;\n                return this.keys.open();\n\n              case 27:\n                _context3.next = 29;\n                return this.version.check(constants.repoVersion);\n\n              case 29:\n                isCompatible = _context3.sent;\n\n                if (isCompatible) {\n                  _context3.next = 39;\n                  break;\n                }\n\n                _context3.next = 33;\n                return this._isAutoMigrationEnabled();\n\n              case 33:\n                if (!_context3.sent) {\n                  _context3.next = 38;\n                  break;\n                }\n\n                _context3.next = 36;\n                return this._migrate(constants.repoVersion);\n\n              case 36:\n                _context3.next = 39;\n                break;\n\n              case 38:\n                throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n\n              case 39:\n                this.closed = false;\n                log('all opened');\n                _context3.next = 56;\n                break;\n\n              case 43:\n                _context3.prev = 43;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                if (!this.lockfile) {\n                  _context3.next = 55;\n                  break;\n                }\n\n                _context3.prev = 46;\n                _context3.next = 49;\n                return this._closeLock();\n\n              case 49:\n                this.lockfile = null;\n                _context3.next = 55;\n                break;\n\n              case 52:\n                _context3.prev = 52;\n                _context3.t1 = _context3[\"catch\"](46);\n                log('error removing lock', _context3.t1);\n\n              case 55:\n                throw _context3.t0;\n\n              case 56:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 43], [46, 52]]);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Returns the repo locker to be used. Null will be returned if no locker is requested\n     *\n     * @private\n     * @returns {Locker}\n     */\n\n  }, {\n    key: \"_getLocker\",\n    value: function _getLocker() {\n      if (typeof this.options.lock === 'string') {\n        if (!lockers[this.options.lock]) {\n          throw new Error('Unknown lock type: ' + this.options.lock);\n        }\n\n        return lockers[this.options.lock];\n      }\n\n      if (!this.options.lock) {\n        throw new Error('No lock provided');\n      }\n\n      return this.options.lock;\n    }\n    /**\n     * Opens the root backend, catching and ignoring an 'Already open' error\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_openRoot\",\n    value: function () {\n      var _openRoot2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return this.root.open();\n\n              case 3:\n                _context4.next = 9;\n                break;\n\n              case 5:\n                _context4.prev = 5;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                if (!(_context4.t0.message !== 'Already open')) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw _context4.t0;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 5]]);\n      }));\n\n      function _openRoot() {\n        return _openRoot2.apply(this, arguments);\n      }\n\n      return _openRoot;\n    }()\n    /**\n     * Creates a lock on the repo if a locker is specified. The lockfile object will\n     * be returned in the callback if one has been created.\n     *\n     * @param {string} path\n     * @returns {Promise<lockfile>}\n     */\n\n  }, {\n    key: \"_openLock\",\n    value: function () {\n      var _openLock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(path) {\n        var lockfile;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._locker.lock(path);\n\n              case 2:\n                lockfile = _context5.sent;\n\n                if (!(typeof lockfile.close !== 'function')) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n\n              case 5:\n                return _context5.abrupt(\"return\", lockfile);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _openLock(_x2) {\n        return _openLock2.apply(this, arguments);\n      }\n\n      return _openLock;\n    }()\n    /**\n     * Closes the lock on the repo\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_closeLock\",\n    value: function _closeLock() {\n      return this.lockfile.close();\n    }\n    /**\n     * Check if the repo is already initialized.\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_checkInitialized\",\n    value: function () {\n      var _checkInitialized2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var config, _yield$Promise$all, _yield$Promise$all2;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                log('init check');\n                _context6.prev = 1;\n                _context6.next = 4;\n                return Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n\n              case 4:\n                _yield$Promise$all = _context6.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 1);\n                config = _yield$Promise$all2[0];\n                _context6.next = 14;\n                break;\n\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](1);\n\n                if (!(_context6.t0.code === 'ERR_NOT_FOUND')) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 13:\n                throw _context6.t0;\n\n              case 14:\n                if (config) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 9]]);\n      }));\n\n      function _checkInitialized() {\n        return _checkInitialized2.apply(this, arguments);\n      }\n\n      return _checkInitialized;\n    }()\n    /**\n     * Close the repo and cleanup.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!this.closed) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n\n              case 2:\n                log('closing at: %s', this.path);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return this.apiAddr.delete();\n\n              case 6:\n                _context7.next = 12;\n                break;\n\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](3);\n\n                if (!(_context7.t0.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !_context7.t0.message.startsWith('ENOENT'))) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                throw _context7.t0;\n\n              case 12:\n                _context7.next = 14;\n                return Promise.all([this.root, this.blocks, this.keys, this.datastore].map(function (store) {\n                  return store.close();\n                }));\n\n              case 14:\n                log('unlocking');\n                this.closed = true;\n                _context7.next = 18;\n                return this._closeLock();\n\n              case 18:\n                this.lockfile = null;\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[3, 8]]);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Check if a repo exists.\n     *\n     * @returns {Promise<bool>}\n     */\n\n  }, {\n    key: \"exists\",\n    value: function () {\n      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this.version.exists());\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function exists() {\n        return _exists.apply(this, arguments);\n      }\n\n      return exists;\n    }()\n    /**\n     * Get repo status.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _yield$Promise$all3, _yield$Promise$all4, storageMax, blocks, version, datastore, keys, size;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n\n              case 2:\n                _yield$Promise$all3 = _context9.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 5);\n                storageMax = _yield$Promise$all4[0];\n                blocks = _yield$Promise$all4[1];\n                version = _yield$Promise$all4[2];\n                datastore = _yield$Promise$all4[3];\n                keys = _yield$Promise$all4[4];\n                size = blocks.size.plus(datastore).plus(keys);\n                return _context9.abrupt(\"return\", {\n                  repoPath: this.path,\n                  storageMax: storageMax,\n                  version: version,\n                  numObjects: blocks.count,\n                  repoSize: size\n                });\n\n              case 11:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function stat() {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n  }, {\n    key: \"_isAutoMigrationEnabled\",\n    value: function () {\n      var _isAutoMigrationEnabled2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var autoMigrateConfig;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(this.options.autoMigrate !== undefined)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.options.autoMigrate);\n\n              case 2:\n                _context10.prev = 2;\n                _context10.next = 5;\n                return this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n\n              case 5:\n                autoMigrateConfig = _context10.sent;\n                _context10.next = 15;\n                break;\n\n              case 8:\n                _context10.prev = 8;\n                _context10.t0 = _context10[\"catch\"](2);\n\n                if (!(_context10.t0.code === ERRORS.NotFoundError.code)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                autoMigrateConfig = true; // Config's default value is True\n\n                _context10.next = 15;\n                break;\n\n              case 14:\n                throw _context10.t0;\n\n              case 15:\n                return _context10.abrupt(\"return\", autoMigrateConfig);\n\n              case 16:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 8]]);\n      }));\n\n      function _isAutoMigrationEnabled() {\n        return _isAutoMigrationEnabled2.apply(this, arguments);\n      }\n\n      return _isAutoMigrationEnabled;\n    }()\n  }, {\n    key: \"_migrate\",\n    value: function () {\n      var _migrate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(toVersion) {\n        var currentRepoVersion;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.version.get();\n\n              case 2:\n                currentRepoVersion = _context11.sent;\n\n                if (!(currentRepoVersion > toVersion)) {\n                  _context11.next = 8;\n                  break;\n                }\n\n                log('reverting to version ' + toVersion);\n                return _context11.abrupt(\"return\", migrator.revert(this.path, toVersion, {\n                  ignoreLock: true,\n                  repoOptions: this.options\n                }));\n\n              case 8:\n                log('migrating to version ' + toVersion);\n                return _context11.abrupt(\"return\", migrator.migrate(this.path, toVersion, {\n                  ignoreLock: true,\n                  repoOptions: this.options\n                }));\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _migrate(_x3) {\n        return _migrate2.apply(this, arguments);\n      }\n\n      return _migrate;\n    }()\n  }, {\n    key: \"_storageMaxStat\",\n    value: function () {\n      var _storageMaxStat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var max;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return this.config.get('Datastore.StorageMax');\n\n              case 3:\n                max = _context12.sent;\n                return _context12.abrupt(\"return\", new Big(bytes(max)));\n\n              case 7:\n                _context12.prev = 7;\n                _context12.t0 = _context12[\"catch\"](0);\n                return _context12.abrupt(\"return\", new Big(noLimit));\n\n              case 10:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 7]]);\n      }));\n\n      function _storageMaxStat() {\n        return _storageMaxStat2.apply(this, arguments);\n      }\n\n      return _storageMaxStat;\n    }()\n  }, {\n    key: \"_blockStat\",\n    value: function () {\n      var _blockStat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var count, size, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, block;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                count = new Big(0);\n                size = new Big(0);\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context13.prev = 4;\n                _iterator = _asyncIterator(this.blocks.query({}));\n\n              case 6:\n                _context13.next = 8;\n                return _iterator.next();\n\n              case 8:\n                _step = _context13.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context13.next = 12;\n                return _step.value;\n\n              case 12:\n                _value = _context13.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context13.next = 20;\n                  break;\n                }\n\n                block = _value;\n                count = count.plus(1);\n                size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n\n              case 17:\n                _iteratorNormalCompletion = true;\n                _context13.next = 6;\n                break;\n\n              case 20:\n                _context13.next = 26;\n                break;\n\n              case 22:\n                _context13.prev = 22;\n                _context13.t0 = _context13[\"catch\"](4);\n                _didIteratorError = true;\n                _iteratorError = _context13.t0;\n\n              case 26:\n                _context13.prev = 26;\n                _context13.prev = 27;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context13.next = 31;\n                  break;\n                }\n\n                _context13.next = 31;\n                return _iterator.return();\n\n              case 31:\n                _context13.prev = 31;\n\n                if (!_didIteratorError) {\n                  _context13.next = 34;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 34:\n                return _context13.finish(31);\n\n              case 35:\n                return _context13.finish(26);\n\n              case 36:\n                return _context13.abrupt(\"return\", {\n                  count: count,\n                  size: size\n                });\n\n              case 37:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[4, 22, 26, 36], [27,, 31, 35]]);\n      }));\n\n      function _blockStat() {\n        return _blockStat2.apply(this, arguments);\n      }\n\n      return _blockStat;\n    }()\n  }]);\n\n  return IpfsRepo;\n}();\n\nfunction getSize(_x4) {\n  return _getSize.apply(this, arguments);\n}\n\nfunction _getSize() {\n  _getSize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(queryFn) {\n    var sum, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, block;\n\n    return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            sum = new Big(0);\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context14.prev = 3;\n            _iterator2 = _asyncIterator(queryFn.query({}));\n\n          case 5:\n            _context14.next = 7;\n            return _iterator2.next();\n\n          case 7:\n            _step2 = _context14.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context14.next = 11;\n            return _step2.value;\n\n          case 11:\n            _value2 = _context14.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context14.next = 18;\n              break;\n            }\n\n            block = _value2;\n            sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n\n          case 15:\n            _iteratorNormalCompletion2 = true;\n            _context14.next = 5;\n            break;\n\n          case 18:\n            _context14.next = 24;\n            break;\n\n          case 20:\n            _context14.prev = 20;\n            _context14.t0 = _context14[\"catch\"](3);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context14.t0;\n\n          case 24:\n            _context14.prev = 24;\n            _context14.prev = 25;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context14.next = 29;\n              break;\n            }\n\n            _context14.next = 29;\n            return _iterator2.return();\n\n          case 29:\n            _context14.prev = 29;\n\n            if (!_didIteratorError2) {\n              _context14.next = 32;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 32:\n            return _context14.finish(29);\n\n          case 33:\n            return _context14.finish(24);\n\n          case 34:\n            return _context14.abrupt(\"return\", sum);\n\n          case 35:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14, null, [[3, 20, 24, 34], [25,, 29, 33]]);\n  }));\n  return _getSize.apply(this, arguments);\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.utils = {\n  blockstore: require('./blockstore-utils')\n};\nmodule.exports.repoVersion = constants.repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction buildOptions(_options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  var spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(function (mounting) {\n      return {\n        mountpoint: mounting.mountpoint,\n        type: mounting.child.type,\n        path: mounting.child.path,\n        shardFunc: mounting.child.shardFunc\n      };\n    })\n  };\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo/src/index.js"],"names":["_get","require","debug","Big","errcode","migrator","bytes","pathJoin","constants","backends","version","config","spec","apiAddr","blockstore","defaultOptions","defaultDatastore","ERRORS","log","noLimit","Number","MAX_SAFE_INTEGER","AUTO_MIGRATE_CONFIG_KEY","lockers","memory","fs","IpfsRepo","repoPath","options","Error","buildOptions","closed","path","_locker","_getLocker","root","create","_openRoot","set","buildConfig","buildDatastoreSpec","repoVersion","_checkInitialized","close","ERR_REPO_ALREADY_OPEN","_openLock","lockfile","datastore","open","blocksBaseStore","storageBackendOptions","blocks","keys","check","isCompatible","_isAutoMigrationEnabled","_migrate","InvalidRepoVersionError","_closeLock","lock","message","Promise","all","exists","code","ERR_REPO_NOT_INITIALIZED","ERR_REPO_ALREADY_CLOSED","delete","startsWith","map","store","_storageMaxStat","_blockStat","get","getSize","storageMax","size","plus","numObjects","count","repoSize","autoMigrate","undefined","autoMigrateConfig","NotFoundError","toVersion","currentRepoVersion","revert","ignoreLock","repoOptions","migrate","max","query","block","value","byteLength","key","_buf","queryFn","sum","module","exports","utils","errors","_options","Object","assign","storageBackends","_config","Spec","type","mounts","mounting","mountpoint","child","shardFunc"],"mappings":"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","sourcesContent":["'use strict'\n\nconst _get = require('just-safe-get')\nconst debug = require('debug')\nconst Big = require('bignumber.js')\nconst errcode = require('err-code')\nconst migrator = require('ipfs-repo-migrations')\nconst bytes = require('bytes')\nconst pathJoin = require('ipfs-utils/src/path-join')\n\nconst constants = require('./constants')\nconst backends = require('./backends')\nconst version = require('./version')\nconst config = require('./config')\nconst spec = require('./spec')\nconst apiAddr = require('./api-addr')\nconst blockstore = require('./blockstore')\nconst defaultOptions = require('./default-options')\nconst defaultDatastore = require('./default-datastore')\nconst ERRORS = require('./errors')\n\nconst log = debug('repo')\n\nconst noLimit = Number.MAX_SAFE_INTEGER\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate'\n\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n}\n\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor (repoPath, options) {\n    if (typeof repoPath !== 'string') {\n      throw new Error('missing repoPath')\n    }\n\n    this.options = buildOptions(options)\n    this.closed = true\n    this.path = repoPath\n\n    this._locker = this._getLocker()\n\n    this.root = backends.create('root', this.path, this.options)\n    this.version = version(this.root)\n    this.config = config(this.root)\n    this.spec = spec(this.root)\n    this.apiAddr = apiAddr(this.root)\n  }\n\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n  async init (config) {\n    log('initializing at: %s', this.path)\n    await this._openRoot()\n    await this.config.set(buildConfig(config))\n    await this.spec.set(buildDatastoreSpec(config))\n    await this.version.set(constants.repoVersion)\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   * @returns {Promise<Boolean>}\n   */\n  async isInitialized () {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot()\n      await this._checkInitialized()\n      await this.root.close()\n\n      return true\n    } catch (err) {\n      // FIXME: do not use exceptions for flow control\n      return false\n    }\n  }\n\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n  async open () {\n    if (!this.closed) {\n      throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN)\n    }\n    log('opening at: %s', this.path)\n\n    // check if the repo is already initialized\n    try {\n      await this._openRoot()\n      await this._checkInitialized()\n      this.lockfile = await this._openLock(this.path)\n      log('acquired repo.lock')\n      log('creating datastore')\n      this.datastore = backends.create('datastore', pathJoin(this.path, 'datastore'), this.options)\n      await this.datastore.open()\n      log('creating blocks')\n      const blocksBaseStore = backends.create('blocks', pathJoin(this.path, 'blocks'), this.options)\n      await blocksBaseStore.open()\n      this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks)\n      log('creating keystore')\n      this.keys = backends.create('keys', pathJoin(this.path, 'keys'), this.options)\n      await this.keys.open()\n      const isCompatible = await this.version.check(constants.repoVersion)\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion)\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.')\n        }\n      }\n\n      this.closed = false\n      log('all opened')\n    } catch (err) {\n      if (this.lockfile) {\n        try {\n          await this._closeLock()\n          this.lockfile = null\n        } catch (err2) {\n          log('error removing lock', err2)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n  _getLocker () {\n    if (typeof this.options.lock === 'string') {\n      if (!lockers[this.options.lock]) {\n        throw new Error('Unknown lock type: ' + this.options.lock)\n      }\n      return lockers[this.options.lock]\n    }\n\n    if (!this.options.lock) {\n      throw new Error('No lock provided')\n    }\n    return this.options.lock\n  }\n\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   * @returns {Promise}\n   */\n  async _openRoot () {\n    try {\n      await this.root.open()\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err\n      }\n    }\n  }\n\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @returns {Promise<lockfile>}\n   */\n  async _openLock (path) {\n    const lockfile = await this._locker.lock(path)\n\n    if (typeof lockfile.close !== 'function') {\n      throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION')\n    }\n\n    return lockfile\n  }\n\n  /**\n   * Closes the lock on the repo\n   *\n   * @returns {Promise<void>}\n   */\n  _closeLock () {\n    return this.lockfile.close()\n  }\n\n  /**\n   * Check if the repo is already initialized.\n   * @private\n   * @returns {Promise}\n   */\n  async _checkInitialized () {\n    log('init check')\n    let config\n    try {\n      [config] = await Promise.all([\n        this.config.exists(),\n        this.spec.exists(),\n        this.version.exists()\n      ])\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        })\n      }\n\n      throw err\n    }\n\n    if (!config) {\n      throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      })\n    }\n  }\n\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this.closed) {\n      throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED)\n    }\n    log('closing at: %s', this.path)\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete()\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err\n      }\n    }\n\n    await Promise.all([\n      this.root,\n      this.blocks,\n      this.keys,\n      this.datastore\n    ].map((store) => store.close()))\n\n    log('unlocking')\n    this.closed = true\n    await this._closeLock()\n    this.lockfile = null\n  }\n\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<bool>}\n   */\n  async exists () { // eslint-disable-line require-await\n    return this.version.exists()\n  }\n\n  /**\n   * Get repo status.\n   *\n   * @returns {Object}\n   */\n  async stat () {\n    const [storageMax, blocks, version, datastore, keys] = await Promise.all([\n      this._storageMaxStat(),\n      this._blockStat(),\n      this.version.get(),\n      getSize(this.datastore),\n      getSize(this.keys)\n    ])\n    const size = blocks.size\n      .plus(datastore)\n      .plus(keys)\n\n    return {\n      repoPath: this.path,\n      storageMax,\n      version: version,\n      numObjects: blocks.count,\n      repoSize: size\n    }\n  }\n\n  async _isAutoMigrationEnabled () {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate\n    }\n\n    let autoMigrateConfig\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY)\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true // Config's default value is True\n      } else {\n        throw e\n      }\n    }\n\n    return autoMigrateConfig\n  }\n\n  async _migrate (toVersion) {\n    const currentRepoVersion = await this.version.get()\n\n    if (currentRepoVersion > toVersion) {\n      log('reverting to version ' + toVersion)\n      return migrator.revert(this.path, toVersion, { ignoreLock: true, repoOptions: this.options })\n    } else {\n      log('migrating to version ' + toVersion)\n      return migrator.migrate(this.path, toVersion, { ignoreLock: true, repoOptions: this.options })\n    }\n  }\n\n  async _storageMaxStat () {\n    try {\n      const max = await this.config.get('Datastore.StorageMax')\n      return new Big(bytes(max))\n    } catch (err) {\n      return new Big(noLimit)\n    }\n  }\n\n  async _blockStat () {\n    let count = new Big(0)\n    let size = new Big(0)\n\n    for await (const block of this.blocks.query({})) {\n      count = count.plus(1)\n      size = size\n        .plus(block.value.byteLength)\n        .plus(block.key._buf.byteLength)\n    }\n\n    return { count, size }\n  }\n}\n\nasync function getSize (queryFn) {\n  const sum = new Big(0)\n  for await (const block of queryFn.query({})) {\n    sum.plus(block.value.byteLength)\n      .plus(block.key._buf.byteLength)\n  }\n  return sum\n}\n\nmodule.exports = IpfsRepo\nmodule.exports.utils = { blockstore: require('./blockstore-utils') }\nmodule.exports.repoVersion = constants.repoVersion\nmodule.exports.errors = ERRORS\n\nfunction buildOptions (_options) {\n  const options = Object.assign({}, defaultOptions, _options)\n\n  options.storageBackends = Object.assign(\n    {},\n    defaultOptions.storageBackends,\n    options.storageBackends)\n\n  options.storageBackendOptions = Object.assign(\n    {},\n    defaultOptions.storageBackendOptions,\n    options.storageBackendOptions)\n\n  return options\n}\n\n// TODO this should come from js-ipfs instead\nfunction buildConfig (_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}))\n\n  return _config\n}\n\nfunction buildDatastoreSpec (_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}))\n\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map((mounting) => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}