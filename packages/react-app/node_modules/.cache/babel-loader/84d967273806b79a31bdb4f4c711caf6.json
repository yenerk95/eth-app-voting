{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst {\n  parallelMap,\n  filter\n} = require('streaming-iterables');\n\nconst pipe = require('it-pipe');\n\nconst {\n  PinTypes\n} = require('../pin/pin-manager');\n\nconst {\n  cleanCid\n} = require('./utils');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst BLOCK_RM_CONCURRENCY = 8;\n\nmodule.exports = ({\n  blockService,\n  gcLock,\n  pinManager\n}) => {\n  return withTimeoutOption(async function* rm(cids, options) {\n    options = options || {};\n\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    } // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n\n\n    const release = await gcLock.writeLock();\n\n    try {\n      yield* pipe(cids, parallelMap(BLOCK_RM_CONCURRENCY, async cid => {\n        cid = cleanCid(cid);\n        const result = {\n          cid\n        };\n\n        try {\n          const pinResult = await pinManager.isPinnedWithType(cid, PinTypes.all);\n\n          if (pinResult.pinned) {\n            if (CID.isCID(pinResult.reason)) {\n              // eslint-disable-line max-depth\n              throw errCode(new Error(`pinned via ${pinResult.reason}`));\n            }\n\n            throw errCode(new Error(`pinned: ${pinResult.reason}`));\n          } // remove has check when https://github.com/ipfs/js-ipfs-block-service/pull/88 is merged\n\n\n          const has = await blockService._repo.blocks.has(cid);\n\n          if (!has) {\n            throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n          }\n\n          await blockService.delete(cid);\n        } catch (err) {\n          if (!options.force) {\n            err.message = `cannot remove ${cid}: ${err.message}`;\n            result.error = err;\n          }\n        }\n\n        return result;\n      }), filter(() => !options.quiet));\n    } finally {\n      release();\n    }\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/block/rm.js"],"names":["CID","require","errCode","parallelMap","filter","pipe","PinTypes","cleanCid","withTimeoutOption","BLOCK_RM_CONCURRENCY","module","exports","blockService","gcLock","pinManager","rm","cids","options","Array","isArray","release","writeLock","cid","result","pinResult","isPinnedWithType","all","pinned","isCID","reason","Error","has","_repo","blocks","delete","err","force","message","error","quiet"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;AAAEE,EAAAA,WAAF;AAAeC,EAAAA;AAAf,IAA0BH,OAAO,CAAC,qBAAD,CAAvC;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,SAAD,CAApB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAeL,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAM;AAAEM,EAAAA;AAAF,IAAeN,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAM;AAAEO,EAAAA;AAAF,IAAwBP,OAAO,CAAC,aAAD,CAArC;;AAEA,MAAMQ,oBAAoB,GAAG,CAA7B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,YAAF;AAAgBC,EAAAA,MAAhB;AAAwBC,EAAAA;AAAxB,CAAD,KAA0C;AACzD,SAAON,iBAAiB,CAAC,gBAAiBO,EAAjB,CAAqBC,IAArB,EAA2BC,OAA3B,EAAoC;AAC3DA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcH,IAAd,CAAL,EAA0B;AACxBA,MAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD,KAL0D,CAO3D;AACA;;;AACA,UAAMI,OAAO,GAAG,MAAMP,MAAM,CAACQ,SAAP,EAAtB;;AAEA,QAAI;AACF,aAAQhB,IAAI,CACVW,IADU,EAEVb,WAAW,CAACM,oBAAD,EAAuB,MAAMa,GAAN,IAAa;AAC7CA,QAAAA,GAAG,GAAGf,QAAQ,CAACe,GAAD,CAAd;AAEA,cAAMC,MAAM,GAAG;AAAED,UAAAA;AAAF,SAAf;;AAEA,YAAI;AACF,gBAAME,SAAS,GAAG,MAAMV,UAAU,CAACW,gBAAX,CAA4BH,GAA5B,EAAiChB,QAAQ,CAACoB,GAA1C,CAAxB;;AAEA,cAAIF,SAAS,CAACG,MAAd,EAAsB;AACpB,gBAAI3B,GAAG,CAAC4B,KAAJ,CAAUJ,SAAS,CAACK,MAApB,CAAJ,EAAiC;AAAE;AACjC,oBAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAW,cAAaN,SAAS,CAACK,MAAO,EAAzC,CAAD,CAAb;AACD;;AAED,kBAAM3B,OAAO,CAAC,IAAI4B,KAAJ,CAAW,WAAUN,SAAS,CAACK,MAAO,EAAtC,CAAD,CAAb;AACD,WATC,CAWF;;;AACA,gBAAME,GAAG,GAAG,MAAMnB,YAAY,CAACoB,KAAb,CAAmBC,MAAnB,CAA0BF,GAA1B,CAA8BT,GAA9B,CAAlB;;AAEA,cAAI,CAACS,GAAL,EAAU;AACR,kBAAM7B,OAAO,CAAC,IAAI4B,KAAJ,CAAU,iBAAV,CAAD,EAA+B,qBAA/B,CAAb;AACD;;AAED,gBAAMlB,YAAY,CAACsB,MAAb,CAAoBZ,GAApB,CAAN;AACD,SAnBD,CAmBE,OAAOa,GAAP,EAAY;AACZ,cAAI,CAAClB,OAAO,CAACmB,KAAb,EAAoB;AAClBD,YAAAA,GAAG,CAACE,OAAJ,GAAe,iBAAgBf,GAAI,KAAIa,GAAG,CAACE,OAAQ,EAAnD;AACAd,YAAAA,MAAM,CAACe,KAAP,GAAeH,GAAf;AACD;AACF;;AAED,eAAOZ,MAAP;AACD,OAhCU,CAFD,EAmCVnB,MAAM,CAAC,MAAM,CAACa,OAAO,CAACsB,KAAhB,CAnCI,CAAZ;AAqCD,KAtCD,SAsCU;AACRnB,MAAAA,OAAO;AACR;AACF,GApDuB,CAAxB;AAqDD,CAtDD","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst errCode = require('err-code')\nconst { parallelMap, filter } = require('streaming-iterables')\nconst pipe = require('it-pipe')\nconst { PinTypes } = require('../pin/pin-manager')\nconst { cleanCid } = require('./utils')\nconst { withTimeoutOption } = require('../../utils')\n\nconst BLOCK_RM_CONCURRENCY = 8\n\nmodule.exports = ({ blockService, gcLock, pinManager }) => {\n  return withTimeoutOption(async function * rm (cids, options) {\n    options = options || {}\n\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n    const release = await gcLock.writeLock()\n\n    try {\n      yield * pipe(\n        cids,\n        parallelMap(BLOCK_RM_CONCURRENCY, async cid => {\n          cid = cleanCid(cid)\n\n          const result = { cid }\n\n          try {\n            const pinResult = await pinManager.isPinnedWithType(cid, PinTypes.all)\n\n            if (pinResult.pinned) {\n              if (CID.isCID(pinResult.reason)) { // eslint-disable-line max-depth\n                throw errCode(new Error(`pinned via ${pinResult.reason}`))\n              }\n\n              throw errCode(new Error(`pinned: ${pinResult.reason}`))\n            }\n\n            // remove has check when https://github.com/ipfs/js-ipfs-block-service/pull/88 is merged\n            const has = await blockService._repo.blocks.has(cid)\n\n            if (!has) {\n              throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND')\n            }\n\n            await blockService.delete(cid)\n          } catch (err) {\n            if (!options.force) {\n              err.message = `cannot remove ${cid}: ${err.message}`\n              result.error = err\n            }\n          }\n\n          return result\n        }),\n        filter(() => !options.quiet)\n      )\n    } finally {\n      release()\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}