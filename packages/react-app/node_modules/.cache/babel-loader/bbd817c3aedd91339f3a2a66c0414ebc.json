{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar errcode = require('err-code');\n\nvar mergeOptions = require('merge-options');\n\nvar LatencyMonitor = require('./latency-monitor');\n\nvar debug = require('debug')('libp2p:connection-manager');\n\nvar retimer = require('retimer');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar PeerId = require('peer-id');\n\nvar _require2 = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require2.ERR_INVALID_PARAMETERS;\n\nvar defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n/**\n * Responsible for managing known connections.\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\n\nvar ConnectionManager = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ConnectionManager, _EventEmitter);\n\n  var _super = _createSuper(ConnectionManager);\n\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   */\n  function ConnectionManager(libp2p, options) {\n    var _this;\n\n    _classCallCheck(this, ConnectionManager);\n\n    _this = _super.call(this);\n    _this._libp2p = libp2p;\n    _this._peerId = libp2p.peerId.toB58String();\n    _this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (_this._options.maxConnections < _this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    debug('options: %j', _this._options);\n    _this._libp2p = libp2p;\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     * @type {Map<string, number>}\n     */\n\n    _this._peerValues = new Map();\n    /**\n     * Map of connections per peer\n     * @type {Map<string, Array<conn>>}\n     */\n\n    _this.connections = new Map();\n    _this._timer = null;\n    _this._checkMetrics = _this._checkMetrics.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Get current number of open connections.\n   */\n\n\n  _createClass(ConnectionManager, [{\n    key: \"start\",\n\n    /**\n     * Starts the Connection Manager. If Metrics are not enabled on libp2p\n     * only event loop and connection limits will be monitored.\n     */\n    value: function start() {\n      if (this._libp2p.metrics) {\n        this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n      } // latency monitor\n\n\n      this._latencyMonitor = new LatencyMonitor({\n        latencyCheckIntervalMs: this._options.pollInterval,\n        dataEmitIntervalMs: this._options.pollInterval\n      });\n      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n      this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n      debug('started');\n    }\n    /**\n     * Stops the Connection Manager\n     * @async\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._timer && this._timer.clear();\n                this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n                _context.next = 4;\n                return this._close();\n\n              case 4:\n                debug('stopped');\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Cleans up the connections\n     * @async\n     */\n\n  }, {\n    key: \"_close\",\n    value: function () {\n      var _close2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var tasks, _iterator, _step, connectionList, _iterator2, _step2, connection;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Close all connections we're tracking\n                tasks = [];\n                _iterator = _createForOfIteratorHelper(this.connections.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    connectionList = _step.value;\n                    _iterator2 = _createForOfIteratorHelper(connectionList);\n\n                    try {\n                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                        connection = _step2.value;\n                        tasks.push(connection.close());\n                      }\n                    } catch (err) {\n                      _iterator2.e(err);\n                    } finally {\n                      _iterator2.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context2.next = 5;\n                return tasks;\n\n              case 5:\n                this.connections.clear();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _close() {\n        return _close2.apply(this, arguments);\n      }\n\n      return _close;\n    }()\n    /**\n     * Sets the value of the given peer. Peers with lower values\n     * will be disconnected first.\n     * @param {PeerId} peerId\n     * @param {number} value A number between 0 and 1\n     */\n\n  }, {\n    key: \"setPeerValue\",\n    value: function setPeerValue(peerId, value) {\n      if (value < 0 || value > 1) {\n        throw new Error('value should be a number between 0 and 1');\n      }\n\n      if (peerId.toB58String) {\n        peerId = peerId.toB58String();\n      }\n\n      this._peerValues.set(peerId, value);\n    }\n    /**\n     * Checks the libp2p metrics to determine if any values have exceeded\n     * the configured maximums.\n     * @private\n     */\n\n  }, {\n    key: \"_checkMetrics\",\n    value: function _checkMetrics() {\n      var movingAverages = this._libp2p.metrics.global.movingAverages;\n\n      var received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxReceivedData', received);\n\n      var sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxSentData', sent);\n\n      var total = received + sent;\n\n      this._checkLimit('maxData', total);\n\n      debug('metrics update', total);\n\n      this._timer.reschedule(this._options.pollInterval);\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     * @param {Connection} connection\n     */\n\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(connection) {\n      var peerId = connection.remotePeer;\n      var peerIdStr = peerId.toB58String();\n      var storedConn = this.connections.get(peerIdStr);\n      this.emit('peer:connect', connection);\n\n      if (storedConn) {\n        storedConn.push(connection);\n      } else {\n        this.connections.set(peerIdStr, [connection]);\n      }\n\n      this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);\n\n      if (!this._peerValues.has(peerIdStr)) {\n        this._peerValues.set(peerIdStr, this._options.defaultPeerValue);\n      }\n\n      this._checkLimit('maxConnections', this.size);\n    }\n    /**\n     * Removes the connection from tracking\n     * @param {Connection} connection\n     */\n\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(connection) {\n      var peerId = connection.remotePeer.toB58String();\n      var storedConn = this.connections.get(peerId);\n\n      if (storedConn && storedConn.length > 1) {\n        storedConn = storedConn.filter(function (conn) {\n          return conn.id !== connection.id;\n        });\n        this.connections.set(peerId, storedConn);\n      } else if (storedConn) {\n        this.connections.delete(peerId);\n\n        this._peerValues.delete(connection.remotePeer.toB58String());\n\n        this.emit('peer:disconnect', connection);\n      }\n    }\n    /**\n     * Get a connection with a peer.\n     * @param {PeerId} peerId\n     * @returns {Connection}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(peerId) {\n      var connections = this.getAll(peerId);\n\n      if (connections.length) {\n        return connections[0];\n      }\n\n      return null;\n    }\n    /**\n     * Get all open connections with a peer.\n     * @param {PeerId} peerId\n     * @returns {Array<Connection>}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(peerId) {\n      if (!PeerId.isPeerId(peerId)) {\n        throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n      }\n\n      var id = peerId.toB58String();\n      var connections = this.connections.get(id); // Return all open connections\n\n      if (connections) {\n        return connections.filter(function (connection) {\n          return connection.stat.status === 'open';\n        });\n      }\n\n      return [];\n    }\n    /**\n     * If the event loop is slow, maybe close a connection\n     * @private\n     * @param {*} summary The LatencyMonitor summary\n     */\n\n  }, {\n    key: \"_onLatencyMeasure\",\n    value: function _onLatencyMeasure(summary) {\n      this._checkLimit('maxEventLoopDelay', summary.avgMs);\n    }\n    /**\n     * If the `value` of `name` has exceeded its limit, maybe close a connection\n     * @private\n     * @param {string} name The name of the field to check limits for\n     * @param {number} value The current value of the field\n     */\n\n  }, {\n    key: \"_checkLimit\",\n    value: function _checkLimit(name, value) {\n      var limit = this._options[name];\n      debug('checking limit of %s. current value: %d of %d', name, value, limit);\n\n      if (value > limit) {\n        debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n    /**\n     * If we have more connections than our maximum, close a connection\n     * to the lowest valued peer.\n     * @private\n     */\n\n  }, {\n    key: \"_maybeDisconnectOne\",\n    value: function _maybeDisconnectOne() {\n      if (this._options.minConnections < this.connections.size) {\n        var peerValues = Array.from(this._peerValues).sort(byPeerValue);\n        debug('%s: sorted peer values: %j', this._peerId, peerValues);\n        var disconnectPeer = peerValues[0];\n\n        if (disconnectPeer) {\n          var peerId = disconnectPeer[0];\n          debug('%s: lowest value peer is %s', this._peerId, peerId);\n          debug('%s: closing a connection to %j', this._peerId, peerId);\n\n          var _iterator3 = _createForOfIteratorHelper(this.connections.values()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var connections = _step3.value;\n\n              if (connections[0].remotePeer.toB58String() === peerId) {\n                connections[0].close();\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return Array.from(this.connections.values()).reduce(function (accumulator, value) {\n        return accumulator + value.length;\n      }, 0);\n    }\n  }]);\n\n  return ConnectionManager;\n}(EventEmitter);\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/connection-manager/index.js"],"names":["errcode","require","mergeOptions","LatencyMonitor","debug","retimer","EventEmitter","PeerId","ERR_INVALID_PARAMETERS","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","libp2p","options","_libp2p","_peerId","peerId","toB58String","_options","call","ignoreUndefined","Error","_peerValues","Map","connections","_timer","_checkMetrics","bind","metrics","_latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","_onLatencyMeasure","on","clear","removeListener","_close","tasks","values","connectionList","connection","push","close","value","set","movingAverages","global","received","dataReceived","movingAverage","_checkLimit","sent","dataSent","total","reschedule","remotePeer","peerIdStr","storedConn","get","emit","peerStore","keyBook","pubKey","has","size","length","filter","conn","id","delete","getAll","isPeerId","stat","status","summary","avgMs","name","limit","_maybeDisconnectOne","peerValues","Array","from","sort","byPeerValue","disconnectPeer","reduce","accumulator","module","exports","peerValueEntryA","peerValueEntryB"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst LatencyMonitor = require('./latency-monitor')\nconst debug = require('debug')('libp2p:connection-manager')\nconst retimer = require('retimer')\n\nconst { EventEmitter } = require('events')\n\nconst PeerId = require('peer-id')\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors')\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\n/**\n * Responsible for managing known connections.\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\nclass ConnectionManager extends EventEmitter {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   */\n  constructor (libp2p, options) {\n    super()\n\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId.toB58String()\n\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS)\n    }\n\n    debug('options: %j', this._options)\n\n    this._libp2p = libp2p\n\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     * @type {Map<string, number>}\n     */\n    this._peerValues = new Map()\n\n    /**\n     * Map of connections per peer\n     * @type {Map<string, Array<conn>>}\n     */\n    this.connections = new Map()\n\n    this._timer = null\n    this._checkMetrics = this._checkMetrics.bind(this)\n  }\n\n  /**\n   * Get current number of open connections.\n   */\n  get size () {\n    return Array.from(this.connections.values())\n      .reduce((accumulator, value) => accumulator + value.length, 0)\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  start () {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval)\n    }\n\n    // latency monitor\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n    debug('started')\n  }\n\n  /**\n   * Stops the Connection Manager\n   * @async\n   */\n  async stop () {\n    this._timer && this._timer.clear()\n    this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n\n    await this._close()\n    debug('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   * @async\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close())\n      }\n    }\n\n    await tasks\n    this.connections.clear()\n  }\n\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   * @param {PeerId} peerId\n   * @param {number} value A number between 0 and 1\n   */\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String()\n    }\n    this._peerValues.set(peerId, value)\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   * @private\n   */\n  _checkMetrics () {\n    const movingAverages = this._libp2p.metrics.global.movingAverages\n    const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxReceivedData', received)\n    const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxSentData', sent)\n    const total = received + sent\n    this._checkLimit('maxData', total)\n    debug('metrics update', total)\n    this._timer.reschedule(this._options.pollInterval)\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   * @param {Connection} connection\n   */\n  onConnect (connection) {\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toB58String()\n    const storedConn = this.connections.get(peerIdStr)\n\n    this.emit('peer:connect', connection)\n    if (storedConn) {\n      storedConn.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey)\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue)\n    }\n\n    this._checkLimit('maxConnections', this.size)\n  }\n\n  /**\n   * Removes the connection from tracking\n   * @param {Connection} connection\n   */\n  onDisconnect (connection) {\n    const peerId = connection.remotePeer.toB58String()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn) {\n      this.connections.delete(peerId)\n      this._peerValues.delete(connection.remotePeer.toB58String())\n      this.emit('peer:disconnect', connection)\n    }\n  }\n\n  /**\n   * Get a connection with a peer.\n   * @param {PeerId} peerId\n   * @returns {Connection}\n   */\n  get (peerId) {\n    const connections = this.getAll(peerId)\n    if (connections.length) {\n      return connections[0]\n    }\n    return null\n  }\n\n  /**\n   * Get all open connections with a peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Connection>}\n   */\n  getAll (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toB58String()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open')\n    }\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   * @private\n   * @param {*} summary The LatencyMonitor summary\n   */\n  _onLatencyMeasure (summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   * @private\n   * @param {string} name The name of the field to check limits for\n   * @param {number} value The current value of the field\n   */\n  _checkLimit (name, value) {\n    const limit = this._options[name]\n    debug('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   * @private\n   */\n  _maybeDisconnectOne () {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue)\n      debug('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        debug('%s: lowest value peer is %s', this._peerId, peerId)\n        debug('%s: closing a connection to %j', this._peerId, peerId)\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close()\n            break\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n\nfunction byPeerValue (peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1]\n}\n"]},"metadata":{},"sourceType":"script"}