{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('interface-datastore'),\n    Adapter = _require.Adapter,\n    Key = _require.Key,\n    Errors = _require.Errors,\n    _require$utils = _require.utils,\n    filter = _require$utils.filter,\n    take = _require$utils.take,\n    sortAll = _require$utils.sortAll,\n    replaceStartWith = _require$utils.replaceStartWith;\n\nvar Keytransform = require('./keytransform');\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\n\n\nvar MountDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(MountDatastore, _Adapter);\n\n  var _super = _createSuper(MountDatastore);\n\n  function MountDatastore(mounts) {\n    var _this;\n\n    _classCallCheck(this, MountDatastore);\n\n    _this = _super.call(this);\n    _this.mounts = mounts.slice();\n    return _this;\n  }\n\n  _createClass(MountDatastore, [{\n    key: \"open\",\n    value: function open() {\n      return Promise.all(this.mounts.map(function (m) {\n        return m.datastore.open();\n      }));\n    }\n    /**\n     * Lookup the matching datastore for the given key.\n     *\n     * @private\n     * @param {Key} key\n     * @returns {{Datastore, Key, Key}}\n     */\n\n  }, {\n    key: \"_lookup\",\n    value: function _lookup(key) {\n      var _iterator2 = _createForOfIteratorHelper(this.mounts),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mount = _step2.value;\n\n          if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n            var s = replaceStartWith(key.toString(), mount.prefix.toString());\n            return {\n              datastore: mount.datastore,\n              mountpoint: mount.prefix,\n              rest: new Key(s)\n            };\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(key, value, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.put(match.rest, value, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.get(match.rest, options);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return false;\n      }\n\n      return match.datastore.has(match.rest, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.delete(match.rest, options);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.all(this.mounts.map(function (m) {\n        return m.datastore.close();\n      }));\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var _this2 = this;\n\n      var batchMounts = {};\n\n      var lookup = function lookup(key) {\n        var match = _this2._lookup(key);\n\n        if (match == null) {\n          throw new Error('No datastore mounted for this key');\n        }\n\n        var m = match.mountpoint.toString();\n\n        if (batchMounts[m] == null) {\n          batchMounts[m] = match.datastore.batch();\n        }\n\n        return {\n          batch: batchMounts[m],\n          rest: match.rest\n        };\n      };\n\n      return {\n        put: function put(key, value) {\n          var match = lookup(key);\n          match.batch.put(match.rest, value);\n        },\n        delete: function _delete(key) {\n          var match = lookup(key);\n          match.batch.delete(match.rest);\n        },\n        commit: function commit(options) {\n          return Promise.all(Object.keys(batchMounts).map(function (p) {\n            return batchMounts[p].commit(options);\n          }));\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q, options) {\n      var qs = this.mounts.map(function (m) {\n        var ks = new Keytransform(m.datastore, {\n          convert: function convert(key) {\n            throw new Error('should never be called');\n          },\n          invert: function invert(key) {\n            return m.prefix.child(key);\n          }\n        });\n        var prefix;\n\n        if (q.prefix != null) {\n          prefix = replaceStartWith(q.prefix, m.prefix.toString());\n        }\n\n        return ks.query({\n          prefix: prefix,\n          filters: q.filters,\n          keysOnly: q.keysOnly\n        }, options);\n      });\n\n      var it = _many(qs);\n\n      if (q.filters) q.filters.forEach(function (f) {\n        it = filter(it, f);\n      });\n      if (q.orders) q.orders.forEach(function (o) {\n        it = sortAll(it, o);\n      });\n\n      if (q.offset != null) {\n        var i = 0;\n        it = filter(it, function () {\n          return i++ >= q.offset;\n        });\n      }\n\n      if (q.limit != null) it = take(it, q.limit);\n      return it;\n    }\n  }]);\n\n  return MountDatastore;\n}(Adapter);\n\nfunction _many(iterable) {\n  return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var i, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, v;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < iterable.length)) {\n              _context.next = 39;\n              break;\n            }\n\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 4;\n            _iterator = _asyncIterator(iterable[i]);\n\n          case 6:\n            _context.next = 8;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 8:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 12;\n            return _awaitAsyncGenerator(_step.value);\n\n          case 12:\n            _value = _context.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context.next = 20;\n              break;\n            }\n\n            v = _value;\n            _context.next = 17;\n            return v;\n\n          case 17:\n            _iteratorNormalCompletion = true;\n            _context.next = 6;\n            break;\n\n          case 20:\n            _context.next = 26;\n            break;\n\n          case 22:\n            _context.prev = 22;\n            _context.t0 = _context[\"catch\"](4);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 26:\n            _context.prev = 26;\n            _context.prev = 27;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context.next = 31;\n              break;\n            }\n\n            _context.next = 31;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 31:\n            _context.prev = 31;\n\n            if (!_didIteratorError) {\n              _context.next = 34;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 34:\n            return _context.finish(31);\n\n          case 35:\n            return _context.finish(26);\n\n          case 36:\n            i++;\n            _context.next = 1;\n            break;\n\n          case 39:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }))();\n}\n\nmodule.exports = MountDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-core/src/mount.js"],"names":["require","Adapter","Key","Errors","utils","filter","take","sortAll","replaceStartWith","Keytransform","MountDatastore","mounts","slice","Promise","all","map","m","datastore","open","key","mount","prefix","toString","isAncestorOf","s","mountpoint","rest","value","options","match","_lookup","dbWriteFailedError","Error","put","notFoundError","get","has","dbDeleteFailedError","delete","close","batchMounts","lookup","batch","commit","Object","keys","p","q","qs","ks","convert","invert","child","query","filters","keysOnly","it","_many","forEach","f","orders","o","offset","i","limit","iterable","length","v","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n'use strict'\n\nconst {\n  Adapter, Key, Errors, utils: {\n    filter,\n    take,\n    sortAll,\n    replaceStartWith\n  }\n} = require('interface-datastore')\n\nconst Keytransform = require('./keytransform')\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\nclass MountDatastore extends Adapter {\n  constructor (mounts) {\n    super()\n\n    this.mounts = mounts.slice()\n  }\n\n  open () {\n    return Promise.all(this.mounts.map((m) => m.datastore.open()))\n  }\n\n  /**\n   * Lookup the matching datastore for the given key.\n   *\n   * @private\n   * @param {Key} key\n   * @returns {{Datastore, Key, Key}}\n   */\n  _lookup (key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        const s = replaceStartWith(key.toString(), mount.prefix.toString())\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix,\n          rest: new Key(s)\n        }\n      }\n    }\n  }\n\n  put (key, value, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.put(match.rest, value, options)\n  }\n\n  get (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'))\n    }\n    return match.datastore.get(match.rest, options)\n  }\n\n  has (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      return false\n    }\n    return match.datastore.has(match.rest, options)\n  }\n\n  delete (key, options) {\n    const match = this._lookup(key)\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'))\n    }\n\n    return match.datastore.delete(match.rest, options)\n  }\n\n  close () {\n    return Promise.all(this.mounts.map((m) => {\n      return m.datastore.close()\n    }))\n  }\n\n  batch () {\n    const batchMounts = {}\n    const lookup = (key) => {\n      const match = this._lookup(key)\n      if (match == null) {\n        throw new Error('No datastore mounted for this key')\n      }\n\n      const m = match.mountpoint.toString()\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch()\n      }\n\n      return {\n        batch: batchMounts[m],\n        rest: match.rest\n      }\n    }\n\n    return {\n      put: (key, value) => {\n        const match = lookup(key)\n        match.batch.put(match.rest, value)\n      },\n      delete: (key) => {\n        const match = lookup(key)\n        match.batch.delete(match.rest)\n      },\n      commit: (options) => {\n        return Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)))\n      }\n    }\n  }\n\n  query (q, options) {\n    const qs = this.mounts.map(m => {\n      const ks = new Keytransform(m.datastore, {\n        convert: (key) => {\n          throw new Error('should never be called')\n        },\n        invert: (key) => {\n          return m.prefix.child(key)\n        }\n      })\n\n      let prefix\n      if (q.prefix != null) {\n        prefix = replaceStartWith(q.prefix, m.prefix.toString())\n      }\n\n      return ks.query({\n        prefix: prefix,\n        filters: q.filters,\n        keysOnly: q.keysOnly\n      }, options)\n    })\n\n    let it = _many(qs)\n    if (q.filters) q.filters.forEach(f => { it = filter(it, f) })\n    if (q.orders) q.orders.forEach(o => { it = sortAll(it, o) })\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= q.offset)\n    }\n    if (q.limit != null) it = take(it, q.limit)\n\n    return it\n  }\n}\n\nfunction _many (iterable) {\n  return (async function * () {\n    for (let i = 0; i < iterable.length; i++) {\n      for await (const v of iterable[i]) {\n        yield v\n      }\n    }\n  })()\n}\n\nmodule.exports = MountDatastore\n"]},"metadata":{},"sourceType":"script"}