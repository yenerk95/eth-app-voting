{"ast":null,"code":"'use strict';\n\nconst connect = require('it-ws/client');\n\nconst mafmt = require('mafmt');\n\nconst withIs = require('class-is');\n\nconst toUri = require('multiaddr-to-uri');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst log = require('debug')('libp2p:websockets');\n\nconst createListener = require('./listener');\n\nconst toConnection = require('./socket-to-conn');\n\nconst {\n  CODE_CIRCUIT,\n  CODE_P2P\n} = require('./constants');\n/**\n * @class WebSockets\n */\n\n\nclass WebSockets {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  constructor({\n    upgrader\n  }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  async dial(ma, options = {}) {\n    log('dialing %s', ma);\n    const socket = await this._connect(ma, options);\n    const maConn = toConnection(socket, {\n      remoteAddr: ma,\n      signal: options.signal\n    });\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await this._upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n\n\n  async _connect(ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError();\n    }\n\n    const cOpts = ma.toOptions();\n    log('dialing %s:%s', cOpts.host, cOpts.port);\n    const rawSocket = connect(toUri(ma), Object.assign({\n      binary: true\n    }, options));\n\n    if (!options.signal) {\n      await rawSocket.connected();\n      log('connected %s', ma);\n      return rawSocket;\n    } // Allow abort via signal during connect\n\n\n    let onAbort;\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError());\n        rawSocket.close();\n      }; // Already aborted?\n\n\n      if (options.signal.aborted) return onAbort();\n      options.signal.addEventListener('abort', onAbort);\n    });\n\n    try {\n      await Promise.race([abort, rawSocket.connected()]);\n    } finally {\n      options.signal.removeEventListener('abort', onAbort);\n    }\n\n    log('connected %s', ma);\n    return rawSocket;\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   * @param {object} [options]\n   * @param {http.Server} [options.server] A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n\n\n  createListener(options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    return createListener({\n      handler,\n      upgrader: this._upgrader\n    }, options);\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false;\n      }\n\n      return mafmt.WebSockets.matches(ma.decapsulateCode(CODE_P2P)) || mafmt.WebSocketsSecure.matches(ma.decapsulateCode(CODE_P2P));\n    });\n  }\n\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-websockets/src/index.js"],"names":["connect","require","mafmt","withIs","toUri","AbortError","log","createListener","toConnection","CODE_CIRCUIT","CODE_P2P","WebSockets","constructor","upgrader","Error","_upgrader","dial","ma","options","socket","_connect","maConn","remoteAddr","signal","conn","upgradeOutbound","aborted","cOpts","toOptions","host","port","rawSocket","Object","assign","binary","connected","onAbort","abort","Promise","resolve","reject","close","addEventListener","race","removeEventListener","handler","filter","multiaddrs","Array","isArray","protoCodes","includes","matches","decapsulateCode","WebSocketsSecure","module","exports","className","symbolName"],"mappings":"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","sourcesContent":["'use strict'\n\nconst connect = require('it-ws/client')\nconst mafmt = require('mafmt')\nconst withIs = require('class-is')\nconst toUri = require('multiaddr-to-uri')\nconst { AbortError } = require('abortable-iterator')\n\nconst log = require('debug')('libp2p:websockets')\n\nconst createListener = require('./listener')\nconst toConnection = require('./socket-to-conn')\nconst { CODE_CIRCUIT, CODE_P2P } = require('./constants')\n\n/**\n * @class WebSockets\n */\nclass WebSockets {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  constructor ({ upgrader }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')\n    }\n    this._upgrader = upgrader\n  }\n\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n  async dial (ma, options = {}) {\n    log('dialing %s', ma)\n\n    const socket = await this._connect(ma, options)\n    const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal })\n    log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await this._upgrader.upgradeOutbound(maConn)\n    log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n  async _connect (ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options))\n\n    if (!options.signal) {\n      await rawSocket.connected()\n\n      log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        rawSocket.close()\n      }\n\n      // Already aborted?\n      if (options.signal.aborted) return onAbort()\n      options.signal.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, rawSocket.connected()])\n    } finally {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   * @param {object} [options]\n   * @param {http.Server} [options.server] A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n  createListener (options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options\n      options = {}\n    }\n\n    return createListener({ handler, upgrader: this._upgrader }, options)\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n  filter (multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false\n      }\n\n      return mafmt.WebSockets.matches(ma.decapsulateCode(CODE_P2P)) ||\n        mafmt.WebSocketsSecure.matches(ma.decapsulateCode(CODE_P2P))\n    })\n  }\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n})\n"]},"metadata":{},"sourceType":"script"}