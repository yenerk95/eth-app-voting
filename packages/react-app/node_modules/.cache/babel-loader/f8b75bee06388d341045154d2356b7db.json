{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar libp2pRecord = require('libp2p-record');\n\nvar c = require('../constants');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n\nvar Record = libp2pRecord.Record;\n\nmodule.exports = function (dht) {\n  var putLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, rec) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", dht.datastore.put(utils.bufferToKey(key), rec));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function putLocal(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @returns {Promise<Record>}\n   *\n   * @private\n   */\n\n\n  var getLocal = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n      var raw, rec;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              dht._log('getLocal %b', key);\n\n              _context2.next = 3;\n              return dht.datastore.get(utils.bufferToKey(key));\n\n            case 3:\n              raw = _context2.sent;\n\n              dht._log('found %b in local datastore', key);\n\n              rec = Record.deserialize(raw);\n              _context2.next = 8;\n              return dht._verifyRecordLocally(rec);\n\n            case 8:\n              return _context2.abrupt(\"return\", rec);\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function getLocal(_x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n\n\n  var sendCorrectionRecord = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key, vals, best) {\n      var fixupRec;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return utils.createPutRecord(key, best);\n\n            case 2:\n              fixupRec = _context4.sent;\n              return _context4.abrupt(\"return\", Promise.all(vals.map( /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(v) {\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!v.val.equals(best)) {\n                            _context3.next = 2;\n                            break;\n                          }\n\n                          return _context3.abrupt(\"return\");\n\n                        case 2:\n                          if (!dht._isSelf(v.from)) {\n                            _context3.next = 12;\n                            break;\n                          }\n\n                          _context3.prev = 3;\n                          _context3.next = 6;\n                          return dht._putLocal(key, fixupRec);\n\n                        case 6:\n                          _context3.next = 11;\n                          break;\n\n                        case 8:\n                          _context3.prev = 8;\n                          _context3.t0 = _context3[\"catch\"](3);\n\n                          dht._log.error('Failed error correcting self', _context3.t0);\n\n                        case 11:\n                          return _context3.abrupt(\"return\");\n\n                        case 12:\n                          _context3.prev = 12;\n                          _context3.next = 15;\n                          return dht._putValueToPeer(key, fixupRec, v.from);\n\n                        case 15:\n                          _context3.next = 20;\n                          break;\n\n                        case 17:\n                          _context3.prev = 17;\n                          _context3.t1 = _context3[\"catch\"](12);\n\n                          dht._log.error('Failed error correcting entry', _context3.t1);\n\n                        case 20:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3, null, [[3, 8], [12, 17]]);\n                }));\n\n                return function (_x7) {\n                  return _ref4.apply(this, arguments);\n                };\n              }())));\n\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function sendCorrectionRecord(_x4, _x5, _x6) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @returns {Promise<void>}\n     * @private\n     */\n    _putLocal: function _putLocal(key, rec) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", putLocal(key, rec));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     * @returns {Promise<void>}\n     */\n    put: function put(key, value) {\n      var _arguments = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var options, record, counterAll, counterSuccess, minPeers, error;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n\n                dht._log('PutValue %b', key); // create record in the dht format\n\n\n                _context7.next = 4;\n                return utils.createPutRecord(key, value);\n\n              case 4:\n                record = _context7.sent;\n                _context7.next = 7;\n                return putLocal(key, record);\n\n              case 7:\n                // put record to the closest peers\n                counterAll = 0;\n                counterSuccess = 0;\n                _context7.next = 11;\n                return utils.mapParallel(dht.getClosestPeers(key, {\n                  shallow: true\n                }), /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peer) {\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.prev = 0;\n                            counterAll += 1;\n                            _context6.next = 4;\n                            return dht._putValueToPeer(key, record, peer);\n\n                          case 4:\n                            counterSuccess += 1;\n                            _context6.next = 10;\n                            break;\n\n                          case 7:\n                            _context6.prev = 7;\n                            _context6.t0 = _context6[\"catch\"](0);\n\n                            dht._log.error('Failed to put to peer (%b): %s', peer.id, _context6.t0);\n\n                          case 10:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, null, [[0, 7]]);\n                  }));\n\n                  return function (_x8) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }());\n\n              case 11:\n                // verify if we were able to put to enough peers\n                minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n                if (!(minPeers > counterSuccess)) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                error = errcode(new Error(\"Failed to put value to enough peers: \".concat(counterSuccess, \"/\").concat(minPeers)), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n                dht._log.error(error);\n\n                throw error;\n\n              case 16:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }))();\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Buffer>}\n     */\n    get: function get(key) {\n      var _arguments2 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var options, vals, recs, i, best;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('_get %b', key);\n\n                _context8.next = 5;\n                return dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n\n              case 5:\n                vals = _context8.sent;\n                recs = vals.map(function (v) {\n                  return v.val;\n                });\n                i = 0;\n                _context8.prev = 8;\n                i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n                _context8.next = 16;\n                break;\n\n              case 12:\n                _context8.prev = 12;\n                _context8.t0 = _context8[\"catch\"](8);\n\n                if (!(_context8.t0.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY')) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                throw _context8.t0;\n\n              case 16:\n                best = recs[i];\n\n                dht._log('GetValue %b %s', key, best);\n\n                if (best) {\n                  _context8.next = 20;\n                  break;\n                }\n\n                throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n\n              case 20:\n                _context8.next = 22;\n                return sendCorrectionRecord(key, vals, best);\n\n              case 22:\n                return _context8.abrupt(\"return\", best);\n\n              case 23:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[8, 12]]);\n      }))();\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    getMany: function getMany(key, nvals) {\n      var _arguments3 = arguments,\n          _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var options, vals, localRec, paths, id, rtp, errMsg, query, error;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                options = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('getMany %b (%s)', key, nvals);\n\n                vals = [];\n                _context10.prev = 4;\n                _context10.next = 7;\n                return getLocal(key);\n\n              case 7:\n                localRec = _context10.sent;\n                _context10.next = 14;\n                break;\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](4);\n\n                if (!(nvals === 0)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                throw _context10.t0;\n\n              case 14:\n                if (localRec) {\n                  vals.push({\n                    val: localRec.value,\n                    from: dht.peerId\n                  });\n                }\n\n                if (!(vals.length >= nvals)) {\n                  _context10.next = 17;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", vals);\n\n              case 17:\n                paths = [];\n                _context10.next = 20;\n                return utils.convertBuffer(key);\n\n              case 20:\n                id = _context10.sent;\n                rtp = dht.routingTable.closestPeers(id, _this.kBucketSize);\n\n                dht._log('peers in rt: %d', rtp.length);\n\n                if (!(rtp.length === 0)) {\n                  _context10.next = 29;\n                  break;\n                }\n\n                errMsg = 'Failed to lookup key! No peers from routing table!';\n\n                dht._log.error(errMsg);\n\n                if (!(vals.length === 0)) {\n                  _context10.next = 28;\n                  break;\n                }\n\n                throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n\n              case 28:\n                return _context10.abrupt(\"return\", vals);\n\n              case 29:\n                // we have peers, lets do the actual query to them\n                query = new Query(dht, key, function (pathIndex, numPaths) {\n                  // This function body runs once per disjoint path\n                  var pathSize = utils.pathSize(nvals - vals.length, numPaths);\n                  var pathVals = [];\n                  paths.push(pathVals); // Here we return the query function to use on this particular disjoint path\n\n                  return /*#__PURE__*/function () {\n                    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(peer) {\n                      var rec, peers, lookupErr, results, res;\n                      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n                        while (1) {\n                          switch (_context9.prev = _context9.next) {\n                            case 0:\n                              _context9.prev = 0;\n                              _context9.next = 3;\n                              return dht._getValueOrPeers(peer, key);\n\n                            case 3:\n                              results = _context9.sent;\n                              rec = results.record;\n                              peers = results.peers;\n                              _context9.next = 13;\n                              break;\n\n                            case 8:\n                              _context9.prev = 8;\n                              _context9.t0 = _context9[\"catch\"](0);\n\n                              if (!(_context9.t0.code !== 'ERR_INVALID_RECORD')) {\n                                _context9.next = 12;\n                                break;\n                              }\n\n                              throw _context9.t0;\n\n                            case 12:\n                              lookupErr = _context9.t0;\n\n                            case 13:\n                              res = {\n                                closerPeers: peers\n                              };\n\n                              if (rec && rec.value || lookupErr) {\n                                pathVals.push({\n                                  val: rec && rec.value,\n                                  from: peer\n                                });\n                              } // enough is enough\n\n\n                              if (pathVals.length >= pathSize) {\n                                res.pathComplete = true;\n                              }\n\n                              return _context9.abrupt(\"return\", res);\n\n                            case 17:\n                            case \"end\":\n                              return _context9.stop();\n                          }\n                        }\n                      }, _callee9, null, [[0, 8]]);\n                    }));\n\n                    return function (_x9) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }();\n                });\n                _context10.prev = 30;\n                _context10.next = 33;\n                return pTimeout(query.run(rtp), options.timeout);\n\n              case 33:\n                _context10.next = 38;\n                break;\n\n              case 35:\n                _context10.prev = 35;\n                _context10.t1 = _context10[\"catch\"](30);\n                error = _context10.t1;\n\n              case 38:\n                query.stop(); // combine vals from each path\n\n                vals = [].concat.apply(vals, paths).slice(0, nvals);\n\n                if (!(error && vals.length === 0)) {\n                  _context10.next = 42;\n                  break;\n                }\n\n                throw error;\n\n              case 42:\n                return _context10.abrupt(\"return\", vals);\n\n              case 43:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[4, 10], [30, 35]]);\n      }))();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/content-fetching/index.js"],"names":["errcode","require","pTimeout","libp2pRecord","c","Query","utils","Record","module","exports","dht","putLocal","key","rec","datastore","put","bufferToKey","getLocal","_log","get","raw","deserialize","_verifyRecordLocally","sendCorrectionRecord","vals","best","createPutRecord","fixupRec","Promise","all","map","v","val","equals","_isSelf","from","_putLocal","error","_putValueToPeer","value","options","record","counterAll","counterSuccess","mapParallel","getClosestPeers","shallow","peer","id","minPeers","Error","timeout","minute","getMany","GET_MANY_RECORD_COUNT","recs","i","selection","bestRecord","selectors","code","nvals","localRec","push","peerId","length","paths","convertBuffer","rtp","routingTable","closestPeers","kBucketSize","errMsg","query","pathIndex","numPaths","pathSize","pathVals","_getValueOrPeers","results","peers","lookupErr","res","closerPeers","pathComplete","run","stop","concat","apply","slice"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst libp2pRecord = require('libp2p-record')\n\nconst c = require('../constants')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\nconst Record = libp2pRecord.Record\n\nmodule.exports = (dht) => {\n  const putLocal = async (key, rec) => { // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec)\n  }\n\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @returns {Promise<Record>}\n   *\n   * @private\n   */\n  const getLocal = async (key) => {\n    dht._log('getLocal %b', key)\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key))\n    dht._log('found %b in local datastore', key)\n    const rec = Record.deserialize(raw)\n\n    await dht._verifyRecordLocally(rec)\n    return rec\n  }\n\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best)\n\n    return Promise.all(vals.map(async (v) => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return\n      }\n\n      // correct ourself\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec)\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err)\n        }\n        return\n      }\n\n      // send correction\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from)\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err)\n      }\n    }))\n  }\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _putLocal (key, rec) { // eslint-disable-line require-await\n      return putLocal(key, rec)\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     * @returns {Promise<void>}\n     */\n    async put (key, value, options = {}) {\n      dht._log('PutValue %b', key)\n\n      // create record in the dht format\n      const record = await utils.createPutRecord(key, value)\n\n      // store the record locally\n      await putLocal(key, record)\n\n      // put record to the closest peers\n      let counterAll = 0\n      let counterSuccess = 0\n\n      await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {\n        try {\n          counterAll += 1\n          await dht._putValueToPeer(key, record, peer)\n          counterSuccess += 1\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err)\n        }\n      })\n\n      // verify if we were able to put to enough peers\n      const minPeers = options.minPeers || counterAll // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS')\n        dht._log.error(error)\n        throw error\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Buffer>}\n     */\n    async get (key, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('_get %b', key)\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options)\n      const recs = vals.map((v) => v.val)\n      let i = 0\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs)\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err\n        }\n      }\n\n      const best = recs[i]\n      dht._log('GetValue %b %s', key, best)\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND')\n      }\n\n      await sendCorrectionRecord(key, vals, best)\n\n      return best\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany (key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute\n\n      dht._log('getMany %b (%s)', key, nvals)\n\n      let vals = []\n      let localRec\n\n      try {\n        localRec = await getLocal(key)\n      } catch (err) {\n        if (nvals === 0) {\n          throw err\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerId\n        })\n      }\n\n      if (vals.length >= nvals) {\n        return vals\n      }\n\n      const paths = []\n      const id = await utils.convertBuffer(key)\n      const rtp = dht.routingTable.closestPeers(id, this.kBucketSize)\n\n      dht._log('peers in rt: %d', rtp.length)\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!'\n\n        dht._log.error(errMsg)\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE')\n        }\n        return vals\n      }\n\n      // we have peers, lets do the actual query to them\n      const query = new Query(dht, key, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - vals.length, numPaths)\n        const pathVals = []\n        paths.push(pathVals)\n\n        // Here we return the query function to use on this particular disjoint path\n        return async (peer) => {\n          let rec, peers, lookupErr\n          try {\n            const results = await dht._getValueOrPeers(peer, key)\n            rec = results.record\n            peers = results.peers\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err\n            }\n            lookupErr = err\n          }\n\n          const res = { closerPeers: peers }\n\n          if ((rec && rec.value) || lookupErr) {\n            pathVals.push({\n              val: rec && rec.value,\n              from: peer\n            })\n          }\n\n          // enough is enough\n          if (pathVals.length >= pathSize) {\n            res.pathComplete = true\n          }\n\n          return res\n        }\n      })\n\n      let error\n      try {\n        await pTimeout(query.run(rtp), options.timeout)\n      } catch (err) {\n        error = err\n      }\n      query.stop()\n\n      // combine vals from each path\n      vals = [].concat.apply(vals, paths).slice(0, nvals)\n\n      if (error && vals.length === 0) {\n        throw error\n      }\n\n      return vals\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}