{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar sha = require('multihashing-async/src/sha');\n\nvar protobuf = require('protons');\n\nvar multibase = require('multibase');\n\nvar errcode = require('err-code');\n\nvar crypto = require('./ed25519');\n\nvar pbm = protobuf(require('./keys.proto'));\n\nvar Ed25519PublicKey = /*#__PURE__*/function () {\n  function Ed25519PublicKey(key) {\n    _classCallCheck(this, Ed25519PublicKey);\n\n    this._key = ensureKey(key, crypto.publicKeyLength);\n  }\n\n  _createClass(Ed25519PublicKey, [{\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data, sig) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", crypto.hashAndVerify(this._key, sig, data));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function verify(_x, _x2) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return Buffer.from(this._key);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", sha.multihashing(this.bytes, 'sha2-256'));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function hash() {\n        return _hash.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PublicKey.encode({\n        Type: pbm.KeyType.Ed25519,\n        Data: this.marshal()\n      });\n    }\n  }]);\n\n  return Ed25519PublicKey;\n}();\n\nvar Ed25519PrivateKey = /*#__PURE__*/function () {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  function Ed25519PrivateKey(key, publicKey) {\n    _classCallCheck(this, Ed25519PrivateKey);\n\n    this._key = ensureKey(key, crypto.privateKeyLength);\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength);\n  }\n\n  _createClass(Ed25519PrivateKey, [{\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(message) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", crypto.hashAndSign(this._key, message));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sign(_x3) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)]);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n  }, {\n    key: \"hash\",\n    value: function () {\n      var _hash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", sha.multihashing(this.bytes, 'sha2-256'));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function hash() {\n        return _hash2.apply(this, arguments);\n      }\n\n      return hash;\n    }()\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @returns {Promise<String>}\n     */\n\n  }, {\n    key: \"id\",\n    value: function () {\n      var _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var hash;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.public.hash();\n\n              case 2:\n                hash = _context5.sent;\n                return _context5.abrupt(\"return\", multibase.encode('base58btc', hash).toString().slice(1));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function id() {\n        return _id.apply(this, arguments);\n      }\n\n      return id;\n    }()\n  }, {\n    key: \"public\",\n    get: function get() {\n      return new Ed25519PublicKey(this._publicKey);\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      return pbm.PrivateKey.encode({\n        Type: pbm.KeyType.Ed25519,\n        Data: this.marshal()\n      });\n    }\n  }]);\n\n  return Ed25519PrivateKey;\n}();\n\nfunction unmarshalEd25519PrivateKey(bytes) {\n  bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength);\n  var privateKeyBytes = bytes.slice(0, crypto.privateKeyLength);\n  var publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length);\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);\n}\n\nfunction unmarshalEd25519PublicKey(bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength);\n  return new Ed25519PublicKey(bytes);\n}\n\nfunction generateKeyPair() {\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction _generateKeyPair() {\n  _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var _yield$crypto$generat, privateKey, publicKey;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return crypto.generateKey();\n\n          case 2:\n            _yield$crypto$generat = _context6.sent;\n            privateKey = _yield$crypto$generat.privateKey;\n            publicKey = _yield$crypto$generat.publicKey;\n            return _context6.abrupt(\"return\", new Ed25519PrivateKey(privateKey, publicKey));\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _generateKeyPair.apply(this, arguments);\n}\n\nfunction generateKeyPairFromSeed(_x4) {\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n\nfunction _generateKeyPairFromSeed() {\n  _generateKeyPairFromSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(seed) {\n    var _yield$crypto$generat2, privateKey, publicKey;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return crypto.generateKeyFromSeed(seed);\n\n          case 2:\n            _yield$crypto$generat2 = _context7.sent;\n            privateKey = _yield$crypto$generat2.privateKey;\n            publicKey = _yield$crypto$generat2.publicKey;\n            return _context7.abrupt(\"return\", new Ed25519PrivateKey(privateKey, publicKey));\n\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _generateKeyPairFromSeed.apply(this, arguments);\n}\n\nfunction ensureKey(key, length) {\n  if (Buffer.isBuffer(key)) {\n    key = new Uint8Array(key);\n  }\n\n  if (!(key instanceof Uint8Array) || key.length !== length) {\n    throw errcode(new Error('Key must be a Uint8Array or Buffer of length ' + length), 'ERR_INVALID_KEY_TYPE');\n  }\n\n  return key;\n}\n\nmodule.exports = {\n  Ed25519PublicKey: Ed25519PublicKey,\n  Ed25519PrivateKey: Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey: unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey: unmarshalEd25519PublicKey,\n  generateKeyPair: generateKeyPair,\n  generateKeyPairFromSeed: generateKeyPairFromSeed\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/ed25519-class.js"],"names":["require","Buffer","sha","protobuf","multibase","errcode","crypto","pbm","Ed25519PublicKey","key","_key","ensureKey","publicKeyLength","data","sig","hashAndVerify","from","bytes","equals","multihashing","PublicKey","encode","Type","KeyType","Ed25519","Data","marshal","Ed25519PrivateKey","publicKey","privateKeyLength","_publicKey","message","hashAndSign","concat","public","hash","toString","slice","PrivateKey","unmarshalEd25519PrivateKey","privateKeyBytes","publicKeyBytes","length","unmarshalEd25519PublicKey","generateKeyPair","generateKey","privateKey","generateKeyPairFromSeed","seed","generateKeyFromSeed","isBuffer","Uint8Array","Error","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst sha = require('multihashing-async/src/sha')\nconst protobuf = require('protons')\nconst multibase = require('multibase')\nconst errcode = require('err-code')\n\nconst crypto = require('./ed25519')\nconst pbm = protobuf(require('./keys.proto'))\n\nclass Ed25519PublicKey {\n  constructor (key) {\n    this._key = ensureKey(key, crypto.publicKeyLength)\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return Buffer.from(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n}\n\nclass Ed25519PrivateKey {\n  // key       - 64 byte Uint8Array or Buffer containing private key\n  // publicKey - 32 byte Uint8Array or Buffer containing public key\n  constructor (key, publicKey) {\n    this._key = ensureKey(key, crypto.privateKeyLength)\n    this._publicKey = ensureKey(publicKey, crypto.publicKeyLength)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    return new Ed25519PublicKey(this._publicKey)\n  }\n\n  marshal () {\n    return Buffer.concat([Buffer.from(this._key), Buffer.from(this._publicKey)])\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.Ed25519,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return multibase.encode('base58btc', hash).toString().slice(1)\n  }\n}\n\nfunction unmarshalEd25519PrivateKey (bytes) {\n  bytes = ensureKey(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n  const privateKeyBytes = bytes.slice(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.slice(crypto.privateKeyLength, bytes.length)\n  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes)\n}\n\nfunction unmarshalEd25519PublicKey (bytes) {\n  bytes = ensureKey(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKey(bytes)\n}\n\nasync function generateKeyPair () {\n  const { privateKey, publicKey } = await crypto.generateKey()\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nasync function generateKeyPairFromSeed (seed) {\n  const { privateKey, publicKey } = await crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKey(privateKey, publicKey)\n}\n\nfunction ensureKey (key, length) {\n  if (Buffer.isBuffer(key)) {\n    key = new Uint8Array(key)\n  }\n  if (!(key instanceof Uint8Array) || key.length !== length) {\n    throw errcode(new Error('Key must be a Uint8Array or Buffer of length ' + length), 'ERR_INVALID_KEY_TYPE')\n  }\n  return key\n}\n\nmodule.exports = {\n  Ed25519PublicKey,\n  Ed25519PrivateKey,\n  unmarshalEd25519PrivateKey,\n  unmarshalEd25519PublicKey,\n  generateKeyPair,\n  generateKeyPairFromSeed\n}\n"]},"metadata":{},"sourceType":"script"}