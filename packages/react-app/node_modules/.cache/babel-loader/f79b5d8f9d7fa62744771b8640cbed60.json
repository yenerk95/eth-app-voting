{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst findShardCid = require('../../utils/find-cid-in-shard');\n\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\n\nconst contentExporters = {\n  raw: require('./content/file'),\n  file: require('./content/file'),\n  directory: require('./content/directory'),\n  'hamt-sharded-directory': require('./content/hamt-sharded-directory'),\n  metadata: (cid, node, unixfs, path, resolve, depth, ipld) => {},\n  symlink: (cid, node, unixfs, path, resolve, depth, ipld) => {}\n};\n\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, ipld, options) => {\n  const node = await ipld.get(cid, options);\n  let unixfs;\n  let next;\n\n  if (!name) {\n    name = cid.toBaseEncodedString();\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n\n  if (!path) {\n    path = name;\n  }\n\n  if (toResolve.length) {\n    let linkCid;\n\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], ipld);\n    } else {\n      linkCid = findLinkCid(node, toResolve[0]);\n    }\n\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n    } // remove the path component we have resolved\n\n\n    const nextName = toResolve.shift();\n    const nextPath = `${path}/${nextName}`;\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName,\n      path: nextPath\n    };\n  }\n\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node,\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, ipld, options),\n      unixfs,\n      depth\n    },\n    next\n  };\n};\n\nmodule.exports = unixFsResolver;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js"],"names":["errCode","require","UnixFS","findShardCid","findLinkCid","node","name","link","Links","find","Name","Hash","contentExporters","raw","file","directory","metadata","cid","unixfs","path","resolve","depth","ipld","symlink","unixFsResolver","toResolve","options","get","next","toBaseEncodedString","unmarshal","Data","err","length","linkCid","type","Error","nextName","shift","nextPath","entry","content","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,+BAAD,CAA5B;;AAEA,MAAMG,WAAW,GAAG,CAACC,IAAD,EAAOC,IAAP,KAAgB;AAClC,QAAMC,IAAI,GAAGF,IAAI,CAACG,KAAL,CAAWC,IAAX,CAAgBF,IAAI,IAAIA,IAAI,CAACG,IAAL,KAAcJ,IAAtC,CAAb;AAEA,SAAOC,IAAI,IAAIA,IAAI,CAACI,IAApB;AACD,CAJD;;AAMA,MAAMC,gBAAgB,GAAG;AACvBC,EAAAA,GAAG,EAAEZ,OAAO,CAAC,gBAAD,CADW;AAEvBa,EAAAA,IAAI,EAAEb,OAAO,CAAC,gBAAD,CAFU;AAGvBc,EAAAA,SAAS,EAAEd,OAAO,CAAC,qBAAD,CAHK;AAIvB,4BAA0BA,OAAO,CAAC,kCAAD,CAJV;AAKvBe,EAAAA,QAAQ,EAAE,CAACC,GAAD,EAAMZ,IAAN,EAAYa,MAAZ,EAAoBC,IAApB,EAA0BC,OAA1B,EAAmCC,KAAnC,EAA0CC,IAA1C,KAAmD,CAAE,CALxC;AAMvBC,EAAAA,OAAO,EAAE,CAACN,GAAD,EAAMZ,IAAN,EAAYa,MAAZ,EAAoBC,IAApB,EAA0BC,OAA1B,EAAmCC,KAAnC,EAA0CC,IAA1C,KAAmD,CAAE;AANvC,CAAzB;;AASA,MAAME,cAAc,GAAG,OAAOP,GAAP,EAAYX,IAAZ,EAAkBa,IAAlB,EAAwBM,SAAxB,EAAmCL,OAAnC,EAA4CC,KAA5C,EAAmDC,IAAnD,EAAyDI,OAAzD,KAAqE;AAC1F,QAAMrB,IAAI,GAAG,MAAMiB,IAAI,CAACK,GAAL,CAASV,GAAT,EAAcS,OAAd,CAAnB;AACA,MAAIR,MAAJ;AACA,MAAIU,IAAJ;;AAEA,MAAI,CAACtB,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAGW,GAAG,CAACY,mBAAJ,EAAP;AACD;;AAED,MAAI;AACFX,IAAAA,MAAM,GAAGhB,MAAM,CAAC4B,SAAP,CAAiBzB,IAAI,CAAC0B,IAAtB,CAAT;AACD,GAFD,CAEE,OAAOC,GAAP,EAAY;AACZ;AACA,UAAMhC,OAAO,CAACgC,GAAD,EAAM,gBAAN,CAAb;AACD;;AAED,MAAI,CAACb,IAAL,EAAW;AACTA,IAAAA,IAAI,GAAGb,IAAP;AACD;;AAED,MAAImB,SAAS,CAACQ,MAAd,EAAsB;AACpB,QAAIC,OAAJ;;AAEA,QAAIhB,MAAM,IAAIA,MAAM,CAACiB,IAAP,KAAgB,wBAA9B,EAAwD;AACtD;AACAD,MAAAA,OAAO,GAAG,MAAM/B,YAAY,CAACE,IAAD,EAAOoB,SAAS,CAAC,CAAD,CAAhB,EAAqBH,IAArB,CAA5B;AACD,KAHD,MAGO;AACLY,MAAAA,OAAO,GAAG9B,WAAW,CAACC,IAAD,EAAOoB,SAAS,CAAC,CAAD,CAAhB,CAArB;AACD;;AAED,QAAI,CAACS,OAAL,EAAc;AACZ,YAAMlC,OAAO,CAAC,IAAIoC,KAAJ,CAAU,qBAAV,CAAD,EAAmC,eAAnC,CAAb;AACD,KAZmB,CAcpB;;;AACA,UAAMC,QAAQ,GAAGZ,SAAS,CAACa,KAAV,EAAjB;AACA,UAAMC,QAAQ,GAAI,GAAEpB,IAAK,IAAGkB,QAAS,EAArC;AAEAT,IAAAA,IAAI,GAAG;AACLX,MAAAA,GAAG,EAAEiB,OADA;AAELT,MAAAA,SAFK;AAGLnB,MAAAA,IAAI,EAAE+B,QAHD;AAILlB,MAAAA,IAAI,EAAEoB;AAJD,KAAP;AAMD;;AAED,SAAO;AACLC,IAAAA,KAAK,EAAE;AACLlC,MAAAA,IADK;AAELa,MAAAA,IAFK;AAGLF,MAAAA,GAHK;AAILZ,MAAAA,IAJK;AAKLoC,MAAAA,OAAO,EAAE7B,gBAAgB,CAACM,MAAM,CAACiB,IAAR,CAAhB,CAA8BlB,GAA9B,EAAmCZ,IAAnC,EAAyCa,MAAzC,EAAiDC,IAAjD,EAAuDC,OAAvD,EAAgEC,KAAhE,EAAuEC,IAAvE,EAA6EI,OAA7E,CALJ;AAMLR,MAAAA,MANK;AAOLG,MAAAA;AAPK,KADF;AAULO,IAAAA;AAVK,GAAP;AAYD,CA1DD;;AA4DAc,MAAM,CAACC,OAAP,GAAiBnB,cAAjB","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst UnixFS = require('ipfs-unixfs')\nconst findShardCid = require('../../utils/find-cid-in-shard')\n\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link && link.Hash\n}\n\nconst contentExporters = {\n  raw: require('./content/file'),\n  file: require('./content/file'),\n  directory: require('./content/directory'),\n  'hamt-sharded-directory': require('./content/hamt-sharded-directory'),\n  metadata: (cid, node, unixfs, path, resolve, depth, ipld) => {},\n  symlink: (cid, node, unixfs, path, resolve, depth, ipld) => {}\n}\n\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, ipld, options) => {\n  const node = await ipld.get(cid, options)\n  let unixfs\n  let next\n\n  if (!name) {\n    name = cid.toBaseEncodedString()\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS')\n  }\n\n  if (!path) {\n    path = name\n  }\n\n  if (toResolve.length) {\n    let linkCid\n\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], ipld)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName,\n      path: nextPath\n    }\n  }\n\n  return {\n    entry: {\n      name,\n      path,\n      cid,\n      node,\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, ipld, options),\n      unixfs,\n      depth\n    },\n    next\n  }\n}\n\nmodule.exports = unixFsResolver\n"]},"metadata":{},"sourceType":"script"}