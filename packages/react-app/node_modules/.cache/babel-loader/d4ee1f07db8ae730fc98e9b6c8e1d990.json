{"ast":null,"code":"'use strict';\n\nconst {\n  Adapter,\n  Errors\n} = require('interface-datastore');\n\nconst log = require('debug')('datastore:core:tiered');\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nclass TieredDatastore extends Adapter {\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n\n  async open() {\n    try {\n      await Promise.all(this.stores.map(store => store.open()));\n    } catch (err) {\n      throw Errors.dbOpenFailedError();\n    }\n  }\n\n  async put(key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)));\n    } catch (err) {\n      throw Errors.dbWriteFailedError();\n    }\n  }\n\n  async get(key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options);\n        if (res) return res;\n      } catch (err) {\n        log(err);\n      }\n    }\n\n    throw Errors.notFoundError();\n  }\n\n  async has(key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async delete(key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)));\n    } catch (err) {\n      throw Errors.dbDeleteFailedError();\n    }\n  }\n\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async options => {\n        for (const batch of batches) {\n          await batch.commit(options);\n        }\n      }\n    };\n  }\n\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n\n}\n\nmodule.exports = TieredDatastore;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-core/src/tiered.js"],"names":["Adapter","Errors","require","log","TieredDatastore","constructor","stores","slice","open","Promise","all","map","store","err","dbOpenFailedError","put","key","value","dbWriteFailedError","get","options","res","notFoundError","has","s","delete","dbDeleteFailedError","close","batch","batches","forEach","b","commit","query","q","length","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Adapter, Errors } = require('interface-datastore')\nconst log = require('debug')('datastore:core:tiered')\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\nclass TieredDatastore extends Adapter {\n  constructor (stores) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async open () {\n    try {\n      await Promise.all(this.stores.map((store) => store.open()))\n    } catch (err) {\n      throw Errors.dbOpenFailedError()\n    }\n  }\n\n  async put (key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)))\n    } catch (err) {\n      throw Errors.dbWriteFailedError()\n    }\n  }\n\n  async get (key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n        if (res) return res\n      } catch (err) {\n        log(err)\n      }\n    }\n    throw Errors.notFoundError()\n  }\n\n  async has (key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  async delete (key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)))\n    } catch (err) {\n      throw Errors.dbDeleteFailedError()\n    }\n  }\n\n  async close () {\n    await Promise.all(this.stores.map(store => store.close()))\n  }\n\n  batch () {\n    const batches = this.stores.map(store => store.batch())\n\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value))\n      },\n      delete: (key) => {\n        batches.forEach(b => b.delete(key))\n      },\n      commit: async (options) => {\n        for (const batch of batches) {\n          await batch.commit(options)\n        }\n      }\n    }\n  }\n\n  query (q, options) {\n    return this.stores[this.stores.length - 1].query(q, options)\n  }\n}\n\nmodule.exports = TieredDatastore\n"]},"metadata":{},"sourceType":"script"}