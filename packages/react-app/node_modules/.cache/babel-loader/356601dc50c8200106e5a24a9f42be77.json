{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst LatencyMonitor = require('./latency-monitor');\n\nconst debug = require('debug')('libp2p:connection-manager');\n\nconst retimer = require('retimer');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors');\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n/**\n * Responsible for managing known connections.\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\n\nclass ConnectionManager extends EventEmitter {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   */\n  constructor(libp2p, options) {\n    super();\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId.toB58String();\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    debug('options: %j', this._options);\n    this._libp2p = libp2p;\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     * @type {Map<string, number>}\n     */\n\n    this._peerValues = new Map();\n    /**\n     * Map of connections per peer\n     * @type {Map<string, Array<conn>>}\n     */\n\n    this.connections = new Map();\n    this._timer = null;\n    this._checkMetrics = this._checkMetrics.bind(this);\n  }\n  /**\n   * Get current number of open connections.\n   */\n\n\n  get size() {\n    return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  start() {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n    } // latency monitor\n\n\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    });\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n    this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n    debug('started');\n  }\n  /**\n   * Stops the Connection Manager\n   * @async\n   */\n\n\n  async stop() {\n    this._timer && this._timer.clear();\n    this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n    await this._close();\n    debug('stopped');\n  }\n  /**\n   * Cleans up the connections\n   * @async\n   */\n\n\n  async _close() {\n    // Close all connections we're tracking\n    const tasks = [];\n\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close());\n      }\n    }\n\n    await tasks;\n    this.connections.clear();\n  }\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   * @param {PeerId} peerId\n   * @param {number} value A number between 0 and 1\n   */\n\n\n  setPeerValue(peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1');\n    }\n\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String();\n    }\n\n    this._peerValues.set(peerId, value);\n  }\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   * @private\n   */\n\n\n  _checkMetrics() {\n    const movingAverages = this._libp2p.metrics.global.movingAverages;\n\n    const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n    this._checkLimit('maxReceivedData', received);\n\n    const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n    this._checkLimit('maxSentData', sent);\n\n    const total = received + sent;\n\n    this._checkLimit('maxData', total);\n\n    debug('metrics update', total);\n\n    this._timer.reschedule(this._options.pollInterval);\n  }\n  /**\n   * Tracks the incoming connection and check the connection limit\n   * @param {Connection} connection\n   */\n\n\n  onConnect(connection) {\n    const peerId = connection.remotePeer;\n    const peerIdStr = peerId.toB58String();\n    const storedConn = this.connections.get(peerIdStr);\n    this.emit('peer:connect', connection);\n\n    if (storedConn) {\n      storedConn.push(connection);\n    } else {\n      this.connections.set(peerIdStr, [connection]);\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue);\n    }\n\n    this._checkLimit('maxConnections', this.size);\n  }\n  /**\n   * Removes the connection from tracking\n   * @param {Connection} connection\n   */\n\n\n  onDisconnect(connection) {\n    const peerId = connection.remotePeer.toB58String();\n    let storedConn = this.connections.get(peerId);\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter(conn => conn.id !== connection.id);\n      this.connections.set(peerId, storedConn);\n    } else if (storedConn) {\n      this.connections.delete(peerId);\n\n      this._peerValues.delete(connection.remotePeer.toB58String());\n\n      this.emit('peer:disconnect', connection);\n    }\n  }\n  /**\n   * Get a connection with a peer.\n   * @param {PeerId} peerId\n   * @returns {Connection}\n   */\n\n\n  get(peerId) {\n    const connections = this.getAll(peerId);\n\n    if (connections.length) {\n      return connections[0];\n    }\n\n    return null;\n  }\n  /**\n   * Get all open connections with a peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Connection>}\n   */\n\n\n  getAll(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerId.toB58String();\n    const connections = this.connections.get(id); // Return all open connections\n\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open');\n    }\n\n    return [];\n  }\n  /**\n   * If the event loop is slow, maybe close a connection\n   * @private\n   * @param {*} summary The LatencyMonitor summary\n   */\n\n\n  _onLatencyMeasure(summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs);\n  }\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   * @private\n   * @param {string} name The name of the field to check limits for\n   * @param {number} value The current value of the field\n   */\n\n\n  _checkLimit(name, value) {\n    const limit = this._options[name];\n    debug('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n      this._maybeDisconnectOne();\n    }\n  }\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   * @private\n   */\n\n\n  _maybeDisconnectOne() {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue);\n      debug('%s: sorted peer values: %j', this._peerId, peerValues);\n      const disconnectPeer = peerValues[0];\n\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0];\n        debug('%s: lowest value peer is %s', this._peerId, peerId);\n        debug('%s: closing a connection to %j', this._peerId, peerId);\n\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close();\n            break;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/connection-manager/index.js"],"names":["errcode","require","mergeOptions","LatencyMonitor","debug","retimer","EventEmitter","PeerId","ERR_INVALID_PARAMETERS","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","movingAverageInterval","defaultPeerValue","ConnectionManager","constructor","libp2p","options","_libp2p","_peerId","peerId","toB58String","_options","call","ignoreUndefined","Error","_peerValues","Map","connections","_timer","_checkMetrics","bind","size","Array","from","values","reduce","accumulator","value","length","start","metrics","_latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","_onLatencyMeasure","on","stop","clear","removeListener","_close","tasks","connectionList","connection","push","close","setPeerValue","set","movingAverages","global","received","dataReceived","movingAverage","_checkLimit","sent","dataSent","total","reschedule","onConnect","remotePeer","peerIdStr","storedConn","get","emit","peerStore","keyBook","pubKey","has","onDisconnect","filter","conn","id","delete","getAll","isPeerId","stat","status","summary","avgMs","name","limit","_maybeDisconnectOne","peerValues","sort","byPeerValue","disconnectPeer","module","exports","peerValueEntryA","peerValueEntryB"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst LatencyMonitor = require('./latency-monitor')\nconst debug = require('debug')('libp2p:connection-manager')\nconst retimer = require('retimer')\n\nconst { EventEmitter } = require('events')\n\nconst PeerId = require('peer-id')\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors')\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\n/**\n * Responsible for managing known connections.\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\nclass ConnectionManager extends EventEmitter {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   */\n  constructor (libp2p, options) {\n    super()\n\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId.toB58String()\n\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS)\n    }\n\n    debug('options: %j', this._options)\n\n    this._libp2p = libp2p\n\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     * @type {Map<string, number>}\n     */\n    this._peerValues = new Map()\n\n    /**\n     * Map of connections per peer\n     * @type {Map<string, Array<conn>>}\n     */\n    this.connections = new Map()\n\n    this._timer = null\n    this._checkMetrics = this._checkMetrics.bind(this)\n  }\n\n  /**\n   * Get current number of open connections.\n   */\n  get size () {\n    return Array.from(this.connections.values())\n      .reduce((accumulator, value) => accumulator + value.length, 0)\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  start () {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval)\n    }\n\n    // latency monitor\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n    debug('started')\n  }\n\n  /**\n   * Stops the Connection Manager\n   * @async\n   */\n  async stop () {\n    this._timer && this._timer.clear()\n    this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n\n    await this._close()\n    debug('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   * @async\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close())\n      }\n    }\n\n    await tasks\n    this.connections.clear()\n  }\n\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   * @param {PeerId} peerId\n   * @param {number} value A number between 0 and 1\n   */\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String()\n    }\n    this._peerValues.set(peerId, value)\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   * @private\n   */\n  _checkMetrics () {\n    const movingAverages = this._libp2p.metrics.global.movingAverages\n    const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxReceivedData', received)\n    const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage()\n    this._checkLimit('maxSentData', sent)\n    const total = received + sent\n    this._checkLimit('maxData', total)\n    debug('metrics update', total)\n    this._timer.reschedule(this._options.pollInterval)\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   * @param {Connection} connection\n   */\n  onConnect (connection) {\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toB58String()\n    const storedConn = this.connections.get(peerIdStr)\n\n    this.emit('peer:connect', connection)\n    if (storedConn) {\n      storedConn.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey)\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue)\n    }\n\n    this._checkLimit('maxConnections', this.size)\n  }\n\n  /**\n   * Removes the connection from tracking\n   * @param {Connection} connection\n   */\n  onDisconnect (connection) {\n    const peerId = connection.remotePeer.toB58String()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn) {\n      this.connections.delete(peerId)\n      this._peerValues.delete(connection.remotePeer.toB58String())\n      this.emit('peer:disconnect', connection)\n    }\n  }\n\n  /**\n   * Get a connection with a peer.\n   * @param {PeerId} peerId\n   * @returns {Connection}\n   */\n  get (peerId) {\n    const connections = this.getAll(peerId)\n    if (connections.length) {\n      return connections[0]\n    }\n    return null\n  }\n\n  /**\n   * Get all open connections with a peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Connection>}\n   */\n  getAll (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toB58String()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open')\n    }\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   * @private\n   * @param {*} summary The LatencyMonitor summary\n   */\n  _onLatencyMeasure (summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs)\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   * @private\n   * @param {string} name The name of the field to check limits for\n   * @param {number} value The current value of the field\n   */\n  _checkLimit (name, value) {\n    const limit = this._options[name]\n    debug('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      this._maybeDisconnectOne()\n    }\n  }\n\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   * @private\n   */\n  _maybeDisconnectOne () {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue)\n      debug('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        debug('%s: lowest value peer is %s', this._peerId, peerId)\n        debug('%s: closing a connection to %j', this._peerId, peerId)\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close()\n            break\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n\nfunction byPeerValue (peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1]\n}\n"]},"metadata":{},"sourceType":"script"}