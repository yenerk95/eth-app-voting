{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar loadMfsRoot = require('./with-mfs-root');\n\nvar toPathComponents = require('./to-path-components');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar errCode = require('err-code');\n\nvar IPFS_PREFIX = 'ipfs';\n\nvar toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, path, options) {\n    var outputArray, paths, root;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            outputArray = Array.isArray(path);\n            paths = Array.isArray(path) ? path : [path];\n            _context2.next = 4;\n            return loadMfsRoot(context, options);\n\n          case 4:\n            root = _context2.sent;\n            paths = paths.map(function (path) {\n              path = (path || '').trim();\n              path = path.replace(/(\\/\\/+)/g, '/');\n\n              if (path.endsWith('/') && path.length > 1) {\n                path = path.substring(0, path.length - 1);\n              }\n\n              if (!path) {\n                throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n              }\n\n              if (path.substring(0, 1) !== '/') {\n                throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n              }\n\n              if (path.substring(path.length - 1) === '/') {\n                path = path.substring(0, path.length - 1);\n              }\n\n              var pathComponents = toPathComponents(path);\n\n              if (pathComponents[0] === IPFS_PREFIX) {\n                // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n                var _mfsDirectory;\n\n                if (pathComponents.length === 2) {\n                  _mfsDirectory = \"/\".concat(pathComponents.join('/'));\n                } else {\n                  _mfsDirectory = \"/\".concat(pathComponents.slice(0, pathComponents.length - 1).join('/'));\n                }\n\n                return {\n                  type: 'ipfs',\n                  depth: pathComponents.length - 2,\n                  mfsPath: \"/\".concat(pathComponents.join('/')),\n                  mfsDirectory: _mfsDirectory,\n                  parts: pathComponents,\n                  path: \"/\".concat(pathComponents.join('/')),\n                  name: pathComponents[pathComponents.length - 1]\n                };\n              }\n\n              var mfsPath = \"/\".concat(IPFS_PREFIX, \"/\").concat(root).concat(pathComponents.length ? '/' + pathComponents.join('/') : '');\n              var mfsDirectory = \"/\".concat(IPFS_PREFIX, \"/\").concat(root, \"/\").concat(pathComponents.slice(0, pathComponents.length - 1).join('/'));\n              return {\n                type: 'mfs',\n                depth: pathComponents.length,\n                mfsDirectory: mfsDirectory,\n                mfsPath: mfsPath,\n                parts: pathComponents,\n                path: \"/\".concat(pathComponents.join('/')),\n                name: pathComponents[pathComponents.length - 1]\n              };\n            });\n            _context2.next = 8;\n            return Promise.all(paths.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path) {\n                var cidPath, res;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return exporter(cidPath, context.ipld);\n\n                      case 4:\n                        res = _context.sent;\n                        path.cid = res.cid;\n                        path.mfsPath = \"/ipfs/\".concat(res.path);\n                        path.unixfs = res.unixfs;\n                        path.content = res.content;\n                        _context.next = 15;\n                        break;\n\n                      case 11:\n                        _context.prev = 11;\n                        _context.t0 = _context[\"catch\"](1);\n\n                        if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n                          _context.next = 15;\n                          break;\n                        }\n\n                        throw _context.t0;\n\n                      case 15:\n                        path.exists = Boolean(path.cid);\n\n                      case 16:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 11]]);\n              }));\n\n              return function (_x4) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 8:\n            if (!outputArray) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", paths);\n\n          case 10:\n            return _context2.abrupt(\"return\", paths[0]);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function toMfsPath(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = toMfsPath;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/utils/to-mfs-path.js"],"names":["loadMfsRoot","require","toPathComponents","exporter","errCode","IPFS_PREFIX","toMfsPath","context","path","options","outputArray","Array","isArray","paths","root","map","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","Promise","all","cidPath","ipld","res","cid","unixfs","content","code","exists","Boolean","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst exporter = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\n\nconst IPFS_PREFIX = 'ipfs'\n\nconst toMfsPath = async (context, path, options) => {\n  const outputArray = Array.isArray(path)\n  let paths = Array.isArray(path) ? path : [path]\n  const root = await loadMfsRoot(context, options)\n\n  paths = paths.map(path => {\n    path = (path || '').trim()\n    path = path.replace(/(\\/\\/+)/g, '/')\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1)\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(path.length - 1) === '/') {\n      path = path.substring(0, path.length - 1)\n    }\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      }\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  })\n\n  await Promise.all(\n    paths.map(async (path) => {\n      const cidPath = path.type === 'mfs' ? path.mfsPath : path.path\n\n      try {\n        const res = await exporter(cidPath, context.ipld)\n\n        path.cid = res.cid\n        path.mfsPath = `/ipfs/${res.path}`\n        path.unixfs = res.unixfs\n        path.content = res.content\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      path.exists = Boolean(path.cid)\n    })\n  )\n\n  if (outputArray) {\n    return paths\n  }\n\n  return paths[0]\n}\n\nmodule.exports = toMfsPath\n"]},"metadata":{},"sourceType":"script"}