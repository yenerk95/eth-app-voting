{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst {\n  normalizeCidPath\n} = require('../../utils');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n\nmodule.exports = function ({\n  ipld,\n  resolve,\n  preload\n}) {\n  return withTimeoutOption(async function* refs(ipfsPath, options) {\n    // eslint-disable-line require-await\n    options = options || {};\n\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      yield* refsStream(resolve, ipld, path, options);\n    }\n  });\n};\n\nmodule.exports.Format = Format;\n\nfunction getFullPath(preload, ipfsPath, options) {\n  // normalizeCidPath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizeCidPath(ipfsPath);\n  const pathComponents = path.split('/');\n  const cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`);\n  }\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nasync function* refsStream(resolve, ipld, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path); // path is /ipfs/<cid>\n\n  const parts = resPath.split('/');\n  const cid = parts[2]; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(ipld, cid, options.maxDepth, options.unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n} // Get formatted link\n\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nasync function* objectStream(ipld, rootCid, maxDepth, uniqueOnly) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for (const link of await getLinks(ipld, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n} // Fetch a node from IPLD then get all its links\n\n\nasync function getLinks(ipld, cid) {\n  const node = await ipld.get(new CID(cid));\n\n  if (DAGNode.isDAGNode(node)) {\n    return node.Links.map(({\n      Name,\n      Hash\n    }) => ({\n      name: Name,\n      cid: new CID(Hash)\n    }));\n  }\n\n  return getNodeLinks(node);\n} // Recursively search the node for CIDs\n\n\nfunction getNodeLinks(node, path = '') {\n  let links = [];\n\n  for (const [name, value] of Object.entries(node)) {\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/refs/index.js"],"names":["isIpfs","require","CID","DAGNode","normalizeCidPath","Errors","ERR_NOT_FOUND","notFoundError","code","withTimeoutOption","Format","default","edges","module","exports","ipld","resolve","preload","refs","ipfsPath","options","maxDepth","format","Error","recursive","Infinity","rawPaths","Array","isArray","paths","map","p","getFullPath","path","refsStream","pathComponents","split","cid","resPath","parts","obj","objectStream","unique","parent","isDuplicate","ref","formatLink","node","name","srcCid","dstCid","linkName","out","replace","toString","rootCid","uniqueOnly","seen","Set","traverseLevel","depth","nextLevelDepth","link","getLinks","has","add","err","message","get","isDAGNode","Links","Name","Hash","getNodeLinks","links","value","Object","entries","isCID","push","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst { DAGNode } = require('ipld-dag-pb')\nconst { normalizeCidPath } = require('../../utils')\nconst { Errors } = require('interface-datastore')\nconst ERR_NOT_FOUND = Errors.notFoundError().code\nconst { withTimeoutOption } = require('../../utils')\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n}\n\nmodule.exports = function ({ ipld, resolve, preload }) {\n  return withTimeoutOption(async function * refs (ipfsPath, options) { // eslint-disable-line require-await\n    options = options || {}\n\n    if (options.maxDepth === 0) {\n      return\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format')\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1\n    }\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath]\n    const paths = rawPaths.map(p => getFullPath(preload, p, options))\n\n    for (const path of paths) {\n      yield * refsStream(resolve, ipld, path, options)\n    }\n  })\n}\n\nmodule.exports.Format = Format\n\nfunction getFullPath (preload, ipfsPath, options) {\n  // normalizeCidPath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizeCidPath(ipfsPath)\n  const pathComponents = path.split('/')\n  const cid = pathComponents[0]\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`)\n  }\n\n  if (options.preload !== false) {\n    preload(cid)\n  }\n\n  return '/ipfs/' + path\n}\n\n// Get a stream of refs at the given path\nasync function * refsStream (resolve, ipld, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path)\n  // path is /ipfs/<cid>\n  const parts = resPath.split('/')\n  const cid = parts[2]\n\n  // Traverse the DAG, converting it into a stream\n  for await (const obj of objectStream(ipld, cid, options.maxDepth, options.unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue\n    }\n\n    // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n    if (obj.isDuplicate) {\n      continue\n    }\n\n    // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    }\n  }\n}\n\n// Get formatted link\nfunction formatLink (srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString())\n  out = out.replace(/<dst>/g, dstCid.toString())\n  out = out.replace(/<linkname>/g, linkName)\n  return out\n}\n\n// Do a depth first search of the DAG, starting from the given root cid\nasync function * objectStream (ipld, rootCid, maxDepth, uniqueOnly) { // eslint-disable-line require-await\n  const seen = new Set()\n\n  async function * traverseLevel (parent, depth) {\n    const nextLevelDepth = depth + 1\n\n    // Check the depth\n    if (nextLevelDepth > maxDepth) {\n      return\n    }\n\n    // Get this object's links\n    try {\n      // Look at each link, parent and the new depth\n      for (const link of await getLinks(ipld, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        }\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString())\n        }\n\n        yield * traverseLevel(link, nextLevelDepth)\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`\n      }\n\n      throw err\n    }\n  }\n\n  yield * traverseLevel({ cid: rootCid }, 0)\n}\n\n// Fetch a node from IPLD then get all its links\nasync function getLinks (ipld, cid) {\n  const node = await ipld.get(new CID(cid))\n\n  if (DAGNode.isDAGNode(node)) {\n    return node.Links.map(({ Name, Hash }) => ({ name: Name, cid: new CID(Hash) }))\n  }\n\n  return getNodeLinks(node)\n}\n\n// Recursively search the node for CIDs\nfunction getNodeLinks (node, path = '') {\n  let links = []\n  for (const [name, value] of Object.entries(node)) {\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      })\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'))\n    }\n  }\n  return links\n}\n"]},"metadata":{},"sourceType":"script"}