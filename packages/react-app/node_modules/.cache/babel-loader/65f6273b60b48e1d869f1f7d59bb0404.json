{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar parseDuration = require('parse-duration');\n\nvar Key = require('interface-datastore').Key;\n\nvar _require2 = require('./errors'),\n    TimeoutError = _require2.TimeoutError;\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n};\nexports.MFS_ROOT_KEY = new Key('/local/filesroot');\nexports.MFS_MAX_CHUNK_SIZE = 262144;\nexports.MFS_MAX_LINKS = 174;\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  var matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw new Error('invalid ipfs ref path');\n  }\n\n  var _matched$1$split = matched[1].split('/'),\n      _matched$1$split2 = _toArray(_matched$1$split),\n      hash = _matched$1$split2[0],\n      links = _matched$1$split2.slice(1); // check that a CID can be constructed with the hash\n\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash: hash,\n      links: links\n    };\n  } else {\n    throw new Error('invalid ipfs ref path');\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nvar normalizePath = function normalizePath(pathStr) {\n  if (isIpfs.cid(pathStr)) {\n    return \"/ipfs/\".concat(new CID(pathStr));\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(\"invalid path: \".concat(pathStr)), {\n      code: ERR_BAD_PATH\n    });\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n\n\nvar normalizeCidPath = function normalizeCidPath(path) {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param {Dag} dag The IPFS dag api\n * @param {Array<CID|string>} ipfsPaths A single or collection of ipfs-paths\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {Promise<Array<CID>>}\n */\n\n\nvar resolvePath = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dag, ipfsPaths, options) {\n    var cids, _iterator2, _step2, path, _parseIpfsPath, hash, links, cid, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, _value2, value, linkName;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = options || {};\n\n            if (!Array.isArray(ipfsPaths)) {\n              ipfsPaths = [ipfsPaths];\n            }\n\n            cids = [];\n            _iterator2 = _createForOfIteratorHelper(ipfsPaths);\n            _context.prev = 4;\n\n            _iterator2.s();\n\n          case 6:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 59;\n              break;\n            }\n\n            path = _step2.value;\n\n            if (!isIpfs.cid(path)) {\n              _context.next = 11;\n              break;\n            }\n\n            cids.push(new CID(path));\n            return _context.abrupt(\"continue\", 57);\n\n          case 11:\n            _parseIpfsPath = parseIpfsPath(path), hash = _parseIpfsPath.hash, links = _parseIpfsPath.links;\n\n            if (links.length) {\n              _context.next = 15;\n              break;\n            }\n\n            cids.push(new CID(hash));\n            return _context.abrupt(\"continue\", 57);\n\n          case 15:\n            cid = new CID(hash);\n            _context.prev = 16;\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 19;\n            _iterator = _asyncIterator(dag.resolve(path, options));\n\n          case 21:\n            _context.next = 23;\n            return _iterator.next();\n\n          case 23:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 27;\n            return _step.value;\n\n          case 27:\n            _value = _context.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context.next = 34;\n              break;\n            }\n\n            _value2 = _value, value = _value2.value;\n\n            if (CID.isCID(value)) {\n              cid = value;\n            }\n\n          case 31:\n            _iteratorNormalCompletion = true;\n            _context.next = 21;\n            break;\n\n          case 34:\n            _context.next = 40;\n            break;\n\n          case 36:\n            _context.prev = 36;\n            _context.t0 = _context[\"catch\"](19);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 40:\n            _context.prev = 40;\n            _context.prev = 41;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context.next = 45;\n              break;\n            }\n\n            _context.next = 45;\n            return _iterator.return();\n\n          case 45:\n            _context.prev = 45;\n\n            if (!_didIteratorError) {\n              _context.next = 48;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 48:\n            return _context.finish(45);\n\n          case 49:\n            return _context.finish(40);\n\n          case 50:\n            _context.next = 56;\n            break;\n\n          case 52:\n            _context.prev = 52;\n            _context.t1 = _context[\"catch\"](16);\n\n            // TODO: add error codes to IPLD\n            if (_context.t1.message.startsWith('Object has no property')) {\n              linkName = _context.t1.message.replace('Object has no property \\'', '').slice(0, -1);\n              _context.t1.message = \"no link named \\\"\".concat(linkName, \"\\\" under \").concat(cid);\n              _context.t1.code = 'ERR_NO_LINK';\n            }\n\n            throw _context.t1;\n\n          case 56:\n            cids.push(cid);\n\n          case 57:\n            _context.next = 6;\n            break;\n\n          case 59:\n            _context.next = 64;\n            break;\n\n          case 61:\n            _context.prev = 61;\n            _context.t2 = _context[\"catch\"](4);\n\n            _iterator2.e(_context.t2);\n\n          case 64:\n            _context.prev = 64;\n\n            _iterator2.f();\n\n            return _context.finish(64);\n\n          case 67:\n            return _context.abrupt(\"return\", cids);\n\n          case 68:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 61, 64, 67], [16, 52], [19, 36, 40, 50], [41,, 45, 49]]);\n  }));\n\n  return function resolvePath(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar mapFile = function mapFile(file, options) {\n  options = options || {};\n  var output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'dir'\n  };\n\n  if (file.unixfs) {\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize();\n      output.type = 'file';\n\n      if (options.includeContent) {\n        output.content = file.content();\n      }\n    }\n\n    output.mode = file.unixfs.mode;\n    output.mtime = file.unixfs.mtime;\n  }\n\n  return output;\n};\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n    if (!options || !options.timeout) return fn.apply(void 0, args);\n    var timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n    var controller = new TimeoutController(timeout);\n    options.signal = anySignal([options.signal, controller.signal]);\n    var fnRes = fn.apply(void 0, args);\n    var timeoutPromise = new Promise(function (resolve, reject) {\n      controller.signal.addEventListener('abort', function () {\n        reject(new TimeoutError());\n      });\n    });\n    var start = Date.now();\n\n    var maybeThrowTimeoutError = function maybeThrowTimeoutError() {\n      if (controller.signal.aborted) {\n        throw new TimeoutError();\n      }\n\n      var timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n\n      if (timeTaken > timeout) {\n        controller.abort();\n        throw new TimeoutError();\n      }\n    };\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var it, _yield$_awaitAsyncGen, value, done;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                it = fnRes[Symbol.asyncIterator]();\n                _context2.prev = 1;\n\n              case 2:\n                if (!true) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                _context2.next = 5;\n                return _awaitAsyncGenerator(Promise.race([it.next(), timeoutPromise]));\n\n              case 5:\n                _yield$_awaitAsyncGen = _context2.sent;\n                value = _yield$_awaitAsyncGen.value;\n                done = _yield$_awaitAsyncGen.done;\n\n                if (!done) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 15);\n\n              case 10:\n                maybeThrowTimeoutError();\n                _context2.next = 13;\n                return value;\n\n              case 13:\n                _context2.next = 2;\n                break;\n\n              case 15:\n                _context2.next = 21;\n                break;\n\n              case 17:\n                _context2.prev = 17;\n                _context2.t0 = _context2[\"catch\"](1);\n                maybeThrowTimeoutError();\n                throw _context2.t0;\n\n              case 21:\n                _context2.prev = 21;\n                controller.clear();\n\n                if (it.return) {\n                  it.return();\n                }\n\n                return _context2.finish(21);\n\n              case 25:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[1, 17, 21, 25]]);\n      }))();\n    }\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return Promise.race([fnRes, timeoutPromise]);\n\n            case 3:\n              res = _context3.sent;\n              maybeThrowTimeoutError();\n              return _context3.abrupt(\"return\", res);\n\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](0);\n              maybeThrowTimeoutError();\n              throw _context3.t0;\n\n            case 12:\n              _context3.prev = 12;\n              controller.clear();\n              return _context3.finish(12);\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[0, 8, 12, 15]]);\n    }))();\n  };\n}\n\nexports.normalizePath = normalizePath;\nexports.normalizeCidPath = normalizeCidPath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;\nexports.mapFile = mapFile;\nexports.withTimeoutOption = withTimeoutOption;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/utils.js"],"names":["isIpfs","require","CID","Buffer","TimeoutController","anySignal","parseDuration","Key","TimeoutError","ERR_BAD_PATH","exports","OFFLINE_ERROR","MFS_FILE_TYPES","file","directory","MFS_ROOT_KEY","MFS_MAX_CHUNK_SIZE","MFS_MAX_LINKS","parseIpfsPath","ipfsPath","replace","matched","match","Error","split","hash","links","cid","normalizePath","pathStr","path","Object","assign","code","normalizeCidPath","isBuffer","toString","isCID","indexOf","substring","length","charAt","resolvePath","dag","ipfsPaths","options","Array","isArray","cids","push","resolve","value","message","startsWith","linkName","slice","mapFile","output","name","depth","size","type","unixfs","fileSize","includeContent","content","mode","mtime","withTimeoutOption","fn","optionsArgIndex","args","timeout","controller","signal","fnRes","timeoutPromise","Promise","reject","addEventListener","start","Date","now","maybeThrowTimeoutError","aborted","timeTaken","abort","Symbol","asyncIterator","it","race","next","done","clear","return","res"],"mappings":"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","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst { Buffer } = require('buffer')\nconst TimeoutController = require('timeout-abort-controller')\nconst anySignal = require('any-signal')\nconst parseDuration = require('parse-duration')\nconst Key = require('interface-datastore').Key\nconst { TimeoutError } = require('./errors')\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH'\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.'\n\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n}\nexports.MFS_ROOT_KEY = new Key('/local/filesroot')\nexports.MFS_MAX_CHUNK_SIZE = 262144\nexports.MFS_MAX_LINKS = 174\n\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\nfunction parseIpfsPath (ipfsPath) {\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '')\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/)\n  if (!matched) {\n    throw new Error('invalid ipfs ref path')\n  }\n\n  const [hash, ...links] = matched[1].split('/')\n\n  // check that a CID can be constructed with the hash\n  if (isIpfs.cid(hash)) {\n    return { hash, links }\n  } else {\n    throw new Error('invalid ipfs ref path')\n  }\n}\n\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\nconst normalizePath = (pathStr) => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${new CID(pathStr)}`\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr\n  } else {\n    throw Object.assign(new Error(`invalid path: ${pathStr}`), { code: ERR_BAD_PATH })\n  }\n}\n\n// TODO: do we need both normalizePath and normalizeCidPath?\nconst normalizeCidPath = (path) => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString()\n  }\n  if (CID.isCID(path)) {\n    return path.toString()\n  }\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length)\n  }\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1)\n  }\n  return path\n}\n\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param {Dag} dag The IPFS dag api\n * @param {Array<CID|string>} ipfsPaths A single or collection of ipfs-paths\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {Promise<Array<CID>>}\n */\nconst resolvePath = async function (dag, ipfsPaths, options) {\n  options = options || {}\n\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths]\n  }\n\n  const cids = []\n\n  for (const path of ipfsPaths) {\n    if (isIpfs.cid(path)) {\n      cids.push(new CID(path))\n      continue\n    }\n\n    const { hash, links } = parseIpfsPath(path)\n\n    if (!links.length) {\n      cids.push(new CID(hash))\n      continue\n    }\n\n    let cid = new CID(hash)\n    try {\n      for await (const { value } of dag.resolve(path, options)) {\n        if (CID.isCID(value)) {\n          cid = value\n        }\n      }\n    } catch (err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        const linkName = err.message.replace('Object has no property \\'', '').slice(0, -1)\n        err.message = `no link named \"${linkName}\" under ${cid}`\n        err.code = 'ERR_NO_LINK'\n      }\n      throw err\n    }\n    cids.push(cid)\n  }\n\n  return cids\n}\n\nconst mapFile = (file, options) => {\n  options = options || {}\n\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'dir'\n  }\n\n  if (file.unixfs) {\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize()\n      output.type = 'file'\n\n      if (options.includeContent) {\n        output.content = file.content()\n      }\n    }\n\n    output.mode = file.unixfs.mode\n    output.mtime = file.unixfs.mtime\n  }\n\n  return output\n}\n\nfunction withTimeoutOption (fn, optionsArgIndex) {\n  return (...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex]\n    if (!options || !options.timeout) return fn(...args)\n\n    const timeout = typeof options.timeout === 'string'\n      ? parseDuration(options.timeout)\n      : options.timeout\n\n    const controller = new TimeoutController(timeout)\n\n    options.signal = anySignal([options.signal, controller.signal])\n\n    const fnRes = fn(...args)\n    const timeoutPromise = new Promise((resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError())\n      })\n    })\n\n    const start = Date.now()\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError()\n      }\n\n      const timeTaken = Date.now() - start\n\n      // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n      if (timeTaken > timeout) {\n        controller.abort()\n        throw new TimeoutError()\n      }\n    }\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return (async function * () {\n        const it = fnRes[Symbol.asyncIterator]()\n\n        try {\n          while (true) {\n            const { value, done } = await Promise.race([it.next(), timeoutPromise])\n\n            if (done) {\n              break\n            }\n\n            maybeThrowTimeoutError()\n\n            yield value\n          }\n        } catch (err) {\n          maybeThrowTimeoutError()\n\n          throw err\n        } finally {\n          controller.clear()\n\n          if (it.return) {\n            it.return()\n          }\n        }\n      })()\n    }\n\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise])\n\n        maybeThrowTimeoutError()\n\n        return res\n      } catch (err) {\n        maybeThrowTimeoutError()\n\n        throw err\n      } finally {\n        controller.clear()\n      }\n    })()\n  }\n}\n\nexports.normalizePath = normalizePath\nexports.normalizeCidPath = normalizeCidPath\nexports.parseIpfsPath = parseIpfsPath\nexports.resolvePath = resolvePath\nexports.mapFile = mapFile\nexports.withTimeoutOption = withTimeoutOption\n"]},"metadata":{},"sourceType":"script"}