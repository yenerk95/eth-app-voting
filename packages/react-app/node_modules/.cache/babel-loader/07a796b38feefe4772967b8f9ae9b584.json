{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\n\n\nconst libp2p_pubsub_1 = require(\"libp2p-pubsub\");\n\nconst messageCache_1 = require(\"./messageCache\");\n\nconst message_1 = require(\"./message\");\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst heartbeat_1 = require(\"./heartbeat\");\n\nconst getGossipPeers_1 = require(\"./getGossipPeers\");\n\nconst utils_1 = require(\"./utils\"); // @ts-ignore\n\n\nconst TimeCache = require(\"time-cache\");\n\nconst BasicPubsub = require(\"./pubsub\");\n\nclass Gossipsub extends BasicPubsub {\n  /**\n   * @param {PeerId} peerId instance of the peer's PeerId\n   * @param {Object} registrar\n   * @param {function} registrar.handle\n   * @param {function} registrar.register\n   * @param {function} registrar.unregister\n   * @param {Object} [options]\n   * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @param {function} [options.msgIdFn] override the default message id function\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @constructor\n   */\n  constructor(peerId, registrar, options = {}) {\n    const multicodecs = [constants.GossipsubID];\n\n    const _options = Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true\n    }, options); // Also wants to get notified of peers connected using floodsub\n\n\n    if (_options.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodSubID);\n    }\n\n    super({\n      debugName: 'libp2p:gossipsub',\n      multicodecs,\n      peerId,\n      registrar,\n      options: _options\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache();\n    /**\n     * Map of topic meshes\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     *\n     * @type {Map<string, Number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     *\n     * @type {Map<Peer, Array<ControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     *\n     * @type {Map<Peer, ControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Use the overriden mesgIdFn or the default one.\n     */\n\n    this._msgIdFn = options.msgIdFn || this.defaultMsgIdFn;\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = options.messageCache || new messageCache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this._msgIdFn);\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new heartbeat_1.Heartbeat(this);\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {Peer} peer\n   * @returns {Peer}\n   */\n\n\n  _removePeer(peer) {\n    super._removePeer(peer); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.mesh.values()) {\n      peers.delete(peer);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(peer);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(peer); // Remove from control mapping\n\n    this.control.delete(peer);\n    return peer;\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @override\n   * @param {String} idB58Str\n   * @param {Peer} peer\n   * @param {RPC} rpc\n   * @returns {void}\n   */\n\n\n  _processRpc(idB58Str, peer, rpc) {\n    super._processRpc(idB58Str, peer, rpc);\n\n    if (rpc.control) {\n      this._processRpcControlMessage(peer, rpc.control);\n    }\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {Peer} peer\n   * @param {ControlMessage} controlMsg\n   * @returns {void}\n   */\n\n\n  _processRpcControlMessage(peer, controlMsg) {\n    if (!controlMsg) {\n      return;\n    }\n\n    const iwant = this._handleIHave(peer, controlMsg.ihave);\n\n    const ihave = this._handleIWant(peer, controlMsg.iwant);\n\n    const prune = this._handleGraft(peer, controlMsg.graft);\n\n    this._handlePrune(peer, controlMsg.prune);\n\n    if (!iwant || !ihave || !prune) {\n      return;\n    }\n\n    const outRpc = utils_1.createGossipRpc(ihave, {\n      iwant: [iwant],\n      prune\n    });\n\n    this._sendRpc(peer, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @override\n   * @param {Peer} peer\n   * @param {Message} msg\n   */\n\n\n  _processRpcMessage(peer, msg) {\n    const msgID = this.getMsgId(msg); // Ignore if we've already seen the message\n\n    if (this.seenCache.has(msgID)) {\n      return;\n    }\n\n    this.seenCache.put(msgID);\n\n    super._processRpcMessage(peer, msg);\n\n    const topics = msg.topicIDs; // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n\n    if (!this._options.gossipIncoming) {\n      return;\n    } // Emit to floodsub peers\n\n\n    this.peers.forEach(peer => {\n      if (peer.protocols.includes(constants.FloodSubID) && peer.id.toB58String() !== msg.from && libp2p_pubsub_1.utils.anyMatch(peer.topics, topics) && peer.isWritable) {\n        peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n        this.log('publish msg on topics - floodsub', topics, peer.id.toB58String());\n      }\n    }); // Emit to peers in the mesh\n\n    topics.forEach(topic => {\n      const meshPeers = this.mesh.get(topic);\n\n      if (!meshPeers) {\n        return;\n      }\n\n      meshPeers.forEach(peer => {\n        if (!peer.isWritable || peer.id.toB58String() === msg.from) {\n          return;\n        }\n\n        peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n        this.log('publish msg on topic - meshsub', topic, peer.id.toB58String());\n      });\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {Peer} peer\n   * @param {Array<ControlIHave>} ihave\n   * @returns {ControlIWant}\n   */\n\n\n  _handleIHave(peer, ihave) {\n    const iwant = new Set();\n    ihave.forEach(({\n      topicID,\n      messageIDs\n    }) => {\n      if (!topicID || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        if (this.seenCache.has(msgID)) {\n          return;\n        }\n\n        iwant.add(msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return;\n    }\n\n    this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.id.toB58String());\n    return {\n      messageIDs: Array.from(iwant)\n    };\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {Peer} peer\n   * @param {Array<ControlIWant>} iwant\n   * @returns {Array<Message>}\n   */\n\n\n  _handleIWant(peer, iwant) {\n    // @type {Map<string, Message>}\n    const ihave = new Map();\n    iwant.forEach(({\n      messageIDs\n    }) => {\n      messageIDs.forEach(msgID => {\n        const msg = this.messageCache.get(msgID);\n\n        if (msg) {\n          ihave.set(msgID, msg);\n        }\n      });\n    });\n\n    if (!ihave.size) {\n      return;\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, peer.id.toB58String());\n    return Array.from(ihave.values());\n  }\n  /**\n   * Handles Graft messages\n   * @param {Peer} peer\n   * @param {Array<ControlGraft>} graft\n   * @return {Array<ControlPrune>}\n   */\n\n\n  _handleGraft(peer, graft) {\n    const prune = [];\n    graft.forEach(({\n      topicID\n    }) => {\n      if (!topicID) {\n        return;\n      }\n\n      const peers = this.mesh.get(topicID);\n\n      if (!peers) {\n        prune.push(topicID);\n      } else {\n        this.log('GRAFT: Add mesh link from %s in %s', peer.id.toB58String(), topicID);\n        peers.add(peer);\n        peer.topics.add(topicID);\n        this.mesh.set(topicID, peers);\n      }\n    });\n\n    if (!prune.length) {\n      return;\n    }\n\n    const buildCtrlPruneMsg = topic => {\n      return {\n        topicID: topic\n      };\n    };\n\n    return prune.map(buildCtrlPruneMsg);\n  }\n  /**\n   * Handles Prune messages\n   * @param {Peer} peer\n   * @param {Array<ControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(peer, prune) {\n    prune.forEach(({\n      topicID\n    }) => {\n      if (!topicID) {\n        return;\n      }\n\n      const peers = this.mesh.get(topicID);\n\n      if (peers) {\n        this.log('PRUNE: Remove mesh link to %s in %s', peer.id.toB58String(), topicID);\n        peers.delete(peer);\n        peer.topics.delete(topicID);\n      }\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {Promise}\n   */\n\n\n  start() {\n    const _super = Object.create(null, {\n      start: {\n        get: () => super.start\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.start.call(this);\n      this.heartbeat.start();\n    });\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {Promise}\n   */\n\n\n  stop() {\n    const _super = Object.create(null, {\n      stop: {\n        get: () => super.stop\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.stop.call(this);\n      this.heartbeat.stop();\n      this.mesh = new Map();\n      this.fanout = new Map();\n      this.lastpub = new Map();\n      this.gossip = new Map();\n      this.control = new Map();\n    });\n  }\n  /**\n   * Subscribes to topics\n   *\n   * @override\n   * @param {Array<string>} topics\n   * @returns {void}\n   */\n\n\n  _subscribe(topics) {\n    super._subscribe(topics);\n\n    this.join(topics);\n  }\n  /**\n   * Unsubscribes to topics\n   *\n   * @override\n   * @param {Array<string>} topics\n   * @returns {void}\n   */\n\n\n  _unsubscribe(topics) {\n    super._unsubscribe(topics);\n\n    this.leave(topics);\n  }\n  /**\n   * Join topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  join(topics) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    topics = libp2p_pubsub_1.utils.ensureArray(topics);\n    this.log('JOIN %s', topics);\n    topics.forEach(topic => {\n      // Send GRAFT to mesh peers\n      const fanoutPeers = this.fanout.get(topic);\n\n      if (fanoutPeers) {\n        this.mesh.set(topic, fanoutPeers);\n        this.fanout.delete(topic);\n        this.lastpub.delete(topic);\n      } else {\n        const peers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n        this.mesh.set(topic, peers);\n      }\n\n      this.mesh.get(topic).forEach(peer => {\n        this.log('JOIN: Add mesh link to %s in %s', peer.id.toB58String(), topic);\n\n        this._sendGraft(peer, topic);\n      });\n    });\n  }\n  /**\n   * Leave topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  leave(topics) {\n    topics = libp2p_pubsub_1.utils.ensureArray(topics);\n    this.log('LEAVE %s', topics);\n    topics.forEach(topic => {\n      // Send PRUNE to mesh peers\n      const meshPeers = this.mesh.get(topic);\n\n      if (meshPeers) {\n        meshPeers.forEach(peer => {\n          this.log('LEAVE: Remove mesh link to %s in %s', peer.id.toB58String(), topic);\n\n          this._sendPrune(peer, topic);\n        });\n        this.mesh.delete(topic);\n      }\n    });\n  }\n  /**\n   * Override the default implementation in BasicPubSub.\n   * If we don't provide msgIdFn in constructor option, it's the same.\n   * @override\n   * @param {Message} msg the message object\n   * @returns {string} message id as string\n   */\n\n\n  getMsgId(msg) {\n    return this._msgIdFn(msg);\n  }\n  /**\n   * Publish messages\n   *\n   * Note: this function assumes all messages are well-formed RPC objects\n   * @override\n   * @param {Array<Message>} msgs\n   * @returns {void}\n   */\n\n\n  _publish(msgs) {\n    msgs.forEach(msgObj => {\n      const msgID = this.getMsgId(msgObj); // put in seen cache\n\n      this.seenCache.put(msgID);\n      this.messageCache.put(msgObj);\n      const tosend = new Set();\n      msgObj.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        } // floodsub peers\n\n\n        peersInTopic.forEach(peer => {\n          if (peer.protocols.includes(constants.FloodSubID)) {\n            tosend.add(peer);\n          }\n        }); // Gossipsub peers handling\n\n        let meshPeers = this.mesh.get(topic);\n\n        if (!meshPeers || !meshPeers.size) {\n          // We are not in the mesh for topic, use fanout peers\n          meshPeers = this.fanout.get(topic);\n\n          if (!meshPeers) {\n            // If we are not in the fanout, then pick any peers in topic\n            const peers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n\n            if (peers.size > 0) {\n              meshPeers = peers;\n              this.fanout.set(topic, peers);\n            } else {\n              meshPeers = new Set();\n            }\n          } // Store the latest publishing time\n\n\n          this.lastpub.set(topic, this._now());\n        }\n\n        meshPeers.forEach(peer => {\n          tosend.add(peer);\n        });\n      }); // Publish messages to peers\n\n      tosend.forEach(peer => {\n        if (peer.id.toB58String() === msgObj.from) {\n          return;\n        }\n\n        this._sendRpc(peer, utils_1.createGossipRpc([libp2p_pubsub_1.utils.normalizeOutRpcMessage(msgObj)]));\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(peer, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      graft\n    });\n\n    this._sendRpc(peer, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(peer, topic) {\n    const prune = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      prune\n    });\n\n    this._sendRpc(peer, out);\n  }\n\n  _sendRpc(peer, outRpc) {\n    if (!peer || !peer.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(peer);\n\n    if (ctrl) {\n      this._piggybackControl(peer, outRpc, ctrl);\n\n      this.control.delete(peer);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(peer);\n\n    if (ihave) {\n      this._piggybackGossip(peer, outRpc, ihave);\n\n      this.gossip.delete(peer);\n    }\n\n    peer.write(message_1.RPCCodec.encode(outRpc));\n  }\n\n  _piggybackControl(peer, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(({\n      topicID\n    }) => (topicID && this.mesh.get(topicID) || new Set()).has(peer));\n    const toprune = (ctrl.prune || []).filter(({\n      topicID\n    }) => !(topicID && this.mesh.get(topicID) || new Set()).has(peer));\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    if (outRpc.control) {\n      outRpc.control.graft = outRpc.control.graft.concat(tograft);\n      outRpc.control.prune = outRpc.control.prune.concat(toprune);\n    } else {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: tograft,\n        prune: toprune\n      };\n    }\n  }\n\n  _piggybackGossip(peer, outRpc, ihave) {\n    if (!outRpc.control) {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: [],\n        prune: []\n      };\n    }\n\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<Peer, Array<String>>} tograft\n   * @param {Map<Peer, Array<String>>} toprune\n   */\n\n\n  _sendGraftPrune(tograft, toprune) {\n    for (const [p, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = []; // If a peer also has prunes, process them now\n\n      const pruneMsg = toprune.get(p);\n\n      if (pruneMsg) {\n        prune = pruneMsg.map(topicID => ({\n          topicID\n        }));\n        toprune.delete(p);\n      }\n\n      const outRpc = utils_1.createGossipRpc([], {\n        graft,\n        prune\n      });\n\n      this._sendRpc(p, outRpc);\n    }\n\n    for (const [p, topics] of toprune) {\n      const prune = topics.map(topicID => ({\n        topicID\n      }));\n      const outRpc = utils_1.createGossipRpc([], {\n        prune\n      });\n\n      this._sendRpc(p, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {String} topic\n   * @param {Set<Peer>} peers - peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, peers) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    }\n\n    const gossipSubPeers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n    gossipSubPeers.forEach(peer => {\n      // skip mesh peers\n      if (!peers.has(peer)) {\n        this._pushGossip(peer, {\n          topicID: topic,\n          messageIDs: messageIDs\n        });\n      }\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        ihave\n      });\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        graft: control.graft,\n        prune: control.prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {Peer} peer\n   * @param {Array<ControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(peer, controlIHaveMsgs) {\n    this.log('Add gossip to %s', peer.id.toB58String());\n    const gossip = this.gossip.get(peer) || [];\n    this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n\n}\n\nGossipsub.multicodec = constants.GossipsubID;\nmodule.exports = Gossipsub;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-gossipsub/src/index.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","libp2p_pubsub_1","require","messageCache_1","message_1","constants","heartbeat_1","getGossipPeers_1","utils_1","TimeCache","BasicPubsub","Gossipsub","constructor","peerId","registrar","options","multicodecs","GossipsubID","_options","assign","gossipIncoming","fallbackToFloodsub","push","FloodSubID","debugName","seenCache","mesh","Map","fanout","lastpub","gossip","control","_msgIdFn","msgIdFn","defaultMsgIdFn","messageCache","MessageCache","GossipsubHistoryGossip","GossipsubHistoryLength","heartbeat","Heartbeat","_removePeer","peer","peers","values","delete","_processRpc","idB58Str","rpc","_processRpcControlMessage","controlMsg","iwant","_handleIHave","ihave","_handleIWant","prune","_handleGraft","graft","_handlePrune","outRpc","createGossipRpc","_sendRpc","_processRpcMessage","msg","msgID","getMsgId","has","put","topics","topicIDs","forEach","protocols","includes","id","toB58String","from","utils","anyMatch","isWritable","sendMessages","normalizeOutRpcMessages","log","topic","meshPeers","Set","topicID","messageIDs","add","size","Array","set","length","buildCtrlPruneMsg","map","start","_super","stop","_subscribe","join","_unsubscribe","leave","started","Error","ensureArray","fanoutPeers","getGossipPeers","GossipsubD","_sendGraft","_sendPrune","_publish","msgs","msgObj","tosend","peersInTopic","_now","normalizeOutRpcMessage","out","ctrl","_piggybackControl","_piggybackGossip","write","RPCCodec","encode","tograft","filter","toprune","concat","_sendGraftPrune","p","pruneMsg","_emitGossip","getGossipIDs","gossipSubPeers","_pushGossip","_flush","entries","controlIHaveMsgs","Date","now","multicodec","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\nconst libp2p_pubsub_1 = require(\"libp2p-pubsub\");\nconst messageCache_1 = require(\"./messageCache\");\nconst message_1 = require(\"./message\");\nconst constants = __importStar(require(\"./constants\"));\nconst heartbeat_1 = require(\"./heartbeat\");\nconst getGossipPeers_1 = require(\"./getGossipPeers\");\nconst utils_1 = require(\"./utils\");\n// @ts-ignore\nconst TimeCache = require(\"time-cache\");\nconst BasicPubsub = require(\"./pubsub\");\nclass Gossipsub extends BasicPubsub {\n    /**\n     * @param {PeerId} peerId instance of the peer's PeerId\n     * @param {Object} registrar\n     * @param {function} registrar.handle\n     * @param {function} registrar.register\n     * @param {function} registrar.unregister\n     * @param {Object} [options]\n     * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n     * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n     * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n     * @param {function} [options.msgIdFn] override the default message id function\n     * @param {Object} [options.messageCache] override the default MessageCache\n     * @constructor\n     */\n    constructor(peerId, registrar, options = {}) {\n        const multicodecs = [constants.GossipsubID];\n        const _options = Object.assign({ gossipIncoming: true, fallbackToFloodsub: true }, options);\n        // Also wants to get notified of peers connected using floodsub\n        if (_options.fallbackToFloodsub) {\n            multicodecs.push(constants.FloodSubID);\n        }\n        super({\n            debugName: 'libp2p:gossipsub',\n            multicodecs,\n            peerId,\n            registrar,\n            options: _options\n        });\n        /**\n         * Cache of seen messages\n         *\n         * @type {TimeCache}\n         */\n        this.seenCache = new TimeCache();\n        /**\n         * Map of topic meshes\n         *\n         * @type {Map<string, Set<Peer>>}\n         */\n        this.mesh = new Map();\n        /**\n         * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n         *\n         * @type {Map<string, Set<Peer>>}\n         */\n        this.fanout = new Map();\n        /**\n         * Map of last publish time for fanout topics\n         *\n         * @type {Map<string, Number>}\n         */\n        this.lastpub = new Map();\n        /**\n         * Map of pending messages to gossip\n         *\n         * @type {Map<Peer, Array<ControlIHave object>> }\n         */\n        this.gossip = new Map();\n        /**\n         * Map of control messages\n         *\n         * @type {Map<Peer, ControlMessage object>}\n         */\n        this.control = new Map();\n        /**\n         * Use the overriden mesgIdFn or the default one.\n         */\n        this._msgIdFn = options.msgIdFn || this.defaultMsgIdFn;\n        /**\n         * A message cache that contains the messages for last few hearbeat ticks\n         *\n         */\n        this.messageCache = options.messageCache || new messageCache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this._msgIdFn);\n        /**\n         * A heartbeat timer that maintains the mesh\n         */\n        this.heartbeat = new heartbeat_1.Heartbeat(this);\n    }\n    /**\n     * Removes a peer from the router\n     * @override\n     * @param {Peer} peer\n     * @returns {Peer}\n     */\n    _removePeer(peer) {\n        super._removePeer(peer);\n        // Remove this peer from the mesh\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.mesh.values()) {\n            peers.delete(peer);\n        }\n        // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n        for (const peers of this.fanout.values()) {\n            peers.delete(peer);\n        }\n        // Remove from gossip mapping\n        this.gossip.delete(peer);\n        // Remove from control mapping\n        this.control.delete(peer);\n        return peer;\n    }\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @override\n     * @param {String} idB58Str\n     * @param {Peer} peer\n     * @param {RPC} rpc\n     * @returns {void}\n     */\n    _processRpc(idB58Str, peer, rpc) {\n        super._processRpc(idB58Str, peer, rpc);\n        if (rpc.control) {\n            this._processRpcControlMessage(peer, rpc.control);\n        }\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {Peer} peer\n     * @param {ControlMessage} controlMsg\n     * @returns {void}\n     */\n    _processRpcControlMessage(peer, controlMsg) {\n        if (!controlMsg) {\n            return;\n        }\n        const iwant = this._handleIHave(peer, controlMsg.ihave);\n        const ihave = this._handleIWant(peer, controlMsg.iwant);\n        const prune = this._handleGraft(peer, controlMsg.graft);\n        this._handlePrune(peer, controlMsg.prune);\n        if (!iwant || !ihave || !prune) {\n            return;\n        }\n        const outRpc = utils_1.createGossipRpc(ihave, { iwant: [iwant], prune });\n        this._sendRpc(peer, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @override\n     * @param {Peer} peer\n     * @param {Message} msg\n     */\n    _processRpcMessage(peer, msg) {\n        const msgID = this.getMsgId(msg);\n        // Ignore if we've already seen the message\n        if (this.seenCache.has(msgID)) {\n            return;\n        }\n        this.seenCache.put(msgID);\n        super._processRpcMessage(peer, msg);\n        const topics = msg.topicIDs;\n        // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n        if (!this._options.gossipIncoming) {\n            return;\n        }\n        // Emit to floodsub peers\n        this.peers.forEach((peer) => {\n            if (peer.protocols.includes(constants.FloodSubID) &&\n                peer.id.toB58String() !== msg.from &&\n                libp2p_pubsub_1.utils.anyMatch(peer.topics, topics) &&\n                peer.isWritable) {\n                peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n                this.log('publish msg on topics - floodsub', topics, peer.id.toB58String());\n            }\n        });\n        // Emit to peers in the mesh\n        topics.forEach((topic) => {\n            const meshPeers = this.mesh.get(topic);\n            if (!meshPeers) {\n                return;\n            }\n            meshPeers.forEach((peer) => {\n                if (!peer.isWritable || peer.id.toB58String() === msg.from) {\n                    return;\n                }\n                peer.sendMessages(libp2p_pubsub_1.utils.normalizeOutRpcMessages([msg]));\n                this.log('publish msg on topic - meshsub', topic, peer.id.toB58String());\n            });\n        });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {Peer} peer\n     * @param {Array<ControlIHave>} ihave\n     * @returns {ControlIWant}\n     */\n    _handleIHave(peer, ihave) {\n        const iwant = new Set();\n        ihave.forEach(({ topicID, messageIDs }) => {\n            if (!topicID || !this.mesh.has(topicID)) {\n                return;\n            }\n            messageIDs.forEach((msgID) => {\n                if (this.seenCache.has(msgID)) {\n                    return;\n                }\n                iwant.add(msgID);\n            });\n        });\n        if (!iwant.size) {\n            return;\n        }\n        this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.id.toB58String());\n        return {\n            messageIDs: Array.from(iwant)\n        };\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {Peer} peer\n     * @param {Array<ControlIWant>} iwant\n     * @returns {Array<Message>}\n     */\n    _handleIWant(peer, iwant) {\n        // @type {Map<string, Message>}\n        const ihave = new Map();\n        iwant.forEach(({ messageIDs }) => {\n            messageIDs.forEach((msgID) => {\n                const msg = this.messageCache.get(msgID);\n                if (msg) {\n                    ihave.set(msgID, msg);\n                }\n            });\n        });\n        if (!ihave.size) {\n            return;\n        }\n        this.log('IWANT: Sending %d messages to %s', ihave.size, peer.id.toB58String());\n        return Array.from(ihave.values());\n    }\n    /**\n     * Handles Graft messages\n     * @param {Peer} peer\n     * @param {Array<ControlGraft>} graft\n     * @return {Array<ControlPrune>}\n     */\n    _handleGraft(peer, graft) {\n        const prune = [];\n        graft.forEach(({ topicID }) => {\n            if (!topicID) {\n                return;\n            }\n            const peers = this.mesh.get(topicID);\n            if (!peers) {\n                prune.push(topicID);\n            }\n            else {\n                this.log('GRAFT: Add mesh link from %s in %s', peer.id.toB58String(), topicID);\n                peers.add(peer);\n                peer.topics.add(topicID);\n                this.mesh.set(topicID, peers);\n            }\n        });\n        if (!prune.length) {\n            return;\n        }\n        const buildCtrlPruneMsg = (topic) => {\n            return {\n                topicID: topic\n            };\n        };\n        return prune.map(buildCtrlPruneMsg);\n    }\n    /**\n     * Handles Prune messages\n     * @param {Peer} peer\n     * @param {Array<ControlPrune>} prune\n     * @returns {void}\n     */\n    _handlePrune(peer, prune) {\n        prune.forEach(({ topicID }) => {\n            if (!topicID) {\n                return;\n            }\n            const peers = this.mesh.get(topicID);\n            if (peers) {\n                this.log('PRUNE: Remove mesh link to %s in %s', peer.id.toB58String(), topicID);\n                peers.delete(peer);\n                peer.topics.delete(topicID);\n            }\n        });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {Promise}\n     */\n    start() {\n        const _super = Object.create(null, {\n            start: { get: () => super.start }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.start.call(this);\n            this.heartbeat.start();\n        });\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {Promise}\n     */\n    stop() {\n        const _super = Object.create(null, {\n            stop: { get: () => super.stop }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.stop.call(this);\n            this.heartbeat.stop();\n            this.mesh = new Map();\n            this.fanout = new Map();\n            this.lastpub = new Map();\n            this.gossip = new Map();\n            this.control = new Map();\n        });\n    }\n    /**\n     * Subscribes to topics\n     *\n     * @override\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _subscribe(topics) {\n        super._subscribe(topics);\n        this.join(topics);\n    }\n    /**\n     * Unsubscribes to topics\n     *\n     * @override\n     * @param {Array<string>} topics\n     * @returns {void}\n     */\n    _unsubscribe(topics) {\n        super._unsubscribe(topics);\n        this.leave(topics);\n    }\n    /**\n     * Join topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    join(topics) {\n        if (!this.started) {\n            throw new Error('Gossipsub has not started');\n        }\n        topics = libp2p_pubsub_1.utils.ensureArray(topics);\n        this.log('JOIN %s', topics);\n        topics.forEach((topic) => {\n            // Send GRAFT to mesh peers\n            const fanoutPeers = this.fanout.get(topic);\n            if (fanoutPeers) {\n                this.mesh.set(topic, fanoutPeers);\n                this.fanout.delete(topic);\n                this.lastpub.delete(topic);\n            }\n            else {\n                const peers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n                this.mesh.set(topic, peers);\n            }\n            this.mesh.get(topic).forEach((peer) => {\n                this.log('JOIN: Add mesh link to %s in %s', peer.id.toB58String(), topic);\n                this._sendGraft(peer, topic);\n            });\n        });\n    }\n    /**\n     * Leave topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n    leave(topics) {\n        topics = libp2p_pubsub_1.utils.ensureArray(topics);\n        this.log('LEAVE %s', topics);\n        topics.forEach((topic) => {\n            // Send PRUNE to mesh peers\n            const meshPeers = this.mesh.get(topic);\n            if (meshPeers) {\n                meshPeers.forEach((peer) => {\n                    this.log('LEAVE: Remove mesh link to %s in %s', peer.id.toB58String(), topic);\n                    this._sendPrune(peer, topic);\n                });\n                this.mesh.delete(topic);\n            }\n        });\n    }\n    /**\n     * Override the default implementation in BasicPubSub.\n     * If we don't provide msgIdFn in constructor option, it's the same.\n     * @override\n     * @param {Message} msg the message object\n     * @returns {string} message id as string\n     */\n    getMsgId(msg) {\n        return this._msgIdFn(msg);\n    }\n    /**\n     * Publish messages\n     *\n     * Note: this function assumes all messages are well-formed RPC objects\n     * @override\n     * @param {Array<Message>} msgs\n     * @returns {void}\n     */\n    _publish(msgs) {\n        msgs.forEach((msgObj) => {\n            const msgID = this.getMsgId(msgObj);\n            // put in seen cache\n            this.seenCache.put(msgID);\n            this.messageCache.put(msgObj);\n            const tosend = new Set();\n            msgObj.topicIDs.forEach((topic) => {\n                const peersInTopic = this.topics.get(topic);\n                if (!peersInTopic) {\n                    return;\n                }\n                // floodsub peers\n                peersInTopic.forEach((peer) => {\n                    if (peer.protocols.includes(constants.FloodSubID)) {\n                        tosend.add(peer);\n                    }\n                });\n                // Gossipsub peers handling\n                let meshPeers = this.mesh.get(topic);\n                if (!meshPeers || !meshPeers.size) {\n                    // We are not in the mesh for topic, use fanout peers\n                    meshPeers = this.fanout.get(topic);\n                    if (!meshPeers) {\n                        // If we are not in the fanout, then pick any peers in topic\n                        const peers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n                        if (peers.size > 0) {\n                            meshPeers = peers;\n                            this.fanout.set(topic, peers);\n                        }\n                        else {\n                            meshPeers = new Set();\n                        }\n                    }\n                    // Store the latest publishing time\n                    this.lastpub.set(topic, this._now());\n                }\n                meshPeers.forEach((peer) => {\n                    tosend.add(peer);\n                });\n            });\n            // Publish messages to peers\n            tosend.forEach((peer) => {\n                if (peer.id.toB58String() === msgObj.from) {\n                    return;\n                }\n                this._sendRpc(peer, utils_1.createGossipRpc([libp2p_pubsub_1.utils.normalizeOutRpcMessage(msgObj)]));\n            });\n        });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n    _sendGraft(peer, topic) {\n        const graft = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { graft });\n        this._sendRpc(peer, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n    _sendPrune(peer, topic) {\n        const prune = [{\n                topicID: topic\n            }];\n        const out = utils_1.createGossipRpc([], { prune });\n        this._sendRpc(peer, out);\n    }\n    _sendRpc(peer, outRpc) {\n        if (!peer || !peer.isWritable) {\n            return;\n        }\n        // piggyback control message retries\n        const ctrl = this.control.get(peer);\n        if (ctrl) {\n            this._piggybackControl(peer, outRpc, ctrl);\n            this.control.delete(peer);\n        }\n        // piggyback gossip\n        const ihave = this.gossip.get(peer);\n        if (ihave) {\n            this._piggybackGossip(peer, outRpc, ihave);\n            this.gossip.delete(peer);\n        }\n        peer.write(message_1.RPCCodec.encode(outRpc));\n    }\n    _piggybackControl(peer, outRpc, ctrl) {\n        const tograft = (ctrl.graft || [])\n            .filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(peer));\n        const toprune = (ctrl.prune || [])\n            .filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(peer));\n        if (!tograft.length && !toprune.length) {\n            return;\n        }\n        if (outRpc.control) {\n            outRpc.control.graft = outRpc.control.graft.concat(tograft);\n            outRpc.control.prune = outRpc.control.prune.concat(toprune);\n        }\n        else {\n            outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };\n        }\n    }\n    _piggybackGossip(peer, outRpc, ihave) {\n        if (!outRpc.control) {\n            outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };\n        }\n        outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<Peer, Array<String>>} tograft\n     * @param {Map<Peer, Array<String>>} toprune\n     */\n    _sendGraftPrune(tograft, toprune) {\n        for (const [p, topics] of tograft) {\n            const graft = topics.map((topicID) => ({ topicID }));\n            let prune = [];\n            // If a peer also has prunes, process them now\n            const pruneMsg = toprune.get(p);\n            if (pruneMsg) {\n                prune = pruneMsg.map((topicID) => ({ topicID }));\n                toprune.delete(p);\n            }\n            const outRpc = utils_1.createGossipRpc([], { graft, prune });\n            this._sendRpc(p, outRpc);\n        }\n        for (const [p, topics] of toprune) {\n            const prune = topics.map((topicID) => ({ topicID }));\n            const outRpc = utils_1.createGossipRpc([], { prune });\n            this._sendRpc(p, outRpc);\n        }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {String} topic\n     * @param {Set<Peer>} peers - peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, peers) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        const gossipSubPeers = getGossipPeers_1.getGossipPeers(this, topic, constants.GossipsubD);\n        gossipSubPeers.forEach((peer) => {\n            // skip mesh peers\n            if (!peers.has(peer)) {\n                this._pushGossip(peer, {\n                    topicID: topic,\n                    messageIDs: messageIDs\n                });\n            }\n        });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n    _flush() {\n        // send gossip first, which will also piggyback control\n        for (const [peer, ihave] of this.gossip.entries()) {\n            this.gossip.delete(peer);\n            const out = utils_1.createGossipRpc([], { ihave });\n            this._sendRpc(peer, out);\n        }\n        // send the remaining control messages\n        for (const [peer, control] of this.control.entries()) {\n            this.control.delete(peer);\n            const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });\n            this._sendRpc(peer, out);\n        }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {Peer} peer\n     * @param {Array<ControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n    _pushGossip(peer, controlIHaveMsgs) {\n        this.log('Add gossip to %s', peer.id.toB58String());\n        const gossip = this.gossip.get(peer) || [];\n        this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n    _now() {\n        return Date.now();\n    }\n}\nGossipsub.multicodec = constants.GossipsubID;\nmodule.exports = Gossipsub;\n"]},"metadata":{},"sourceType":"script"}