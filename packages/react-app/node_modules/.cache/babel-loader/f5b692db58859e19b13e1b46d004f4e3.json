{"ast":null,"code":"'use strict';\n\nconst MAX_MSG_SIZE = 1 << 20; // 1MB\n\n/**\n * Creates an iterable transform that restricts message sizes to\n * the given maximum size.\n * @param {number} [max] The maximum message size. Defaults to 1MB\n * @returns {*} An iterable transform.\n */\n\nmodule.exports = max => {\n  max = max || MAX_MSG_SIZE;\n\n  const checkSize = msg => {\n    if (msg.data && msg.data.length > max) {\n      throw Object.assign(new Error('message size too large!'), {\n        code: 'ERR_MSG_TOO_BIG'\n      });\n    }\n  };\n\n  return source => {\n    return async function* restrictSize() {\n      for await (const msg of source) {\n        if (Array.isArray(msg)) {\n          msg.forEach(checkSize);\n        } else {\n          checkSize(msg);\n        }\n\n        yield msg;\n      }\n    }();\n  };\n};\n\nmodule.exports.MAX_MSG_SIZE = MAX_MSG_SIZE;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-mplex/src/restrict-size.js"],"names":["MAX_MSG_SIZE","module","exports","max","checkSize","msg","data","length","Object","assign","Error","code","source","restrictSize","Array","isArray","forEach"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAG,KAAK,EAA1B,C,CAA6B;;AAE7B;;;;;;;AAMAC,MAAM,CAACC,OAAP,GAAiBC,GAAG,IAAI;AACtBA,EAAAA,GAAG,GAAGA,GAAG,IAAIH,YAAb;;AAEA,QAAMI,SAAS,GAAGC,GAAG,IAAI;AACvB,QAAIA,GAAG,CAACC,IAAJ,IAAYD,GAAG,CAACC,IAAJ,CAASC,MAAT,GAAkBJ,GAAlC,EAAuC;AACrC,YAAMK,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,yBAAV,CAAd,EAAoD;AAAEC,QAAAA,IAAI,EAAE;AAAR,OAApD,CAAN;AACD;AACF,GAJD;;AAMA,SAAOC,MAAM,IAAI;AACf,WAAQ,gBAAiBC,YAAjB,GAAiC;AACvC,iBAAW,MAAMR,GAAjB,IAAwBO,MAAxB,EAAgC;AAC9B,YAAIE,KAAK,CAACC,OAAN,CAAcV,GAAd,CAAJ,EAAwB;AACtBA,UAAAA,GAAG,CAACW,OAAJ,CAAYZ,SAAZ;AACD,SAFD,MAEO;AACLA,UAAAA,SAAS,CAACC,GAAD,CAAT;AACD;;AACD,cAAMA,GAAN;AACD;AACF,KATM,EAAP;AAUD,GAXD;AAYD,CArBD;;AAuBAJ,MAAM,CAACC,OAAP,CAAeF,YAAf,GAA8BA,YAA9B","sourcesContent":["'use strict'\n\nconst MAX_MSG_SIZE = 1 << 20 // 1MB\n\n/**\n * Creates an iterable transform that restricts message sizes to\n * the given maximum size.\n * @param {number} [max] The maximum message size. Defaults to 1MB\n * @returns {*} An iterable transform.\n */\nmodule.exports = max => {\n  max = max || MAX_MSG_SIZE\n\n  const checkSize = msg => {\n    if (msg.data && msg.data.length > max) {\n      throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' })\n    }\n  }\n\n  return source => {\n    return (async function * restrictSize () {\n      for await (const msg of source) {\n        if (Array.isArray(msg)) {\n          msg.forEach(checkSize)\n        } else {\n          checkSize(msg)\n        }\n        yield msg\n      }\n    })()\n  }\n}\n\nmodule.exports.MAX_MSG_SIZE = MAX_MSG_SIZE\n"]},"metadata":{},"sourceType":"script"}