{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst globalThis = require('ipfs-utils/src/globalthis');\n/*\n * Transform one of:\n *\n * ```\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * ```\n * Into:\n *\n * ```\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @param input Object\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\n\n\nmodule.exports = function normaliseInput(input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'));\n  } // String\n\n\n  if (typeof input === 'string' || input instanceof String) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // Buffer|ArrayBuffer|TypedArray\n  // Blob|File\n\n\n  if (isBytes(input) || isBloby(input)) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // Iterable<?>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]();\n      const first = iterator.next();\n      if (first.done) return iterator; // Iterable<Number>\n      // Iterable<Bytes>\n\n      if (Number.isInteger(first.value) || isBytes(first.value)) {\n        yield toFileObject(function* () {\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // Iterable<Bloby>\n      // Iterable<String>\n      // Iterable<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // window.ReadableStream\n\n\n  if (typeof input.getReader === 'function') {\n    return async function* () {\n      for await (const obj of browserStreamToIt(input)) {\n        yield toFileObject(obj);\n      }\n    }();\n  } // AsyncIterable<?>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      const iterator = input[Symbol.asyncIterator]();\n      const first = await iterator.next();\n      if (first.done) return iterator; // AsyncIterable<Bytes>\n\n      if (isBytes(first.value)) {\n        yield toFileObject(async function* () {\n          // eslint-disable-line require-await\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // AsyncIterable<Bloby>\n      // AsyncIterable<String>\n      // AsyncIterable<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for await (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // { path, content: ? }\n  // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n\n\n  if (isFileObject(input)) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n};\n\nfunction toFileObject(input) {\n  const obj = {\n    path: input.path || '',\n    mode: input.mode,\n    mtime: input.mtime\n  };\n\n  if (input.content) {\n    obj.content = toAsyncIterable(input.content);\n  } else if (!input.path) {\n    // Not already a file object with path or content prop\n    obj.content = toAsyncIterable(input);\n  }\n\n  return obj;\n}\n\nfunction toAsyncIterable(input) {\n  // Bytes | String\n  if (isBytes(input) || typeof input === 'string') {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toBuffer(input);\n    }();\n  } // Bloby\n\n\n  if (isBloby(input)) {\n    return blobToAsyncGenerator(input);\n  } // Browser stream\n\n\n  if (typeof input.getReader === 'function') {\n    return browserStreamToIt(input);\n  } // Iterator<?>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]();\n      const first = iterator.next();\n      if (first.done) return iterator; // Iterable<Number>\n\n      if (Number.isInteger(first.value)) {\n        yield toBuffer(Array.from(function* () {\n          yield first.value;\n          yield* iterator;\n        }()));\n        return;\n      } // Iterable<Bytes>\n\n\n      if (isBytes(first.value)) {\n        yield toBuffer(first.value);\n\n        for (const chunk of iterator) {\n          yield toBuffer(chunk);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // AsyncIterable<Bytes>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      for await (const chunk of input) {\n        yield toBuffer(chunk);\n      }\n    }();\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');\n}\n\nfunction toBuffer(chunk) {\n  return isBytes(chunk) ? chunk : Buffer.from(chunk);\n}\n\nfunction isBytes(obj) {\n  return Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\n\nfunction isBloby(obj) {\n  return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob;\n} // An object with a path or content property\n\n\nfunction isFileObject(obj) {\n  return typeof obj === 'object' && (obj.path || obj.content);\n}\n\nfunction blobToAsyncGenerator(blob) {\n  if (typeof blob.stream === 'function') {\n    // firefox < 69 does not support blob.stream()\n    return browserStreamToIt(blob.stream());\n  }\n\n  return readBlob(blob);\n}\n\nasync function* browserStreamToIt(stream) {\n  const reader = stream.getReader();\n\n  while (true) {\n    const result = await reader.read();\n\n    if (result.done) {\n      return;\n    }\n\n    yield result.value;\n  }\n}\n\nasync function* readBlob(blob, options) {\n  options = options || {};\n  const reader = new globalThis.FileReader();\n  const chunkSize = options.chunkSize || 1024 * 1024;\n  let offset = options.offset || 0;\n\n  const getNextChunk = () => new Promise((resolve, reject) => {\n    reader.onloadend = e => {\n      const data = e.target.result;\n      resolve(data.byteLength === 0 ? null : data);\n    };\n\n    reader.onerror = reject;\n    const end = offset + chunkSize;\n    const slice = blob.slice(offset, end);\n    reader.readAsArrayBuffer(slice);\n    offset = end;\n  });\n\n  while (true) {\n    const data = await getNextChunk();\n\n    if (data == null) {\n      return;\n    }\n\n    yield Buffer.from(data);\n  }\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-core-utils/src/files/normalise-input.js"],"names":["errCode","require","Buffer","globalThis","module","exports","normaliseInput","input","undefined","Error","String","toFileObject","isBytes","isBloby","Symbol","iterator","first","next","done","Number","isInteger","value","isFileObject","obj","getReader","browserStreamToIt","asyncIterator","path","mode","mtime","content","toAsyncIterable","toBuffer","blobToAsyncGenerator","Array","from","chunk","isBuffer","ArrayBuffer","isView","Blob","blob","stream","readBlob","reader","result","read","options","FileReader","chunkSize","offset","getNextChunk","Promise","resolve","reject","onloadend","e","data","target","byteLength","onerror","end","slice","readAsArrayBuffer"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errCode = require('err-code')\nconst { Buffer } = require('buffer')\nconst globalThis = require('ipfs-utils/src/globalthis')\n\n/*\n * Transform one of:\n *\n * ```\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * ```\n * Into:\n *\n * ```\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @param input Object\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\nmodule.exports = function normaliseInput (input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'))\n  }\n\n  // String\n  if (typeof input === 'string' || input instanceof String) {\n    return (async function * () { // eslint-disable-line require-await\n      yield toFileObject(input)\n    })()\n  }\n\n  // Buffer|ArrayBuffer|TypedArray\n  // Blob|File\n  if (isBytes(input) || isBloby(input)) {\n    return (async function * () { // eslint-disable-line require-await\n      yield toFileObject(input)\n    })()\n  }\n\n  // Iterable<?>\n  if (input[Symbol.iterator]) {\n    return (async function * () { // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]()\n      const first = iterator.next()\n      if (first.done) return iterator\n\n      // Iterable<Number>\n      // Iterable<Bytes>\n      if (Number.isInteger(first.value) || isBytes(first.value)) {\n        yield toFileObject((function * () {\n          yield first.value\n          yield * iterator\n        })())\n        return\n      }\n\n      // Iterable<Bloby>\n      // Iterable<String>\n      // Iterable<{ path, content }>\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value)\n        for (const obj of iterator) {\n          yield toFileObject(obj)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  // window.ReadableStream\n  if (typeof input.getReader === 'function') {\n    return (async function * () {\n      for await (const obj of browserStreamToIt(input)) {\n        yield toFileObject(obj)\n      }\n    })()\n  }\n\n  // AsyncIterable<?>\n  if (input[Symbol.asyncIterator]) {\n    return (async function * () {\n      const iterator = input[Symbol.asyncIterator]()\n      const first = await iterator.next()\n      if (first.done) return iterator\n\n      // AsyncIterable<Bytes>\n      if (isBytes(first.value)) {\n        yield toFileObject((async function * () { // eslint-disable-line require-await\n          yield first.value\n          yield * iterator\n        })())\n        return\n      }\n\n      // AsyncIterable<Bloby>\n      // AsyncIterable<String>\n      // AsyncIterable<{ path, content }>\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value)\n        for await (const obj of iterator) {\n          yield toFileObject(obj)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  // { path, content: ? }\n  // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n  if (isFileObject(input)) {\n    return (async function * () { // eslint-disable-line require-await\n      yield toFileObject(input)\n    })()\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n}\n\nfunction toFileObject (input) {\n  const obj = {\n    path: input.path || '',\n    mode: input.mode,\n    mtime: input.mtime\n  }\n\n  if (input.content) {\n    obj.content = toAsyncIterable(input.content)\n  } else if (!input.path) { // Not already a file object with path or content prop\n    obj.content = toAsyncIterable(input)\n  }\n\n  return obj\n}\n\nfunction toAsyncIterable (input) {\n  // Bytes | String\n  if (isBytes(input) || typeof input === 'string') {\n    return (async function * () { // eslint-disable-line require-await\n      yield toBuffer(input)\n    })()\n  }\n\n  // Bloby\n  if (isBloby(input)) {\n    return blobToAsyncGenerator(input)\n  }\n\n  // Browser stream\n  if (typeof input.getReader === 'function') {\n    return browserStreamToIt(input)\n  }\n\n  // Iterator<?>\n  if (input[Symbol.iterator]) {\n    return (async function * () { // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]()\n      const first = iterator.next()\n      if (first.done) return iterator\n\n      // Iterable<Number>\n      if (Number.isInteger(first.value)) {\n        yield toBuffer(Array.from((function * () {\n          yield first.value\n          yield * iterator\n        })()))\n        return\n      }\n\n      // Iterable<Bytes>\n      if (isBytes(first.value)) {\n        yield toBuffer(first.value)\n        for (const chunk of iterator) {\n          yield toBuffer(chunk)\n        }\n        return\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT')\n    })()\n  }\n\n  // AsyncIterable<Bytes>\n  if (input[Symbol.asyncIterator]) {\n    return (async function * () {\n      for await (const chunk of input) {\n        yield toBuffer(chunk)\n      }\n    })()\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT')\n}\n\nfunction toBuffer (chunk) {\n  return isBytes(chunk) ? chunk : Buffer.from(chunk)\n}\n\nfunction isBytes (obj) {\n  return Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer\n}\n\nfunction isBloby (obj) {\n  return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob\n}\n\n// An object with a path or content property\nfunction isFileObject (obj) {\n  return typeof obj === 'object' && (obj.path || obj.content)\n}\n\nfunction blobToAsyncGenerator (blob) {\n  if (typeof blob.stream === 'function') {\n    // firefox < 69 does not support blob.stream()\n    return browserStreamToIt(blob.stream())\n  }\n\n  return readBlob(blob)\n}\n\nasync function * browserStreamToIt (stream) {\n  const reader = stream.getReader()\n\n  while (true) {\n    const result = await reader.read()\n\n    if (result.done) {\n      return\n    }\n\n    yield result.value\n  }\n}\n\nasync function * readBlob (blob, options) {\n  options = options || {}\n\n  const reader = new globalThis.FileReader()\n  const chunkSize = options.chunkSize || 1024 * 1024\n  let offset = options.offset || 0\n\n  const getNextChunk = () => new Promise((resolve, reject) => {\n    reader.onloadend = e => {\n      const data = e.target.result\n      resolve(data.byteLength === 0 ? null : data)\n    }\n    reader.onerror = reject\n\n    const end = offset + chunkSize\n    const slice = blob.slice(offset, end)\n    reader.readAsArrayBuffer(slice)\n    offset = end\n  })\n\n  while (true) {\n    const data = await getNextChunk()\n\n    if (data == null) {\n      return\n    }\n\n    yield Buffer.from(data)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}