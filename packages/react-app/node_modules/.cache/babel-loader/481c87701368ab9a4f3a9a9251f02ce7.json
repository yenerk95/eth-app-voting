{"ast":null,"code":"'use strict';\n\nconst multibase = require('multibase');\n\nconst sha = require('multihashing-async/src/sha');\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes);\n\n  class Secp256k1PublicKey {\n    constructor(key) {\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    verify(data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data);\n    }\n\n    marshal() {\n      return crypto.compressPublicKey(this._key);\n    }\n\n    get bytes() {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      });\n    }\n\n    equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n\n    hash() {\n      return sha.multihashing(this.bytes, 'sha2-256');\n    }\n\n  }\n\n  class Secp256k1PrivateKey {\n    constructor(key, publicKey) {\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    sign(message) {\n      return crypto.hashAndSign(this._key, message);\n    }\n\n    get public() {\n      return new Secp256k1PublicKey(this._publicKey);\n    }\n\n    marshal() {\n      return this._key;\n    }\n\n    get bytes() {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      });\n    }\n\n    equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n\n    hash() {\n      return sha.multihashing(this.bytes, 'sha2-256');\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @param {function(Error, id)} callback\n     * @returns {undefined}\n     */\n\n\n    async id() {\n      const hash = await this.public.hash();\n      return multibase.encode('base58btc', hash).toString().slice(1);\n    }\n\n  }\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  async function generateKeyPair() {\n    const privateKeyBytes = await crypto.generateKey();\n    return new Secp256k1PrivateKey(privateKeyBytes);\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/secp256k1-class.js"],"names":["multibase","require","sha","module","exports","keysProtobuf","randomBytes","crypto","Secp256k1PublicKey","constructor","key","validatePublicKey","_key","verify","data","sig","hashAndVerify","marshal","compressPublicKey","bytes","PublicKey","encode","Type","KeyType","Secp256k1","Data","equals","hash","multihashing","Secp256k1PrivateKey","publicKey","_publicKey","computePublicKey","validatePrivateKey","sign","message","hashAndSign","public","PrivateKey","id","toString","slice","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","privateKeyBytes","generateKey"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multibase = require('multibase')\nconst sha = require('multihashing-async/src/sha')\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes)\n\n  class Secp256k1PublicKey {\n    constructor (key) {\n      crypto.validatePublicKey(key)\n      this._key = key\n    }\n\n    verify (data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data)\n    }\n\n    marshal () {\n      return crypto.compressPublicKey(this._key)\n    }\n\n    get bytes () {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash () {\n      return sha.multihashing(this.bytes, 'sha2-256')\n    }\n  }\n\n  class Secp256k1PrivateKey {\n    constructor (key, publicKey) {\n      this._key = key\n      this._publicKey = publicKey || crypto.computePublicKey(key)\n      crypto.validatePrivateKey(this._key)\n      crypto.validatePublicKey(this._publicKey)\n    }\n\n    sign (message) {\n      return crypto.hashAndSign(this._key, message)\n    }\n\n    get public () {\n      return new Secp256k1PublicKey(this._publicKey)\n    }\n\n    marshal () {\n      return this._key\n    }\n\n    get bytes () {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash () {\n      return sha.multihashing(this.bytes, 'sha2-256')\n    }\n\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @param {function(Error, id)} callback\n     * @returns {undefined}\n     */\n    async id () {\n      const hash = await this.public.hash()\n      return multibase.encode('base58btc', hash).toString().slice(1)\n    }\n  }\n\n  function unmarshalSecp256k1PrivateKey (bytes) {\n    return new Secp256k1PrivateKey(bytes)\n  }\n\n  function unmarshalSecp256k1PublicKey (bytes) {\n    return new Secp256k1PublicKey(bytes)\n  }\n\n  async function generateKeyPair () {\n    const privateKeyBytes = await crypto.generateKey()\n    return new Secp256k1PrivateKey(privateKeyBytes)\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  }\n}\n"]},"metadata":{},"sourceType":"script"}