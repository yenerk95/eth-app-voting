{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar BufferList = require('bl/BufferList');\n\nvar lp = require('it-length-prefixed');\n\nvar pipe = require('it-pipe');\n\nvar errCode = require('err-code');\n\nvar NewLine = Buffer.from('\\n');\n\nfunction oneChunk(_x) {\n  return _oneChunk.apply(this, arguments);\n}\n\nfunction _oneChunk() {\n  _oneChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context2.prev = 2;\n            _iterator = _asyncIterator(source);\n\n          case 4:\n            _context2.next = 6;\n            return _iterator.next();\n\n          case 6:\n            _step = _context2.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context2.next = 10;\n            return _step.value;\n\n          case 10:\n            _value = _context2.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context2.next = 17;\n              break;\n            }\n\n            chunk = _value;\n            return _context2.abrupt(\"return\", chunk);\n\n          case 14:\n            _iteratorNormalCompletion = true;\n            _context2.next = 4;\n            break;\n\n          case 17:\n            _context2.next = 23;\n            break;\n\n          case 19:\n            _context2.prev = 19;\n            _context2.t0 = _context2[\"catch\"](2);\n            _didIteratorError = true;\n            _iteratorError = _context2.t0;\n\n          case 23:\n            _context2.prev = 23;\n            _context2.prev = 24;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context2.next = 28;\n              break;\n            }\n\n            _context2.next = 28;\n            return _iterator.return();\n\n          case 28:\n            _context2.prev = 28;\n\n            if (!_didIteratorError) {\n              _context2.next = 31;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 31:\n            return _context2.finish(28);\n\n          case 32:\n            return _context2.finish(23);\n\n          case 33:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 19, 23, 33], [24,, 28, 32]]);\n  }));\n  return _oneChunk.apply(this, arguments);\n}\n\nexports.encode = function (buffer) {\n  return lp.encode.single(new BufferList([buffer, NewLine]));\n}; // `write` encodes and writes a single buffer\n\n\nexports.write = function (writer, buffer) {\n  return writer.push(exports.encode(buffer));\n}; // `writeAll` behaves like `write`, except it encodes an array of items as a single write\n\n\nexports.writeAll = function (writer, buffers) {\n  writer.push(buffers.reduce(function (bl, buffer) {\n    return bl.append(exports.encode(buffer));\n  }, new BufferList()));\n};\n\nexports.read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(reader) {\n    var _varByteSource;\n\n    var byteLength, varByteSource, onLength, buf;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteLength = 1; // Read single byte chunks until the length is known\n\n            varByteSource = (_varByteSource = {}, _defineProperty(_varByteSource, Symbol.asyncIterator, function () {\n              return this;\n            }), _defineProperty(_varByteSource, \"next\", function next() {\n              return reader.next(byteLength);\n            }), _varByteSource); // Once the length has been parsed, read chunk for that length\n\n            onLength = function onLength(l) {\n              byteLength = l;\n            };\n\n            _context.next = 5;\n            return pipe(varByteSource, lp.decode({\n              onLength: onLength\n            }), oneChunk);\n\n          case 5:\n            buf = _context.sent;\n\n            if (!(buf.get(buf.length - 1) !== NewLine[0])) {\n              _context.next = 8;\n              break;\n            }\n\n            throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n\n          case 8:\n            return _context.abrupt(\"return\", buf.shallowSlice(0, -1));\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/multistream-select/src/multistream.js"],"names":["require","Buffer","BufferList","lp","pipe","errCode","NewLine","from","oneChunk","source","chunk","exports","encode","buffer","single","write","writer","push","writeAll","buffers","reduce","bl","append","read","reader","byteLength","varByteSource","Symbol","asyncIterator","next","onLength","l","decode","buf","get","length","Error","shallowSlice"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst BufferList = require('bl/BufferList')\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\nconst errCode = require('err-code')\n\nconst NewLine = Buffer.from('\\n')\n\nasync function oneChunk (source) {\n  for await (const chunk of source) return chunk // We only need one!\n}\n\nexports.encode = buffer => lp.encode.single(new BufferList([buffer, NewLine]))\n\n// `write` encodes and writes a single buffer\nexports.write = (writer, buffer) => writer.push(exports.encode(buffer))\n\n// `writeAll` behaves like `write`, except it encodes an array of items as a single write\nexports.writeAll = (writer, buffers) => {\n  writer.push(buffers.reduce((bl, buffer) => bl.append(exports.encode(buffer)), new BufferList()))\n}\n\nexports.read = async reader => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = { // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator] () { return this },\n    next: () => reader.next(byteLength)\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  const onLength = l => { byteLength = l }\n  const buf = await pipe(varByteSource, lp.decode({ onLength }), oneChunk)\n\n  if (buf.get(buf.length - 1) !== NewLine[0]) {\n    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.shallowSlice(0, -1) // Remove newline\n}\n"]},"metadata":{},"sourceType":"script"}