{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar sanitize = require('sanitize-filename');\n\nvar mergeOptions = require('merge-options');\n\nvar crypto = require('libp2p-crypto');\n\nvar DS = require('interface-datastore');\n\nvar CMS = require('./cms');\n\nvar errcode = require('err-code');\n\nvar keyPrefix = '/pkcs8/';\nvar infoPrefix = '/info/'; // NIST SP 800-132\n\nvar NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nvar defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string | Error} err - The error\n * @private\n */\n\n\nfunction throwDelayed(_x) {\n  return _throwDelayed.apply(this, arguments);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction _throwDelayed() {\n  _throwDelayed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(err) {\n    var min, max, delay;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            min = 200;\n            max = 1000;\n            delay = Math.random() * (max - min) + min;\n            _context11.next = 5;\n            return new Promise(function (resolve) {\n              return setTimeout(resolve, delay);\n            });\n\n          case 5:\n            throw err;\n\n          case 6:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _throwDelayed.apply(this, arguments);\n}\n\nfunction DsName(name) {\n  return new DS.Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new DS.Key(infoPrefix + name);\n}\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nvar Keychain = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  function Keychain(store, options) {\n    _classCallCheck(this, Keychain);\n\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    this.opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (!this.opts.passPhrase || this.opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters');\n    }\n\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(\"dek.keyLength must be least \".concat(NIST.minKeyLength, \" bytes\"));\n    }\n\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(\"dek.saltLength must be least \".concat(NIST.minSaltLength, \" bytes\"));\n    }\n\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(\"dek.iterationCount must be least \".concat(NIST.minIterationCount));\n    } // Create the derived encrypting key\n\n\n    var dek = crypto.pbkdf2(this.opts.passPhrase, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash);\n    Object.defineProperty(this, '_', {\n      value: function value() {\n        return dek;\n      }\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  _createClass(Keychain, [{\n    key: \"createKey\",\n\n    /**\n     * Create a new key.\n     *\n     * @param {string} name - The local key name; cannot already exist.\n     * @param {string} type - One of the key types; 'rsa'.\n     * @param {int} size - The key size in bits.\n      * @returns {KeyInfo}\n     */\n    value: function () {\n      var _createKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name, type, size) {\n        var self, dsname, exists, keyInfo, keypair, kid, pem, batch;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (!(typeof type !== 'string')) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key type '\".concat(type, \"'\")), 'ERR_INVALID_KEY_TYPE')));\n\n              case 5:\n                if (Number.isSafeInteger(size)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key size '\".concat(size, \"'\")), 'ERR_INVALID_KEY_SIZE')));\n\n              case 7:\n                dsname = DsName(name);\n                _context.next = 10;\n                return self.store.has(dsname);\n\n              case 10:\n                exists = _context.sent;\n\n                if (!exists) {\n                  _context.next = 13;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 13:\n                _context.t0 = type.toLowerCase();\n                _context.next = _context.t0 === 'rsa' ? 16 : 19;\n                break;\n\n              case 16:\n                if (!(size < 2048)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid RSA key size \".concat(size)), 'ERR_INVALID_KEY_SIZE')));\n\n              case 18:\n                return _context.abrupt(\"break\", 20);\n\n              case 19:\n                return _context.abrupt(\"break\", 20);\n\n              case 20:\n                _context.prev = 20;\n                _context.next = 23;\n                return crypto.keys.generateKeyPair(type, size);\n\n              case 23:\n                keypair = _context.sent;\n                _context.next = 26;\n                return keypair.id();\n\n              case 26:\n                kid = _context.sent;\n                _context.next = 29;\n                return keypair.export(this._());\n\n              case 29:\n                pem = _context.sent;\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, pem);\n                batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n                _context.next = 36;\n                return batch.commit();\n\n              case 36:\n                _context.next = 41;\n                break;\n\n              case 38:\n                _context.prev = 38;\n                _context.t1 = _context[\"catch\"](20);\n                return _context.abrupt(\"return\", throwDelayed(_context.t1));\n\n              case 41:\n                return _context.abrupt(\"return\", keyInfo);\n\n              case 42:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[20, 38]]);\n      }));\n\n      function createKey(_x2, _x3, _x4) {\n        return _createKey.apply(this, arguments);\n      }\n\n      return createKey;\n    }()\n    /**\n     * List all the keys.\n     *\n      * @returns {KeyInfo[]}\n     */\n\n  }, {\n    key: \"listKeys\",\n    value: function () {\n      var _listKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var self, query, info, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, value;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                self = this;\n                query = {\n                  prefix: infoPrefix\n                };\n                info = [];\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context2.prev = 5;\n                _iterator = _asyncIterator(self.store.query(query));\n\n              case 7:\n                _context2.next = 9;\n                return _iterator.next();\n\n              case 9:\n                _step = _context2.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context2.next = 13;\n                return _step.value;\n\n              case 13:\n                _value = _context2.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                value = _value;\n                info.push(JSON.parse(value.value));\n\n              case 17:\n                _iteratorNormalCompletion = true;\n                _context2.next = 7;\n                break;\n\n              case 20:\n                _context2.next = 26;\n                break;\n\n              case 22:\n                _context2.prev = 22;\n                _context2.t0 = _context2[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context2.t0;\n\n              case 26:\n                _context2.prev = 26;\n                _context2.prev = 27;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context2.next = 31;\n                  break;\n                }\n\n                _context2.next = 31;\n                return _iterator.return();\n\n              case 31:\n                _context2.prev = 31;\n\n                if (!_didIteratorError) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 34:\n                return _context2.finish(31);\n\n              case 35:\n                return _context2.finish(26);\n\n              case 36:\n                return _context2.abrupt(\"return\", info);\n\n              case 37:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 22, 26, 36], [27,, 31, 35]]);\n      }));\n\n      function listKeys() {\n        return _listKeys.apply(this, arguments);\n      }\n\n      return listKeys;\n    }()\n    /**\n     * Find a key by it's id.\n     *\n     * @param {string} id - The universally unique key identifier.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"findKeyById\",\n    value: function () {\n      var _findKeyById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id) {\n        var keys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.listKeys();\n\n              case 3:\n                keys = _context3.sent;\n                return _context3.abrupt(\"return\", keys.find(function (k) {\n                  return k.id === id;\n                }));\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", throwDelayed(_context3.t0));\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n\n      function findKeyById(_x5) {\n        return _findKeyById.apply(this, arguments);\n      }\n\n      return findKeyById;\n    }()\n    /**\n     * Find a key by it's name.\n     *\n     * @param {string} name - The local key name.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"findKeyByName\",\n    value: function () {\n      var _findKeyByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(name) {\n        var dsname, res;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                dsname = DsInfoName(name);\n                _context4.prev = 3;\n                _context4.next = 6;\n                return this.store.get(dsname);\n\n              case 6:\n                res = _context4.sent;\n                return _context4.abrupt(\"return\", JSON.parse(res.toString()));\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](3);\n                return _context4.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(_context4.t0.message)), 'ERR_KEY_NOT_FOUND')));\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 10]]);\n      }));\n\n      function findKeyByName(_x6) {\n        return _findKeyByName.apply(this, arguments);\n      }\n\n      return findKeyByName;\n    }()\n    /**\n     * Remove an existing key.\n     *\n     * @param {string} name - The local key name; must already exist.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"removeKey\",\n    value: function () {\n      var _removeKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(name) {\n        var self, dsname, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                dsname = DsName(name);\n                _context5.next = 6;\n                return self.findKeyByName(name);\n\n              case 6:\n                keyInfo = _context5.sent;\n                batch = self.store.batch();\n                batch.delete(dsname);\n                batch.delete(DsInfoName(name));\n                _context5.next = 12;\n                return batch.commit();\n\n              case 12:\n                return _context5.abrupt(\"return\", keyInfo);\n\n              case 13:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function removeKey(_x7) {\n        return _removeKey.apply(this, arguments);\n      }\n\n      return removeKey;\n    }()\n    /**\n     * Rename a key\n     *\n     * @param {string} oldName - The old local key name; must already exist.\n     * @param {string} newName - The new local key name; must not already exist.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"renameKey\",\n    value: function () {\n      var _renameKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(oldName, newName) {\n        var self, oldDsname, newDsname, oldInfoName, newInfoName, exists, res, pem, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(oldName) || oldName === 'self')) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid old key name '\".concat(oldName, \"'\")), 'ERR_OLD_KEY_NAME_INVALID')));\n\n              case 3:\n                if (!(!validateKeyName(newName) || newName === 'self')) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid new key name '\".concat(newName, \"'\")), 'ERR_NEW_KEY_NAME_INVALID')));\n\n              case 5:\n                oldDsname = DsName(oldName);\n                newDsname = DsName(newName);\n                oldInfoName = DsInfoName(oldName);\n                newInfoName = DsInfoName(newName);\n                _context6.next = 11;\n                return self.store.has(newDsname);\n\n              case 11:\n                exists = _context6.sent;\n\n                if (!exists) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(newName, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 14:\n                _context6.prev = 14;\n                _context6.next = 17;\n                return this.store.get(oldDsname);\n\n              case 17:\n                res = _context6.sent;\n                pem = res.toString();\n                _context6.next = 21;\n                return self.store.get(oldInfoName);\n\n              case 21:\n                res = _context6.sent;\n                keyInfo = JSON.parse(res.toString());\n                keyInfo.name = newName;\n                batch = self.store.batch();\n                batch.put(newDsname, pem);\n                batch.put(newInfoName, JSON.stringify(keyInfo));\n                batch.delete(oldDsname);\n                batch.delete(oldInfoName);\n                _context6.next = 31;\n                return batch.commit();\n\n              case 31:\n                return _context6.abrupt(\"return\", keyInfo);\n\n              case 34:\n                _context6.prev = 34;\n                _context6.t0 = _context6[\"catch\"](14);\n                return _context6.abrupt(\"return\", throwDelayed(_context6.t0));\n\n              case 37:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[14, 34]]);\n      }));\n\n      function renameKey(_x8, _x9) {\n        return _renameKey.apply(this, arguments);\n      }\n\n      return renameKey;\n    }()\n    /**\n     * Export an existing key as a PEM encrypted PKCS #8 string\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {string} password - The password\n      * @returns {string}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function () {\n      var _exportKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(name, password) {\n        var dsname, res, pem, privateKey;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                if (password) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED')));\n\n              case 4:\n                dsname = DsName(name);\n                _context7.prev = 5;\n                _context7.next = 8;\n                return this.store.get(dsname);\n\n              case 8:\n                res = _context7.sent;\n                pem = res.toString();\n                _context7.next = 12;\n                return crypto.keys.import(pem, this._());\n\n              case 12:\n                privateKey = _context7.sent;\n                return _context7.abrupt(\"return\", privateKey.export(password));\n\n              case 16:\n                _context7.prev = 16;\n                _context7.t0 = _context7[\"catch\"](5);\n                return _context7.abrupt(\"return\", throwDelayed(_context7.t0));\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[5, 16]]);\n      }));\n\n      function exportKey(_x10, _x11) {\n        return _exportKey.apply(this, arguments);\n      }\n\n      return exportKey;\n    }()\n    /**\n     * Import a new key from a PEM encoded PKCS #8 string\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {string} pem - The PEM encoded PKCS #8 string\n     * @param {string} password - The password.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function () {\n      var _importKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(name, pem, password) {\n        var self, dsname, exists, privateKey, kid, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (pem) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED')));\n\n              case 5:\n                dsname = DsName(name);\n                _context8.next = 8;\n                return self.store.has(dsname);\n\n              case 8:\n                exists = _context8.sent;\n\n                if (!exists) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 11:\n                _context8.prev = 11;\n                _context8.next = 14;\n                return crypto.keys.import(pem, password);\n\n              case 14:\n                privateKey = _context8.sent;\n                _context8.next = 20;\n                break;\n\n              case 17:\n                _context8.prev = 17;\n                _context8.t0 = _context8[\"catch\"](11);\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY')));\n\n              case 20:\n                _context8.prev = 20;\n                _context8.next = 23;\n                return privateKey.id();\n\n              case 23:\n                kid = _context8.sent;\n                _context8.next = 26;\n                return privateKey.export(this._());\n\n              case 26:\n                pem = _context8.sent;\n                _context8.next = 32;\n                break;\n\n              case 29:\n                _context8.prev = 29;\n                _context8.t1 = _context8[\"catch\"](20);\n                return _context8.abrupt(\"return\", throwDelayed(_context8.t1));\n\n              case 32:\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, pem);\n                batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n                _context8.next = 38;\n                return batch.commit();\n\n              case 38:\n                return _context8.abrupt(\"return\", keyInfo);\n\n              case 39:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[11, 17], [20, 29]]);\n      }));\n\n      function importKey(_x12, _x13, _x14) {\n        return _importKey.apply(this, arguments);\n      }\n\n      return importKey;\n    }()\n  }, {\n    key: \"importPeer\",\n    value: function () {\n      var _importPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(name, peer) {\n        var self, privateKey, dsname, exists, kid, pem, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                self = this;\n\n                if (validateKeyName(name)) {\n                  _context9.next = 3;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (!(!peer || !peer.privKey)) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY')));\n\n              case 5:\n                privateKey = peer.privKey;\n                dsname = DsName(name);\n                _context9.next = 9;\n                return self.store.has(dsname);\n\n              case 9:\n                exists = _context9.sent;\n\n                if (!exists) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 12:\n                _context9.prev = 12;\n                _context9.next = 15;\n                return privateKey.id();\n\n              case 15:\n                kid = _context9.sent;\n                _context9.next = 18;\n                return privateKey.export(this._());\n\n              case 18:\n                pem = _context9.sent;\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, pem);\n                batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n                _context9.next = 25;\n                return batch.commit();\n\n              case 25:\n                return _context9.abrupt(\"return\", keyInfo);\n\n              case 28:\n                _context9.prev = 28;\n                _context9.t0 = _context9[\"catch\"](12);\n                return _context9.abrupt(\"return\", throwDelayed(_context9.t0));\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[12, 28]]);\n      }));\n\n      function importPeer(_x15, _x16) {\n        return _importPeer.apply(this, arguments);\n      }\n\n      return importPeer;\n    }()\n    /**\n     * Gets the private key as PEM encoded PKCS #8 string.\n     *\n     * @param {string} name\n      * @returns {string}\n     * @private\n     */\n\n  }, {\n    key: \"_getPrivateKey\",\n    value: function () {\n      var _getPrivateKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(name) {\n        var dsname, res;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                _context10.prev = 2;\n                dsname = DsName(name);\n                _context10.next = 6;\n                return this.store.get(dsname);\n\n              case 6:\n                res = _context10.sent;\n                return _context10.abrupt(\"return\", res.toString());\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](2);\n                return _context10.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(_context10.t0.message)), 'ERR_KEY_NOT_FOUND')));\n\n              case 13:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 10]]);\n      }));\n\n      function _getPrivateKey(_x17) {\n        return _getPrivateKey2.apply(this, arguments);\n      }\n\n      return _getPrivateKey;\n    }()\n  }, {\n    key: \"cms\",\n    get: function get() {\n      return new CMS(this);\n    }\n    /**\n     * Generates the options for a keychain.  A random salt is produced.\n     *\n     * @returns {object}\n     */\n\n  }], [{\n    key: \"generateOptions\",\n    value: function generateOptions() {\n      var options = Object.assign({}, defaultOptions);\n      var saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n      options.dek.salt = crypto.randomBytes(saltLength).toString('base64');\n      return options;\n    }\n    /**\n     * Gets an object that can encrypt/decrypt protected data.\n     * The default options for a keychain.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return defaultOptions;\n    }\n  }]);\n\n  return Keychain;\n}();\n\nmodule.exports = Keychain;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/keychain/index.js"],"names":["sanitize","require","mergeOptions","crypto","DS","CMS","errcode","keyPrefix","infoPrefix","NIST","minKeyLength","minSaltLength","minIterationCount","defaultOptions","dek","keyLength","iterationCount","salt","hash","validateKeyName","name","trim","throwDelayed","err","min","max","delay","Math","random","Promise","resolve","setTimeout","DsName","Key","DsInfoName","Keychain","store","options","Error","opts","passPhrase","length","pbkdf2","Object","defineProperty","value","type","size","self","Number","isSafeInteger","dsname","has","exists","toLowerCase","keys","generateKeyPair","keypair","id","kid","export","_","pem","keyInfo","batch","put","JSON","stringify","commit","query","prefix","info","push","parse","listKeys","find","k","get","res","toString","message","findKeyByName","delete","oldName","newName","oldDsname","newDsname","oldInfoName","newInfoName","password","import","privateKey","peer","privKey","assign","saltLength","ceil","randomBytes","module","exports"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict'\n\nconst sanitize = require('sanitize-filename')\nconst mergeOptions = require('merge-options')\nconst crypto = require('libp2p-crypto')\nconst DS = require('interface-datastore')\nconst CMS = require('./cms')\nconst errcode = require('err-code')\n\nconst keyPrefix = '/pkcs8/'\nconst infoPrefix = '/info/'\n\n// NIST SP 800-132\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n}\n\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n}\n\nfunction validateKeyName (name) {\n  if (!name) return false\n  if (typeof name !== 'string') return false\n  return name === sanitize(name.trim())\n}\n\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string | Error} err - The error\n * @private\n */\nasync function throwDelayed (err) {\n  const min = 200\n  const max = 1000\n  const delay = Math.random() * (max - min) + min\n\n  await new Promise(resolve => setTimeout(resolve, delay))\n  throw err\n}\n\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\nfunction DsName (name) {\n  return new DS.Key(keyPrefix + name)\n}\n\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\nfunction DsInfoName (name) {\n  return new DS.Key(infoPrefix + name)\n}\n\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  constructor (store, options) {\n    if (!store) {\n      throw new Error('store is required')\n    }\n    this.store = store\n\n    this.opts = mergeOptions(defaultOptions, options)\n\n    // Enforce NIST SP 800-132\n    if (!this.opts.passPhrase || this.opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters')\n    }\n    if (this.opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`)\n    }\n    if (this.opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`)\n    }\n    if (this.opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`)\n    }\n\n    // Create the derived encrypting key\n    const dek = crypto.pbkdf2(\n      this.opts.passPhrase,\n      this.opts.dek.salt,\n      this.opts.dek.iterationCount,\n      this.opts.dek.keyLength,\n      this.opts.dek.hash)\n    Object.defineProperty(this, '_', { value: () => dek })\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n  get cms () {\n    return new CMS(this)\n  }\n\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n  static generateOptions () {\n    const options = Object.assign({}, defaultOptions)\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3 // no base64 padding\n    options.dek.salt = crypto.randomBytes(saltLength).toString('base64')\n    return options\n  }\n\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n  static get options () {\n    return defaultOptions\n  }\n\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {int} size - The key size in bits.\n    * @returns {KeyInfo}\n   */\n  async createKey (name, type, size) {\n    const self = this\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    if (typeof type !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'))\n    }\n\n    if (!Number.isSafeInteger(size)) {\n      return throwDelayed(errcode(new Error(`Invalid key size '${size}'`), 'ERR_INVALID_KEY_SIZE'))\n    }\n\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (size < 2048) {\n          return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'))\n        }\n        break\n      default:\n        break\n    }\n\n    let keyInfo\n    try {\n      const keypair = await crypto.keys.generateKeyPair(type, size)\n      const kid = await keypair.id()\n      const pem = await keypair.export(this._())\n      keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, pem)\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n\n      await batch.commit()\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    return keyInfo\n  }\n\n  /**\n   * List all the keys.\n   *\n    * @returns {KeyInfo[]}\n   */\n  async listKeys () {\n    const self = this\n    const query = {\n      prefix: infoPrefix\n    }\n\n    const info = []\n    for await (const value of self.store.query(query)) {\n      info.push(JSON.parse(value.value))\n    }\n\n    return info\n  }\n\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n    * @returns {KeyInfo}\n   */\n  async findKeyById (id) {\n    try {\n      const keys = await this.listKeys()\n      return keys.find((k) => k.id === id)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n    * @returns {KeyInfo}\n   */\n  async findKeyByName (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    const dsname = DsInfoName(name)\n    try {\n      const res = await this.store.get(dsname)\n      return JSON.parse(res.toString())\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n    * @returns {KeyInfo}\n   */\n  async removeKey (name) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    const dsname = DsName(name)\n    const keyInfo = await self.findKeyByName(name)\n    const batch = self.store.batch()\n    batch.delete(dsname)\n    batch.delete(DsInfoName(name))\n    await batch.commit()\n    return keyInfo\n  }\n\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n    * @returns {KeyInfo}\n   */\n  async renameKey (oldName, newName) {\n    const self = this\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'))\n    }\n    if (!validateKeyName(newName) || newName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'))\n    }\n    const oldDsname = DsName(oldName)\n    const newDsname = DsName(newName)\n    const oldInfoName = DsInfoName(oldName)\n    const newInfoName = DsInfoName(newName)\n\n    const exists = await self.store.has(newDsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      let res = await this.store.get(oldDsname)\n      const pem = res.toString()\n      res = await self.store.get(oldInfoName)\n\n      const keyInfo = JSON.parse(res.toString())\n      keyInfo.name = newName\n      const batch = self.store.batch()\n      batch.put(newDsname, pem)\n      batch.put(newInfoName, JSON.stringify(keyInfo))\n      batch.delete(oldDsname)\n      batch.delete(oldInfoName)\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n    * @returns {string}\n   */\n  async exportKey (name, password) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!password) {\n      return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))\n    }\n\n    const dsname = DsName(name)\n    try {\n      const res = await this.store.get(dsname)\n      const pem = res.toString()\n      const privateKey = await crypto.keys.import(pem, this._())\n      return privateKey.export(password)\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n    * @returns {KeyInfo}\n   */\n  async importKey (name, pem, password) {\n    const self = this\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!pem) {\n      return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'))\n    }\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    let privateKey\n    try {\n      privateKey = await crypto.keys.import(pem, password)\n    } catch (err) {\n      return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))\n    }\n\n    let kid\n    try {\n      kid = await privateKey.id()\n      pem = await privateKey.export(this._())\n    } catch (err) {\n      return throwDelayed(err)\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    }\n    const batch = self.store.batch()\n    batch.put(dsname, pem)\n    batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n    await batch.commit()\n\n    return keyInfo\n  }\n\n  async importPeer (name, peer) {\n    const self = this\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n    if (!peer || !peer.privKey) {\n      return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))\n    }\n\n    const privateKey = peer.privKey\n    const dsname = DsName(name)\n    const exists = await self.store.has(dsname)\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))\n\n    try {\n      const kid = await privateKey.id()\n      const pem = await privateKey.export(this._())\n      const keyInfo = {\n        name: name,\n        id: kid\n      }\n      const batch = self.store.batch()\n      batch.put(dsname, pem)\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo))\n      await batch.commit()\n      return keyInfo\n    } catch (err) {\n      return throwDelayed(err)\n    }\n  }\n\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n    * @returns {string}\n   * @private\n   */\n  async _getPrivateKey (name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'))\n    }\n\n    try {\n      const dsname = DsName(name)\n      const res = await this.store.get(dsname)\n      return res.toString()\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'))\n    }\n  }\n}\n\nmodule.exports = Keychain\n"]},"metadata":{},"sourceType":"script"}