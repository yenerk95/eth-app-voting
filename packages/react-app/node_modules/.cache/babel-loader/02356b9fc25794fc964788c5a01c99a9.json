{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar WantManager = require('./want-manager');\n\nvar Network = require('./network');\n\nvar DecisionEngine = require('./decision-engine');\n\nvar Notifications = require('./notifications');\n\nvar logger = require('./utils').logger;\n\nvar Stats = require('./stats');\n\nvar AbortController = require('abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nvar statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\n\nvar Bitswap = /*#__PURE__*/function () {\n  function Bitswap(libp2p, blockstore, options) {\n    _classCallCheck(this, Bitswap);\n\n    this._libp2p = libp2p;\n    this._log = logger(this.peerId);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerId, this.network, this._stats);\n    this.notifications = new Notifications(this.peerId);\n  }\n\n  _createClass(Bitswap, [{\n    key: \"_receiveMessage\",\n    // handle messages received through the network\n    value: function () {\n      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peerId, incoming) {\n        var _this3 = this;\n\n        var blocks, wanted;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.engine.messageReceived(peerId, incoming);\n\n              case 3:\n                _context2.next = 8;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                // Log instead of throwing an error so as to process as much as\n                // possible of the message. Currently `messageReceived` does not\n                // throw any errors, but this could change in the future.\n                this._log('failed to receive message', incoming);\n\n              case 8:\n                if (!(incoming.blocks.size === 0)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 10:\n                blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n                wanted = blocks.filter(function (b) {\n                  return _this3.wm.wantlist.contains(b.cid);\n                }).map(function (b) {\n                  return b.cid;\n                });\n                this.wm.cancelWants(wanted);\n                _context2.next = 15;\n                return Promise.all(blocks.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(b) {\n                    var wasWanted;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            wasWanted = wanted.includes(b.cid);\n                            _context.next = 3;\n                            return _this3._handleReceivedBlock(peerId, b, wasWanted);\n\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x3) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 5]]);\n      }));\n\n      function _receiveMessage(_x, _x2) {\n        return _receiveMessage2.apply(this, arguments);\n      }\n\n      return _receiveMessage;\n    }()\n  }, {\n    key: \"_handleReceivedBlock\",\n    value: function () {\n      var _handleReceivedBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId, block, wasWanted) {\n        var has;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._log('received block');\n\n                _context3.next = 3;\n                return this.blockstore.has(block.cid);\n\n              case 3:\n                has = _context3.sent;\n\n                this._updateReceiveCounters(peerId.toB58String(), block, has);\n\n                if (wasWanted) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 7:\n                _context3.next = 9;\n                return this.put(block);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _handleReceivedBlock(_x4, _x5, _x6) {\n        return _handleReceivedBlock2.apply(this, arguments);\n      }\n\n      return _handleReceivedBlock;\n    }()\n  }, {\n    key: \"_updateReceiveCounters\",\n    value: function _updateReceiveCounters(peerId, block, exists) {\n      this._stats.push(peerId, 'blocksReceived', 1);\n\n      this._stats.push(peerId, 'dataReceived', block.data.length);\n\n      if (exists) {\n        this._stats.push(peerId, 'dupBlksReceived', 1);\n\n        this._stats.push(peerId, 'dupDataReceived', block.data.length);\n      }\n    } // handle errors on the receiving channel\n\n  }, {\n    key: \"_receiveError\",\n    value: function _receiveError(err) {\n      this._log.error('ReceiveError: %s', err.message);\n    } // handle new peers\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId) {\n      this.wm.connected(peerId);\n    } // handle peers being disconnected\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId) {\n      this.wm.disconnected(peerId);\n      this.engine.peerDisconnected(peerId);\n\n      this._stats.disconnected(peerId);\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"enableStats\",\n    value: function enableStats() {\n      this._stats.enable();\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disableStats\",\n    value: function disableStats() {\n      this._stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {Map}\n     */\n\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<Block>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(cid) {\n        var _this4 = this;\n\n        var options,\n            fetchFromNetwork,\n            promptedNetwork,\n            loadOrFetchFromNetwork,\n            controller,\n            signal,\n            block,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n\n                fetchFromNetwork = function fetchFromNetwork(cid, options) {\n                  // add it to the want list - n.b. later we will abort the AbortSignal\n                  // so no need to remove the blocks from the wantlist after we have it\n                  _this4.wm.wantBlocks([cid], options);\n\n                  return _this4.notifications.wantBlock(cid, options);\n                };\n\n                promptedNetwork = false;\n\n                loadOrFetchFromNetwork = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, options) {\n                    var _block;\n\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.prev = 0;\n                            _context4.next = 3;\n                            return _this4.blockstore.get(cid, options);\n\n                          case 3:\n                            _block = _context4.sent;\n                            return _context4.abrupt(\"return\", _block);\n\n                          case 7:\n                            _context4.prev = 7;\n                            _context4.t0 = _context4[\"catch\"](0);\n\n                            if (!(_context4.t0.code !== 'ERR_NOT_FOUND')) {\n                              _context4.next = 11;\n                              break;\n                            }\n\n                            throw _context4.t0;\n\n                          case 11:\n                            if (!promptedNetwork) {\n                              promptedNetwork = true;\n\n                              _this4.network.findAndConnect(cid).catch(function (err) {\n                                return _this4._log.error(err);\n                              });\n                            } // we don't have the block locally so fetch it from the network\n\n\n                            return _context4.abrupt(\"return\", fetchFromNetwork(cid, options));\n\n                          case 13:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, null, [[0, 7]]);\n                  }));\n\n                  return function loadOrFetchFromNetwork(_x8, _x9) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }(); // depending on implementation it's possible for blocks to come in while\n                // we do the async operations to get them from the blockstore leading to\n                // a race condition, so register for incoming block notifications as well\n                // as trying to get it from the datastore\n\n\n                controller = new AbortController();\n                signal = anySignal([options.signal, controller.signal]);\n                _context5.next = 8;\n                return Promise.race([this.notifications.wantBlock(cid, {\n                  signal: signal\n                }), loadOrFetchFromNetwork(cid, {\n                  signal: signal\n                })]);\n\n              case 8:\n                block = _context5.sent;\n                // since we have the block we can now remove our listener\n                controller.abort();\n                return _context5.abrupt(\"return\", block);\n\n              case 11:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function get(_x7) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Fetch a a list of blocks by cid. If the blocks are in the local\n     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<AsyncIterator<Block>>}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context6.prev = 2;\n                _iterator = _asyncIterator(cids);\n\n              case 4:\n                _context6.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context6.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context6.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context6.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                cid = _value;\n                _context6.next = 15;\n                return _this.get(cid, options);\n\n              case 15:\n                _iteratorNormalCompletion = true;\n                _context6.next = 4;\n                break;\n\n              case 18:\n                _context6.next = 24;\n                break;\n\n              case 20:\n                _context6.prev = 20;\n                _context6.t0 = _context6[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context6.t0;\n\n              case 24:\n                _context6.prev = 24;\n                _context6.prev = 25;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context6.next = 29;\n                  break;\n                }\n\n                _context6.next = 29;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 29:\n                _context6.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context6.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context6.finish(29);\n\n              case 33:\n                return _context6.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n      }))();\n    }\n    /**\n     * Removes the given CIDs from the wantlist independent of any ref counts.\n     *\n     * This will cause all outstanding promises for a given block to reject.\n     *\n     * If you want to cancel the want for a block without doing that, pass an\n     * AbortSignal in to `.get` or `.getMany` and abort it.\n     *\n     * @param {Iterable<CID>} cids\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unwant\",\n    value: function unwant(cids) {\n      var _this5 = this;\n\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.unwantBlocks(cids);\n      cids.forEach(function (cid) {\n        return _this5.notifications.unwantBlock(cid);\n      });\n    }\n    /**\n     * Removes the given keys from the want list. This may cause pending promises\n     * for blocks to never resolve.  If you wish these promises to abort instead\n     * call `unwant(cids)` instead.\n     *\n     * @param {Iterable<CID>} cids\n     * @returns {void}\n     */\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.cancelWants(cids);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     *\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(block) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.blockstore.put(block);\n\n              case 2:\n                this._sendHaveBlockNotifications(block);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function put(_x10) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     *\n     * @param {AsyncIterable<Block>} blocks\n     * @returns {AsyncIterable<Block>}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks) {\n      var _this2 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, block;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context8.prev = 2;\n                _iterator2 = _asyncIterator(_this2.blockstore.putMany(blocks));\n\n              case 4:\n                _context8.next = 6;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 6:\n                _step2 = _context8.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context8.next = 10;\n                return _awaitAsyncGenerator(_step2.value);\n\n              case 10:\n                _value2 = _context8.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                block = _value2;\n\n                _this2._sendHaveBlockNotifications(block);\n\n                _context8.next = 16;\n                return block;\n\n              case 16:\n                _iteratorNormalCompletion2 = true;\n                _context8.next = 4;\n                break;\n\n              case 19:\n                _context8.next = 25;\n                break;\n\n              case 21:\n                _context8.prev = 21;\n                _context8.t0 = _context8[\"catch\"](2);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context8.t0;\n\n              case 25:\n                _context8.prev = 25;\n                _context8.prev = 26;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context8.next = 30;\n                  break;\n                }\n\n                _context8.next = 30;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 30:\n                _context8.prev = 30;\n\n                if (!_didIteratorError2) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 33:\n                return _context8.finish(30);\n\n              case 34:\n                return _context8.finish(25);\n\n              case 35:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[2, 21, 25, 35], [26,, 30, 34]]);\n      }))();\n    }\n    /**\n     * Sends notifications about the arrival of a block\n     *\n     * @param {Block} block\n     */\n\n  }, {\n    key: \"_sendHaveBlockNotifications\",\n    value: function _sendHaveBlockNotifications(block) {\n      var _this6 = this;\n\n      this.notifications.hasBlock(block);\n      this.engine.receivedBlocks([block]); // Note: Don't wait for provide to finish before returning\n\n      this.network.provide(block.cid).catch(function (err) {\n        _this6._log.error('Failed to provide: %s', err.message);\n      });\n    }\n    /**\n     * Get the current list of wants.\n     *\n     * @returns {Iterator<WantlistEntry>}\n     */\n\n  }, {\n    key: \"getWantlist\",\n    value: function getWantlist() {\n      return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners.\n     *\n     * @returns {Iterator<PeerId>}\n     */\n\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return this.engine.peers();\n    }\n    /**\n     * Get stats about the bitswap node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat() {\n      return this._stats;\n    }\n    /**\n     * Start the bitswap node.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.wm.start();\n      this.network.start();\n      this.engine.start();\n    }\n    /**\n     * Stop the bitswap node.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stats.stop();\n\n      this.wm.stop();\n      this.network.stop();\n      this.engine.stop();\n    }\n  }, {\n    key: \"peerId\",\n    get: function get() {\n      return this._libp2p.peerId;\n    }\n  }]);\n\n  return Bitswap;\n}();\n\nmodule.exports = Bitswap;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/index.js"],"names":["WantManager","require","Network","DecisionEngine","Notifications","logger","Stats","AbortController","anySignal","defaultOptions","statsEnabled","statsComputeThrottleTimeout","statsComputeThrottleMaxQueueSize","statsKeys","Bitswap","libp2p","blockstore","options","_libp2p","_log","peerId","_options","Object","assign","_stats","enabled","computeThrottleTimeout","computeThrottleMaxQueueSize","network","engine","wm","notifications","incoming","messageReceived","blocks","size","Array","from","values","wanted","filter","b","wantlist","contains","cid","map","cancelWants","Promise","all","wasWanted","includes","_handleReceivedBlock","block","has","_updateReceiveCounters","toB58String","put","exists","push","data","length","err","error","message","connected","disconnected","peerDisconnected","enable","disable","wantlistForPeer","ledgerForPeer","fetchFromNetwork","wantBlocks","wantBlock","promptedNetwork","loadOrFetchFromNetwork","get","code","findAndConnect","catch","controller","signal","race","abort","cids","isArray","unwantBlocks","forEach","unwantBlock","_sendHaveBlockNotifications","putMany","hasBlock","receivedBlocks","provide","entries","peers","start","stop","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAME,cAAc,GAAGF,OAAO,CAAC,mBAAD,CAA9B;;AACA,IAAMG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA7B;;AACA,IAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAD,CAAP,CAAmBI,MAAlC;;AACA,IAAMC,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AACA,IAAMM,eAAe,GAAGN,OAAO,CAAC,kBAAD,CAA/B;;AACA,IAAMO,SAAS,GAAGP,OAAO,CAAC,YAAD,CAAzB;;AAEA,IAAMQ,cAAc,GAAG;AACrBC,EAAAA,YAAY,EAAE,KADO;AAErBC,EAAAA,2BAA2B,EAAE,IAFR;AAGrBC,EAAAA,gCAAgC,EAAE;AAHb,CAAvB;AAKA,IAAMC,SAAS,GAAG,CAChB,gBADgB,EAEhB,cAFgB,EAGhB,iBAHgB,EAIhB,iBAJgB,EAKhB,YALgB,EAMhB,UANgB,EAOhB,sBAPgB,EAQhB,gBARgB,EAShB,WATgB,CAAlB;AAYA;;;;;;;;;IAQMC,O;AACJ,mBAAaC,MAAb,EAAqBC,UAArB,EAAiCC,OAAjC,EAA0C;AAAA;;AACxC,SAAKC,OAAL,GAAeH,MAAf;AACA,SAAKI,IAAL,GAAYd,MAAM,CAAC,KAAKe,MAAN,CAAlB;AAEA,SAAKC,QAAL,GAAgBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBd,cAAlB,EAAkCQ,OAAlC,CAAhB,CAJwC,CAMxC;;AACA,SAAKO,MAAL,GAAc,IAAIlB,KAAJ,CAAUO,SAAV,EAAqB;AACjCY,MAAAA,OAAO,EAAE,KAAKJ,QAAL,CAAcX,YADU;AAEjCgB,MAAAA,sBAAsB,EAAE,KAAKL,QAAL,CAAcV,2BAFL;AAGjCgB,MAAAA,2BAA2B,EAAE,KAAKN,QAAL,CAAcT;AAHV,KAArB,CAAd,CAPwC,CAaxC;;AACA,SAAKgB,OAAL,GAAe,IAAI1B,OAAJ,CAAYa,MAAZ,EAAoB,IAApB,EAA0B,EAA1B,EAA8B,KAAKS,MAAnC,CAAf,CAdwC,CAgBxC;;AACA,SAAKR,UAAL,GAAkBA,UAAlB;AAEA,SAAKa,MAAL,GAAc,IAAI1B,cAAJ,CAAmB,KAAKiB,MAAxB,EAAgCJ,UAAhC,EAA4C,KAAKY,OAAjD,EAA0D,KAAKJ,MAA/D,CAAd,CAnBwC,CAqBxC;;AACA,SAAKM,EAAL,GAAU,IAAI9B,WAAJ,CAAgB,KAAKoB,MAArB,EAA6B,KAAKQ,OAAlC,EAA2C,KAAKJ,MAAhD,CAAV;AAEA,SAAKO,aAAL,GAAqB,IAAI3B,aAAJ,CAAkB,KAAKgB,MAAvB,CAArB;AACD;;;;AAMD;;wGACuBA,M,EAAQY,Q;;;;;;;;;;uBAKrB,KAAKH,MAAL,CAAYI,eAAZ,CAA4Bb,MAA5B,EAAoCY,QAApC,C;;;;;;;;;;AAEN;AACA;AACA;AACA,qBAAKb,IAAL,CAAU,2BAAV,EAAuCa,QAAvC;;;sBAGEA,QAAQ,CAACE,MAAT,CAAgBC,IAAhB,KAAyB,C;;;;;;;;AAIvBD,gBAAAA,M,GAASE,KAAK,CAACC,IAAN,CAAWL,QAAQ,CAACE,MAAT,CAAgBI,MAAhB,EAAX,C,EAEf;;AACMC,gBAAAA,M,GAASL,MAAM,CAClBM,MADY,CACL,UAACC,CAAD;AAAA,yBAAO,MAAI,CAACX,EAAL,CAAQY,QAAR,CAAiBC,QAAjB,CAA0BF,CAAC,CAACG,GAA5B,CAAP;AAAA,iBADK,EAEZC,GAFY,CAER,UAACJ,CAAD;AAAA,yBAAOA,CAAC,CAACG,GAAT;AAAA,iBAFQ,C;AAIf,qBAAKd,EAAL,CAAQgB,WAAR,CAAoBP,MAApB;;uBAEMQ,OAAO,CAACC,GAAR,CAAYd,MAAM,CAACW,GAAP;AAAA,sFAAW,iBAAOJ,CAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACrBQ,4BAAAA,SADqB,GACTV,MAAM,CAACW,QAAP,CAAgBT,CAAC,CAACG,GAAlB,CADS;AAAA;AAAA,mCAErB,MAAI,CAACO,oBAAL,CAA0B/B,MAA1B,EAAkCqB,CAAlC,EAAqCQ,SAArC,CAFqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAX;;AAAA;AAAA;AAAA;AAAA,oBAAZ,C;;;;;;;;;;;;;;;;;;;6GAMoB7B,M,EAAQgC,K,EAAOH,S;;;;;;AACzC,qBAAK9B,IAAL,CAAU,gBAAV;;;uBAEkB,KAAKH,UAAL,CAAgBqC,GAAhB,CAAoBD,KAAK,CAACR,GAA1B,C;;;AAAZS,gBAAAA,G;;AAEN,qBAAKC,sBAAL,CAA4BlC,MAAM,CAACmC,WAAP,EAA5B,EAAkDH,KAAlD,EAAyDC,GAAzD;;oBAEKJ,S;;;;;;;;;uBAIC,KAAKO,GAAL,CAASJ,KAAT,C;;;;;;;;;;;;;;;;;;2CAGgBhC,M,EAAQgC,K,EAAOK,M,EAAQ;AAC7C,WAAKjC,MAAL,CAAYkC,IAAZ,CAAiBtC,MAAjB,EAAyB,gBAAzB,EAA2C,CAA3C;;AACA,WAAKI,MAAL,CAAYkC,IAAZ,CAAiBtC,MAAjB,EAAyB,cAAzB,EAAyCgC,KAAK,CAACO,IAAN,CAAWC,MAApD;;AAEA,UAAIH,MAAJ,EAAY;AACV,aAAKjC,MAAL,CAAYkC,IAAZ,CAAiBtC,MAAjB,EAAyB,iBAAzB,EAA4C,CAA5C;;AACA,aAAKI,MAAL,CAAYkC,IAAZ,CAAiBtC,MAAjB,EAAyB,iBAAzB,EAA4CgC,KAAK,CAACO,IAAN,CAAWC,MAAvD;AACD;AACF,K,CAED;;;;kCACeC,G,EAAK;AAClB,WAAK1C,IAAL,CAAU2C,KAAV,CAAgB,kBAAhB,EAAoCD,GAAG,CAACE,OAAxC;AACD,K,CAED;;;;qCACkB3C,M,EAAQ;AACxB,WAAKU,EAAL,CAAQkC,SAAR,CAAkB5C,MAAlB;AACD,K,CAED;;;;wCACqBA,M,EAAQ;AAC3B,WAAKU,EAAL,CAAQmC,YAAR,CAAqB7C,MAArB;AACA,WAAKS,MAAL,CAAYqC,gBAAZ,CAA6B9C,MAA7B;;AACA,WAAKI,MAAL,CAAYyC,YAAZ,CAAyB7C,MAAzB;AACD;AAED;;;;;;kCAGe;AACb,WAAKI,MAAL,CAAY2C,MAAZ;AACD;AAED;;;;;;mCAGgB;AACd,WAAK3C,MAAL,CAAY4C,OAAZ;AACD;AAED;;;;;;;;;oCAMiBhD,M,EAAQ;AACvB,aAAO,KAAKS,MAAL,CAAYwC,eAAZ,CAA4BjD,MAA5B,CAAP;AACD;AAED;;;;;;;;;kCAMeA,M,EAAQ;AACrB,aAAO,KAAKS,MAAL,CAAYyC,aAAZ,CAA0BlD,MAA1B,CAAP;AACD;AAED;;;;;;;;;;;;;4FASWwB,G;;;;;;;;;;;;;;;AAAK3B,gBAAAA,O,8DAAU,E;;AAClBsD,gBAAAA,gB,GAAmB,SAAnBA,gBAAmB,CAAC3B,GAAD,EAAM3B,OAAN,EAAkB;AACzC;AACA;AACA,kBAAA,MAAI,CAACa,EAAL,CAAQ0C,UAAR,CAAmB,CAAC5B,GAAD,CAAnB,EAA0B3B,OAA1B;;AAEA,yBAAO,MAAI,CAACc,aAAL,CAAmB0C,SAAnB,CAA6B7B,GAA7B,EAAkC3B,OAAlC,CAAP;AACD,iB;;AAEGyD,gBAAAA,e,GAAkB,K;;AAEhBC,gBAAAA,sB;uFAAyB,kBAAO/B,GAAP,EAAY3B,OAAZ;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCAGP,MAAI,CAACD,UAAL,CAAgB4D,GAAhB,CAAoBhC,GAApB,EAAyB3B,OAAzB,CAHO;;AAAA;AAGrBmC,4BAAAA,MAHqB;AAAA,8DAKpBA,MALoB;;AAAA;AAAA;AAAA;;AAAA,kCAOvB,aAAIyB,IAAJ,KAAa,eAPU;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAW3B,gCAAI,CAACH,eAAL,EAAsB;AACpBA,8BAAAA,eAAe,GAAG,IAAlB;;AAEA,8BAAA,MAAI,CAAC9C,OAAL,CAAakD,cAAb,CAA4BlC,GAA5B,EACGmC,KADH,CACS,UAAClB,GAAD;AAAA,uCAAS,MAAI,CAAC1C,IAAL,CAAU2C,KAAV,CAAgBD,GAAhB,CAAT;AAAA,+BADT;AAED,6BAhB0B,CAkB3B;;;AAlB2B,8DAmBpBU,gBAAgB,CAAC3B,GAAD,EAAM3B,OAAN,CAnBI;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mB;;kCAAzB0D,sB;;;qBAuBN;AACA;AACA;AACA;;;AACMK,gBAAAA,U,GAAa,IAAIzE,eAAJ,E;AACb0E,gBAAAA,M,GAASzE,SAAS,CAAC,CAACS,OAAO,CAACgE,MAAT,EAAiBD,UAAU,CAACC,MAA5B,CAAD,C;;uBAEJlC,OAAO,CAACmC,IAAR,CAAa,CAC/B,KAAKnD,aAAL,CAAmB0C,SAAnB,CAA6B7B,GAA7B,EAAkC;AAChCqC,kBAAAA,MAAM,EAANA;AADgC,iBAAlC,CAD+B,EAI/BN,sBAAsB,CAAC/B,GAAD,EAAM;AAC1BqC,kBAAAA,MAAM,EAANA;AAD0B,iBAAN,CAJS,CAAb,C;;;AAAd7B,gBAAAA,K;AASN;AACA4B,gBAAAA,UAAU,CAACG,KAAX;kDAEO/B,K;;;;;;;;;;;;;;;;AAGT;;;;;;;;;;;;4BASiBgC,I,EAAoB;AAAA;;AAAA,UAAdnE,OAAc,uEAAJ,EAAI;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CACXmE,IADW;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAClBxC,gBAAAA,GADkB;AAAA;AAEjC,uBAAM,KAAI,CAACgC,GAAL,CAAShC,GAAT,EAAc3B,OAAd,CAAN;;AAFiC;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIpC;AAED;;;;;;;;;;;;;;2BAWQmE,I,EAAM;AAAA;;AACZ,UAAI,CAAChD,KAAK,CAACiD,OAAN,CAAcD,IAAd,CAAL,EAA0B;AACxBA,QAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD;;AAED,WAAKtD,EAAL,CAAQwD,YAAR,CAAqBF,IAArB;AACAA,MAAAA,IAAI,CAACG,OAAL,CAAa,UAAC3C,GAAD;AAAA,eAAS,MAAI,CAACb,aAAL,CAAmByD,WAAnB,CAA+B5C,GAA/B,CAAT;AAAA,OAAb;AACD;AAED;;;;;;;;;;;gCAQawC,I,EAAM;AACjB,UAAI,CAAChD,KAAK,CAACiD,OAAN,CAAcD,IAAd,CAAL,EAA0B;AACxBA,QAAAA,IAAI,GAAG,CAACA,IAAD,CAAP;AACD;;AACD,WAAKtD,EAAL,CAAQgB,WAAR,CAAoBsC,IAApB;AACD;AAED;;;;;;;;;;;4FAOWhC,K;;;;;;uBACH,KAAKpC,UAAL,CAAgBwC,GAAhB,CAAoBJ,KAApB,C;;;AACN,qBAAKqC,2BAAL,CAAiCrC,KAAjC;;;;;;;;;;;;;;;;AAGF;;;;;;;;;;4BAOiBlB,M,EAAQ;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CACG,MAAI,CAAClB,UAAL,CAAgB0E,OAAhB,CAAwBxD,MAAxB,CADH;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACNkB,gBAAAA,KADM;;AAErB,gBAAA,MAAI,CAACqC,2BAAL,CAAiCrC,KAAjC;;AAFqB;AAIrB,uBAAMA,KAAN;;AAJqB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMxB;AAED;;;;;;;;gDAK6BA,K,EAAO;AAAA;;AAClC,WAAKrB,aAAL,CAAmB4D,QAAnB,CAA4BvC,KAA5B;AACA,WAAKvB,MAAL,CAAY+D,cAAZ,CAA2B,CAACxC,KAAD,CAA3B,EAFkC,CAGlC;;AACA,WAAKxB,OAAL,CAAaiE,OAAb,CAAqBzC,KAAK,CAACR,GAA3B,EAAgCmC,KAAhC,CAAsC,UAAClB,GAAD,EAAS;AAC7C,QAAA,MAAI,CAAC1C,IAAL,CAAU2C,KAAV,CAAgB,uBAAhB,EAAyCD,GAAG,CAACE,OAA7C;AACD,OAFD;AAGD;AAED;;;;;;;;kCAKe;AACb,aAAO,KAAKjC,EAAL,CAAQY,QAAR,CAAiBoD,OAAjB,EAAP;AACD;AAED;;;;;;;;4BAKS;AACP,aAAO,KAAKjE,MAAL,CAAYkE,KAAZ,EAAP;AACD;AAED;;;;;;;;2BAKQ;AACN,aAAO,KAAKvE,MAAZ;AACD;AAED;;;;;;;;4BAKS;AACP,WAAKM,EAAL,CAAQkE,KAAR;AACA,WAAKpE,OAAL,CAAaoE,KAAb;AACA,WAAKnE,MAAL,CAAYmE,KAAZ;AACD;AAED;;;;;;;;2BAKQ;AACN,WAAKxE,MAAL,CAAYyE,IAAZ;;AACA,WAAKnE,EAAL,CAAQmE,IAAR;AACA,WAAKrE,OAAL,CAAaqE,IAAb;AACA,WAAKpE,MAAL,CAAYoE,IAAZ;AACD;;;wBA5Ta;AACZ,aAAO,KAAK/E,OAAL,CAAaE,MAApB;AACD;;;;;;AA6TH8E,MAAM,CAACC,OAAP,GAAiBrF,OAAjB","sourcesContent":["'use strict'\n\nconst WantManager = require('./want-manager')\nconst Network = require('./network')\nconst DecisionEngine = require('./decision-engine')\nconst Notifications = require('./notifications')\nconst logger = require('./utils').logger\nconst Stats = require('./stats')\nconst AbortController = require('abort-controller')\nconst anySignal = require('any-signal')\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n}\nconst statsKeys = [\n  'blocksReceived',\n  'dataReceived',\n  'dupBlksReceived',\n  'dupDataReceived',\n  'blocksSent',\n  'dataSent',\n  'providesBufferLength',\n  'wantListLength',\n  'peerCount'\n]\n\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\nclass Bitswap {\n  constructor (libp2p, blockstore, options) {\n    this._libp2p = libp2p\n    this._log = logger(this.peerId)\n\n    this._options = Object.assign({}, defaultOptions, options)\n\n    // stats\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    })\n\n    // the network delivers messages\n    this.network = new Network(libp2p, this, {}, this._stats)\n\n    // local database\n    this.blockstore = blockstore\n\n    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats)\n\n    // handle message sending\n    this.wm = new WantManager(this.peerId, this.network, this._stats)\n\n    this.notifications = new Notifications(this.peerId)\n  }\n\n  get peerId () {\n    return this._libp2p.peerId\n  }\n\n  // handle messages received through the network\n  async _receiveMessage (peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming)\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming)\n    }\n\n    if (incoming.blocks.size === 0) {\n      return\n    }\n\n    const blocks = Array.from(incoming.blocks.values())\n\n    // quickly send out cancels, reduces chances of duplicate block receives\n    const wanted = blocks\n      .filter((b) => this.wm.wantlist.contains(b.cid))\n      .map((b) => b.cid)\n\n    this.wm.cancelWants(wanted)\n\n    await Promise.all(blocks.map(async (b) => {\n      const wasWanted = wanted.includes(b.cid)\n      await this._handleReceivedBlock(peerId, b, wasWanted)\n    }))\n  }\n\n  async _handleReceivedBlock (peerId, block, wasWanted) {\n    this._log('received block')\n\n    const has = await this.blockstore.has(block.cid)\n\n    this._updateReceiveCounters(peerId.toB58String(), block, has)\n\n    if (!wasWanted) {\n      return\n    }\n\n    await this.put(block)\n  }\n\n  _updateReceiveCounters (peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1)\n    this._stats.push(peerId, 'dataReceived', block.data.length)\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1)\n      this._stats.push(peerId, 'dupDataReceived', block.data.length)\n    }\n  }\n\n  // handle errors on the receiving channel\n  _receiveError (err) {\n    this._log.error('ReceiveError: %s', err.message)\n  }\n\n  // handle new peers\n  _onPeerConnected (peerId) {\n    this.wm.connected(peerId)\n  }\n\n  // handle peers being disconnected\n  _onPeerDisconnected (peerId) {\n    this.wm.disconnected(peerId)\n    this.engine.peerDisconnected(peerId)\n    this._stats.disconnected(peerId)\n  }\n\n  /**\n   * @returns {void}\n   */\n  enableStats () {\n    this._stats.enable()\n  }\n\n  /**\n   * @returns {void}\n   */\n  disableStats () {\n    this._stats.disable()\n  }\n\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Map}\n   */\n  wantlistForPeer (peerId) {\n    return this.engine.wantlistForPeer(peerId)\n  }\n\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Object}\n   */\n  ledgerForPeer (peerId) {\n    return this.engine.ledgerForPeer(peerId)\n  }\n\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Block>}\n   */\n  async get (cid, options = {}) {\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options)\n\n      return this.notifications.wantBlock(cid, options)\n    }\n\n    let promptedNetwork = false\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options)\n\n        return block\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true\n\n          this.network.findAndConnect(cid)\n            .catch((err) => this._log.error(err))\n        }\n\n        // we don't have the block locally so fetch it from the network\n        return fetchFromNetwork(cid, options)\n      }\n    }\n\n    // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n    const controller = new AbortController()\n    const signal = anySignal([options.signal, controller.signal])\n\n    const block = await Promise.race([\n      this.notifications.wantBlock(cid, {\n        signal\n      }),\n      loadOrFetchFromNetwork(cid, {\n        signal\n      })\n    ])\n\n    // since we have the block we can now remove our listener\n    controller.abort()\n\n    return block\n  }\n\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<AsyncIterator<Block>>}\n   */\n  async * getMany (cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options)\n    }\n  }\n\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n  unwant (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n\n    this.wm.unwantBlocks(cids)\n    cids.forEach((cid) => this.notifications.unwantBlock(cid))\n  }\n\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n  cancelWants (cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids]\n    }\n    this.wm.cancelWants(cids)\n  }\n\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @returns {Promise<void>}\n   */\n  async put (block) {\n    await this.blockstore.put(block)\n    this._sendHaveBlockNotifications(block)\n  }\n\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {AsyncIterable<Block>} blocks\n   * @returns {AsyncIterable<Block>}\n   */\n  async * putMany (blocks) {\n    for await (const block of this.blockstore.putMany(blocks)) {\n      this._sendHaveBlockNotifications(block)\n\n      yield block\n    }\n  }\n\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @param {Block} block\n   */\n  _sendHaveBlockNotifications (block) {\n    this.notifications.hasBlock(block)\n    this.engine.receivedBlocks([block])\n    // Note: Don't wait for provide to finish before returning\n    this.network.provide(block.cid).catch((err) => {\n      this._log.error('Failed to provide: %s', err.message)\n    })\n  }\n\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n  getWantlist () {\n    return this.wm.wantlist.entries()\n  }\n\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Iterator<PeerId>}\n   */\n  peers () {\n    return this.engine.peers()\n  }\n\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n  stat () {\n    return this._stats\n  }\n\n  /**\n   * Start the bitswap node.\n   *\n   * @returns {void}\n   */\n  start () {\n    this.wm.start()\n    this.network.start()\n    this.engine.start()\n  }\n\n  /**\n   * Stop the bitswap node.\n   *\n   * @returns {void}\n   */\n  stop () {\n    this._stats.stop()\n    this.wm.stop()\n    this.network.stop()\n    this.engine.stop()\n  }\n}\n\nmodule.exports = Bitswap\n"]},"metadata":{},"sourceType":"script"}