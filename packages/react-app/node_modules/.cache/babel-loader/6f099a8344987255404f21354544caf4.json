{"ast":null,"code":"'use strict';\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst CID = require('cids');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils');\n\nconst errCode = require('err-code');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashing-async').multihash;\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`);\n    options.parent = await context.ipld.get(options.parentCid);\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, options);\n  }\n\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, options);\n};\n\nconst removeFromDirectory = async (context, options) => {\n  const hashAlg = mh.names[options.hashAlg];\n  options.parent.rmLink(options.name);\n  const cid = await context.ipld.put(options.parent, mc.DAG_PB, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  });\n  log(`Updated regular directory ${cid}`);\n  return {\n    node: options.parent,\n    cid\n  };\n};\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options);\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop();\n  const link = node.Links.find(link => link.Name.substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`);\n    node.rmLink(link.Name);\n    await bucket.del(child.name);\n    return updateHamtDirectory(context, node.Links, bucket, options);\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`);\n  const result = await updateShard(context, positions, child, options);\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n    result.cid = result.node.Links[0].Hash;\n    result.node = result.node.Links[0];\n    newName = `${prefix}${result.node.Name.substring(2)}`;\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`);\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options);\n};\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName);\n  parent.addLink(new DAGLink(newName, size, cid));\n  return updateHamtDirectory(context, parent.Links, bucket, options);\n};\n\nmodule.exports = removeLink;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/utils/remove-link.js"],"names":["DAGNode","DAGLink","require","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","mc","mh","multihash","removeLink","context","options","parentCid","parent","Error","isCID","ipld","get","name","meta","unmarshal","Data","type","removeFromShardedDirectory","removeFromDirectory","hashAlg","names","rmLink","cid","put","DAG_PB","cidVersion","node","rootBucket","path","del","updateShard","size","flush","Links","positions","child","bucket","prefix","pop","link","find","Name","substring","result","newName","length","Hash","isDAGNode","Tsize","updateShardParent","oldName","addLink","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb')\nconst CID = require('cids')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst UnixFS = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\nconst mc = require('multicodec')\nconst mh = require('multihashing-async').multihash\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`)\n\n    options.parent = await context.ipld.get(options.parentCid)\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, options)\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, options)\n}\n\nconst removeFromDirectory = async (context, options) => {\n  const hashAlg = mh.names[options.hashAlg]\n\n  options.parent.rmLink(options.name)\n  const cid = await context.ipld.put(options.parent, mc.DAG_PB, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  })\n\n  log(`Updated regular directory ${cid}`)\n\n  return {\n    node: options.parent,\n    cid\n  }\n}\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop()\n\n  const link = node.Links\n    .find(link => link.Name.substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    node.rmLink(link.Name)\n\n    await bucket.del(child.name)\n\n    return updateHamtDirectory(context, node.Links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`)\n\n  const result = await updateShard(context, positions, child, options)\n\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    result.cid = result.node.Links[0].Hash\n    result.node = result.node.Links[0]\n\n    newName = `${prefix}${result.node.Name.substring(2)}`\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options)\n}\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName)\n  parent.addLink(new DAGLink(newName, size, cid))\n\n  return updateHamtDirectory(context, parent.Links, bucket, options)\n}\n\nmodule.exports = removeLink\n"]},"metadata":{},"sourceType":"script"}