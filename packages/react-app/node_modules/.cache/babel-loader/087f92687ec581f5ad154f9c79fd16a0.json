{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  parallelMap\n} = require('streaming-iterables');\n\nconst CID = require('cids');\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst PinManager = require('./pin-manager');\n\nconst {\n  PinTypes\n} = PinManager;\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst PIN_LS_CONCURRENCY = 8;\n\nmodule.exports = ({\n  pinManager,\n  dag\n}) => {\n  return withTimeoutOption(async function* ls(paths, options) {\n    options = options || {};\n    let type = PinTypes.all;\n\n    if (paths && !Array.isArray(paths) && !CID.isCID(paths) && typeof paths !== 'string') {\n      options = paths;\n      paths = null;\n    }\n\n    if (options.type) {\n      type = options.type;\n\n      if (typeof options.type === 'string') {\n        type = options.type.toLowerCase();\n      }\n\n      const err = PinManager.checkPinType(type);\n\n      if (err) {\n        throw err;\n      }\n    }\n\n    if (paths) {\n      paths = Array.isArray(paths) ? paths : [paths]; // check the pinned state of specific hashes\n\n      const cids = await resolvePath(dag, paths);\n      yield* parallelMap(PIN_LS_CONCURRENCY, async cid => {\n        const {\n          reason,\n          pinned\n        } = await pinManager.isPinnedWithType(cid, type);\n\n        if (!pinned) {\n          throw new Error(`path '${paths[cids.indexOf(cid)]}' is not pinned`);\n        }\n\n        if (reason === PinTypes.direct || reason === PinTypes.recursive) {\n          return {\n            cid,\n            type: reason\n          };\n        }\n\n        return {\n          cid,\n          type: `${PinTypes.indirect} through ${reason}`\n        };\n      }, cids);\n      return;\n    } // show all pinned items of type\n\n\n    let pins = [];\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      pins = pins.concat(Array.from(pinManager.directPins).map(cid => ({\n        type: PinTypes.direct,\n        cid: new CID(cid)\n      })));\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      pins = pins.concat(Array.from(pinManager.recursivePins).map(cid => ({\n        type: PinTypes.recursive,\n        cid: new CID(cid)\n      })));\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      const indirects = await pinManager.getIndirectKeys(options);\n      pins = pins // if something is pinned both directly and indirectly,\n      // report the indirect entry\n      .filter(({\n        cid\n      }) => !indirects.includes(cid.toString()) || !pinManager.directPins.has(cid.toString())).concat(indirects.map(cid => ({\n        type: PinTypes.indirect,\n        cid: new CID(cid)\n      })));\n    } // FIXME: https://github.com/ipfs/js-ipfs/issues/2244\n\n\n    yield* pins;\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/ls.js"],"names":["parallelMap","require","CID","resolvePath","PinManager","PinTypes","withTimeoutOption","PIN_LS_CONCURRENCY","module","exports","pinManager","dag","ls","paths","options","type","all","Array","isArray","isCID","toLowerCase","err","checkPinType","cids","cid","reason","pinned","isPinnedWithType","Error","indexOf","direct","recursive","indirect","pins","concat","from","directPins","map","recursivePins","indirects","getIndirectKeys","filter","includes","toString","has"],"mappings":"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","sourcesContent":["/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict'\n\nconst { parallelMap } = require('streaming-iterables')\nconst CID = require('cids')\nconst { resolvePath } = require('../../utils')\nconst PinManager = require('./pin-manager')\nconst { PinTypes } = PinManager\nconst { withTimeoutOption } = require('../../utils')\n\nconst PIN_LS_CONCURRENCY = 8\n\nmodule.exports = ({ pinManager, dag }) => {\n  return withTimeoutOption(async function * ls (paths, options) {\n    options = options || {}\n\n    let type = PinTypes.all\n\n    if (paths && !Array.isArray(paths) && !CID.isCID(paths) && typeof paths !== 'string') {\n      options = paths\n      paths = null\n    }\n\n    if (options.type) {\n      type = options.type\n      if (typeof options.type === 'string') {\n        type = options.type.toLowerCase()\n      }\n      const err = PinManager.checkPinType(type)\n      if (err) {\n        throw err\n      }\n    }\n\n    if (paths) {\n      paths = Array.isArray(paths) ? paths : [paths]\n\n      // check the pinned state of specific hashes\n      const cids = await resolvePath(dag, paths)\n\n      yield * parallelMap(PIN_LS_CONCURRENCY, async cid => {\n        const { reason, pinned } = await pinManager.isPinnedWithType(cid, type)\n\n        if (!pinned) {\n          throw new Error(`path '${paths[cids.indexOf(cid)]}' is not pinned`)\n        }\n\n        if (reason === PinTypes.direct || reason === PinTypes.recursive) {\n          return { cid, type: reason }\n        }\n\n        return { cid, type: `${PinTypes.indirect} through ${reason}` }\n      }, cids)\n\n      return\n    }\n\n    // show all pinned items of type\n    let pins = []\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      pins = pins.concat(\n        Array.from(pinManager.directPins).map(cid => ({\n          type: PinTypes.direct,\n          cid: new CID(cid)\n        }))\n      )\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      pins = pins.concat(\n        Array.from(pinManager.recursivePins).map(cid => ({\n          type: PinTypes.recursive,\n          cid: new CID(cid)\n        }))\n      )\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      const indirects = await pinManager.getIndirectKeys(options)\n\n      pins = pins\n        // if something is pinned both directly and indirectly,\n        // report the indirect entry\n        .filter(({ cid }) => !indirects.includes(cid.toString()) || !pinManager.directPins.has(cid.toString()))\n        .concat(indirects.map(cid => ({ type: PinTypes.indirect, cid: new CID(cid) })))\n    }\n\n    // FIXME: https://github.com/ipfs/js-ipfs/issues/2244\n    yield * pins\n  })\n}\n"]},"metadata":{},"sourceType":"script"}