{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar c = require('../constants');\n\nvar LimitedPeerList = require('../peer-list/limited-peer-list');\n\nvar Message = require('../message');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n\nmodule.exports = function (dht) {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n  var findProvidersSingle = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer, key) {\n      var msg;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0);\n              return _context.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function findProvidersSingle(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Announce to the network that we can provide given key's value.\n     * @param {CID} key\n     * @returns {Promise<void>}\n     */\n    provide: function provide(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var errors, multiaddrs, msg;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                dht._log('provide: %s', key.toBaseEncodedString());\n\n                errors = []; // Add peer as provider\n\n                _context3.next = 4;\n                return dht.providers.addProvider(key, dht.peerId);\n\n              case 4:\n                multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];\n                msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0);\n                msg.providerPeers = [{\n                  id: dht.peerId,\n                  multiaddrs: multiaddrs\n                }]; // Notify closest peers\n\n                _context3.next = 9;\n                return utils.mapParallel(dht.getClosestPeers(key.buffer), /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peer) {\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            dht._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n                            _context2.prev = 1;\n                            _context2.next = 4;\n                            return dht.network.sendMessage(peer, msg);\n\n                          case 4:\n                            _context2.next = 9;\n                            break;\n\n                          case 6:\n                            _context2.prev = 6;\n                            _context2.t0 = _context2[\"catch\"](1);\n                            errors.push(_context2.t0);\n\n                          case 9:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, null, [[1, 6]]);\n                  }));\n\n                  return function (_x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n              case 9:\n                if (!errors.length) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                throw errcode(new Error(\"Failed to provide to \".concat(errors.length, \" of \").concat(dht.kBucketSize, \" peers\"), 'ERR_SOME_PROVIDES_FAILED'), {\n                  errors: errors\n                });\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    findProviders: function findProviders(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var providerTimeout, n, out, provs, _iterator, _step, pData, paths, query, peers, _iterator2, _step2, _pData;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                providerTimeout = options.timeout || c.minute;\n                n = options.maxNumProviders || c.K;\n\n                dht._log('findProviders %s', key.toBaseEncodedString());\n\n                out = new LimitedPeerList(n);\n                _context5.next = 6;\n                return _awaitAsyncGenerator(dht.providers.getProviders(key));\n\n              case 6:\n                provs = _context5.sent;\n                provs.forEach(function (id) {\n                  var peerData = dht.peerStore.get(id) || {};\n                  out.push({\n                    id: peerData.id || id,\n                    multiaddrs: (peerData.addresses || []).map(function (address) {\n                      return address.multiaddr;\n                    })\n                  });\n                }); // All done\n\n                if (!(out.length >= n)) {\n                  _context5.next = 27;\n                  break;\n                }\n\n                // yield values\n                _iterator = _createForOfIteratorHelper(out.toArray());\n                _context5.prev = 10;\n\n                _iterator.s();\n\n              case 12:\n                if ((_step = _iterator.n()).done) {\n                  _context5.next = 18;\n                  break;\n                }\n\n                pData = _step.value;\n                _context5.next = 16;\n                return pData;\n\n              case 16:\n                _context5.next = 12;\n                break;\n\n              case 18:\n                _context5.next = 23;\n                break;\n\n              case 20:\n                _context5.prev = 20;\n                _context5.t0 = _context5[\"catch\"](10);\n\n                _iterator.e(_context5.t0);\n\n              case 23:\n                _context5.prev = 23;\n\n                _iterator.f();\n\n                return _context5.finish(23);\n\n              case 26:\n                return _context5.abrupt(\"return\");\n\n              case 27:\n                // need more, query the network\n                paths = [];\n                query = new Query(dht, key.buffer, function (pathIndex, numPaths) {\n                  // This function body runs once per disjoint path\n                  var pathSize = utils.pathSize(n - out.length, numPaths);\n                  var pathProviders = new LimitedPeerList(pathSize);\n                  paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n                  return /*#__PURE__*/function () {\n                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peer) {\n                      var msg, provs;\n                      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              _context4.next = 2;\n                              return findProvidersSingle(peer, key);\n\n                            case 2:\n                              msg = _context4.sent;\n                              provs = msg.providerPeers;\n\n                              dht._log('(%s) found %s provider entries', dht.peerId.toB58String(), provs.length);\n\n                              provs.forEach(function (prov) {\n                                pathProviders.push({\n                                  id: prov.id\n                                });\n                              }); // hooray we have all that we want\n\n                              if (!(pathProviders.length >= pathSize)) {\n                                _context4.next = 8;\n                                break;\n                              }\n\n                              return _context4.abrupt(\"return\", {\n                                pathComplete: true\n                              });\n\n                            case 8:\n                              return _context4.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 9:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee4);\n                    }));\n\n                    return function (_x4) {\n                      return _ref3.apply(this, arguments);\n                    };\n                  }();\n                });\n                peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize);\n                _context5.prev = 30;\n                _context5.next = 33;\n                return _awaitAsyncGenerator(pTimeout(query.run(peers), providerTimeout));\n\n              case 33:\n                _context5.next = 39;\n                break;\n\n              case 35:\n                _context5.prev = 35;\n                _context5.t1 = _context5[\"catch\"](30);\n\n                if (!(_context5.t1.name !== pTimeout.TimeoutError.name)) {\n                  _context5.next = 39;\n                  break;\n                }\n\n                throw _context5.t1;\n\n              case 39:\n                _context5.prev = 39;\n                query.stop();\n                return _context5.finish(39);\n\n              case 42:\n                // combine peers from each path\n                paths.forEach(function (path) {\n                  path.toArray().forEach(function (peer) {\n                    out.push(peer);\n                  });\n                });\n\n                if (!(out.length === 0)) {\n                  _context5.next = 45;\n                  break;\n                }\n\n                throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND');\n\n              case 45:\n                _iterator2 = _createForOfIteratorHelper(out.toArray());\n                _context5.prev = 46;\n\n                _iterator2.s();\n\n              case 48:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context5.next = 54;\n                  break;\n                }\n\n                _pData = _step2.value;\n                _context5.next = 52;\n                return _pData;\n\n              case 52:\n                _context5.next = 48;\n                break;\n\n              case 54:\n                _context5.next = 59;\n                break;\n\n              case 56:\n                _context5.prev = 56;\n                _context5.t2 = _context5[\"catch\"](46);\n\n                _iterator2.e(_context5.t2);\n\n              case 59:\n                _context5.prev = 59;\n\n                _iterator2.f();\n\n                return _context5.finish(59);\n\n              case 62:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[10, 20, 23, 26], [30, 35, 39, 42], [46, 56, 59, 62]]);\n      }))();\n    }\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/content-routing/index.js"],"names":["errcode","require","pTimeout","c","LimitedPeerList","Message","Query","utils","module","exports","dht","findProvidersSingle","peer","key","msg","TYPES","GET_PROVIDERS","buffer","network","sendRequest","provide","_log","toBaseEncodedString","errors","providers","addProvider","peerId","multiaddrs","libp2p","ADD_PROVIDER","providerPeers","id","mapParallel","getClosestPeers","toB58String","sendMessage","push","length","Error","kBucketSize","findProviders","options","providerTimeout","timeout","minute","n","maxNumProviders","K","out","getProviders","provs","forEach","peerData","peerStore","get","addresses","map","address","multiaddr","toArray","pData","paths","query","pathIndex","numPaths","pathSize","pathProviders","prov","pathComplete","closerPeers","peers","routingTable","closestPeers","run","name","TimeoutError","stop","path"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst c = require('../constants')\nconst LimitedPeerList = require('../peer-list/limited-peer-list')\nconst Message = require('../message')\nconst Query = require('../query')\nconst utils = require('../utils')\n\nmodule.exports = (dht) => {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n  const findProvidersSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  return {\n    /**\n     * Announce to the network that we can provide given key's value.\n     * @param {CID} key\n     * @returns {Promise<void>}\n     */\n    async provide (key) {\n      dht._log('provide: %s', key.toBaseEncodedString())\n\n      const errors = []\n\n      // Add peer as provider\n      await dht.providers.addProvider(key, dht.peerId)\n\n      const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : []\n      const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0)\n      msg.providerPeers = [{\n        id: dht.peerId,\n        multiaddrs\n      }]\n\n      // Notify closest peers\n      await utils.mapParallel(dht.getClosestPeers(key.buffer), async (peer) => {\n        dht._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String())\n        try {\n          await dht.network.sendMessage(peer, msg)\n        } catch (err) {\n          errors.push(err)\n        }\n      })\n\n      if (errors.length) {\n        // TODO:\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        throw errcode(new Error(`Failed to provide to ${errors.length} of ${dht.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED'), { errors })\n      }\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async * findProviders (key, options = {}) {\n      const providerTimeout = options.timeout || c.minute\n      const n = options.maxNumProviders || c.K\n\n      dht._log('findProviders %s', key.toBaseEncodedString())\n\n      const out = new LimitedPeerList(n)\n      const provs = await dht.providers.getProviders(key)\n\n      provs.forEach((id) => {\n        const peerData = dht.peerStore.get(id) || {}\n        out.push({\n          id: peerData.id || id,\n          multiaddrs: (peerData.addresses || []).map((address) => address.multiaddr)\n        })\n      })\n\n      // All done\n      if (out.length >= n) {\n        // yield values\n        for (const pData of out.toArray()) {\n          yield pData\n        }\n        return\n      }\n\n      // need more, query the network\n      const paths = []\n      const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(n - out.length, numPaths)\n        const pathProviders = new LimitedPeerList(pathSize)\n        paths.push(pathProviders)\n\n        // Here we return the query function to use on this particular disjoint path\n        return async (peer) => {\n          const msg = await findProvidersSingle(peer, key)\n          const provs = msg.providerPeers\n          dht._log('(%s) found %s provider entries', dht.peerId.toB58String(), provs.length)\n\n          provs.forEach((prov) => {\n            pathProviders.push({ id: prov.id })\n          })\n\n          // hooray we have all that we want\n          if (pathProviders.length >= pathSize) {\n            return { pathComplete: true }\n          }\n\n          // it looks like we want some more\n          return { closerPeers: msg.closerPeers }\n        }\n      })\n\n      const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize)\n\n      try {\n        await pTimeout(\n          query.run(peers),\n          providerTimeout\n        )\n      } catch (err) {\n        if (err.name !== pTimeout.TimeoutError.name) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      // combine peers from each path\n      paths.forEach((path) => {\n        path.toArray().forEach((peer) => {\n          out.push(peer)\n        })\n      })\n\n      if (out.length === 0) {\n        throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND')\n      }\n\n      for (const pData of out.toArray()) {\n        yield pData\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}