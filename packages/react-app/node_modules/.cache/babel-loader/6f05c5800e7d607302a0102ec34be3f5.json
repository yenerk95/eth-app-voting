{"ast":null,"code":"'use strict';\n\nconst {\n  filter,\n  sortAll,\n  take,\n  map\n} = require('./utils');\n\nconst drain = require('it-drain');\n\nclass InterfaceDatastoreAdapter {\n  async open() {// eslint-disable-line require-await\n  }\n\n  async close() {// eslint-disable-line require-await\n  }\n  /**\n   * Store the passed value under the passed key\n   *\n   * @param {Key} key\n   * @param {Buffer} val\n   * @param {Object} options\n   * @returns {Promise<void>}\n   */\n\n\n  async put(key, val, options = {}) {// eslint-disable-line require-await\n  }\n  /**\n   * Store the given key/value pairs\n   *\n   * @param {AsyncIterator<{ key: Key, value: Buffer }>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<{ key: Key, value: Buffer }>}\n   */\n\n\n  async *putMany(source, options = {}) {\n    for await (const {\n      key,\n      value\n    } of source) {\n      await this.put(key, value, options);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  /**\n   * Retrieve the value for the passed key\n   *\n   * @param {Key} key\n   * @param {Object} options\n   * @returns {Promise<Buffer>}\n   */\n\n\n  async get(key, options = {}) {// eslint-disable-line require-await\n  }\n  /**\n   * Retrieve values for the passed keys\n   *\n   * @param {AsyncIterator<Key>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<Buffer>}\n   */\n\n\n  async *getMany(source, options = {}) {\n    for await (const key of source) {\n      yield this.get(key, options);\n    }\n  }\n  /**\n   * Check for the existence of a value for the passed key\n   *\n   * @param {Key} key\n   * @returns {Promise<bool>}\n   */\n\n\n  async has(key) {// eslint-disable-line require-await\n  }\n  /**\n   * Remove the record for the passed key\n   *\n   * @param {Key} key\n   * @param {Object} options\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(key, options = {}) {// eslint-disable-line require-await\n  }\n  /**\n   * Remove values for the passed keys\n   *\n   * @param {AsyncIterator<Key>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<Key>}\n   */\n\n\n  async *deleteMany(source, options = {}) {\n    for await (const key of source) {\n      await this.delete(key, options);\n      yield key;\n    }\n  }\n  /**\n   * Create a new batch object.\n   *\n   * @returns {Object}\n   */\n\n\n  batch() {\n    let puts = [];\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n\n      delete(key) {\n        dels.push(key);\n      },\n\n      commit: async options => {\n        await drain(this.putMany(puts, options));\n        puts = [];\n        await drain(this.deleteMany(dels, options));\n        dels = [];\n      }\n    };\n  }\n  /**\n   * Yield all datastore values\n   *\n   * @param {Object} q\n   * @param {Object} options\n   * @returns {AsyncIterable<{ key: Key, value: Buffer }>}\n   */\n\n\n  async *_all(q, options) {// eslint-disable-line require-await\n  }\n  /**\n   * Query the store.\n   *\n   * @param {Object} q\n   * @param {Object} options\n   * @returns {AsyncIterable<Buffer>}\n   */\n\n\n  async *query(q, options) {\n    // eslint-disable-line require-await\n    let it = this._all(q, options);\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    if (q.keysOnly === true) {\n      it = map(it, e => ({\n        key: e.key\n      }));\n    }\n\n    yield* it;\n  }\n\n}\n\nmodule.exports = InterfaceDatastoreAdapter;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/interface-datastore/src/adapter.js"],"names":["filter","sortAll","take","map","require","drain","InterfaceDatastoreAdapter","open","close","put","key","val","options","putMany","source","value","get","getMany","has","delete","deleteMany","batch","puts","dels","push","commit","_all","q","query","it","prefix","e","toString","startsWith","Array","isArray","filters","reduce","f","orders","offset","i","limit","keysOnly","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { filter, sortAll, take, map } = require('./utils')\nconst drain = require('it-drain')\n\nclass InterfaceDatastoreAdapter {\n  async open () { // eslint-disable-line require-await\n\n  }\n\n  async close () { // eslint-disable-line require-await\n\n  }\n\n  /**\n   * Store the passed value under the passed key\n   *\n   * @param {Key} key\n   * @param {Buffer} val\n   * @param {Object} options\n   * @returns {Promise<void>}\n   */\n  async put (key, val, options = {}) { // eslint-disable-line require-await\n\n  }\n\n  /**\n   * Store the given key/value pairs\n   *\n   * @param {AsyncIterator<{ key: Key, value: Buffer }>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<{ key: Key, value: Buffer }>}\n   */\n  async * putMany (source, options = {}) {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield { key, value }\n    }\n  }\n\n  /**\n   * Retrieve the value for the passed key\n   *\n   * @param {Key} key\n   * @param {Object} options\n   * @returns {Promise<Buffer>}\n   */\n  async get (key, options = {}) { // eslint-disable-line require-await\n\n  }\n\n  /**\n   * Retrieve values for the passed keys\n   *\n   * @param {AsyncIterator<Key>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<Buffer>}\n   */\n  async * getMany (source, options = {}) {\n    for await (const key of source) {\n      yield this.get(key, options)\n    }\n  }\n\n  /**\n   * Check for the existence of a value for the passed key\n   *\n   * @param {Key} key\n   * @returns {Promise<bool>}\n   */\n  async has (key) { // eslint-disable-line require-await\n\n  }\n\n  /**\n   * Remove the record for the passed key\n   *\n   * @param {Key} key\n   * @param {Object} options\n   * @returns {Promise<void>}\n   */\n  async delete (key, options = {}) { // eslint-disable-line require-await\n\n  }\n\n  /**\n   * Remove values for the passed keys\n   *\n   * @param {AsyncIterator<Key>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<Key>}\n   */\n  async * deleteMany (source, options = {}) {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  /**\n   * Create a new batch object.\n   *\n   * @returns {Object}\n   */\n  batch () {\n    let puts = []\n    let dels = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Yield all datastore values\n   *\n   * @param {Object} q\n   * @param {Object} options\n   * @returns {AsyncIterable<{ key: Key, value: Buffer }>}\n   */\n  async * _all (q, options) { // eslint-disable-line require-await\n\n  }\n\n  /**\n   * Query the store.\n   *\n   * @param {Object} q\n   * @param {Object} options\n   * @returns {AsyncIterable<Buffer>}\n   */\n  async * query (q, options) { // eslint-disable-line require-await\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      it = filter(it, () => i++ >= q.offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    if (q.keysOnly === true) {\n      it = map(it, e => ({ key: e.key }))\n    }\n\n    yield * it\n  }\n}\n\nmodule.exports = InterfaceDatastoreAdapter\n"]},"metadata":{},"sourceType":"script"}