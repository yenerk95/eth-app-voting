{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar errcode = require('err-code');\n\nvar hmac = require('../hmac');\n\nvar cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}; // Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cipherType, hash, secret) {\n    var cipher, allowed, cipherKeySize, ivSize, hmacKeySize, seed, resultLength, m, a, result, j, b, todo, half, resultBuffer, r1, r2, createKey;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            cipher = cipherMap[cipherType];\n\n            if (cipher) {\n              _context.next = 4;\n              break;\n            }\n\n            allowed = Object.keys(cipherMap).join(' / ');\n            throw errcode(new Error(\"unknown cipher type '\".concat(cipherType, \"'. Must be \").concat(allowed)), 'ERR_INVALID_CIPHER_TYPE');\n\n          case 4:\n            if (hash) {\n              _context.next = 6;\n              break;\n            }\n\n            throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE');\n\n          case 6:\n            cipherKeySize = cipher.keySize;\n            ivSize = cipher.ivSize;\n            hmacKeySize = 20;\n            seed = Buffer.from('key expansion');\n            resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n            _context.next = 13;\n            return hmac.create(hash, secret);\n\n          case 13:\n            m = _context.sent;\n            _context.next = 16;\n            return m.digest(seed);\n\n          case 16:\n            a = _context.sent;\n            result = [];\n            j = 0;\n\n          case 19:\n            if (!(j < resultLength)) {\n              _context.next = 32;\n              break;\n            }\n\n            _context.next = 22;\n            return m.digest(Buffer.concat([a, seed]));\n\n          case 22:\n            b = _context.sent;\n            todo = b.length;\n\n            if (j + todo > resultLength) {\n              todo = resultLength - j;\n            }\n\n            result.push(b);\n            j += todo;\n            _context.next = 29;\n            return m.digest(a);\n\n          case 29:\n            a = _context.sent;\n            _context.next = 19;\n            break;\n\n          case 32:\n            half = resultLength / 2;\n            resultBuffer = Buffer.concat(result);\n            r1 = resultBuffer.slice(0, half);\n            r2 = resultBuffer.slice(half, resultLength);\n\n            createKey = function createKey(res) {\n              return {\n                iv: res.slice(0, ivSize),\n                cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n                macKey: res.slice(ivSize + cipherKeySize)\n              };\n            };\n\n            return _context.abrupt(\"return\", {\n              k1: createKey(r1),\n              k2: createKey(r2)\n            });\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/key-stretcher.js"],"names":["require","Buffer","errcode","hmac","cipherMap","ivSize","keySize","Blowfish","cipherKeySize","module","exports","cipherType","hash","secret","cipher","allowed","Object","keys","join","Error","hmacKeySize","seed","from","resultLength","create","m","digest","a","result","j","concat","b","todo","length","push","half","resultBuffer","r1","slice","r2","createKey","res","iv","cipherKey","macKey","k1","k2"],"mappings":"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","sourcesContent":["'use strict'\nconst { Buffer } = require('buffer')\nconst errcode = require('err-code')\nconst hmac = require('../hmac')\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}\n\n// Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\nmodule.exports = async (cipherType, hash, secret) => {\n  const cipher = cipherMap[cipherType]\n\n  if (!cipher) {\n    const allowed = Object.keys(cipherMap).join(' / ')\n    throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), 'ERR_INVALID_CIPHER_TYPE')\n  }\n\n  if (!hash) {\n    throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE')\n  }\n\n  const cipherKeySize = cipher.keySize\n  const ivSize = cipher.ivSize\n  const hmacKeySize = 20\n  const seed = Buffer.from('key expansion')\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize)\n\n  const m = await hmac.create(hash, secret)\n  let a = await m.digest(seed)\n\n  const result = []\n  let j = 0\n\n  while (j < resultLength) {\n    const b = await m.digest(Buffer.concat([a, seed]))\n    let todo = b.length\n\n    if (j + todo > resultLength) {\n      todo = resultLength - j\n    }\n\n    result.push(b)\n    j += todo\n    a = await m.digest(a)\n  }\n\n  const half = resultLength / 2\n  const resultBuffer = Buffer.concat(result)\n  const r1 = resultBuffer.slice(0, half)\n  const r2 = resultBuffer.slice(half, resultLength)\n\n  const createKey = (res) => ({\n    iv: res.slice(0, ivSize),\n    cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n    macKey: res.slice(ivSize + cipherKeySize)\n  })\n\n  return {\n    k1: createKey(r1),\n    k2: createKey(r2)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}