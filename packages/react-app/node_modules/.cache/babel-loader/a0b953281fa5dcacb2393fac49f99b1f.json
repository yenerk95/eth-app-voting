{"ast":null,"code":"import _classCallCheck from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Buffer } from 'buffer';\nimport { generateKeypair, isValidPublicKey } from '../utils';\nimport { AbstractHandshake } from \"./abstract-handshake\";\nexport var XX = /*#__PURE__*/function (_AbstractHandshake) {\n  _inherits(XX, _AbstractHandshake);\n\n  var _super = _createSuper(XX);\n\n  function XX() {\n    _classCallCheck(this, XX);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(XX, [{\n    key: \"initializeInitiator\",\n    value: function initializeInitiator(prologue, s, rs, psk) {\n      var name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n      var ss = this.initializeSymmetric(name);\n      this.mixHash(ss, prologue);\n      var re = Buffer.alloc(32);\n      return {\n        ss: ss,\n        s: s,\n        rs: rs,\n        psk: psk,\n        re: re\n      };\n    }\n  }, {\n    key: \"initializeResponder\",\n    value: function initializeResponder(prologue, s, rs, psk) {\n      var name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n      var ss = this.initializeSymmetric(name);\n      this.mixHash(ss, prologue);\n      var re = Buffer.alloc(32);\n      return {\n        ss: ss,\n        s: s,\n        rs: rs,\n        psk: psk,\n        re: re\n      };\n    }\n  }, {\n    key: \"writeMessageA\",\n    value: function writeMessageA(hs, payload, e) {\n      var ns = Buffer.alloc(0);\n\n      if (e) {\n        hs.e = e;\n      } else {\n        hs.e = generateKeypair();\n      }\n\n      var ne = hs.e.publicKey;\n      this.mixHash(hs.ss, ne);\n      var ciphertext = this.encryptAndHash(hs.ss, payload);\n      return {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n    }\n  }, {\n    key: \"writeMessageB\",\n    value: function writeMessageB(hs, payload) {\n      hs.e = generateKeypair();\n      var ne = hs.e.publicKey;\n      this.mixHash(hs.ss, ne);\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n      var spk = Buffer.from(hs.s.publicKey);\n      var ns = this.encryptAndHash(hs.ss, spk);\n      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n      var ciphertext = this.encryptAndHash(hs.ss, payload);\n      return {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n    }\n  }, {\n    key: \"writeMessageC\",\n    value: function writeMessageC(hs, payload) {\n      var spk = Buffer.from(hs.s.publicKey);\n      var ns = this.encryptAndHash(hs.ss, spk);\n      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n      var ciphertext = this.encryptAndHash(hs.ss, payload);\n      var ne = this.createEmptyKey();\n      var messageBuffer = {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n\n      var _this$split = this.split(hs.ss),\n          cs1 = _this$split.cs1,\n          cs2 = _this$split.cs2;\n\n      return {\n        h: hs.ss.h,\n        messageBuffer: messageBuffer,\n        cs1: cs1,\n        cs2: cs2\n      };\n    }\n  }, {\n    key: \"readMessageA\",\n    value: function readMessageA(hs, message) {\n      if (isValidPublicKey(message.ne)) {\n        hs.re = message.ne;\n      }\n\n      this.mixHash(hs.ss, hs.re);\n      return this.decryptAndHash(hs.ss, message.ciphertext);\n    }\n  }, {\n    key: \"readMessageB\",\n    value: function readMessageB(hs, message) {\n      if (isValidPublicKey(message.ne)) {\n        hs.re = message.ne;\n      }\n\n      this.mixHash(hs.ss, hs.re);\n\n      if (!hs.e) {\n        throw new Error(\"Handshake state `e` param is missing.\");\n      }\n\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n\n      var _this$decryptAndHash = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash.plaintext,\n          valid1 = _this$decryptAndHash.valid;\n\n      if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n        hs.rs = ns;\n      }\n\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n      var _this$decryptAndHash2 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash2.plaintext,\n          valid2 = _this$decryptAndHash2.valid;\n\n      return {\n        plaintext: plaintext,\n        valid: valid1 && valid2\n      };\n    }\n  }, {\n    key: \"readMessageC\",\n    value: function readMessageC(hs, message) {\n      var _this$decryptAndHash3 = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash3.plaintext,\n          valid1 = _this$decryptAndHash3.valid;\n\n      if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n        hs.rs = ns;\n      }\n\n      if (!hs.e) {\n        throw new Error(\"Handshake state `e` param is missing.\");\n      }\n\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n      var _this$decryptAndHash4 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash4.plaintext,\n          valid2 = _this$decryptAndHash4.valid;\n\n      var _this$split2 = this.split(hs.ss),\n          cs1 = _this$split2.cs1,\n          cs2 = _this$split2.cs2;\n\n      return {\n        h: hs.ss.h,\n        plaintext: plaintext,\n        valid: valid1 && valid2,\n        cs1: cs1,\n        cs2: cs2\n      };\n    }\n  }, {\n    key: \"initSession\",\n    value: function initSession(initiator, prologue, s) {\n      var psk = this.createEmptyKey();\n      var rs = Buffer.alloc(32); // no static key yet\n\n      var hs;\n\n      if (initiator) {\n        hs = this.initializeInitiator(prologue, s, rs, psk);\n      } else {\n        hs = this.initializeResponder(prologue, s, rs, psk);\n      }\n\n      return {\n        hs: hs,\n        i: initiator,\n        mc: 0\n      };\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(session, message, ephemeral) {\n      var messageBuffer;\n\n      if (session.mc === 0) {\n        messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n      } else if (session.mc === 1) {\n        messageBuffer = this.writeMessageB(session.hs, message);\n      } else if (session.mc === 2) {\n        var _this$writeMessageC = this.writeMessageC(session.hs, message),\n            h = _this$writeMessageC.h,\n            resultingBuffer = _this$writeMessageC.messageBuffer,\n            cs1 = _this$writeMessageC.cs1,\n            cs2 = _this$writeMessageC.cs2;\n\n        messageBuffer = resultingBuffer;\n        session.h = h;\n        session.cs1 = cs1;\n        session.cs2 = cs2;\n      } else if (session.mc > 2) {\n        if (session.i) {\n          if (!session.cs1) {\n            throw new Error(\"CS1 (cipher state) is not defined\");\n          }\n\n          messageBuffer = this.writeMessageRegular(session.cs1, message);\n        } else {\n          if (!session.cs2) {\n            throw new Error(\"CS2 (cipher state) is not defined\");\n          }\n\n          messageBuffer = this.writeMessageRegular(session.cs2, message);\n        }\n      } else {\n        throw new Error(\"Session invalid.\");\n      }\n\n      session.mc++;\n      return messageBuffer;\n    }\n  }, {\n    key: \"recvMessage\",\n    value: function recvMessage(session, message) {\n      var plaintext = Buffer.alloc(0);\n      var valid = false;\n\n      if (session.mc === 0) {\n        var _this$readMessageA = this.readMessageA(session.hs, message);\n\n        plaintext = _this$readMessageA.plaintext;\n        valid = _this$readMessageA.valid;\n      } else if (session.mc === 1) {\n        var _this$readMessageB = this.readMessageB(session.hs, message);\n\n        plaintext = _this$readMessageB.plaintext;\n        valid = _this$readMessageB.valid;\n      } else if (session.mc === 2) {\n        var _this$readMessageC = this.readMessageC(session.hs, message),\n            h = _this$readMessageC.h,\n            resultingPlaintext = _this$readMessageC.plaintext,\n            resultingValid = _this$readMessageC.valid,\n            cs1 = _this$readMessageC.cs1,\n            cs2 = _this$readMessageC.cs2;\n\n        plaintext = resultingPlaintext;\n        valid = resultingValid;\n        session.h = h;\n        session.cs1 = cs1;\n        session.cs2 = cs2;\n      }\n\n      session.mc++;\n      return {\n        plaintext: plaintext,\n        valid: valid\n      };\n    }\n  }]);\n\n  return XX;\n}(AbstractHandshake);","map":{"version":3,"sources":["../../src/handshakes/xx.ts"],"names":["name","ss","re","Buffer","s","rs","psk","ns","hs","generateKeypair","ne","ciphertext","spk","messageBuffer","cs2","h","cs1","isValidPublicKey","message","plaintext","valid","valid1","valid2","i","mc","session"],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer';\nimport { bytes32, bytes } from '../@types/basic'\nimport { KeyPair } from '../@types/libp2p'\nimport {generateKeypair, isValidPublicKey} from '../utils';\nimport {CipherState, HandshakeState, MessageBuffer, NoiseSession} from \"../@types/handshake\";\nimport {AbstractHandshake} from \"./abstract-handshake\";\n\n\nexport class XX extends AbstractHandshake {\n  private initializeInitiator(prologue: bytes32, s: KeyPair, rs: bytes32, psk: bytes32): HandshakeState {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n\n    return { ss, s, rs, psk, re };\n  }\n\n  private initializeResponder(prologue: bytes32, s: KeyPair, rs: bytes32, psk: bytes32): HandshakeState {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n\n    return { ss, s, rs, psk, re };\n  }\n\n  private writeMessageA(hs: HandshakeState, payload: bytes, e?: KeyPair): MessageBuffer {\n    const ns = Buffer.alloc(0);\n\n    if (e) {\n      hs.e = e;\n    } else {\n      hs.e = generateKeypair();\n    }\n\n    const ne = hs.e.publicKey;\n\n    this.mixHash(hs.ss, ne);\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n\n    return {ne, ns, ciphertext};\n  }\n\n  private writeMessageB(hs: HandshakeState, payload: bytes): MessageBuffer {\n    hs.e = generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n\n    return { ne, ns, ciphertext };\n  }\n\n  private writeMessageC(hs: HandshakeState, payload: bytes) {\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    const ne = this.createEmptyKey();\n    const messageBuffer: MessageBuffer = {ne, ns, ciphertext};\n    const { cs1, cs2 } = this.split(hs.ss);\n\n    return { h: hs.ss.h, messageBuffer, cs1, cs2 };\n  }\n\n  private readMessageA(hs: HandshakeState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    return this.decryptAndHash(hs.ss, message.ciphertext);\n  }\n\n  private readMessageB(hs: HandshakeState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);\n    return {plaintext, valid: (valid1 && valid2)};\n  }\n\n  private readMessageC(hs: HandshakeState, message: MessageBuffer): {h: bytes; plaintext: bytes; valid: boolean; cs1: CipherState; cs2: CipherState} {\n    const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n    const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);\n    const { cs1, cs2 } = this.split(hs.ss);\n\n    return { h: hs.ss.h, plaintext, valid: (valid1 && valid2), cs1, cs2 };\n  }\n\n  public initSession(initiator: boolean, prologue: bytes32, s: KeyPair): NoiseSession {\n    const psk = this.createEmptyKey();\n    const rs = Buffer.alloc(32); // no static key yet\n    let hs;\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk);\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk);\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0,\n    };\n  }\n\n  public sendMessage(session: NoiseSession, message: bytes, ephemeral?: KeyPair): MessageBuffer {\n    let messageBuffer: MessageBuffer;\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n    } else if (session.mc === 1) {\n      messageBuffer = this.writeMessageB(session.hs, message);\n    } else if (session.mc === 2) {\n      const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);\n      messageBuffer = resultingBuffer;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    } else if (session.mc > 2) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error(\"CS1 (cipher state) is not defined\")\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message);\n      } else {\n        if (!session.cs2) {\n          throw new Error(\"CS2 (cipher state) is not defined\")\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message);\n      }\n    } else {\n      throw new Error(\"Session invalid.\")\n    }\n\n    session.mc++;\n    return messageBuffer;\n  }\n\n  public recvMessage(session: NoiseSession, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    let plaintext: bytes = Buffer.alloc(0);\n    let valid = false;\n    if (session.mc === 0) {\n      ({plaintext, valid} = this.readMessageA(session.hs, message));\n    } else if (session.mc === 1) {\n      ({plaintext, valid} = this.readMessageB(session.hs, message));\n    } else if (session.mc === 2) {\n      const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);\n      plaintext = resultingPlaintext;\n      valid = resultingValid;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    }\n    session.mc++;\n    return {plaintext, valid};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}