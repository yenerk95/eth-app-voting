{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  Key,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @returns {Promise}\n   */\n\n\n  async put(key, val) {\n    // eslint-disable-line require-await\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!Buffer.isBuffer(val)) {\n      const errMsg = 'received value is not a buffer';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n    return this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   * @param {Buffer} key identifier of the value to be subscribed.\n   * @returns {Promise<Buffer>}\n   */\n\n\n  async get(key) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key);\n    } // subscribe\n\n\n    try {\n      await this._pubsub.subscribe(stringifiedTopic, this._onMessage);\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   * @param {Buffer} key identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n    return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n  } // Get record from local datastore\n\n\n  async _getLocal(key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n    }\n\n    if (!Buffer.isBuffer(dsVal)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  } // handles pubsub subscription messages\n\n\n  async _onMessage(msg) {\n    const {\n      data,\n      from,\n      topicIDs\n    } = msg;\n    let key;\n\n    try {\n      key = topicToKey(topicIDs[0]);\n    } catch (err) {\n      log.error(err);\n      return;\n    }\n\n    log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (err) {\n      log.error(err);\n    }\n  } // Store the received record if it is better than the current stored\n\n\n  async _storeIfSubscriptionIsBetter(key, data) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(Buffer.from(key), data);\n    }\n  } // Validate record according to the received validation function\n\n\n  async _validateRecord(value, peerId) {\n    // eslint-disable-line require-await\n    return this._validator.validate(value, peerId);\n  } // Select the best record according to the received select function.\n\n\n  async _selectRecord(receivedRecord, currentRecord) {\n    const res = await this._validator.select(receivedRecord, currentRecord); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  } // Verify if the record received through pubsub is valid and better than the one currently stored\n\n\n  async _isBetter(key, val) {\n    // validate received record\n    let error, valid;\n\n    try {\n      valid = await this._validateRecord(val, key);\n    } catch (err) {\n      error = err;\n    } // If not valid, it is not better than the one currently available\n\n\n    if (error || !valid) {\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.toBuffer());\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (currentRecord.equals(val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(val, currentRecord);\n  } // add record to datastore\n\n\n  async _storeRecord(key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n\n  open() {\n    const errMsg = 'open function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  has(key) {\n    const errMsg = 'has function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  delete(key) {\n    const errMsg = 'delete function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  close() {\n    const errMsg = 'close function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  batch() {\n    const errMsg = 'batch function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  query() {\n    const errMsg = 'query function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/datastore-pubsub/src/index.js"],"names":["Buffer","require","Key","Adapter","encodeBase32","keyToTopic","topicToKey","errcode","debug","log","error","DatastorePubsub","constructor","pubsub","datastore","peerId","validator","subscriptionKeyFn","TypeError","validate","select","_pubsub","_datastore","_peerId","_validator","_handleSubscriptionKeyFn","_onMessage","bind","put","key","val","isBuffer","errMsg","Error","stringifiedTopic","publish","get","subscriptions","getTopics","Array","isArray","indexOf","_getLocal","subscribe","err","unsubscribe","routingKey","dsVal","code","toString","msg","data","from","topicIDs","toB58String","res","_storeIfSubscriptionIsBetter","isBetter","_isBetter","_storeRecord","_validateRecord","value","_selectRecord","receivedRecord","currentRecord","valid","dsKey","toBuffer","equals","open","has","delete","close","batch","query","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst { Key, Adapter } = require('interface-datastore')\nconst { encodeBase32, keyToTopic, topicToKey } = require('./utils')\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('datastore-pubsub:publisher')\nlog.error = debug('datastore-pubsub:publisher:error')\n\n// DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor (pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super()\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS')\n    }\n\n    this._pubsub = pubsub\n    this._datastore = datastore\n    this._peerId = peerId\n    this._validator = validator\n    this._handleSubscriptionKeyFn = subscriptionKeyFn\n\n    // Bind _onMessage function, which is called by pubsub.\n    this._onMessage = this._onMessage.bind(this)\n  }\n\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @returns {Promise}\n   */\n  async put (key, val) { // eslint-disable-line require-await\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    if (!Buffer.isBuffer(val)) {\n      const errMsg = 'received value is not a buffer'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n\n    log(`publish value for topic ${stringifiedTopic}`)\n\n    // Publish record to pubsub\n    return this._pubsub.publish(stringifiedTopic, val)\n  }\n\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   * @param {Buffer} key identifier of the value to be subscribed.\n   * @returns {Promise<Buffer>}\n   */\n  async get (key) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY')\n    }\n\n    const stringifiedTopic = keyToTopic(key)\n    const subscriptions = await this._pubsub.getTopics()\n\n    // If already subscribed, just try to get it\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key)\n    }\n\n    // subscribe\n    try {\n      await this._pubsub.subscribe(stringifiedTopic, this._onMessage)\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC')\n    }\n    log(`subscribed values for key ${stringifiedTopic}`)\n\n    return this._getLocal(key)\n  }\n\n  /**\n   * Unsubscribe topic.\n   * @param {Buffer} key identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n  unsubscribe (key) {\n    const stringifiedTopic = keyToTopic(key)\n\n    return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage)\n  }\n\n  // Get record from local datastore\n  async _getLocal (key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n    let dsVal\n\n    try {\n      dsVal = await this._datastore.get(routingKey)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`\n\n        log.error(errMsg)\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD')\n      }\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND')\n    }\n\n    if (!Buffer.isBuffer(dsVal)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED')\n    }\n\n    return dsVal\n  }\n\n  // handles pubsub subscription messages\n  async _onMessage (msg) {\n    const { data, from, topicIDs } = msg\n    let key\n    try {\n      key = topicToKey(topicIDs[0])\n    } catch (err) {\n      log.error(err)\n      return\n    }\n\n    log(`message received for topic ${topicIDs[0]}`)\n\n    // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer')\n      return\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key)\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn')\n        return\n      }\n\n      key = res\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data)\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  // Store the received record if it is better than the current stored\n  async _storeIfSubscriptionIsBetter (key, data) {\n    let isBetter = false\n\n    try {\n      isBetter = await this._isBetter(key, data)\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(Buffer.from(key), data)\n    }\n  }\n\n  // Validate record according to the received validation function\n  async _validateRecord (value, peerId) { // eslint-disable-line require-await\n    return this._validator.validate(value, peerId)\n  }\n\n  // Select the best record according to the received select function.\n  async _selectRecord (receivedRecord, currentRecord) {\n    const res = await this._validator.select(receivedRecord, currentRecord)\n\n    // If the selected was the first (0), it should be stored (true)\n    return res === 0\n  }\n\n  // Verify if the record received through pubsub is valid and better than the one currently stored\n  async _isBetter (key, val) {\n    // validate received record\n    let error, valid\n\n    try {\n      valid = await this._validateRecord(val, key)\n    } catch (err) {\n      error = err\n    }\n\n    // If not valid, it is not better than the one currently available\n    if (error || !valid) {\n      const errMsg = 'record received through pubsub is not valid'\n\n      log.error(errMsg)\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD')\n    }\n\n    // Get Local record\n    const dsKey = new Key(key)\n    let currentRecord\n\n    try {\n      currentRecord = await this._getLocal(dsKey.toBuffer())\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true\n    }\n\n    // if the same record, do not need to store\n    if (currentRecord.equals(val)) {\n      return false\n    }\n\n    // verify if the received record should replace the current one\n    return this._selectRecord(val, currentRecord)\n  }\n\n  // add record to datastore\n  async _storeRecord (key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false)\n\n    await this._datastore.put(routingKey, data)\n    log(`record for ${keyToTopic(key)} was stored in the datastore`)\n  }\n\n  open () {\n    const errMsg = 'open function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  has (key) {\n    const errMsg = 'has function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  delete (key) {\n    const errMsg = 'delete function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  close () {\n    const errMsg = 'close function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  batch () {\n    const errMsg = 'batch function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n\n  query () {\n    const errMsg = 'query function was not implemented yet'\n\n    log.error(errMsg)\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET')\n  }\n}\n\nexports = module.exports = DatastorePubsub\n"]},"metadata":{},"sourceType":"script"}