{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar START_MASKS = [255, 254, 252, 248, 240, 224, 192, 128];\nvar STOP_MASKS = [1, 3, 7, 15, 31, 63, 127, 255];\n\nmodule.exports = /*#__PURE__*/function () {\n  function ConsumableBuffer(value) {\n    _classCallCheck(this, ConsumableBuffer);\n\n    this._value = value;\n    this._currentBytePos = value.length - 1;\n    this._currentBitPos = 7;\n  }\n\n  _createClass(ConsumableBuffer, [{\n    key: \"availableBits\",\n    value: function availableBits() {\n      return this._currentBitPos + 1 + this._currentBytePos * 8;\n    }\n  }, {\n    key: \"totalBits\",\n    value: function totalBits() {\n      return this._value.length * 8;\n    }\n  }, {\n    key: \"take\",\n    value: function take(bits) {\n      var pendingBits = bits;\n      var result = 0;\n\n      while (pendingBits && this._haveBits()) {\n        var byte = this._value[this._currentBytePos];\n        var availableBits = this._currentBitPos + 1;\n        var taking = Math.min(availableBits, pendingBits);\n        var value = byteBitsToInt(byte, availableBits - taking, taking);\n        result = (result << taking) + value;\n        pendingBits -= taking;\n        this._currentBitPos -= taking;\n\n        if (this._currentBitPos < 0) {\n          this._currentBitPos = 7;\n          this._currentBytePos--;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      this._currentBitPos += bits;\n\n      while (this._currentBitPos > 7) {\n        this._currentBitPos -= 8;\n        this._currentBytePos += 1;\n      }\n    }\n  }, {\n    key: \"_haveBits\",\n    value: function _haveBits() {\n      return this._currentBytePos >= 0;\n    }\n  }]);\n\n  return ConsumableBuffer;\n}();\n\nfunction byteBitsToInt(byte, start, length) {\n  var mask = maskFor(start, length);\n  return (byte & mask) >>> start;\n}\n\nfunction maskFor(start, length) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)];\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/hamt-sharding/src/consumable-buffer.js"],"names":["START_MASKS","STOP_MASKS","module","exports","value","_value","_currentBytePos","length","_currentBitPos","bits","pendingBits","result","_haveBits","byte","availableBits","taking","Math","min","byteBitsToInt","start","mask","maskFor"],"mappings":"AAAA;;;;;;AAEA,IAAMA,WAAW,GAAG,CAClB,GADkB,EAElB,GAFkB,EAGlB,GAHkB,EAIlB,GAJkB,EAKlB,GALkB,EAMlB,GANkB,EAOlB,GAPkB,EAQlB,GARkB,CAApB;AAWA,IAAMC,UAAU,GAAG,CACjB,CADiB,EAEjB,CAFiB,EAGjB,CAHiB,EAIjB,EAJiB,EAKjB,EALiB,EAMjB,EANiB,EAOjB,GAPiB,EAQjB,GARiB,CAAnB;;AAWAC,MAAM,CAACC,OAAP;AACE,4BAAaC,KAAb,EAAoB;AAAA;;AAClB,SAAKC,MAAL,GAAcD,KAAd;AACA,SAAKE,eAAL,GAAuBF,KAAK,CAACG,MAAN,GAAe,CAAtC;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACD;;AALH;AAAA;AAAA,oCAOmB;AACf,aAAO,KAAKA,cAAL,GAAsB,CAAtB,GAA0B,KAAKF,eAAL,GAAuB,CAAxD;AACD;AATH;AAAA;AAAA,gCAWe;AACX,aAAO,KAAKD,MAAL,CAAYE,MAAZ,GAAqB,CAA5B;AACD;AAbH;AAAA;AAAA,yBAeQE,IAfR,EAec;AACV,UAAIC,WAAW,GAAGD,IAAlB;AACA,UAAIE,MAAM,GAAG,CAAb;;AACA,aAAOD,WAAW,IAAI,KAAKE,SAAL,EAAtB,EAAwC;AACtC,YAAMC,IAAI,GAAG,KAAKR,MAAL,CAAY,KAAKC,eAAjB,CAAb;AACA,YAAMQ,aAAa,GAAG,KAAKN,cAAL,GAAsB,CAA5C;AACA,YAAMO,MAAM,GAAGC,IAAI,CAACC,GAAL,CAASH,aAAT,EAAwBJ,WAAxB,CAAf;AACA,YAAMN,KAAK,GAAGc,aAAa,CAACL,IAAD,EAAOC,aAAa,GAAGC,MAAvB,EAA+BA,MAA/B,CAA3B;AACAJ,QAAAA,MAAM,GAAG,CAACA,MAAM,IAAII,MAAX,IAAqBX,KAA9B;AAEAM,QAAAA,WAAW,IAAIK,MAAf;AAEA,aAAKP,cAAL,IAAuBO,MAAvB;;AACA,YAAI,KAAKP,cAAL,GAAsB,CAA1B,EAA6B;AAC3B,eAAKA,cAAL,GAAsB,CAAtB;AACA,eAAKF,eAAL;AACD;AACF;;AAED,aAAOK,MAAP;AACD;AAnCH;AAAA;AAAA,2BAqCUF,IArCV,EAqCgB;AACZ,WAAKD,cAAL,IAAuBC,IAAvB;;AACA,aAAO,KAAKD,cAAL,GAAsB,CAA7B,EAAgC;AAC9B,aAAKA,cAAL,IAAuB,CAAvB;AACA,aAAKF,eAAL,IAAwB,CAAxB;AACD;AACF;AA3CH;AAAA;AAAA,gCA6Ce;AACX,aAAO,KAAKA,eAAL,IAAwB,CAA/B;AACD;AA/CH;;AAAA;AAAA;;AAkDA,SAASY,aAAT,CAAwBL,IAAxB,EAA8BM,KAA9B,EAAqCZ,MAArC,EAA6C;AAC3C,MAAMa,IAAI,GAAGC,OAAO,CAACF,KAAD,EAAQZ,MAAR,CAApB;AACA,SAAO,CAACM,IAAI,GAAGO,IAAR,MAAkBD,KAAzB;AACD;;AAED,SAASE,OAAT,CAAkBF,KAAlB,EAAyBZ,MAAzB,EAAiC;AAC/B,SAAOP,WAAW,CAACmB,KAAD,CAAX,GAAqBlB,UAAU,CAACe,IAAI,CAACC,GAAL,CAASV,MAAM,GAAGY,KAAT,GAAiB,CAA1B,EAA6B,CAA7B,CAAD,CAAtC;AACD","sourcesContent":["'use strict'\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nmodule.exports = class ConsumableBuffer {\n  constructor (value) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits () {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits () {\n    return this._value.length * 8\n  }\n\n  take (bits) {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits) {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits () {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte, start, length) {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start, length) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n"]},"metadata":{},"sourceType":"script"}