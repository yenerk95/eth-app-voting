{"ast":null,"code":"'use strict';\n\nconst sha = require('multihashing-async/src/sha');\n\nconst protobuf = require('protons');\n\nconst multibase = require('multibase');\n\nconst errcode = require('err-code');\n\nconst crypto = require('./rsa');\n\nconst pbm = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/sha512');\n\nrequire('node-forge/lib/ed25519');\n\nconst forge = require('node-forge/lib/forge');\n\nclass RsaPublicKey {\n  constructor(key) {\n    this._key = key;\n  }\n\n  async verify(data, sig) {\n    // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkix(this._key);\n  }\n\n  get bytes() {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  encrypt(bytes) {\n    return crypto.encrypt(this._key, bytes);\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor(key, publicKey) {\n    this._key = key;\n    this._publicKey = publicKey;\n  }\n\n  genSecret() {\n    return crypto.getRandomValues(16);\n  }\n\n  async sign(message) {\n    // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message);\n  }\n\n  get public() {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED');\n    }\n\n    return new RsaPublicKey(this._publicKey);\n  }\n\n  decrypt(bytes) {\n    return crypto.decrypt(this._key, bytes);\n  }\n\n  marshal() {\n    return crypto.utils.jwkToPkcs1(this._key);\n  }\n\n  get bytes() {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    });\n  }\n\n  equals(key) {\n    return this.bytes.equals(key.bytes);\n  }\n\n  async hash() {\n    // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256');\n  }\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n\n\n  async id() {\n    const hash = await this.public.hash();\n    return multibase.encode('base58btc', hash).toString().slice(1);\n  }\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   */\n\n\n  async export(password, format = 'pkcs-8') {\n    // eslint-disable-line require-await\n    let pem = null;\n    const buffer = new forge.util.ByteBuffer(this.marshal());\n    const asn1 = forge.asn1.fromDer(buffer);\n    const privateKey = forge.pki.privateKeyFromAsn1(asn1);\n\n    if (format === 'pkcs-8') {\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      };\n      pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options);\n    } else {\n      throw errcode(new Error(`Unknown export format '${format}'. Must be pkcs-8`), 'ERR_INVALID_EXPORT_FORMAT');\n    }\n\n    return pem;\n  }\n\n}\n\nasync function unmarshalRsaPrivateKey(bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes);\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nfunction unmarshalRsaPublicKey(bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes);\n  return new RsaPublicKey(jwk);\n}\n\nasync function fromJwk(jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nasync function generateKeyPair(bits) {\n  const keys = await crypto.generateKey(bits);\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey);\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/rsa-class.js"],"names":["sha","require","protobuf","multibase","errcode","crypto","pbm","forge","RsaPublicKey","constructor","key","_key","verify","data","sig","hashAndVerify","marshal","utils","jwkToPkix","bytes","PublicKey","encode","Type","KeyType","RSA","Data","encrypt","equals","hash","multihashing","RsaPrivateKey","publicKey","_publicKey","genSecret","getRandomValues","sign","message","hashAndSign","public","Error","decrypt","jwkToPkcs1","PrivateKey","id","toString","slice","export","password","format","pem","buffer","util","ByteBuffer","asn1","fromDer","privateKey","pki","privateKeyFromAsn1","options","algorithm","count","saltSize","prfAlgorithm","encryptRsaPrivateKey","unmarshalRsaPrivateKey","jwk","pkcs1ToJwk","keys","unmarshalPrivateKey","unmarshalRsaPublicKey","pkixToJwk","fromJwk","generateKeyPair","bits","generateKey","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst sha = require('multihashing-async/src/sha')\nconst protobuf = require('protons')\nconst multibase = require('multibase')\nconst errcode = require('err-code')\n\nconst crypto = require('./rsa')\nconst pbm = protobuf(require('./keys.proto'))\nrequire('node-forge/lib/sha512')\nrequire('node-forge/lib/ed25519')\nconst forge = require('node-forge/lib/forge')\n\nclass RsaPublicKey {\n  constructor (key) {\n    this._key = key\n  }\n\n  async verify (data, sig) { // eslint-disable-line require-await\n    return crypto.hashAndVerify(this._key, sig, data)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkix(this._key)\n  }\n\n  get bytes () {\n    return pbm.PublicKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  encrypt (bytes) {\n    return crypto.encrypt(this._key, bytes)\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n}\n\nclass RsaPrivateKey {\n  // key       - Object of the jwk format\n  // publicKey - Buffer of the spki format\n  constructor (key, publicKey) {\n    this._key = key\n    this._publicKey = publicKey\n  }\n\n  genSecret () {\n    return crypto.getRandomValues(16)\n  }\n\n  async sign (message) { // eslint-disable-line require-await\n    return crypto.hashAndSign(this._key, message)\n  }\n\n  get public () {\n    if (!this._publicKey) {\n      throw errcode(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')\n    }\n\n    return new RsaPublicKey(this._publicKey)\n  }\n\n  decrypt (bytes) {\n    return crypto.decrypt(this._key, bytes)\n  }\n\n  marshal () {\n    return crypto.utils.jwkToPkcs1(this._key)\n  }\n\n  get bytes () {\n    return pbm.PrivateKey.encode({\n      Type: pbm.KeyType.RSA,\n      Data: this.marshal()\n    })\n  }\n\n  equals (key) {\n    return this.bytes.equals(key.bytes)\n  }\n\n  async hash () { // eslint-disable-line require-await\n    return sha.multihashing(this.bytes, 'sha2-256')\n  }\n\n  /**\n   * Gets the ID of the key.\n   *\n   * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n   * The public key is a protobuf encoding containing a type and the DER encoding\n   * of the PKCS SubjectPublicKeyInfo.\n   *\n   * @returns {Promise<String>}\n   */\n  async id () {\n    const hash = await this.public.hash()\n    return multibase.encode('base58btc', hash).toString().slice(1)\n  }\n\n  /**\n   * Exports the key into a password protected PEM format\n   *\n   * @param {string} password - The password to read the encrypted PEM\n   * @param {string} [format] - Defaults to 'pkcs-8'.\n   */\n  async export (password, format = 'pkcs-8') { // eslint-disable-line require-await\n    let pem = null\n\n    const buffer = new forge.util.ByteBuffer(this.marshal())\n    const asn1 = forge.asn1.fromDer(buffer)\n    const privateKey = forge.pki.privateKeyFromAsn1(asn1)\n\n    if (format === 'pkcs-8') {\n      const options = {\n        algorithm: 'aes256',\n        count: 10000,\n        saltSize: 128 / 8,\n        prfAlgorithm: 'sha512'\n      }\n      pem = forge.pki.encryptRsaPrivateKey(privateKey, password, options)\n    } else {\n      throw errcode(new Error(`Unknown export format '${format}'. Must be pkcs-8`), 'ERR_INVALID_EXPORT_FORMAT')\n    }\n\n    return pem\n  }\n}\n\nasync function unmarshalRsaPrivateKey (bytes) {\n  const jwk = crypto.utils.pkcs1ToJwk(bytes)\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nfunction unmarshalRsaPublicKey (bytes) {\n  const jwk = crypto.utils.pkixToJwk(bytes)\n  return new RsaPublicKey(jwk)\n}\n\nasync function fromJwk (jwk) {\n  const keys = await crypto.unmarshalPrivateKey(jwk)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nasync function generateKeyPair (bits) {\n  const keys = await crypto.generateKey(bits)\n  return new RsaPrivateKey(keys.privateKey, keys.publicKey)\n}\n\nmodule.exports = {\n  RsaPublicKey,\n  RsaPrivateKey,\n  unmarshalRsaPublicKey,\n  unmarshalRsaPrivateKey,\n  generateKeyPair,\n  fromJwk\n}\n"]},"metadata":{},"sourceType":"script"}