{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst c = require('../constants');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nmodule.exports = dht => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   * @param {PeerId} peer\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  const findPeerLocal = async peer => {\n    dht._log('findPeerLocal %s', peer.toB58String());\n\n    const p = await dht.routingTable.find(peer);\n    const peerData = p && dht.peerStore.get(p);\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    }\n  };\n  /**\n   * Get a value via rpc call for the given parameters.\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  const getValueSingle = async (peer, key) => {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n    return dht.network.sendRequest(peer, msg);\n  };\n  /**\n   * Find close peers for a given peer\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log('closerPeersSingle %b from %s', key, peer.toB58String());\n\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n    return msg.closerPeers.filter(peerData => !dht._isSelf(peerData.id)).map(peerData => {\n      dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);\n      return peerData;\n    });\n  };\n  /**\n   * Get the public key directly from a node.\n   * @param {PeerId} peer\n   * @returns {Promise<PublicKey>}\n   * @private\n   */\n\n\n  const getPublicKeyFromNode = async peer => {\n    const pkKey = utils.keyForPublicKey(peer);\n    const msg = await getValueSingle(peer, pkKey);\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD');\n    }\n\n    const recPeer = PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n    }\n\n    return recPeer.pubKey;\n  };\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    async _findPeerSingle(peer, target) {\n      // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String());\n\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n      return dht.network.sendRequest(peer, msg);\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer(id, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n      const pi = await findPeerLocal(id); // already got it\n\n      if (pi != null) {\n        dht._log('found local');\n\n        return pi;\n      }\n\n      const key = await utils.convertPeerId(id);\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n      } // sanity check\n\n\n      const match = peers.find(p => p.isEqual(id));\n\n      if (match) {\n        const peer = dht.peerStore.get(id);\n\n        if (peer) {\n          dht._log('found in peerStore');\n\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map(address => address.multiaddr)\n          };\n        }\n      } // query the network\n\n\n      const query = new Query(dht, id.id, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async peer => {\n          const msg = await this._findPeerSingle(peer, id);\n          const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            };\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          };\n        };\n      });\n      let error, result;\n\n      try {\n        result = await pTimeout(query.run(peers), options.timeout);\n      } catch (err) {\n        error = err;\n      }\n\n      query.stop();\n      if (error) throw error;\n      let success = false;\n      result.paths.forEach(result => {\n        if (result.success) {\n          success = true;\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs);\n        }\n      });\n\n      dht._log('findPeer %s: %s', id.toB58String(), success);\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n      }\n\n      const peerData = dht.peerStore.get(id);\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map(address => address.multiaddr)\n      };\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     * @param {Buffer} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow] shallow query (default: false)\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async *getClosestPeers(key, options = {\n      shallow: false\n    }) {\n      dht._log('getClosestPeers to %b', key);\n\n      const id = await utils.convertBuffer(key);\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async peer => {\n          const closer = await closerPeersSingle(key, peer);\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          };\n        };\n      });\n      const res = await q.run(tablePeers);\n\n      if (!res || !res.finalSet) {\n        return [];\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id);\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId;\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     * @param {PeerId} peer\n     * @returns {Promise<PubKey>}\n     */\n    async getPublicKey(peer) {\n      dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n      const peerData = dht.peerStore.get(peer);\n\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy');\n\n        return peerData.id.pubKey;\n      } // try the node directly\n\n\n      let pk;\n\n      try {\n        pk = await getPublicKeyFromNode(peer);\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer);\n        const value = await dht.get(pkKey);\n        pk = crypto.keys.unmarshalPublicKey(value);\n      }\n\n      peerData.id = new PeerId(peer.id, null, pk);\n      const addrs = peerData.addresses.map(address => address.multiaddr);\n      dht.peerStore.addressBook.add(peerData.id, addrs);\n      dht.peerStore.keyBook.set(peerData.id, pk);\n      return pk;\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/peer-routing/index.js"],"names":["errcode","require","pTimeout","PeerId","crypto","c","Message","Query","utils","module","exports","dht","findPeerLocal","peer","_log","toB58String","p","routingTable","find","peerData","peerStore","get","id","multiaddrs","addresses","map","address","multiaddr","getValueSingle","key","msg","TYPES","GET_VALUE","network","sendRequest","closerPeersSingle","peerRouting","_findPeerSingle","closerPeers","filter","_isSelf","addressBook","add","getPublicKeyFromNode","pkKey","keyForPublicKey","record","value","recPeer","createFromPubKey","isEqual","pubKey","target","FIND_NODE","findPeer","options","timeout","minute","pi","convertPeerId","peers","closestPeers","kBucketSize","length","Error","match","query","queryComplete","error","result","run","err","stop","success","paths","forEach","getClosestPeers","shallow","convertBuffer","tablePeers","q","closer","pathComplete","undefined","res","finalSet","sorted","sortClosestPeers","Array","from","pId","slice","getPublicKey","pk","keys","unmarshalPublicKey","addrs","keyBook","set"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\n\nconst c = require('../constants')\nconst Message = require('../message')\nconst Query = require('../query')\n\nconst utils = require('../utils')\n\nmodule.exports = (dht) => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns its id and addresses, if found, otherwise `undefined`.\n   * @param {PeerId} peer\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  const findPeerLocal = async (peer) => {\n    dht._log('findPeerLocal %s', peer.toB58String())\n    const p = await dht.routingTable.find(peer)\n\n    const peerData = p && dht.peerStore.get(p)\n\n    if (peerData) {\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    }\n  }\n\n  /**\n   * Get a value via rpc call for the given parameters.\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n  const getValueSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  /**\n   * Find close peers for a given peer\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<{ id: PeerId, multiaddrs: Multiaddr[] }>>}\n   * @private\n   */\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log('closerPeersSingle %b from %s', key, peer.toB58String())\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key))\n\n    return msg.closerPeers\n      .filter((peerData) => !dht._isSelf(peerData.id))\n      .map((peerData) => {\n        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs)\n\n        return peerData\n      })\n  }\n\n  /**\n   * Get the public key directly from a node.\n   * @param {PeerId} peer\n   * @returns {Promise<PublicKey>}\n   * @private\n   */\n  const getPublicKeyFromNode = async (peer) => {\n    const pkKey = utils.keyForPublicKey(peer)\n    const msg = await getValueSingle(peer, pkKey)\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD')\n    }\n\n    const recPeer = PeerId.createFromPubKey(msg.record.value)\n\n    // compare hashes of the pub key\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID')\n    }\n\n    return recPeer.pubKey\n  }\n\n  return {\n  /**\n   * Ask peer `peer` if they know where the peer with id `target` is.\n   * @param {PeerId} peer\n   * @param {PeerId} target\n   * @returns {Promise<Message>}\n   * @private\n   */\n    async _findPeerSingle (peer, target) { // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String())\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0)\n\n      return dht.network.sendRequest(peer, msg)\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async findPeer (id, options = {}) {\n      options.timeout = options.timeout || c.minute\n      dht._log('findPeer %s', id.toB58String())\n\n      // Try to find locally\n      const pi = await findPeerLocal(id)\n\n      // already got it\n      if (pi != null) {\n        dht._log('found local')\n        return pi\n      }\n\n      const key = await utils.convertPeerId(id)\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize)\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED')\n      }\n\n      // sanity check\n      const match = peers.find((p) => p.isEqual(id))\n      if (match) {\n        const peer = dht.peerStore.get(id)\n\n        if (peer) {\n          dht._log('found in peerStore')\n          return {\n            id: peer.id,\n            multiaddrs: peer.addresses.map((address) => address.multiaddr)\n          }\n        }\n      }\n\n      // query the network\n      const query = new Query(dht, id.id, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const msg = await this._findPeerSingle(peer, id)\n          const match = msg.closerPeers.find((p) => p.id.isEqual(id))\n\n          // found it\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            }\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          }\n        }\n      })\n\n      let error, result\n      try {\n        result = await pTimeout(query.run(peers), options.timeout)\n      } catch (err) {\n        error = err\n      }\n      query.stop()\n      if (error) throw error\n\n      let success = false\n      result.paths.forEach((result) => {\n        if (result.success) {\n          success = true\n          dht.peerStore.addressBook.add(result.peer.id, result.peer.multiaddrs)\n        }\n      })\n      dht._log('findPeer %s: %s', id.toB58String(), success)\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND')\n      }\n\n      const peerData = dht.peerStore.get(id)\n\n      return {\n        id: peerData.id,\n        multiaddrs: peerData.addresses.map((address) => address.multiaddr)\n      }\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     * @param {Buffer} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow] shallow query (default: false)\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async * getClosestPeers (key, options = { shallow: false }) {\n      dht._log('getClosestPeers to %b', key)\n\n      const id = await utils.convertBuffer(key)\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize)\n\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async (peer) => {\n          const closer = await closerPeersSingle(key, peer)\n\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          }\n        }\n      })\n\n      const res = await q.run(tablePeers)\n      if (!res || !res.finalSet) {\n        return []\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id)\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     * @param {PeerId} peer\n     * @returns {Promise<PubKey>}\n     */\n    async getPublicKey (peer) {\n      dht._log('getPublicKey %s', peer.toB58String())\n\n      // local check\n      const peerData = dht.peerStore.get(peer)\n      if (peerData && peerData.id.pubKey) {\n        dht._log('getPublicKey: found local copy')\n        return peerData.id.pubKey\n      }\n\n      // try the node directly\n      let pk\n      try {\n        pk = await getPublicKeyFromNode(peer)\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer)\n        const value = await dht.get(pkKey)\n        pk = crypto.keys.unmarshalPublicKey(value)\n      }\n\n      peerData.id = new PeerId(peer.id, null, pk)\n      const addrs = peerData.addresses.map((address) => address.multiaddr)\n      dht.peerStore.addressBook.add(peerData.id, addrs)\n      dht.peerStore.keyBook.set(peerData.id, pk)\n\n      return pk\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}