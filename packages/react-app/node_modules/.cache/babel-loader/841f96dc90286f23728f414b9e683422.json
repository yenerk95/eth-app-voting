{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { Buffer } from \"buffer\";\nimport { XXHandshake } from \"./handshake-xx\";\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from \"./utils\";\nimport { logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey } from \"./logger\";\nimport { decode0, decode1 } from \"./encoder\";\nexport class XXFallbackHandshake extends XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    _defineProperty(this, \"ephemeralKeys\", void 0);\n\n    _defineProperty(this, \"initialMsg\", void 0);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n\n\n  async propose() {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys);\n      logger(\"XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.\");\n      logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger(\"XX Fallback Stage 0 - Responder decoding initial msg from IK.\");\n      const receivedMessageBuffer = decode0(this.initialMsg);\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: Buffer.alloc(0),\n        ciphertext: Buffer.alloc(0)\n      });\n\n      if (!valid) {\n        throw new Error(\"xx fallback stage 0 decryption validation fail\");\n      }\n\n      logger(\"XX Fallback Stage 0 - Responder used received message from IK.\");\n      logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = decode1(this.initialMsg);\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error(\"xx fallback stage 1 decryption validation fail\");\n      }\n\n      logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logRemoteEphemeralKey(this.session.hs.re);\n      logRemoteStaticKey(this.session.hs.rs);\n      logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await getPeerIdFromPayload(decodedPayload));\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        throw new Error(\"Error occurred while verifying signed payload from responder: \".concat(e.message));\n      }\n\n      logger(\"All good with the signature!\");\n    } else {\n      logger(\"XX Fallback Stage 1 - Responder start\");\n      await super.exchange();\n      logger(\"XX Fallback Stage 1 - Responder end\");\n    }\n  }\n\n}","map":{"version":3,"sources":["../src/handshake-xx-fallback.ts"],"names":["constructor","Buffer","logger","logLocalEphemeralKeys","receivedMessageBuffer","decode0","valid","ne","ns","ciphertext","logRemoteEphemeralKey","decode1","logRemoteStaticKey","decodedPayload","decodePayload","getPeerIdFromPayload","verifySignedPayload","e"],"mappings":"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","sourcesContent":["import {Buffer} from \"buffer\";\nimport {XXHandshake} from \"./handshake-xx\";\nimport {XX} from \"./handshakes/xx\";\nimport {KeyPair} from \"./@types/libp2p\";\nimport {bytes, bytes32} from \"./@types/basic\";\nimport {decodePayload, getPeerIdFromPayload, verifySignedPayload} from \"./utils\";\nimport {logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey} from \"./logger\";\nimport {WrappedConnection} from \"./noise\";\nimport {decode0, decode1} from \"./encoder\";\nimport PeerId from \"peer-id\";\n\nexport class XXFallbackHandshake extends XXHandshake {\n  private ephemeralKeys?: KeyPair;\n  private initialMsg: bytes;\n\n  constructor(\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    initialMsg: bytes,\n    remotePeer?: PeerId,\n    ephemeralKeys?: KeyPair,\n    handshake?: XX,\n  ) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n    this.initialMsg = initialMsg;\n  }\n\n  // stage 0\n  public async propose(): Promise<void> {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys);\n      logger(\"XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.\");\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger(\"XX Fallback Stage 0 - Responder decoding initial msg from IK.\");\n      const receivedMessageBuffer = decode0(this.initialMsg);\n      const {valid} = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: Buffer.alloc(0),\n        ciphertext: Buffer.alloc(0),\n      });\n      if(!valid) {\n        throw new Error(\"xx fallback stage 0 decryption validation fail\");\n      }\n      logger(\"XX Fallback Stage 0 - Responder used received message from IK.\");\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange(): Promise<void> {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = decode1(this.initialMsg);\n      const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);\n      if(!valid) {\n        throw new Error(\"xx fallback stage 1 decryption validation fail\");\n      }\n      logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\");\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload);\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`);\n      }\n      logger(\"All good with the signature!\");\n    } else {\n      logger(\"XX Fallback Stage 1 - Responder start\");\n      await super.exchange();\n      logger(\"XX Fallback Stage 1 - Responder end\");\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}