{"ast":null,"code":"'use strict';\n\nconst mergeOptions = require('merge-options');\n\nconst pipe = require('it-pipe');\n\nconst {\n  tap\n} = require('streaming-iterables');\n\nconst oldPeerLRU = require('./old-peers');\n\nconst {\n  METRICS: defaultOptions\n} = require('../constants');\n\nconst Stats = require('./stats');\n\nconst initialCounters = ['dataReceived', 'dataSent'];\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n\nclass Metrics {\n  /**\n   *\n   * @param {object} options\n   * @param {ConnectionManager} options.connectionManager\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {number} options.computeThrottleTimeout\n   * @param {Array<number>} options.movingAverageIntervals\n   * @param {number} options.maxOldPeersRetention\n   */\n  constructor(options) {\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this._connectionManager = options.connectionManager;\n\n    this._connectionManager.on('peer:disconnect', connection => {\n      this.onPeerDisconnected(connection.remotePeer);\n    });\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  start() {\n    this._running = true;\n  }\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n\n\n  stop() {\n    this._running = false;\n\n    this._globalStats.stop();\n\n    for (const stats of this._peerStats.values()) {\n      stats.stop();\n    }\n\n    for (const stats of this._protocolStats.values()) {\n      stats.stop();\n    }\n  }\n  /**\n   * Gets the global `Stats` object\n   * @returns {Stats}\n   */\n\n\n  get global() {\n    return this._globalStats;\n  }\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   * @returns {Array<string>}\n   */\n\n\n  get peers() {\n    return Array.from(this._peerStats.keys());\n  }\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n\n\n  forPeer(peerId) {\n    const idString = peerId.toB58String();\n    return this._peerStats.get(idString) || this._oldPeers.get(idString);\n  }\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   * @returns {Array<string>}\n   */\n\n\n  get protocols() {\n    return Array.from(this._protocolStats.keys());\n  }\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n\n\n  forProtocol(protocol) {\n    return this._protocolStats.get(protocol);\n  }\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   * @param {PeerId} peerId\n   */\n\n\n  onPeerDisconnected(peerId) {\n    const idString = peerId.toB58String();\n\n    const peerStats = this._peerStats.get(idString);\n\n    if (peerStats) {\n      peerStats.stop();\n\n      this._peerStats.delete(idString);\n\n      this._oldPeers.set(idString, peerStats);\n    }\n  }\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer Remote peer\n   * @param {string} [params.protocol] Protocol string the stream is running\n   * @param {string} params.direction One of ['in','out']\n   * @param {number} params.dataLength Size of the message\n   * @returns {void}\n   */\n\n\n  _onMessage({\n    remotePeer,\n    protocol,\n    direction,\n    dataLength\n  }) {\n    if (!this._running) return;\n    const key = directionToEvent[direction];\n    let peerStats = this.forPeer(remotePeer);\n\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options);\n\n      this._peerStats.set(remotePeer.toB58String(), peerStats);\n    } // Peer and global stats\n\n\n    peerStats.push(key, dataLength);\n\n    this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol);\n\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options);\n\n        this._protocolStats.set(protocol, protocolStats);\n      }\n\n      protocolStats.push(key, dataLength);\n    }\n  }\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   * @param {PeerId} placeholder A peerId string\n   * @param {PeerId} peerId\n   */\n\n\n  updatePlaceholder(placeholder, peerId) {\n    if (!this._running) return;\n    const placeholderStats = this.forPeer(placeholder);\n    const peerIdString = peerId.toB58String();\n    const existingStats = this.forPeer(peerId);\n    let mergedStats = placeholderStats; // If we already have stats, merge the two\n\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n      this._oldPeers.delete(peerIdString);\n    }\n\n    this._peerStats.delete(placeholder.toB58String());\n\n    this._peerStats.set(peerIdString, mergedStats);\n\n    mergedStats.start();\n  }\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {{ sink: function(*), source: function() }} options.stream A duplex iterable stream\n   * @param {PeerId} [options.peerId] The id of the remote peer that's connected\n   * @param {string} [options.protocol] The protocol the stream is running\n   * @returns {string} The peerId string or placeholder string\n   */\n\n\n  trackStream({\n    stream,\n    remotePeer,\n    protocol\n  }) {\n    const metrics = this;\n    const _source = stream.source;\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source);\n    const _sink = stream.sink;\n\n    stream.sink = source => {\n      return pipe(source, tap(chunk => metrics._onMessage({\n        remotePeer,\n        protocol,\n        direction: 'out',\n        dataLength: chunk.length\n      })), _sink);\n    };\n\n    return stream;\n  }\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n\n\n  static mergeStats(target, other) {\n    target.stop();\n    other.stop(); // Merge queues\n\n    target._queue = [...target._queue, ...other._queue]; // TODO: how to merge moving averages?\n\n    return target;\n  }\n\n}\n\nmodule.exports = Metrics;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/metrics/index.js"],"names":["mergeOptions","require","pipe","tap","oldPeerLRU","METRICS","defaultOptions","Stats","initialCounters","directionToEvent","in","out","Metrics","constructor","options","_options","_globalStats","_peerStats","Map","_protocolStats","_oldPeers","maxOldPeersRetention","_running","_onMessage","bind","_connectionManager","connectionManager","on","connection","onPeerDisconnected","remotePeer","start","stop","stats","values","global","peers","Array","from","keys","forPeer","peerId","idString","toB58String","get","protocols","forProtocol","protocol","peerStats","delete","set","direction","dataLength","key","push","protocolStats","updatePlaceholder","placeholder","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","trackStream","stream","metrics","_source","source","chunk","length","_sink","sink","target","other","_queue","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,SAAD,CAApB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAUF,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,aAAD,CAA1B;;AACA,MAAM;AAAEI,EAAAA,OAAO,EAAEC;AAAX,IAA8BL,OAAO,CAAC,cAAD,CAA3C;;AACA,MAAMM,KAAK,GAAGN,OAAO,CAAC,SAAD,CAArB;;AAEA,MAAMO,eAAe,GAAG,CACtB,cADsB,EAEtB,UAFsB,CAAxB;AAKA,MAAMC,gBAAgB,GAAG;AACvBC,EAAAA,EAAE,EAAE,cADmB;AAEvBC,EAAAA,GAAG,EAAE;AAFkB,CAAzB;;AAKA,MAAMC,OAAN,CAAc;AACZ;;;;;;;;;AASAC,EAAAA,WAAW,CAAEC,OAAF,EAAW;AACpB,SAAKC,QAAL,GAAgBf,YAAY,CAACM,cAAD,EAAiBQ,OAAjB,CAA5B;AACA,SAAKE,YAAL,GAAoB,IAAIT,KAAJ,CAAUC,eAAV,EAA2B,KAAKO,QAAhC,CAApB;AACA,SAAKE,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;AACA,SAAKC,cAAL,GAAsB,IAAID,GAAJ,EAAtB;AACA,SAAKE,SAAL,GAAiBhB,UAAU,CAAC,KAAKW,QAAL,CAAcM,oBAAf,CAA3B;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAAlB;AACA,SAAKC,kBAAL,GAA0BX,OAAO,CAACY,iBAAlC;;AACA,SAAKD,kBAAL,CAAwBE,EAAxB,CAA2B,iBAA3B,EAA+CC,UAAD,IAAgB;AAC5D,WAAKC,kBAAL,CAAwBD,UAAU,CAACE,UAAnC;AACD,KAFD;AAGD;AAED;;;;;;AAIAC,EAAAA,KAAK,GAAI;AACP,SAAKT,QAAL,GAAgB,IAAhB;AACD;AAED;;;;;;AAIAU,EAAAA,IAAI,GAAI;AACN,SAAKV,QAAL,GAAgB,KAAhB;;AACA,SAAKN,YAAL,CAAkBgB,IAAlB;;AACA,SAAK,MAAMC,KAAX,IAAoB,KAAKhB,UAAL,CAAgBiB,MAAhB,EAApB,EAA8C;AAC5CD,MAAAA,KAAK,CAACD,IAAN;AACD;;AACD,SAAK,MAAMC,KAAX,IAAoB,KAAKd,cAAL,CAAoBe,MAApB,EAApB,EAAkD;AAChDD,MAAAA,KAAK,CAACD,IAAN;AACD;AACF;AAED;;;;;;AAIA,MAAIG,MAAJ,GAAc;AACZ,WAAO,KAAKnB,YAAZ;AACD;AAED;;;;;;AAIA,MAAIoB,KAAJ,GAAa;AACX,WAAOC,KAAK,CAACC,IAAN,CAAW,KAAKrB,UAAL,CAAgBsB,IAAhB,EAAX,CAAP;AACD;AAED;;;;;;;;AAMAC,EAAAA,OAAO,CAAEC,MAAF,EAAU;AACf,UAAMC,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;AACA,WAAO,KAAK1B,UAAL,CAAgB2B,GAAhB,CAAoBF,QAApB,KAAiC,KAAKtB,SAAL,CAAewB,GAAf,CAAmBF,QAAnB,CAAxC;AACD;AAED;;;;;;AAIA,MAAIG,SAAJ,GAAiB;AACf,WAAOR,KAAK,CAACC,IAAN,CAAW,KAAKnB,cAAL,CAAoBoB,IAApB,EAAX,CAAP;AACD;AAED;;;;;;;AAKAO,EAAAA,WAAW,CAAEC,QAAF,EAAY;AACrB,WAAO,KAAK5B,cAAL,CAAoByB,GAApB,CAAwBG,QAAxB,CAAP;AACD;AAED;;;;;;;;AAMAlB,EAAAA,kBAAkB,CAAEY,MAAF,EAAU;AAC1B,UAAMC,QAAQ,GAAGD,MAAM,CAACE,WAAP,EAAjB;;AACA,UAAMK,SAAS,GAAG,KAAK/B,UAAL,CAAgB2B,GAAhB,CAAoBF,QAApB,CAAlB;;AACA,QAAIM,SAAJ,EAAe;AACbA,MAAAA,SAAS,CAAChB,IAAV;;AACA,WAAKf,UAAL,CAAgBgC,MAAhB,CAAuBP,QAAvB;;AACA,WAAKtB,SAAL,CAAe8B,GAAf,CAAmBR,QAAnB,EAA6BM,SAA7B;AACD;AACF;AAED;;;;;;;;;;;;;;;AAaAzB,EAAAA,UAAU,CAAE;AAAEO,IAAAA,UAAF;AAAciB,IAAAA,QAAd;AAAwBI,IAAAA,SAAxB;AAAmCC,IAAAA;AAAnC,GAAF,EAAmD;AAC3D,QAAI,CAAC,KAAK9B,QAAV,EAAoB;AAEpB,UAAM+B,GAAG,GAAG5C,gBAAgB,CAAC0C,SAAD,CAA5B;AAEA,QAAIH,SAAS,GAAG,KAAKR,OAAL,CAAaV,UAAb,CAAhB;;AACA,QAAI,CAACkB,SAAL,EAAgB;AACdA,MAAAA,SAAS,GAAG,IAAIzC,KAAJ,CAAUC,eAAV,EAA2B,KAAKO,QAAhC,CAAZ;;AACA,WAAKE,UAAL,CAAgBiC,GAAhB,CAAoBpB,UAAU,CAACa,WAAX,EAApB,EAA8CK,SAA9C;AACD,KAT0D,CAW3D;;;AACAA,IAAAA,SAAS,CAACM,IAAV,CAAeD,GAAf,EAAoBD,UAApB;;AACA,SAAKpC,YAAL,CAAkBsC,IAAlB,CAAuBD,GAAvB,EAA4BD,UAA5B,EAb2D,CAe3D;;;AACA,QAAIL,QAAJ,EAAc;AACZ,UAAIQ,aAAa,GAAG,KAAKT,WAAL,CAAiBC,QAAjB,CAApB;;AACA,UAAI,CAACQ,aAAL,EAAoB;AAClBA,QAAAA,aAAa,GAAG,IAAIhD,KAAJ,CAAUC,eAAV,EAA2B,KAAKO,QAAhC,CAAhB;;AACA,aAAKI,cAAL,CAAoB+B,GAApB,CAAwBH,QAAxB,EAAkCQ,aAAlC;AACD;;AACDA,MAAAA,aAAa,CAACD,IAAd,CAAmBD,GAAnB,EAAwBD,UAAxB;AACD;AACF;AAED;;;;;;;;;AAOAI,EAAAA,iBAAiB,CAAEC,WAAF,EAAehB,MAAf,EAAuB;AACtC,QAAI,CAAC,KAAKnB,QAAV,EAAoB;AACpB,UAAMoC,gBAAgB,GAAG,KAAKlB,OAAL,CAAaiB,WAAb,CAAzB;AACA,UAAME,YAAY,GAAGlB,MAAM,CAACE,WAAP,EAArB;AACA,UAAMiB,aAAa,GAAG,KAAKpB,OAAL,CAAaC,MAAb,CAAtB;AACA,QAAIoB,WAAW,GAAGH,gBAAlB,CALsC,CAOtC;;AACA,QAAIE,aAAJ,EAAmB;AACjB;AACAC,MAAAA,WAAW,GAAGjD,OAAO,CAACkD,UAAR,CAAmBF,aAAnB,EAAkCC,WAAlC,CAAd,CAFiB,CAGjB;;AACA,WAAKzC,SAAL,CAAe6B,MAAf,CAAsBU,YAAtB;AACD;;AAED,SAAK1C,UAAL,CAAgBgC,MAAhB,CAAuBQ,WAAW,CAACd,WAAZ,EAAvB;;AACA,SAAK1B,UAAL,CAAgBiC,GAAhB,CAAoBS,YAApB,EAAkCE,WAAlC;;AACAA,IAAAA,WAAW,CAAC9B,KAAZ;AACD;AAED;;;;;;;;;;;;;;;AAaAgC,EAAAA,WAAW,CAAE;AAAEC,IAAAA,MAAF;AAAUlC,IAAAA,UAAV;AAAsBiB,IAAAA;AAAtB,GAAF,EAAoC;AAC7C,UAAMkB,OAAO,GAAG,IAAhB;AACA,UAAMC,OAAO,GAAGF,MAAM,CAACG,MAAvB;AACAH,IAAAA,MAAM,CAACG,MAAP,GAAgBhE,GAAG,CAACiE,KAAK,IAAIH,OAAO,CAAC1C,UAAR,CAAmB;AAC9CO,MAAAA,UAD8C;AAE9CiB,MAAAA,QAF8C;AAG9CI,MAAAA,SAAS,EAAE,IAHmC;AAI9CC,MAAAA,UAAU,EAAEgB,KAAK,CAACC;AAJ4B,KAAnB,CAAV,CAAH,CAKZH,OALY,CAAhB;AAOA,UAAMI,KAAK,GAAGN,MAAM,CAACO,IAArB;;AACAP,IAAAA,MAAM,CAACO,IAAP,GAAcJ,MAAM,IAAI;AACtB,aAAOjE,IAAI,CACTiE,MADS,EAEThE,GAAG,CAACiE,KAAK,IAAIH,OAAO,CAAC1C,UAAR,CAAmB;AAC9BO,QAAAA,UAD8B;AAE9BiB,QAAAA,QAF8B;AAG9BI,QAAAA,SAAS,EAAE,KAHmB;AAI9BC,QAAAA,UAAU,EAAEgB,KAAK,CAACC;AAJY,OAAnB,CAAV,CAFM,EAQTC,KARS,CAAX;AAUD,KAXD;;AAaA,WAAON,MAAP;AACD;AAED;;;;;;;;;AAOA,SAAOF,UAAP,CAAmBU,MAAnB,EAA2BC,KAA3B,EAAkC;AAChCD,IAAAA,MAAM,CAACxC,IAAP;AACAyC,IAAAA,KAAK,CAACzC,IAAN,GAFgC,CAIhC;;AACAwC,IAAAA,MAAM,CAACE,MAAP,GAAgB,CAAC,GAAGF,MAAM,CAACE,MAAX,EAAmB,GAAGD,KAAK,CAACC,MAA5B,CAAhB,CALgC,CAOhC;;AACA,WAAOF,MAAP;AACD;;AArOW;;AAwOdG,MAAM,CAACC,OAAP,GAAiBhE,OAAjB","sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options')\nconst pipe = require('it-pipe')\nconst { tap } = require('streaming-iterables')\nconst oldPeerLRU = require('./old-peers')\nconst { METRICS: defaultOptions } = require('../constants')\nconst Stats = require('./stats')\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\nclass Metrics {\n  /**\n   *\n   * @param {object} options\n   * @param {ConnectionManager} options.connectionManager\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {number} options.computeThrottleTimeout\n   * @param {Array<number>} options.movingAverageIntervals\n   * @param {number} options.maxOldPeersRetention\n   */\n  constructor (options) {\n    this._options = mergeOptions(defaultOptions, options)\n    this._globalStats = new Stats(initialCounters, this._options)\n    this._peerStats = new Map()\n    this._protocolStats = new Map()\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention)\n    this._running = false\n    this._onMessage = this._onMessage.bind(this)\n    this._connectionManager = options.connectionManager\n    this._connectionManager.on('peer:disconnect', (connection) => {\n      this.onPeerDisconnected(connection.remotePeer)\n    })\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  stop () {\n    this._running = false\n    this._globalStats.stop()\n    for (const stats of this._peerStats.values()) {\n      stats.stop()\n    }\n    for (const stats of this._protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   * @returns {Stats}\n   */\n  get global () {\n    return this._globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   * @returns {Array<string>}\n   */\n  get peers () {\n    return Array.from(this._peerStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n  forPeer (peerId) {\n    const idString = peerId.toB58String()\n    return this._peerStats.get(idString) || this._oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   * @returns {Array<string>}\n   */\n  get protocols () {\n    return Array.from(this._protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n  forProtocol (protocol) {\n    return this._protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   * @param {PeerId} peerId\n   */\n  onPeerDisconnected (peerId) {\n    const idString = peerId.toB58String()\n    const peerStats = this._peerStats.get(idString)\n    if (peerStats) {\n      peerStats.stop()\n      this._peerStats.delete(idString)\n      this._oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer Remote peer\n   * @param {string} [params.protocol] Protocol string the stream is running\n   * @param {string} params.direction One of ['in','out']\n   * @param {number} params.dataLength Size of the message\n   * @returns {void}\n   */\n  _onMessage ({ remotePeer, protocol, direction, dataLength }) {\n    if (!this._running) return\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options)\n      this._peerStats.set(remotePeer.toB58String(), peerStats)\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this._globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol)\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options)\n        this._protocolStats.set(protocol, protocolStats)\n      }\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   * @param {PeerId} placeholder A peerId string\n   * @param {PeerId} peerId\n   */\n  updatePlaceholder (placeholder, peerId) {\n    if (!this._running) return\n    const placeholderStats = this.forPeer(placeholder)\n    const peerIdString = peerId.toB58String()\n    const existingStats = this.forPeer(peerId)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this._oldPeers.delete(peerIdString)\n    }\n\n    this._peerStats.delete(placeholder.toB58String())\n    this._peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {{ sink: function(*), source: function() }} options.stream A duplex iterable stream\n   * @param {PeerId} [options.peerId] The id of the remote peer that's connected\n   * @param {string} [options.protocol] The protocol the stream is running\n   * @returns {string} The peerId string or placeholder string\n   */\n  trackStream ({ stream, remotePeer, protocol }) {\n    const metrics = this\n    const _source = stream.source\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source)\n\n    const _sink = stream.sink\n    stream.sink = source => {\n      return pipe(\n        source,\n        tap(chunk => metrics._onMessage({\n          remotePeer,\n          protocol,\n          direction: 'out',\n          dataLength: chunk.length\n        })),\n        _sink\n      )\n    }\n\n    return stream\n  }\n\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n  static mergeStats (target, other) {\n    target.stop()\n    other.stop()\n\n    // Merge queues\n    target._queue = [...target._queue, ...other._queue]\n\n    // TODO: how to merge moving averages?\n    return target\n  }\n}\n\nmodule.exports = Metrics\n"]},"metadata":{},"sourceType":"script"}