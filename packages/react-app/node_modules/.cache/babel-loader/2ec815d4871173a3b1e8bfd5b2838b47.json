{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar mergeOptions = require('merge-options');\n\nvar pipe = require('it-pipe');\n\nvar _require = require('streaming-iterables'),\n    tap = _require.tap;\n\nvar oldPeerLRU = require('./old-peers');\n\nvar _require2 = require('../constants'),\n    defaultOptions = _require2.METRICS;\n\nvar Stats = require('./stats');\n\nvar initialCounters = ['dataReceived', 'dataSent'];\nvar directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n\nvar Metrics = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {object} options\n   * @param {ConnectionManager} options.connectionManager\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {number} options.computeThrottleTimeout\n   * @param {Array<number>} options.movingAverageIntervals\n   * @param {number} options.maxOldPeersRetention\n   */\n  function Metrics(options) {\n    var _this = this;\n\n    _classCallCheck(this, Metrics);\n\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this._connectionManager = options.connectionManager;\n\n    this._connectionManager.on('peer:disconnect', function (connection) {\n      _this.onPeerDisconnected(connection.remotePeer);\n    });\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  _createClass(Metrics, [{\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n    }\n    /**\n     * Stops all averages timers and prevents new data from being tracked.\n     * Once `stop` is called, `start` must be called to resume stats tracking.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n\n      this._globalStats.stop();\n\n      var _iterator = _createForOfIteratorHelper(this._peerStats.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var stats = _step.value;\n          stats.stop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this._protocolStats.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _stats = _step2.value;\n\n          _stats.stop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Gets the global `Stats` object\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"forPeer\",\n\n    /**\n     * Returns the `Stats` object for the given `PeerId` whether it\n     * is a live peer, or in the disconnected peer LRU cache.\n     * @param {PeerId} peerId\n     * @returns {Stats}\n     */\n    value: function forPeer(peerId) {\n      var idString = peerId.toB58String();\n      return this._peerStats.get(idString) || this._oldPeers.get(idString);\n    }\n    /**\n     * Returns a list of all protocol strings currently being tracked.\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"forProtocol\",\n\n    /**\n     * Returns the `Stats` object for the given `protocol`.\n     * @param {string} protocol\n     * @returns {Stats}\n     */\n    value: function forProtocol(protocol) {\n      return this._protocolStats.get(protocol);\n    }\n    /**\n     * Should be called when all connections to a given peer\n     * have closed. The `Stats` collection for the peer will\n     * be stopped and moved to an LRU for temporary retention.\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"onPeerDisconnected\",\n    value: function onPeerDisconnected(peerId) {\n      var idString = peerId.toB58String();\n\n      var peerStats = this._peerStats.get(idString);\n\n      if (peerStats) {\n        peerStats.stop();\n\n        this._peerStats.delete(idString);\n\n        this._oldPeers.set(idString, peerStats);\n      }\n    }\n    /**\n     * Takes the metadata for a message and tracks it in the\n     * appropriate categories. If the protocol is present, protocol\n     * stats will also be tracked.\n     *\n     * @private\n     * @param {object} params\n     * @param {PeerId} params.remotePeer Remote peer\n     * @param {string} [params.protocol] Protocol string the stream is running\n     * @param {string} params.direction One of ['in','out']\n     * @param {number} params.dataLength Size of the message\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(_ref) {\n      var remotePeer = _ref.remotePeer,\n          protocol = _ref.protocol,\n          direction = _ref.direction,\n          dataLength = _ref.dataLength;\n      if (!this._running) return;\n      var key = directionToEvent[direction];\n      var peerStats = this.forPeer(remotePeer);\n\n      if (!peerStats) {\n        peerStats = new Stats(initialCounters, this._options);\n\n        this._peerStats.set(remotePeer.toB58String(), peerStats);\n      } // Peer and global stats\n\n\n      peerStats.push(key, dataLength);\n\n      this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n      if (protocol) {\n        var protocolStats = this.forProtocol(protocol);\n\n        if (!protocolStats) {\n          protocolStats = new Stats(initialCounters, this._options);\n\n          this._protocolStats.set(protocol, protocolStats);\n        }\n\n        protocolStats.push(key, dataLength);\n      }\n    }\n    /**\n     * Replaces the `PeerId` string with the given `peerId`.\n     * If stats are already being tracked for the given `peerId`, the\n     * placeholder stats will be merged with the existing stats.\n     * @param {PeerId} placeholder A peerId string\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"updatePlaceholder\",\n    value: function updatePlaceholder(placeholder, peerId) {\n      if (!this._running) return;\n      var placeholderStats = this.forPeer(placeholder);\n      var peerIdString = peerId.toB58String();\n      var existingStats = this.forPeer(peerId);\n      var mergedStats = placeholderStats; // If we already have stats, merge the two\n\n      if (existingStats) {\n        // If existing, merge\n        mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n        this._oldPeers.delete(peerIdString);\n      }\n\n      this._peerStats.delete(placeholder.toB58String());\n\n      this._peerStats.set(peerIdString, mergedStats);\n\n      mergedStats.start();\n    }\n    /**\n     * Tracks data running through a given Duplex Iterable `stream`. If\n     * the `peerId` is not provided, a placeholder string will be created and\n     * returned. This allows lazy tracking of a peer when the peer is not yet known.\n     * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n     * with the placeholder string returned from here, and the known `PeerId`.\n     *\n     * @param {Object} options\n     * @param {{ sink: function(*), source: function() }} options.stream A duplex iterable stream\n     * @param {PeerId} [options.peerId] The id of the remote peer that's connected\n     * @param {string} [options.protocol] The protocol the stream is running\n     * @returns {string} The peerId string or placeholder string\n     */\n\n  }, {\n    key: \"trackStream\",\n    value: function trackStream(_ref2) {\n      var stream = _ref2.stream,\n          remotePeer = _ref2.remotePeer,\n          protocol = _ref2.protocol;\n      var metrics = this;\n      var _source = stream.source;\n      stream.source = tap(function (chunk) {\n        return metrics._onMessage({\n          remotePeer: remotePeer,\n          protocol: protocol,\n          direction: 'in',\n          dataLength: chunk.length\n        });\n      })(_source);\n      var _sink = stream.sink;\n\n      stream.sink = function (source) {\n        return pipe(source, tap(function (chunk) {\n          return metrics._onMessage({\n            remotePeer: remotePeer,\n            protocol: protocol,\n            direction: 'out',\n            dataLength: chunk.length\n          });\n        }), _sink);\n      };\n\n      return stream;\n    }\n    /**\n     * Merges `other` into `target`. `target` will be modified\n     * and returned.\n     * @param {Stats} target\n     * @param {Stats} other\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"global\",\n    get: function get() {\n      return this._globalStats;\n    }\n    /**\n     * Returns a list of `PeerId` strings currently being tracked\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"peers\",\n    get: function get() {\n      return Array.from(this._peerStats.keys());\n    }\n  }, {\n    key: \"protocols\",\n    get: function get() {\n      return Array.from(this._protocolStats.keys());\n    }\n  }], [{\n    key: \"mergeStats\",\n    value: function mergeStats(target, other) {\n      target.stop();\n      other.stop(); // Merge queues\n\n      target._queue = [].concat(_toConsumableArray(target._queue), _toConsumableArray(other._queue)); // TODO: how to merge moving averages?\n\n      return target;\n    }\n  }]);\n\n  return Metrics;\n}();\n\nmodule.exports = Metrics;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/metrics/index.js"],"names":["mergeOptions","require","pipe","tap","oldPeerLRU","defaultOptions","METRICS","Stats","initialCounters","directionToEvent","in","out","Metrics","options","_options","_globalStats","_peerStats","Map","_protocolStats","_oldPeers","maxOldPeersRetention","_running","_onMessage","bind","_connectionManager","connectionManager","on","connection","onPeerDisconnected","remotePeer","stop","values","stats","peerId","idString","toB58String","get","protocol","peerStats","delete","set","direction","dataLength","key","forPeer","push","protocolStats","forProtocol","placeholder","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","start","stream","metrics","_source","source","chunk","length","_sink","sink","Array","from","keys","target","other","_queue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mergeOptions = require('merge-options')\nconst pipe = require('it-pipe')\nconst { tap } = require('streaming-iterables')\nconst oldPeerLRU = require('./old-peers')\nconst { METRICS: defaultOptions } = require('../constants')\nconst Stats = require('./stats')\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\nclass Metrics {\n  /**\n   *\n   * @param {object} options\n   * @param {ConnectionManager} options.connectionManager\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {number} options.computeThrottleTimeout\n   * @param {Array<number>} options.movingAverageIntervals\n   * @param {number} options.maxOldPeersRetention\n   */\n  constructor (options) {\n    this._options = mergeOptions(defaultOptions, options)\n    this._globalStats = new Stats(initialCounters, this._options)\n    this._peerStats = new Map()\n    this._protocolStats = new Map()\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention)\n    this._running = false\n    this._onMessage = this._onMessage.bind(this)\n    this._connectionManager = options.connectionManager\n    this._connectionManager.on('peer:disconnect', (connection) => {\n      this.onPeerDisconnected(connection.remotePeer)\n    })\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  stop () {\n    this._running = false\n    this._globalStats.stop()\n    for (const stats of this._peerStats.values()) {\n      stats.stop()\n    }\n    for (const stats of this._protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   * @returns {Stats}\n   */\n  get global () {\n    return this._globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   * @returns {Array<string>}\n   */\n  get peers () {\n    return Array.from(this._peerStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n  forPeer (peerId) {\n    const idString = peerId.toB58String()\n    return this._peerStats.get(idString) || this._oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   * @returns {Array<string>}\n   */\n  get protocols () {\n    return Array.from(this._protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n  forProtocol (protocol) {\n    return this._protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   * @param {PeerId} peerId\n   */\n  onPeerDisconnected (peerId) {\n    const idString = peerId.toB58String()\n    const peerStats = this._peerStats.get(idString)\n    if (peerStats) {\n      peerStats.stop()\n      this._peerStats.delete(idString)\n      this._oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer Remote peer\n   * @param {string} [params.protocol] Protocol string the stream is running\n   * @param {string} params.direction One of ['in','out']\n   * @param {number} params.dataLength Size of the message\n   * @returns {void}\n   */\n  _onMessage ({ remotePeer, protocol, direction, dataLength }) {\n    if (!this._running) return\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options)\n      this._peerStats.set(remotePeer.toB58String(), peerStats)\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this._globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol)\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options)\n        this._protocolStats.set(protocol, protocolStats)\n      }\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   * @param {PeerId} placeholder A peerId string\n   * @param {PeerId} peerId\n   */\n  updatePlaceholder (placeholder, peerId) {\n    if (!this._running) return\n    const placeholderStats = this.forPeer(placeholder)\n    const peerIdString = peerId.toB58String()\n    const existingStats = this.forPeer(peerId)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this._oldPeers.delete(peerIdString)\n    }\n\n    this._peerStats.delete(placeholder.toB58String())\n    this._peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {{ sink: function(*), source: function() }} options.stream A duplex iterable stream\n   * @param {PeerId} [options.peerId] The id of the remote peer that's connected\n   * @param {string} [options.protocol] The protocol the stream is running\n   * @returns {string} The peerId string or placeholder string\n   */\n  trackStream ({ stream, remotePeer, protocol }) {\n    const metrics = this\n    const _source = stream.source\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source)\n\n    const _sink = stream.sink\n    stream.sink = source => {\n      return pipe(\n        source,\n        tap(chunk => metrics._onMessage({\n          remotePeer,\n          protocol,\n          direction: 'out',\n          dataLength: chunk.length\n        })),\n        _sink\n      )\n    }\n\n    return stream\n  }\n\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n  static mergeStats (target, other) {\n    target.stop()\n    other.stop()\n\n    // Merge queues\n    target._queue = [...target._queue, ...other._queue]\n\n    // TODO: how to merge moving averages?\n    return target\n  }\n}\n\nmodule.exports = Metrics\n"]},"metadata":{},"sourceType":"script"}