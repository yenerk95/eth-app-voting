{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nconst pbm = require('./secio.proto');\n\nconst support = require('../support');\n\nconst {\n  UnexpectedPeerError\n} = require('libp2p-interfaces/src/crypto/errors'); // nonceSize is the size of our nonces (in bytes)\n\n\nconst nonceSize = 16;\n\nexports.createProposal = state => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = async state => {\n  const res = await crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT);\n  state.ephemeralKey.local = res.key;\n  state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n  const selectionOut = Buffer.concat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n  const sig = await state.key.local.sign(selectionOut);\n  state.exchange.out = {\n    epubkey: state.ephemeralKey.local,\n    signature: sig\n  };\n  return pbm.Exchange.encode(state.exchange.out);\n};\n\nexports.identify = async (state, msg) => {\n  log('1.1 identify');\n  state.proposalEncoded.in = msg;\n  state.proposal.in = pbm.Propose.decode(msg);\n  const pubkey = state.proposal.in.pubkey;\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n  const remoteId = await PeerId.createFromPubKey(pubkey.toString('base64')); // If we know who we are dialing to, double check\n\n  if (state.id.remote) {\n    if (state.id.remote.toString() !== remoteId.toString()) {\n      throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!');\n    }\n\n    state.id.remote.pubKey = state.key.remote;\n  } else {\n    state.id.remote = remoteId;\n  }\n\n  log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n};\n\nexports.selectProtocols = async state => {\n  log('1.2 selection');\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  };\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  };\n  const selected = await support.selectBest(local, remote); // we use the same params for both directions (must choose same curve)\n  // WARNING: if they dont SelectBest the same way, this won't work...\n\n  state.protocols.remote = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  };\n  state.protocols.local = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  };\n};\n\nexports.verify = async (state, msg) => {\n  log('2.1. verify');\n  state.exchange.in = pbm.Exchange.decode(msg);\n  state.ephemeralKey.remote = state.exchange.in.epubkey;\n  const selectionIn = Buffer.concat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n  const sigOk = await state.key.remote.verify(selectionIn, state.exchange.in.signature);\n\n  if (!sigOk) {\n    throw new Error('Bad signature');\n  }\n\n  log('2.1. verify - signature verified');\n};\n\nexports.generateKeys = async state => {\n  log('2.2. keys');\n  const secret = await state.shared.generate(state.exchange.in.epubkey);\n  state.shared.secret = secret;\n  const keys = await crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret); // use random nonces to decide order.\n\n  if (state.protocols.local.order > 0) {\n    state.protocols.local.keys = keys.k1;\n    state.protocols.remote.keys = keys.k2;\n  } else if (state.protocols.local.order < 0) {\n    // swap\n    state.protocols.local.keys = keys.k2;\n    state.protocols.remote.keys = keys.k1;\n  } else {\n    // we should've bailed before state. but if not, bail here.\n    throw new Error('you are trying to talk to yourself');\n  }\n\n  log('2.3. mac + cipher');\n  await Promise.all([state.protocols.local, state.protocols.remote].map(data => support.makeMacAndCipher(data)));\n};\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand;\n  if (n1.equals(n2)) return;\n  throw new Error(`Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`);\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-secio/src/handshake/crypto.js"],"names":["Buffer","require","PeerId","crypto","debug","log","error","pbm","support","UnexpectedPeerError","nonceSize","exports","createProposal","state","proposal","out","rand","randomBytes","pubkey","key","local","public","bytes","exchanges","join","ciphers","hashes","proposalEncoded","Propose","encode","createExchange","res","keys","generateEphemeralKeyPair","protocols","curveT","ephemeralKey","shared","generate","genSharedKey","selectionOut","concat","in","sig","sign","exchange","epubkey","signature","Exchange","identify","msg","decode","remote","unmarshalPublicKey","remoteId","createFromPubKey","toString","id","pubKey","toB58String","selectProtocols","pubKeyBytes","nonce","split","selected","selectBest","order","cipherT","hashT","verify","selectionIn","sigOk","Error","generateKeys","secret","keyStretcher","k1","k2","Promise","all","map","data","makeMacAndCipher","verifyNonce","n2","n1","equals"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,eAAD,CAAtB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMI,GAAG,GAAGD,KAAK,CAAC,cAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,oBAAD,CAAjB;;AAEA,MAAMG,GAAG,GAAGN,OAAO,CAAC,eAAD,CAAnB;;AAEA,MAAMO,OAAO,GAAGP,OAAO,CAAC,YAAD,CAAvB;;AAEA,MAAM;AAAEQ,EAAAA;AAAF,IAA0BR,OAAO,CAAC,qCAAD,CAAvC,C,CAEA;;;AACA,MAAMS,SAAS,GAAG,EAAlB;;AAEAC,OAAO,CAACC,cAAR,GAA0BC,KAAD,IAAW;AAClCA,EAAAA,KAAK,CAACC,QAAN,CAAeC,GAAf,GAAqB;AACnBC,IAAAA,IAAI,EAAEb,MAAM,CAACc,WAAP,CAAmBP,SAAnB,CADa;AAEnBQ,IAAAA,MAAM,EAAEL,KAAK,CAACM,GAAN,CAAUC,KAAV,CAAgBC,MAAhB,CAAuBC,KAFZ;AAGnBC,IAAAA,SAAS,EAAEf,OAAO,CAACe,SAAR,CAAkBC,IAAlB,CAAuB,GAAvB,CAHQ;AAInBC,IAAAA,OAAO,EAAEjB,OAAO,CAACiB,OAAR,CAAgBD,IAAhB,CAAqB,GAArB,CAJU;AAKnBE,IAAAA,MAAM,EAAElB,OAAO,CAACkB,MAAR,CAAeF,IAAf,CAAoB,GAApB;AALW,GAArB;AAQAX,EAAAA,KAAK,CAACc,eAAN,CAAsBZ,GAAtB,GAA4BR,GAAG,CAACqB,OAAJ,CAAYC,MAAZ,CAAmBhB,KAAK,CAACC,QAAN,CAAeC,GAAlC,CAA5B;AACA,SAAOF,KAAK,CAACc,eAAN,CAAsBZ,GAA7B;AACD,CAXD;;AAaAJ,OAAO,CAACmB,cAAR,GAAyB,MAAOjB,KAAP,IAAiB;AACxC,QAAMkB,GAAG,GAAG,MAAM5B,MAAM,CAAC6B,IAAP,CAAYC,wBAAZ,CAAqCpB,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsBe,MAA3D,CAAlB;AAEAtB,EAAAA,KAAK,CAACuB,YAAN,CAAmBhB,KAAnB,GAA2BW,GAAG,CAACZ,GAA/B;AACAN,EAAAA,KAAK,CAACwB,MAAN,CAAaC,QAAb,GAAwBP,GAAG,CAACQ,YAA5B,CAJwC,CAMxC;;AACA,QAAMC,YAAY,GAAGxC,MAAM,CAACyC,MAAP,CAAc,CACjC5B,KAAK,CAACc,eAAN,CAAsBZ,GADW,EAEjCF,KAAK,CAACc,eAAN,CAAsBe,EAFW,EAGjC7B,KAAK,CAACuB,YAAN,CAAmBhB,KAHc,CAAd,CAArB;AAMA,QAAMuB,GAAG,GAAG,MAAM9B,KAAK,CAACM,GAAN,CAAUC,KAAV,CAAgBwB,IAAhB,CAAqBJ,YAArB,CAAlB;AAEA3B,EAAAA,KAAK,CAACgC,QAAN,CAAe9B,GAAf,GAAqB;AACnB+B,IAAAA,OAAO,EAAEjC,KAAK,CAACuB,YAAN,CAAmBhB,KADT;AAEnB2B,IAAAA,SAAS,EAAEJ;AAFQ,GAArB;AAKA,SAAOpC,GAAG,CAACyC,QAAJ,CAAanB,MAAb,CAAoBhB,KAAK,CAACgC,QAAN,CAAe9B,GAAnC,CAAP;AACD,CArBD;;AAuBAJ,OAAO,CAACsC,QAAR,GAAmB,OAAOpC,KAAP,EAAcqC,GAAd,KAAsB;AACvC7C,EAAAA,GAAG,CAAC,cAAD,CAAH;AAEAQ,EAAAA,KAAK,CAACc,eAAN,CAAsBe,EAAtB,GAA2BQ,GAA3B;AACArC,EAAAA,KAAK,CAACC,QAAN,CAAe4B,EAAf,GAAoBnC,GAAG,CAACqB,OAAJ,CAAYuB,MAAZ,CAAmBD,GAAnB,CAApB;AACA,QAAMhC,MAAM,GAAGL,KAAK,CAACC,QAAN,CAAe4B,EAAf,CAAkBxB,MAAjC;AAEAL,EAAAA,KAAK,CAACM,GAAN,CAAUiC,MAAV,GAAmBjD,MAAM,CAAC6B,IAAP,CAAYqB,kBAAZ,CAA+BnC,MAA/B,CAAnB;AAEA,QAAMoC,QAAQ,GAAG,MAAMpD,MAAM,CAACqD,gBAAP,CAAwBrC,MAAM,CAACsC,QAAP,CAAgB,QAAhB,CAAxB,CAAvB,CATuC,CAWvC;;AACA,MAAI3C,KAAK,CAAC4C,EAAN,CAASL,MAAb,EAAqB;AACnB,QAAIvC,KAAK,CAAC4C,EAAN,CAASL,MAAT,CAAgBI,QAAhB,OAA+BF,QAAQ,CAACE,QAAT,EAAnC,EAAwD;AACtD,YAAM,IAAI/C,mBAAJ,CAAwB,6CAAxB,CAAN;AACD;;AACDI,IAAAA,KAAK,CAAC4C,EAAN,CAASL,MAAT,CAAgBM,MAAhB,GAAyB7C,KAAK,CAACM,GAAN,CAAUiC,MAAnC;AACD,GALD,MAKO;AACLvC,IAAAA,KAAK,CAAC4C,EAAN,CAASL,MAAT,GAAkBE,QAAlB;AACD;;AAEDjD,EAAAA,GAAG,CAAC,kDAAD,EAAqDQ,KAAK,CAAC4C,EAAN,CAASrC,KAAT,CAAeuC,WAAf,EAArD,EAAmF9C,KAAK,CAAC4C,EAAN,CAASL,MAAT,CAAgBO,WAAhB,EAAnF,CAAH;AACD,CAtBD;;AAwBAhD,OAAO,CAACiD,eAAR,GAA0B,MAAO/C,KAAP,IAAiB;AACzCR,EAAAA,GAAG,CAAC,eAAD,CAAH;AAEA,QAAMe,KAAK,GAAG;AACZyC,IAAAA,WAAW,EAAEhD,KAAK,CAACM,GAAN,CAAUC,KAAV,CAAgBC,MAAhB,CAAuBC,KADxB;AAEZC,IAAAA,SAAS,EAAEf,OAAO,CAACe,SAFP;AAGZG,IAAAA,MAAM,EAAElB,OAAO,CAACkB,MAHJ;AAIZD,IAAAA,OAAO,EAAEjB,OAAO,CAACiB,OAJL;AAKZqC,IAAAA,KAAK,EAAEjD,KAAK,CAACC,QAAN,CAAeC,GAAf,CAAmBC;AALd,GAAd;AAQA,QAAMoC,MAAM,GAAG;AACbS,IAAAA,WAAW,EAAEhD,KAAK,CAACC,QAAN,CAAe4B,EAAf,CAAkBxB,MADlB;AAEbK,IAAAA,SAAS,EAAEV,KAAK,CAACC,QAAN,CAAe4B,EAAf,CAAkBnB,SAAlB,CAA4BwC,KAA5B,CAAkC,GAAlC,CAFE;AAGbrC,IAAAA,MAAM,EAAEb,KAAK,CAACC,QAAN,CAAe4B,EAAf,CAAkBhB,MAAlB,CAAyBqC,KAAzB,CAA+B,GAA/B,CAHK;AAIbtC,IAAAA,OAAO,EAAEZ,KAAK,CAACC,QAAN,CAAe4B,EAAf,CAAkBjB,OAAlB,CAA0BsC,KAA1B,CAAgC,GAAhC,CAJI;AAKbD,IAAAA,KAAK,EAAEjD,KAAK,CAACC,QAAN,CAAe4B,EAAf,CAAkB1B;AALZ,GAAf;AAQA,QAAMgD,QAAQ,GAAG,MAAMxD,OAAO,CAACyD,UAAR,CAAmB7C,KAAnB,EAA0BgC,MAA1B,CAAvB,CAnByC,CAqBzC;AACA;;AACAvC,EAAAA,KAAK,CAACqB,SAAN,CAAgBkB,MAAhB,GAAyB;AACvBc,IAAAA,KAAK,EAAEF,QAAQ,CAACE,KADO;AAEvB/B,IAAAA,MAAM,EAAE6B,QAAQ,CAAC7B,MAFM;AAGvBgC,IAAAA,OAAO,EAAEH,QAAQ,CAACG,OAHK;AAIvBC,IAAAA,KAAK,EAAEJ,QAAQ,CAACI;AAJO,GAAzB;AAOAvD,EAAAA,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,GAAwB;AACtB8C,IAAAA,KAAK,EAAEF,QAAQ,CAACE,KADM;AAEtB/B,IAAAA,MAAM,EAAE6B,QAAQ,CAAC7B,MAFK;AAGtBgC,IAAAA,OAAO,EAAEH,QAAQ,CAACG,OAHI;AAItBC,IAAAA,KAAK,EAAEJ,QAAQ,CAACI;AAJM,GAAxB;AAMD,CApCD;;AAsCAzD,OAAO,CAAC0D,MAAR,GAAiB,OAAOxD,KAAP,EAAcqC,GAAd,KAAsB;AACrC7C,EAAAA,GAAG,CAAC,aAAD,CAAH;AAEAQ,EAAAA,KAAK,CAACgC,QAAN,CAAeH,EAAf,GAAoBnC,GAAG,CAACyC,QAAJ,CAAaG,MAAb,CAAoBD,GAApB,CAApB;AACArC,EAAAA,KAAK,CAACuB,YAAN,CAAmBgB,MAAnB,GAA4BvC,KAAK,CAACgC,QAAN,CAAeH,EAAf,CAAkBI,OAA9C;AAEA,QAAMwB,WAAW,GAAGtE,MAAM,CAACyC,MAAP,CAAc,CAChC5B,KAAK,CAACc,eAAN,CAAsBe,EADU,EAEhC7B,KAAK,CAACc,eAAN,CAAsBZ,GAFU,EAGhCF,KAAK,CAACuB,YAAN,CAAmBgB,MAHa,CAAd,CAApB;AAMA,QAAMmB,KAAK,GAAG,MAAM1D,KAAK,CAACM,GAAN,CAAUiC,MAAV,CAAiBiB,MAAjB,CAAwBC,WAAxB,EAAqCzD,KAAK,CAACgC,QAAN,CAAeH,EAAf,CAAkBK,SAAvD,CAApB;;AAEA,MAAI,CAACwB,KAAL,EAAY;AACV,UAAM,IAAIC,KAAJ,CAAU,eAAV,CAAN;AACD;;AAEDnE,EAAAA,GAAG,CAAC,kCAAD,CAAH;AACD,CAnBD;;AAqBAM,OAAO,CAAC8D,YAAR,GAAuB,MAAO5D,KAAP,IAAiB;AACtCR,EAAAA,GAAG,CAAC,WAAD,CAAH;AAEA,QAAMqE,MAAM,GAAG,MAAM7D,KAAK,CAACwB,MAAN,CAAaC,QAAb,CAAsBzB,KAAK,CAACgC,QAAN,CAAeH,EAAf,CAAkBI,OAAxC,CAArB;AAEAjC,EAAAA,KAAK,CAACwB,MAAN,CAAaqC,MAAb,GAAsBA,MAAtB;AAEA,QAAM1C,IAAI,GAAG,MAAM7B,MAAM,CAAC6B,IAAP,CAAY2C,YAAZ,CACjB9D,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsB+C,OADL,EAEjBtD,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsBgD,KAFL,EAGjBvD,KAAK,CAACwB,MAAN,CAAaqC,MAHI,CAAnB,CAPsC,CAYtC;;AACA,MAAI7D,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsB8C,KAAtB,GAA8B,CAAlC,EAAqC;AACnCrD,IAAAA,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsBY,IAAtB,GAA6BA,IAAI,CAAC4C,EAAlC;AACA/D,IAAAA,KAAK,CAACqB,SAAN,CAAgBkB,MAAhB,CAAuBpB,IAAvB,GAA8BA,IAAI,CAAC6C,EAAnC;AACD,GAHD,MAGO,IAAIhE,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsB8C,KAAtB,GAA8B,CAAlC,EAAqC;AAC1C;AACArD,IAAAA,KAAK,CAACqB,SAAN,CAAgBd,KAAhB,CAAsBY,IAAtB,GAA6BA,IAAI,CAAC6C,EAAlC;AACAhE,IAAAA,KAAK,CAACqB,SAAN,CAAgBkB,MAAhB,CAAuBpB,IAAvB,GAA8BA,IAAI,CAAC4C,EAAnC;AACD,GAJM,MAIA;AACL;AACA,UAAM,IAAIJ,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAEDnE,EAAAA,GAAG,CAAC,mBAAD,CAAH;AAEA,QAAMyE,OAAO,CAACC,GAAR,CAAY,CAAClE,KAAK,CAACqB,SAAN,CAAgBd,KAAjB,EAAwBP,KAAK,CAACqB,SAAN,CAAgBkB,MAAxC,EAAgD4B,GAAhD,CAAoDC,IAAI,IAAIzE,OAAO,CAAC0E,gBAAR,CAAyBD,IAAzB,CAA5D,CAAZ,CAAN;AACD,CA5BD;;AA8BAtE,OAAO,CAACwE,WAAR,GAAsB,CAACtE,KAAD,EAAQuE,EAAR,KAAe;AACnC,QAAMC,EAAE,GAAGxE,KAAK,CAACC,QAAN,CAAeC,GAAf,CAAmBC,IAA9B;AAEA,MAAIqE,EAAE,CAACC,MAAH,CAAUF,EAAV,CAAJ,EAAmB;AAEnB,QAAM,IAAIZ,KAAJ,CACH,uCAAsCa,EAAE,CAAC7B,QAAH,CAAY,KAAZ,CAAmB,OAAM4B,EAAE,CAAC5B,QAAH,CAAY,KAAZ,CAAmB,EAD/E,CAAN;AAGD,CARD","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst PeerId = require('peer-id')\nconst crypto = require('libp2p-crypto')\nconst debug = require('debug')\nconst log = debug('libp2p:secio')\nlog.error = debug('libp2p:secio:error')\n\nconst pbm = require('./secio.proto')\n\nconst support = require('../support')\n\nconst { UnexpectedPeerError } = require('libp2p-interfaces/src/crypto/errors')\n\n// nonceSize is the size of our nonces (in bytes)\nconst nonceSize = 16\n\nexports.createProposal = (state) => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  }\n\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out)\n  return state.proposalEncoded.out\n}\n\nexports.createExchange = async (state) => {\n  const res = await crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT)\n\n  state.ephemeralKey.local = res.key\n  state.shared.generate = res.genSharedKey\n\n  // Gather corpus to sign.\n  const selectionOut = Buffer.concat([\n    state.proposalEncoded.out,\n    state.proposalEncoded.in,\n    state.ephemeralKey.local\n  ])\n\n  const sig = await state.key.local.sign(selectionOut)\n\n  state.exchange.out = {\n    epubkey: state.ephemeralKey.local,\n    signature: sig\n  }\n\n  return pbm.Exchange.encode(state.exchange.out)\n}\n\nexports.identify = async (state, msg) => {\n  log('1.1 identify')\n\n  state.proposalEncoded.in = msg\n  state.proposal.in = pbm.Propose.decode(msg)\n  const pubkey = state.proposal.in.pubkey\n\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey)\n\n  const remoteId = await PeerId.createFromPubKey(pubkey.toString('base64'))\n\n  // If we know who we are dialing to, double check\n  if (state.id.remote) {\n    if (state.id.remote.toString() !== remoteId.toString()) {\n      throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!')\n    }\n    state.id.remote.pubKey = state.key.remote\n  } else {\n    state.id.remote = remoteId\n  }\n\n  log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String())\n}\n\nexports.selectProtocols = async (state) => {\n  log('1.2 selection')\n\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  }\n\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  }\n\n  const selected = await support.selectBest(local, remote)\n\n  // we use the same params for both directions (must choose same curve)\n  // WARNING: if they dont SelectBest the same way, this won't work...\n  state.protocols.remote = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  }\n\n  state.protocols.local = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  }\n}\n\nexports.verify = async (state, msg) => {\n  log('2.1. verify')\n\n  state.exchange.in = pbm.Exchange.decode(msg)\n  state.ephemeralKey.remote = state.exchange.in.epubkey\n\n  const selectionIn = Buffer.concat([\n    state.proposalEncoded.in,\n    state.proposalEncoded.out,\n    state.ephemeralKey.remote\n  ])\n\n  const sigOk = await state.key.remote.verify(selectionIn, state.exchange.in.signature)\n\n  if (!sigOk) {\n    throw new Error('Bad signature')\n  }\n\n  log('2.1. verify - signature verified')\n}\n\nexports.generateKeys = async (state) => {\n  log('2.2. keys')\n\n  const secret = await state.shared.generate(state.exchange.in.epubkey)\n\n  state.shared.secret = secret\n\n  const keys = await crypto.keys.keyStretcher(\n    state.protocols.local.cipherT,\n    state.protocols.local.hashT,\n    state.shared.secret)\n\n  // use random nonces to decide order.\n  if (state.protocols.local.order > 0) {\n    state.protocols.local.keys = keys.k1\n    state.protocols.remote.keys = keys.k2\n  } else if (state.protocols.local.order < 0) {\n    // swap\n    state.protocols.local.keys = keys.k2\n    state.protocols.remote.keys = keys.k1\n  } else {\n    // we should've bailed before state. but if not, bail here.\n    throw new Error('you are trying to talk to yourself')\n  }\n\n  log('2.3. mac + cipher')\n\n  await Promise.all([state.protocols.local, state.protocols.remote].map(data => support.makeMacAndCipher(data)))\n}\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand\n\n  if (n1.equals(n2)) return\n\n  throw new Error(\n    `Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`\n  )\n}\n"]},"metadata":{},"sourceType":"script"}