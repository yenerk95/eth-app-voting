{"ast":null,"code":"/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n/**\n * HKDF\n */\n\n\nclass HKDF {\n  constructor(hash, ikm, salt, info) {\n    assert(hash && typeof hash.id === 'string');\n    this.hash = hash;\n    this.size = hash.size;\n    this.prk = null;\n    this.state = null;\n    this.slab = null;\n    this.save = 0;\n    if (ikm || salt || info) this.init(ikm, salt, info);\n  }\n\n  init(ikm, salt, info) {\n    if (ikm == null) ikm = Buffer.alloc(0);\n    if (salt == null) salt = Buffer.alloc(this.size, 0x00);\n    this.prk = this.hash.mac(ikm, salt);\n    this.reset(info);\n    return this;\n  }\n\n  set(prk, info) {\n    assert(Buffer.isBuffer(prk));\n    assert(prk.length === this.size);\n    this.prk = prk;\n    this.reset(info);\n    return this;\n  }\n\n  reset(info) {\n    if (info == null) info = Buffer.alloc(0);\n    assert(Buffer.isBuffer(info)); // state = prev || info || counter\n\n    const state = Buffer.alloc(this.size + info.length + 1);\n    state.fill(0x00, 0, this.size);\n    info.copy(state, this.size);\n    state[state.length - 1] = 0;\n    this.state = state;\n    this.slab = Buffer.alloc(this.size);\n    this.save = 0;\n    return this;\n  }\n\n  generate(len) {\n    assert(len >>> 0 === len);\n    if (!this.prk || !this.state || !this.slab) throw new Error('HKDF is not initialized.');\n    const left = (255 - this.state[this.state.length - 1]) * this.size;\n    if (len > this.save + left) throw new Error('Too many bytes requested.');\n    const blocks = Math.ceil(Math.max(0, len - this.save) / this.size);\n    const okm = Buffer.alloc(this.save + blocks * this.size);\n    this.slab.copy(okm, 0, 0, this.save);\n\n    for (let i = 0; i < blocks; i++) {\n      let state = this.state;\n      if (state[state.length - 1] === 0) state = state.slice(this.size);\n      assert(state[state.length - 1] !== 255);\n      state[state.length - 1] += 1;\n      const mac = this.hash.mac(state, this.prk);\n      mac.copy(this.state, 0);\n      mac.copy(okm, this.save + i * this.size);\n    }\n\n    this.save = okm.copy(this.slab, 0, len);\n    return okm.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n\n  static extract(hash, ikm, salt) {\n    assert(hash && typeof hash.id === 'string');\n    if (ikm == null) ikm = Buffer.alloc(0);\n    if (salt == null) salt = Buffer.alloc(hash.size, 0x00);\n    return hash.mac(ikm, salt);\n  }\n\n  static expand(hash, prk, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.set(prk, info).generate(len);\n  }\n\n  static derive(hash, ikm, salt, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.init(ikm, salt, info).generate(len);\n  }\n\n}\n/*\n * Static\n */\n\n\nHKDF.native = 0;\n/*\n * Expose\n */\n\nmodule.exports = HKDF;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/bcrypto/lib/hkdf.js"],"names":["assert","require","HKDF","constructor","hash","ikm","salt","info","id","size","prk","state","slab","save","init","Buffer","alloc","mac","reset","set","isBuffer","length","fill","copy","generate","len","Error","left","blocks","Math","ceil","max","okm","i","slice","randomBytes","extract","expand","hkdf","derive","native","module","exports"],"mappings":"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","sourcesContent":["/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n\n'use strict';\n\nconst assert = require('./internal/assert');\n\n/**\n * HKDF\n */\n\nclass HKDF {\n  constructor(hash, ikm, salt, info) {\n    assert(hash && typeof hash.id === 'string');\n\n    this.hash = hash;\n    this.size = hash.size;\n    this.prk = null;\n    this.state = null;\n    this.slab = null;\n    this.save = 0;\n\n    if (ikm || salt || info)\n      this.init(ikm, salt, info);\n  }\n\n  init(ikm, salt, info) {\n    if (ikm == null)\n      ikm = Buffer.alloc(0);\n\n    if (salt == null)\n      salt = Buffer.alloc(this.size, 0x00);\n\n    this.prk = this.hash.mac(ikm, salt);\n    this.reset(info);\n\n    return this;\n  }\n\n  set(prk, info) {\n    assert(Buffer.isBuffer(prk));\n    assert(prk.length === this.size);\n\n    this.prk = prk;\n    this.reset(info);\n\n    return this;\n  }\n\n  reset(info) {\n    if (info == null)\n      info = Buffer.alloc(0);\n\n    assert(Buffer.isBuffer(info));\n\n    // state = prev || info || counter\n    const state = Buffer.alloc(this.size + info.length + 1);\n\n    state.fill(0x00, 0, this.size);\n\n    info.copy(state, this.size);\n\n    state[state.length - 1] = 0;\n\n    this.state = state;\n    this.slab = Buffer.alloc(this.size);\n    this.save = 0;\n\n    return this;\n  }\n\n  generate(len) {\n    assert((len >>> 0) === len);\n\n    if (!this.prk || !this.state || !this.slab)\n      throw new Error('HKDF is not initialized.');\n\n    const left = (255 - this.state[this.state.length - 1]) * this.size;\n\n    if (len > this.save + left)\n      throw new Error('Too many bytes requested.');\n\n    const blocks = Math.ceil(Math.max(0, len - this.save) / this.size);\n    const okm = Buffer.alloc(this.save + blocks * this.size);\n\n    this.slab.copy(okm, 0, 0, this.save);\n\n    for (let i = 0; i < blocks; i++) {\n      let state = this.state;\n\n      if (state[state.length - 1] === 0)\n        state = state.slice(this.size);\n\n      assert(state[state.length - 1] !== 255);\n\n      state[state.length - 1] += 1;\n\n      const mac = this.hash.mac(state, this.prk);\n\n      mac.copy(this.state, 0);\n      mac.copy(okm, this.save + i * this.size);\n    }\n\n    this.save = okm.copy(this.slab, 0, len);\n\n    return okm.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n\n  static extract(hash, ikm, salt) {\n    assert(hash && typeof hash.id === 'string');\n\n    if (ikm == null)\n      ikm = Buffer.alloc(0);\n\n    if (salt == null)\n      salt = Buffer.alloc(hash.size, 0x00);\n\n    return hash.mac(ikm, salt);\n  }\n\n  static expand(hash, prk, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.set(prk, info)\n               .generate(len);\n  }\n\n  static derive(hash, ikm, salt, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.init(ikm, salt, info)\n               .generate(len);\n  }\n}\n\n/*\n * Static\n */\n\nHKDF.native = 0;\n\n/*\n * Expose\n */\n\nmodule.exports = HKDF;\n"]},"metadata":{},"sourceType":"script"}