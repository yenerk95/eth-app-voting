{"ast":null,"code":"'use strict';\n\nconst lp = require('it-length-prefixed');\n\nconst handshake = require('it-handshake');\n\nconst {\n  CircuitRelay: CircuitPB\n} = require('../protocol');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit:stream-handler');\nlog.error = debug('libp2p:circuit:stream-handler:error');\n\nclass StreamHandler {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {object} options\n   * @param {*} options.stream - A duplex iterable\n   * @param {Number} options.maxLength - max bytes length of message\n   */\n  constructor({\n    stream,\n    maxLength = 4096\n  }) {\n    this.stream = stream;\n    this.shake = handshake(this.stream);\n    this.decoder = lp.decode.fromReader(this.shake.reader, {\n      maxDataLength: maxLength\n    });\n  }\n  /**\n   * Read and decode message\n   * @async\n   * @returns {void}\n   */\n\n\n  async read() {\n    const msg = await this.decoder.next();\n\n    if (msg.value) {\n      const value = CircuitPB.decode(msg.value.slice());\n      log('read message type', value.type);\n      return value;\n    }\n\n    log('read received no value, closing stream'); // End the stream, we didn't get data\n\n    this.close();\n  }\n  /**\n   * Encode and write array of buffers\n   *\n   * @param {*} msg An unencoded CircuitRelay protobuf message\n   */\n\n\n  write(msg) {\n    log('write message type %s', msg.type);\n    this.shake.write(lp.encode.single(CircuitPB.encode(msg)));\n  }\n  /**\n   * Return the handshake rest stream and invalidate handler\n   *\n   * @return {*} A duplex iterable\n   */\n\n\n  rest() {\n    this.shake.rest();\n    return this.shake.stream;\n  }\n\n  end(msg) {\n    this.write(msg);\n    this.close();\n  }\n  /**\n   * Close the stream\n   *\n   * @returns {void}\n   */\n\n\n  close() {\n    log('closing the stream');\n    this.rest().sink([]);\n  }\n\n}\n\nmodule.exports = StreamHandler;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/circuit/circuit/stream-handler.js"],"names":["lp","require","handshake","CircuitRelay","CircuitPB","debug","log","error","StreamHandler","constructor","stream","maxLength","shake","decoder","decode","fromReader","reader","maxDataLength","read","msg","next","value","slice","type","close","write","encode","single","rest","end","sink","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAM;AAAEE,EAAAA,YAAY,EAAEC;AAAhB,IAA8BH,OAAO,CAAC,aAAD,CAA3C;;AAEA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMK,GAAG,GAAGD,KAAK,CAAC,+BAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,qCAAD,CAAjB;;AAEA,MAAMG,aAAN,CAAoB;AAClB;;;;;;;AAOAC,EAAAA,WAAW,CAAE;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,SAAS,GAAG;AAAtB,GAAF,EAAgC;AACzC,SAAKD,MAAL,GAAcA,MAAd;AAEA,SAAKE,KAAL,GAAaV,SAAS,CAAC,KAAKQ,MAAN,CAAtB;AACA,SAAKG,OAAL,GAAeb,EAAE,CAACc,MAAH,CAAUC,UAAV,CAAqB,KAAKH,KAAL,CAAWI,MAAhC,EAAwC;AAAEC,MAAAA,aAAa,EAAEN;AAAjB,KAAxC,CAAf;AACD;AAED;;;;;;;AAKA,QAAMO,IAAN,GAAc;AACZ,UAAMC,GAAG,GAAG,MAAM,KAAKN,OAAL,CAAaO,IAAb,EAAlB;;AACA,QAAID,GAAG,CAACE,KAAR,EAAe;AACb,YAAMA,KAAK,GAAGjB,SAAS,CAACU,MAAV,CAAiBK,GAAG,CAACE,KAAJ,CAAUC,KAAV,EAAjB,CAAd;AACAhB,MAAAA,GAAG,CAAC,mBAAD,EAAsBe,KAAK,CAACE,IAA5B,CAAH;AACA,aAAOF,KAAP;AACD;;AAEDf,IAAAA,GAAG,CAAC,wCAAD,CAAH,CARY,CASZ;;AACA,SAAKkB,KAAL;AACD;AAED;;;;;;;AAKAC,EAAAA,KAAK,CAAEN,GAAF,EAAO;AACVb,IAAAA,GAAG,CAAC,uBAAD,EAA0Ba,GAAG,CAACI,IAA9B,CAAH;AACA,SAAKX,KAAL,CAAWa,KAAX,CAAiBzB,EAAE,CAAC0B,MAAH,CAAUC,MAAV,CAAiBvB,SAAS,CAACsB,MAAV,CAAiBP,GAAjB,CAAjB,CAAjB;AACD;AAED;;;;;;;AAKAS,EAAAA,IAAI,GAAI;AACN,SAAKhB,KAAL,CAAWgB,IAAX;AACA,WAAO,KAAKhB,KAAL,CAAWF,MAAlB;AACD;;AAEDmB,EAAAA,GAAG,CAAEV,GAAF,EAAO;AACR,SAAKM,KAAL,CAAWN,GAAX;AACA,SAAKK,KAAL;AACD;AAED;;;;;;;AAKAA,EAAAA,KAAK,GAAI;AACPlB,IAAAA,GAAG,CAAC,oBAAD,CAAH;AACA,SAAKsB,IAAL,GAAYE,IAAZ,CAAiB,EAAjB;AACD;;AAlEiB;;AAqEpBC,MAAM,CAACC,OAAP,GAAiBxB,aAAjB","sourcesContent":["'use strict'\n\nconst lp = require('it-length-prefixed')\nconst handshake = require('it-handshake')\nconst { CircuitRelay: CircuitPB } = require('../protocol')\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:stream-handler')\nlog.error = debug('libp2p:circuit:stream-handler:error')\n\nclass StreamHandler {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {object} options\n   * @param {*} options.stream - A duplex iterable\n   * @param {Number} options.maxLength - max bytes length of message\n   */\n  constructor ({ stream, maxLength = 4096 }) {\n    this.stream = stream\n\n    this.shake = handshake(this.stream)\n    this.decoder = lp.decode.fromReader(this.shake.reader, { maxDataLength: maxLength })\n  }\n\n  /**\n   * Read and decode message\n   * @async\n   * @returns {void}\n   */\n  async read () {\n    const msg = await this.decoder.next()\n    if (msg.value) {\n      const value = CircuitPB.decode(msg.value.slice())\n      log('read message type', value.type)\n      return value\n    }\n\n    log('read received no value, closing stream')\n    // End the stream, we didn't get data\n    this.close()\n  }\n\n  /**\n   * Encode and write array of buffers\n   *\n   * @param {*} msg An unencoded CircuitRelay protobuf message\n   */\n  write (msg) {\n    log('write message type %s', msg.type)\n    this.shake.write(lp.encode.single(CircuitPB.encode(msg)))\n  }\n\n  /**\n   * Return the handshake rest stream and invalidate handler\n   *\n   * @return {*} A duplex iterable\n   */\n  rest () {\n    this.shake.rest()\n    return this.shake.stream\n  }\n\n  end (msg) {\n    this.write(msg)\n    this.close()\n  }\n\n  /**\n   * Close the stream\n   *\n   * @returns {void}\n   */\n  close () {\n    log('closing the stream')\n    this.rest().sink([])\n  }\n}\n\nmodule.exports = StreamHandler\n"]},"metadata":{},"sourceType":"script"}