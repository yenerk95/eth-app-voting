{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar _require = require('../../utils'),\n    MFS_FILE_TYPES = _require.MFS_FILE_TYPES,\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar toOutput = function toOutput(fsEntry) {\n  var type = 0;\n  var size = fsEntry.node.size || fsEntry.node.length;\n  var mode;\n  var mtime;\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize();\n    type = MFS_FILE_TYPES[fsEntry.unixfs.type];\n    mode = fsEntry.unixfs.mode;\n    mtime = fsEntry.unixfs.mtime;\n  }\n\n  var output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type: type,\n    size: size\n  };\n\n  if (mtime !== undefined) {\n    output.mtime = mtime;\n  }\n\n  if (mode !== undefined) {\n    output.mode = mode;\n  }\n\n  return output;\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsLs = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var path,\n          options,\n          mfsPath,\n          fsDir,\n          _iteratorNormalCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          _value,\n          fsEntry,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              path = _args.length > 0 && _args[0] !== undefined ? _args[0] : '/';\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              if (typeof path === 'object' && !(path instanceof String)) {\n                options = path;\n                path = '/';\n              }\n\n              _context.next = 5;\n              return _awaitAsyncGenerator(toMfsPath(context, path, options));\n\n            case 5:\n              mfsPath = _context.sent;\n              _context.next = 8;\n              return _awaitAsyncGenerator(exporter(mfsPath.mfsPath, context.ipld));\n\n            case 8:\n              fsDir = _context.sent;\n\n              if (!(!fsDir.unixfs || !fsDir.unixfs.type.includes('directory'))) {\n                _context.next = 13;\n                break;\n              }\n\n              _context.next = 12;\n              return toOutput(fsDir);\n\n            case 12:\n              return _context.abrupt(\"return\");\n\n            case 13:\n              // directory, perhaps sharded\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 15;\n              _iterator = _asyncIterator(fsDir.content(options));\n\n            case 17:\n              _context.next = 19;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 19:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 23;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 23:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 31;\n                break;\n              }\n\n              fsEntry = _value;\n              _context.next = 28;\n              return toOutput(fsEntry);\n\n            case 28:\n              _iteratorNormalCompletion = true;\n              _context.next = 17;\n              break;\n\n            case 31:\n              _context.next = 37;\n              break;\n\n            case 33:\n              _context.prev = 33;\n              _context.t0 = _context[\"catch\"](15);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 37:\n              _context.prev = 37;\n              _context.prev = 38;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 42;\n                break;\n              }\n\n              _context.next = 42;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 42:\n              _context.prev = 42;\n\n              if (!_didIteratorError) {\n                _context.next = 45;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 45:\n              return _context.finish(42);\n\n            case 46:\n              return _context.finish(37);\n\n            case 47:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[15, 33, 37, 47], [38,, 42, 46]]);\n    }));\n\n    function mfsLs() {\n      return _mfsLs.apply(this, arguments);\n    }\n\n    return mfsLs;\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/ls.js"],"names":["exporter","require","toMfsPath","MFS_FILE_TYPES","withTimeoutOption","toOutput","fsEntry","type","size","node","length","mode","mtime","unixfs","fileSize","output","cid","name","undefined","module","exports","context","path","options","String","mfsPath","ipld","fsDir","includes","content","mfsLs"],"mappings":"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","sourcesContent":["'use strict'\n\nconst exporter = require('ipfs-unixfs-exporter')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst {\n  MFS_FILE_TYPES,\n  withTimeoutOption\n} = require('../../utils')\n\nconst toOutput = (fsEntry) => {\n  let type = 0\n  let size = fsEntry.node.size || fsEntry.node.length\n  let mode\n  let mtime\n\n  if (fsEntry.unixfs) {\n    size = fsEntry.unixfs.fileSize()\n    type = MFS_FILE_TYPES[fsEntry.unixfs.type]\n    mode = fsEntry.unixfs.mode\n    mtime = fsEntry.unixfs.mtime\n  }\n\n  const output = {\n    cid: fsEntry.cid,\n    name: fsEntry.name,\n    type,\n    size\n  }\n\n  if (mtime !== undefined) {\n    output.mtime = mtime\n  }\n\n  if (mode !== undefined) {\n    output.mode = mode\n  }\n\n  return output\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function * mfsLs (path = '/', options = {}) {\n    if (typeof path === 'object' && !(path instanceof String)) {\n      options = path\n      path = '/'\n    }\n\n    const mfsPath = await toMfsPath(context, path, options)\n    const fsDir = await exporter(mfsPath.mfsPath, context.ipld)\n\n    // single file/node\n    if (!fsDir.unixfs || !fsDir.unixfs.type.includes('directory')) {\n      yield toOutput(fsDir)\n\n      return\n    }\n\n    // directory, perhaps sharded\n    for await (const fsEntry of fsDir.content(options)) {\n      yield toOutput(fsEntry)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}