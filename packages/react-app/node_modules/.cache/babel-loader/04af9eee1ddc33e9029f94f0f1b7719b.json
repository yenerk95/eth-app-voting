{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar CID = require('cids');\n\nvar errcode = require('err-code');\n\nvar Message = require('../../message');\n\nvar utils = require('../../utils');\n\nmodule.exports = function (dht) {\n  var log = utils.logger(dht.peerId, 'rpc:get-providers');\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n\n  return /*#__PURE__*/function () {\n    var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peerId, msg) {\n      var cid, dsKey, _yield$Promise$all, _yield$Promise$all2, has, peers, closer, providerPeers, closerPeers, response;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              cid = new CID(msg.key);\n              _context.next = 7;\n              break;\n\n            case 4:\n              _context.prev = 4;\n              _context.t0 = _context[\"catch\"](0);\n              throw errcode(new Error(\"Invalid CID: \".concat(_context.t0.message)), 'ERR_INVALID_CID');\n\n            case 7:\n              log('%s', cid.toBaseEncodedString());\n              dsKey = utils.bufferToKey(cid.buffer);\n              _context.next = 11;\n              return Promise.all([dht.datastore.has(dsKey), dht.providers.getProviders(cid), dht._betterPeersToQuery(msg, peerId)]);\n\n            case 11:\n              _yield$Promise$all = _context.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n              has = _yield$Promise$all2[0];\n              peers = _yield$Promise$all2[1];\n              closer = _yield$Promise$all2[2];\n              providerPeers = peers.map(function (peerId) {\n                return {\n                  id: peerId\n                };\n              });\n              closerPeers = closer.map(function (c) {\n                return {\n                  id: c.id\n                };\n              });\n\n              if (has) {\n                providerPeers.push({\n                  id: dht.peerId\n                });\n              }\n\n              response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n              if (providerPeers.length > 0) {\n                response.providerPeers = providerPeers;\n              }\n\n              if (closerPeers.length > 0) {\n                response.closerPeers = closerPeers;\n              }\n\n              log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length);\n              return _context.abrupt(\"return\", response);\n\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 4]]);\n    }));\n\n    function getProviders(_x, _x2) {\n      return _getProviders.apply(this, arguments);\n    }\n\n    return getProviders;\n  }();\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"],"names":["CID","require","errcode","Message","utils","module","exports","dht","log","logger","peerId","msg","cid","key","Error","message","toBaseEncodedString","dsKey","bufferToKey","buffer","Promise","all","datastore","has","providers","getProviders","_betterPeersToQuery","peers","closer","providerPeers","map","id","closerPeers","c","push","response","type","clusterLevel","length"],"mappings":"AAAA;;;;;;;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,MAAD,CAAnB;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAAvB;;AAEA,IAAME,OAAO,GAAGF,OAAO,CAAC,eAAD,CAAvB;;AACA,IAAMG,KAAK,GAAGH,OAAO,CAAC,aAAD,CAArB;;AAEAI,MAAM,CAACC,OAAP,GAAiB,UAACC,GAAD,EAAS;AACxB,MAAMC,GAAG,GAAGJ,KAAK,CAACK,MAAN,CAAaF,GAAG,CAACG,MAAjB,EAAyB,mBAAzB,CAAZ;AAEA;;;;;;;;AAOA;AAAA,iFAAO,iBAA6BA,MAA7B,EAAqCC,GAArC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGHC,cAAAA,GAAG,GAAG,IAAIZ,GAAJ,CAAQW,GAAG,CAACE,GAAZ,CAAN;AAHG;AAAA;;AAAA;AAAA;AAAA;AAAA,oBAKGX,OAAO,CAAC,IAAIY,KAAJ,wBAA0B,YAAIC,OAA9B,EAAD,EAA2C,iBAA3C,CALV;;AAAA;AAQLP,cAAAA,GAAG,CAAC,IAAD,EAAOI,GAAG,CAACI,mBAAJ,EAAP,CAAH;AACMC,cAAAA,KATD,GASSb,KAAK,CAACc,WAAN,CAAkBN,GAAG,CAACO,MAAtB,CATT;AAAA;AAAA,qBAW8BC,OAAO,CAACC,GAAR,CAAY,CAC7Cd,GAAG,CAACe,SAAJ,CAAcC,GAAd,CAAkBN,KAAlB,CAD6C,EAE7CV,GAAG,CAACiB,SAAJ,CAAcC,YAAd,CAA2Bb,GAA3B,CAF6C,EAG7CL,GAAG,CAACmB,mBAAJ,CAAwBf,GAAxB,EAA6BD,MAA7B,CAH6C,CAAZ,CAX9B;;AAAA;AAAA;AAAA;AAWEa,cAAAA,GAXF;AAWOI,cAAAA,KAXP;AAWcC,cAAAA,MAXd;AAiBCC,cAAAA,aAjBD,GAiBiBF,KAAK,CAACG,GAAN,CAAU,UAACpB,MAAD;AAAA,uBAAa;AAAEqB,kBAAAA,EAAE,EAAErB;AAAN,iBAAb;AAAA,eAAV,CAjBjB;AAkBCsB,cAAAA,WAlBD,GAkBeJ,MAAM,CAACE,GAAP,CAAW,UAACG,CAAD;AAAA,uBAAQ;AAAEF,kBAAAA,EAAE,EAAEE,CAAC,CAACF;AAAR,iBAAR;AAAA,eAAX,CAlBf;;AAoBL,kBAAIR,GAAJ,EAAS;AACPM,gBAAAA,aAAa,CAACK,IAAd,CAAmB;AACjBH,kBAAAA,EAAE,EAAExB,GAAG,CAACG;AADS,iBAAnB;AAGD;;AAEKyB,cAAAA,QA1BD,GA0BY,IAAIhC,OAAJ,CAAYQ,GAAG,CAACyB,IAAhB,EAAsBzB,GAAG,CAACE,GAA1B,EAA+BF,GAAG,CAAC0B,YAAnC,CA1BZ;;AA4BL,kBAAIR,aAAa,CAACS,MAAd,GAAuB,CAA3B,EAA8B;AAC5BH,gBAAAA,QAAQ,CAACN,aAAT,GAAyBA,aAAzB;AACD;;AAED,kBAAIG,WAAW,CAACM,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BH,gBAAAA,QAAQ,CAACH,WAAT,GAAuBA,WAAvB;AACD;;AAEDxB,cAAAA,GAAG,CAAC,iCAAD,EAAoCqB,aAAa,CAACS,MAAlD,EAA0DN,WAAW,CAACM,MAAtE,CAAH;AApCK,+CAqCEH,QArCF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAP;;AAAA,aAAsBV,YAAtB;AAAA;AAAA;;AAAA,WAAsBA,YAAtB;AAAA;AAuCD,CAjDD","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst errcode = require('err-code')\n\nconst Message = require('../../message')\nconst utils = require('../../utils')\n\nmodule.exports = (dht) => {\n  const log = utils.logger(dht.peerId, 'rpc:get-providers')\n\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n  return async function getProviders (peerId, msg) {\n    let cid\n    try {\n      cid = new CID(msg.key)\n    } catch (err) {\n      throw errcode(new Error(`Invalid CID: ${err.message}`), 'ERR_INVALID_CID')\n    }\n\n    log('%s', cid.toBaseEncodedString())\n    const dsKey = utils.bufferToKey(cid.buffer)\n\n    const [has, peers, closer] = await Promise.all([\n      dht.datastore.has(dsKey),\n      dht.providers.getProviders(cid),\n      dht._betterPeersToQuery(msg, peerId)\n    ])\n\n    const providerPeers = peers.map((peerId) => ({ id: peerId }))\n    const closerPeers = closer.map((c) => ({ id: c.id }))\n\n    if (has) {\n      providerPeers.push({\n        id: dht.peerId\n      })\n    }\n\n    const response = new Message(msg.type, msg.key, msg.clusterLevel)\n\n    if (providerPeers.length > 0) {\n      response.providerPeers = providerPeers\n    }\n\n    if (closerPeers.length > 0) {\n      response.closerPeers = closerPeers\n    }\n\n    log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length)\n    return response\n  }\n}\n"]},"metadata":{},"sourceType":"script"}