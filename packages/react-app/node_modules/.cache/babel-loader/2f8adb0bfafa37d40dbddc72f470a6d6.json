{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:upgrader');\nlog.error = debug('libp2p:upgrader:error');\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst pipe = require('it-pipe');\n\nconst errCode = require('err-code');\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef MultiaddrConnection\n * @property {function} sink\n * @property {AsyncIterator} source\n * @property {*} conn\n * @property {Multiaddr} remoteAddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {*} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {Metrics} options.metrics\n   * @param {Map<string, Crypto>} options.cryptos\n   * @param {Map<string, Muxer>} options.muxers\n   * @param {function(Connection)} options.onConnection Called when a connection is upgraded\n   * @param {function(Connection)} options.onConnectionEnd\n   */\n  constructor({\n    localPeer,\n    metrics,\n    cryptos,\n    muxers,\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos || new Map();\n    this.muxers = muxers || new Map();\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeInbound(maConn) {\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let Muxer;\n    let cryptoProtocol;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the inbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos)); // Multiplex the connection\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexInbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded inbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * Upgrades an outbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeOutbound(maConn) {\n    let remotePeerId;\n\n    try {\n      remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId());\n    } catch (err) {\n      log.error('multiaddr did not contain a valid peer id', err);\n    }\n\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let Muxer;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the outbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos)); // Multiplex the connection\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexOutbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   * @private\n   * @param {object} options\n   * @param {string} cryptoProtocol The crypto protocol that was negotiated\n   * @param {string} direction One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} maConn The transport layer connection\n   * @param {*} upgradedConn A duplex connection returned from multiplexer and/or crypto selection\n   * @param {Muxer} Muxer The muxer to be used for muxing\n   * @param {PeerId} remotePeer The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    let muxer;\n    let newStream; // eslint-disable-next-line prefer-const\n\n    let connection;\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          const mss = new Multistream.Listener(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = await mss.handle(Array.from(this.protocols.keys()));\n            log('%s: incoming stream opened on %s', direction, protocol);\n            if (this.metrics) this.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            connection.addStream(muxedStream, {\n              protocol\n            });\n\n            this._onStream({\n              connection,\n              stream: { ...muxedStream,\n                ...stream\n              },\n              protocol\n            });\n          } catch (err) {\n            log.error(err);\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = muxer.newStream();\n        const mss = new Multistream.Dialer(muxedStream);\n\n        try {\n          const {\n            stream,\n            protocol\n          } = await mss.select(protocols);\n          if (this.metrics) this.metrics.trackStream({\n            stream,\n            remotePeer,\n            protocol\n          });\n          return {\n            stream: { ...muxedStream,\n              ...stream\n            },\n            protocol\n          };\n        } catch (err) {\n          log.error('could not create new stream', err);\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        }\n      }; // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          connection.stat.status = 'closed';\n          this.onConnectionEnd(connection);\n        }\n\n        return Reflect.set(...args);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed,\n      close: err => maConn.close(err)\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection The connection the stream belongs to\n   * @param {Stream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream({\n    connection,\n    stream,\n    protocol\n  }) {\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptInbound(localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('handling inbound crypto protocol selection', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting inbound connection...');\n      return { ...(await crypto.secureInbound(localPeer, stream)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerId\n   * @param {*} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('selecting outbound crypto protocol', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting outbound connection to %j', remotePeerId);\n      return { ...(await crypto.secureOutbound(localPeer, stream, remotePeerId)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n\n\n  async _multiplexOutbound(connection, muxers) {\n    const dialer = new Multistream.Dialer(connection);\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await dialer.select(protocols);\n      log('%s selected as muxer protocol', protocol);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n\n\n  async _multiplexInbound(connection, muxers) {\n    const listener = new Multistream.Listener(connection);\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await listener.handle(protocols);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n\n}\n\nmodule.exports = Upgrader;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/upgrader.js"],"names":["debug","require","log","error","Multistream","Connection","PeerId","pipe","errCode","mutableProxy","codes","Upgrader","constructor","localPeer","metrics","cryptos","muxers","onConnectionEnd","onConnection","Map","protector","protocols","upgradeInbound","maConn","encryptedConn","remotePeer","upgradedConn","Muxer","cryptoProtocol","setPeer","proxyPeer","setTarget","proxy","idString","parseInt","Math","random","toString","Date","now","toB58String","trackStream","stream","protectedConn","protect","conn","protocol","_encryptInbound","size","_multiplexInbound","err","close","updatePlaceholder","_createConnection","direction","upgradeOutbound","remotePeerId","createFromB58String","remoteAddr","getPeerId","_encryptOutbound","_multiplexOutbound","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","args","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","Error","localAddr","multiplexer","multicodec","encryption","getStreams","streams","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGF,KAAK,CAAC,iBAAD,CAAjB;AACAE,GAAG,CAACC,KAAJ,GAAYH,KAAK,CAAC,uBAAD,CAAjB;;AACA,MAAMI,WAAW,GAAGH,OAAO,CAAC,oBAAD,CAA3B;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAiBJ,OAAO,CAAC,kCAAD,CAA9B;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMM,IAAI,GAAGN,OAAO,CAAC,SAAD,CAApB;;AACA,MAAMO,OAAO,GAAGP,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMQ,YAAY,GAAGR,OAAO,CAAC,eAAD,CAA5B;;AAEA,MAAM;AAAES,EAAAA;AAAF,IAAYT,OAAO,CAAC,UAAD,CAAzB;AAEA;;;;;;;;AAQA;;;;;;;;AAOA,MAAMU,QAAN,CAAe;AACb;;;;;;;;;AASAC,EAAAA,WAAW,CAAE;AACXC,IAAAA,SADW;AAEXC,IAAAA,OAFW;AAGXC,IAAAA,OAHW;AAIXC,IAAAA,MAJW;AAKXC,IAAAA,eAAe,GAAG,MAAM,CAAE,CALf;AAMXC,IAAAA,YAAY,GAAG,MAAM,CAAE;AANZ,GAAF,EAOR;AACD,SAAKL,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,OAAL,GAAeA,OAAO,IAAI,IAAII,GAAJ,EAA1B;AACA,SAAKH,MAAL,GAAcA,MAAM,IAAI,IAAIG,GAAJ,EAAxB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AACA,SAAKC,SAAL,GAAiB,IAAIF,GAAJ,EAAjB;AACA,SAAKD,YAAL,GAAoBA,YAApB;AACA,SAAKD,eAAL,GAAuBA,eAAvB;AACD;AAED;;;;;;;;AAMA,QAAMK,cAAN,CAAsBC,MAAtB,EAA8B;AAC5B,QAAIC,aAAJ;AACA,QAAIC,UAAJ;AACA,QAAIC,YAAJ;AACA,QAAIC,KAAJ;AACA,QAAIC,cAAJ;AACA,QAAIC,OAAJ;AACA,QAAIC,SAAJ;;AAEA,QAAI,KAAKhB,OAAT,EAAkB;AAChB,OAAC;AAAEiB,QAAAA,SAAS,EAAEF,OAAb;AAAsBG,QAAAA,KAAK,EAAEF;AAA7B,UAA2CrB,YAAY,EAAxD;AACA,YAAMwB,QAAQ,GAAIC,QAAQ,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,CAAT,CAAgCC,QAAhC,CAAyC,EAAzC,IAA+CC,IAAI,CAACC,GAAL,EAAhE;AACAV,MAAAA,OAAO,CAAC;AAAEW,QAAAA,WAAW,EAAE,MAAMP;AAArB,OAAD,CAAP;AACAV,MAAAA,MAAM,GAAG,KAAKT,OAAL,CAAa2B,WAAb,CAAyB;AAAEC,QAAAA,MAAM,EAAEnB,MAAV;AAAkBE,QAAAA,UAAU,EAAEK;AAA9B,OAAzB,CAAT;AACD;;AAED5B,IAAAA,GAAG,CAAC,yCAAD,CAAH,CAhB4B,CAkB5B;;AACA,QAAIyC,aAAa,GAAGpB,MAApB;;AACA,QAAI,KAAKH,SAAT,EAAoB;AAClBuB,MAAAA,aAAa,GAAG,MAAM,KAAKvB,SAAL,CAAewB,OAAf,CAAuBrB,MAAvB,CAAtB;AACD;;AAED,QAAI;AACF;AACA,OAAC;AACCsB,QAAAA,IAAI,EAAErB,aADP;AAECC,QAAAA,UAFD;AAGCqB,QAAAA,QAAQ,EAAElB;AAHX,UAIG,MAAM,KAAKmB,eAAL,CAAqB,KAAKlC,SAA1B,EAAqC8B,aAArC,EAAoD,KAAK5B,OAAzD,CAJV,EAFE,CAQF;;AACA,UAAI,KAAKC,MAAL,CAAYgC,IAAhB,EAAsB;AACpB,SAAC;AAAEN,UAAAA,MAAM,EAAEhB,YAAV;AAAwBC,UAAAA;AAAxB,YAAkC,MAAM,KAAKsB,iBAAL,CAAuBzB,aAAvB,EAAsC,KAAKR,MAA3C,CAAzC;AACD,OAFD,MAEO;AACLU,QAAAA,YAAY,GAAGF,aAAf;AACD;AACF,KAdD,CAcE,OAAO0B,GAAP,EAAY;AACZhD,MAAAA,GAAG,CAACC,KAAJ,CAAU,sCAAV,EAAkD+C,GAAlD;AACA,YAAM3B,MAAM,CAAC4B,KAAP,CAAaD,GAAb,CAAN;AACA,YAAMA,GAAN;AACD;;AAED,QAAI,KAAKpC,OAAT,EAAkB;AAChB,WAAKA,OAAL,CAAasC,iBAAb,CAA+BtB,SAA/B,EAA0CL,UAA1C;AACAI,MAAAA,OAAO,CAACJ,UAAD,CAAP;AACD;;AAEDvB,IAAAA,GAAG,CAAC,0CAAD,CAAH;AAEA,WAAO,KAAKmD,iBAAL,CAAuB;AAC5BzB,MAAAA,cAD4B;AAE5B0B,MAAAA,SAAS,EAAE,SAFiB;AAG5B/B,MAAAA,MAH4B;AAI5BG,MAAAA,YAJ4B;AAK5BC,MAAAA,KAL4B;AAM5BF,MAAAA;AAN4B,KAAvB,CAAP;AAQD;AAED;;;;;;;;AAMA,QAAM8B,eAAN,CAAuBhC,MAAvB,EAA+B;AAC7B,QAAIiC,YAAJ;;AACA,QAAI;AACFA,MAAAA,YAAY,GAAGlD,MAAM,CAACmD,mBAAP,CAA2BlC,MAAM,CAACmC,UAAP,CAAkBC,SAAlB,EAA3B,CAAf;AACD,KAFD,CAEE,OAAOT,GAAP,EAAY;AACZhD,MAAAA,GAAG,CAACC,KAAJ,CAAU,2CAAV,EAAuD+C,GAAvD;AACD;;AAED,QAAI1B,aAAJ;AACA,QAAIC,UAAJ;AACA,QAAIC,YAAJ;AACA,QAAIE,cAAJ;AACA,QAAID,KAAJ;AACA,QAAIE,OAAJ;AACA,QAAIC,SAAJ;;AAEA,QAAI,KAAKhB,OAAT,EAAkB;AAChB,OAAC;AAAEiB,QAAAA,SAAS,EAAEF,OAAb;AAAsBG,QAAAA,KAAK,EAAEF;AAA7B,UAA2CrB,YAAY,EAAxD;AACA,YAAMwB,QAAQ,GAAIC,QAAQ,CAACC,IAAI,CAACC,MAAL,KAAgB,GAAjB,CAAT,CAAgCC,QAAhC,CAAyC,EAAzC,IAA+CC,IAAI,CAACC,GAAL,EAAhE;AACAV,MAAAA,OAAO,CAAC;AAAEW,QAAAA,WAAW,EAAE,MAAMP;AAArB,OAAD,CAAP;AACAV,MAAAA,MAAM,GAAG,KAAKT,OAAL,CAAa2B,WAAb,CAAyB;AAAEC,QAAAA,MAAM,EAAEnB,MAAV;AAAkBE,QAAAA,UAAU,EAAEK;AAA9B,OAAzB,CAAT;AACD;;AAED5B,IAAAA,GAAG,CAAC,0CAAD,CAAH,CAvB6B,CAyB7B;;AACA,QAAIyC,aAAa,GAAGpB,MAApB;;AACA,QAAI,KAAKH,SAAT,EAAoB;AAClBuB,MAAAA,aAAa,GAAG,MAAM,KAAKvB,SAAL,CAAewB,OAAf,CAAuBrB,MAAvB,CAAtB;AACD;;AAED,QAAI;AACF;AACA,OAAC;AACCsB,QAAAA,IAAI,EAAErB,aADP;AAECC,QAAAA,UAFD;AAGCqB,QAAAA,QAAQ,EAAElB;AAHX,UAIG,MAAM,KAAKgC,gBAAL,CAAsB,KAAK/C,SAA3B,EAAsC8B,aAAtC,EAAqDa,YAArD,EAAmE,KAAKzC,OAAxE,CAJV,EAFE,CAQF;;AACA,UAAI,KAAKC,MAAL,CAAYgC,IAAhB,EAAsB;AACpB,SAAC;AAAEN,UAAAA,MAAM,EAAEhB,YAAV;AAAwBC,UAAAA;AAAxB,YAAkC,MAAM,KAAKkC,kBAAL,CAAwBrC,aAAxB,EAAuC,KAAKR,MAA5C,CAAzC;AACD,OAFD,MAEO;AACLU,QAAAA,YAAY,GAAGF,aAAf;AACD;AACF,KAdD,CAcE,OAAO0B,GAAP,EAAY;AACZhD,MAAAA,GAAG,CAACC,KAAJ,CAAU,uCAAV,EAAmD+C,GAAnD;AACA,YAAM3B,MAAM,CAAC4B,KAAP,CAAaD,GAAb,CAAN;AACA,YAAMA,GAAN;AACD;;AAED,QAAI,KAAKpC,OAAT,EAAkB;AAChB,WAAKA,OAAL,CAAasC,iBAAb,CAA+BtB,SAA/B,EAA0CL,UAA1C;AACAI,MAAAA,OAAO,CAACJ,UAAD,CAAP;AACD;;AAEDvB,IAAAA,GAAG,CAAC,2CAAD,CAAH;AAEA,WAAO,KAAKmD,iBAAL,CAAuB;AAC5BzB,MAAAA,cAD4B;AAE5B0B,MAAAA,SAAS,EAAE,UAFiB;AAG5B/B,MAAAA,MAH4B;AAI5BG,MAAAA,YAJ4B;AAK5BC,MAAAA,KAL4B;AAM5BF,MAAAA;AAN4B,KAAvB,CAAP;AAQD;AAED;;;;;;;;;;;;;;AAYA4B,EAAAA,iBAAiB,CAAE;AACjBzB,IAAAA,cADiB;AAEjB0B,IAAAA,SAFiB;AAGjB/B,IAAAA,MAHiB;AAIjBG,IAAAA,YAJiB;AAKjBC,IAAAA,KALiB;AAMjBF,IAAAA;AANiB,GAAF,EAOd;AACD,QAAIqC,KAAJ;AACA,QAAIC,SAAJ,CAFC,CAGD;;AACA,QAAIC,UAAJ;;AAEA,QAAIrC,KAAJ,EAAW;AACT;AACAmC,MAAAA,KAAK,GAAG,IAAInC,KAAJ,CAAU;AAChB;AACAsC,QAAAA,QAAQ,EAAE,MAAMC,WAAN,IAAqB;AAC7B,gBAAMC,GAAG,GAAG,IAAI/D,WAAW,CAACgE,QAAhB,CAAyBF,WAAzB,CAAZ;;AACA,cAAI;AACF,kBAAM;AAAExB,cAAAA,MAAF;AAAUI,cAAAA;AAAV,gBAAuB,MAAMqB,GAAG,CAACE,MAAJ,CAAWC,KAAK,CAACC,IAAN,CAAW,KAAKlD,SAAL,CAAemD,IAAf,EAAX,CAAX,CAAnC;AACAtE,YAAAA,GAAG,CAAC,kCAAD,EAAqCoD,SAArC,EAAgDR,QAAhD,CAAH;AACA,gBAAI,KAAKhC,OAAT,EAAkB,KAAKA,OAAL,CAAa2B,WAAb,CAAyB;AAAEC,cAAAA,MAAF;AAAUjB,cAAAA,UAAV;AAAsBqB,cAAAA;AAAtB,aAAzB;AAClBkB,YAAAA,UAAU,CAACS,SAAX,CAAqBP,WAArB,EAAkC;AAAEpB,cAAAA;AAAF,aAAlC;;AACA,iBAAK4B,SAAL,CAAe;AAAEV,cAAAA,UAAF;AAActB,cAAAA,MAAM,EAAE,EAAE,GAAGwB,WAAL;AAAkB,mBAAGxB;AAArB,eAAtB;AAAqDI,cAAAA;AAArD,aAAf;AACD,WAND,CAME,OAAOI,GAAP,EAAY;AACZhD,YAAAA,GAAG,CAACC,KAAJ,CAAU+C,GAAV;AACD;AACF,SAbe;AAchB;AACAyB,QAAAA,WAAW,EAAET,WAAW,IAAI;AAC1BF,UAAAA,UAAU,CAACY,YAAX,CAAwBV,WAAW,CAACW,EAApC;AACD;AAjBe,OAAV,CAAR;;AAoBAd,MAAAA,SAAS,GAAG,MAAM1C,SAAN,IAAmB;AAC7BnB,QAAAA,GAAG,CAAC,+BAAD,EAAkCoD,SAAlC,EAA6CjC,SAA7C,CAAH;AACA,cAAM6C,WAAW,GAAGJ,KAAK,CAACC,SAAN,EAApB;AACA,cAAMI,GAAG,GAAG,IAAI/D,WAAW,CAAC0E,MAAhB,CAAuBZ,WAAvB,CAAZ;;AACA,YAAI;AACF,gBAAM;AAAExB,YAAAA,MAAF;AAAUI,YAAAA;AAAV,cAAuB,MAAMqB,GAAG,CAACY,MAAJ,CAAW1D,SAAX,CAAnC;AACA,cAAI,KAAKP,OAAT,EAAkB,KAAKA,OAAL,CAAa2B,WAAb,CAAyB;AAAEC,YAAAA,MAAF;AAAUjB,YAAAA,UAAV;AAAsBqB,YAAAA;AAAtB,WAAzB;AAClB,iBAAO;AAAEJ,YAAAA,MAAM,EAAE,EAAE,GAAGwB,WAAL;AAAkB,iBAAGxB;AAArB,aAAV;AAAyCI,YAAAA;AAAzC,WAAP;AACD,SAJD,CAIE,OAAOI,GAAP,EAAY;AACZhD,UAAAA,GAAG,CAACC,KAAJ,CAAU,6BAAV,EAAyC+C,GAAzC;AACA,gBAAM1C,OAAO,CAAC0C,GAAD,EAAMxC,KAAK,CAACsE,wBAAZ,CAAb;AACD;AACF,OAZD,CAtBS,CAoCT;;;AACAzE,MAAAA,IAAI,CAACmB,YAAD,EAAeoC,KAAf,EAAsBpC,YAAtB,CAAJ,CAAwCuD,KAAxC,CAA8C/E,GAAG,CAACC,KAAlD;AACD;;AAED,UAAM+E,SAAS,GAAG3D,MAAM,CAAC4D,QAAzB;AACA5D,IAAAA,MAAM,CAAC4D,QAAP,GAAkB,IAAIC,KAAJ,CAAUF,SAAV,EAAqB;AACrCG,MAAAA,GAAG,EAAE,CAAC,GAAGC,IAAJ,KAAa;AAChB,YAAItB,UAAU,IAAIsB,IAAI,CAAC,CAAD,CAAJ,KAAY,OAA1B,IAAqCA,IAAI,CAAC,CAAD,CAAzC,IAAgD,CAACJ,SAAS,CAAC/B,KAA/D,EAAsE;AACpEa,UAAAA,UAAU,CAACuB,IAAX,CAAgBC,MAAhB,GAAyB,QAAzB;AACA,eAAKvE,eAAL,CAAqB+C,UAArB;AACD;;AAED,eAAOyB,OAAO,CAACJ,GAAR,CAAY,GAAGC,IAAf,CAAP;AACD;AARoC,KAArB,CAAlB;AAUA/D,IAAAA,MAAM,CAAC4D,QAAP,CAAgBO,QAAhB,GAA2BpD,IAAI,CAACC,GAAL,EAA3B;;AAEA,UAAMoD,2BAA2B,GAAG,MAAM;AACxC,YAAMnF,OAAO,CAAC,IAAIoF,KAAJ,CAAU,+BAAV,CAAD,EAA6C,gCAA7C,CAAb;AACD,KAFD,CA3DC,CA+DD;;;AACA5B,IAAAA,UAAU,GAAG,IAAI3D,UAAJ,CAAe;AAC1BwF,MAAAA,SAAS,EAAEtE,MAAM,CAACsE,SADQ;AAE1BnC,MAAAA,UAAU,EAAEnC,MAAM,CAACmC,UAFO;AAG1B7C,MAAAA,SAAS,EAAE,KAAKA,SAHU;AAI1BY,MAAAA,UAAU,EAAEA,UAJc;AAK1B8D,MAAAA,IAAI,EAAE;AACJjC,QAAAA,SADI;AAEJ6B,QAAAA,QAAQ,EAAE5D,MAAM,CAAC4D,QAFb;AAGJW,QAAAA,WAAW,EAAEnE,KAAK,IAAIA,KAAK,CAACoE,UAHxB;AAIJC,QAAAA,UAAU,EAAEpE;AAJR,OALoB;AAW1BmC,MAAAA,SAAS,EAAEA,SAAS,IAAI4B,2BAXE;AAY1BM,MAAAA,UAAU,EAAE,MAAMnC,KAAK,GAAGA,KAAK,CAACoC,OAAT,GAAmBP,2BAZhB;AAa1BxC,MAAAA,KAAK,EAAED,GAAG,IAAI3B,MAAM,CAAC4B,KAAP,CAAaD,GAAb;AAbY,KAAf,CAAb;AAgBA,SAAKhC,YAAL,CAAkB8C,UAAlB;AAEA,WAAOA,UAAP;AACD;AAED;;;;;;;;;;AAQAU,EAAAA,SAAS,CAAE;AAAEV,IAAAA,UAAF;AAActB,IAAAA,MAAd;AAAsBI,IAAAA;AAAtB,GAAF,EAAoC;AAC3C,UAAMqD,OAAO,GAAG,KAAK9E,SAAL,CAAe+E,GAAf,CAAmBtD,QAAnB,CAAhB;AACAqD,IAAAA,OAAO,CAAC;AAAEnC,MAAAA,UAAF;AAActB,MAAAA,MAAd;AAAsBI,MAAAA;AAAtB,KAAD,CAAP;AACD;AAED;;;;;;;;;;;AASA,QAAMC,eAAN,CAAuBlC,SAAvB,EAAkCmD,UAAlC,EAA8CjD,OAA9C,EAAuD;AACrD,UAAMoD,GAAG,GAAG,IAAI/D,WAAW,CAACgE,QAAhB,CAAyBJ,UAAzB,CAAZ;AACA,UAAM3C,SAAS,GAAGiD,KAAK,CAACC,IAAN,CAAWxD,OAAO,CAACyD,IAAR,EAAX,CAAlB;AACAtE,IAAAA,GAAG,CAAC,4CAAD,EAA+CmB,SAA/C,CAAH;;AAEA,QAAI;AACF,YAAM;AAAEqB,QAAAA,MAAF;AAAUI,QAAAA;AAAV,UAAuB,MAAMqB,GAAG,CAACE,MAAJ,CAAWhD,SAAX,CAAnC;AACA,YAAMgF,MAAM,GAAGtF,OAAO,CAACqF,GAAR,CAAYtD,QAAZ,CAAf;AACA5C,MAAAA,GAAG,CAAC,kCAAD,CAAH;AAEA,aAAO,EACL,IAAG,MAAMmG,MAAM,CAACC,aAAP,CAAqBzF,SAArB,EAAgC6B,MAAhC,CAAT,CADK;AAELI,QAAAA;AAFK,OAAP;AAID,KATD,CASE,OAAOI,GAAP,EAAY;AACZ,YAAM1C,OAAO,CAAC0C,GAAD,EAAMxC,KAAK,CAAC6F,qBAAZ,CAAb;AACD;AACF;AAED;;;;;;;;;;;;;AAWA,QAAM3C,gBAAN,CAAwB/C,SAAxB,EAAmCmD,UAAnC,EAA+CR,YAA/C,EAA6DzC,OAA7D,EAAsE;AACpE,UAAMoD,GAAG,GAAG,IAAI/D,WAAW,CAAC0E,MAAhB,CAAuBd,UAAvB,CAAZ;AACA,UAAM3C,SAAS,GAAGiD,KAAK,CAACC,IAAN,CAAWxD,OAAO,CAACyD,IAAR,EAAX,CAAlB;AACAtE,IAAAA,GAAG,CAAC,oCAAD,EAAuCmB,SAAvC,CAAH;;AAEA,QAAI;AACF,YAAM;AAAEqB,QAAAA,MAAF;AAAUI,QAAAA;AAAV,UAAuB,MAAMqB,GAAG,CAACY,MAAJ,CAAW1D,SAAX,CAAnC;AACA,YAAMgF,MAAM,GAAGtF,OAAO,CAACqF,GAAR,CAAYtD,QAAZ,CAAf;AACA5C,MAAAA,GAAG,CAAC,sCAAD,EAAyCsD,YAAzC,CAAH;AAEA,aAAO,EACL,IAAG,MAAM6C,MAAM,CAACG,cAAP,CAAsB3F,SAAtB,EAAiC6B,MAAjC,EAAyCc,YAAzC,CAAT,CADK;AAELV,QAAAA;AAFK,OAAP;AAID,KATD,CASE,OAAOI,GAAP,EAAY;AACZ,YAAM1C,OAAO,CAAC0C,GAAD,EAAMxC,KAAK,CAAC6F,qBAAZ,CAAb;AACD;AACF;AAED;;;;;;;;;;;AASA,QAAM1C,kBAAN,CAA0BG,UAA1B,EAAsChD,MAAtC,EAA8C;AAC5C,UAAMyF,MAAM,GAAG,IAAIrG,WAAW,CAAC0E,MAAhB,CAAuBd,UAAvB,CAAf;AACA,UAAM3C,SAAS,GAAGiD,KAAK,CAACC,IAAN,CAAWvD,MAAM,CAACwD,IAAP,EAAX,CAAlB;AACAtE,IAAAA,GAAG,CAAC,6BAAD,EAAgCmB,SAAhC,CAAH;;AACA,QAAI;AACF,YAAM;AAAEqB,QAAAA,MAAF;AAAUI,QAAAA;AAAV,UAAuB,MAAM2D,MAAM,CAAC1B,MAAP,CAAc1D,SAAd,CAAnC;AACAnB,MAAAA,GAAG,CAAC,+BAAD,EAAkC4C,QAAlC,CAAH;AACA,YAAMnB,KAAK,GAAGX,MAAM,CAACoF,GAAP,CAAWtD,QAAX,CAAd;AACA,aAAO;AAAEJ,QAAAA,MAAF;AAAUf,QAAAA;AAAV,OAAP;AACD,KALD,CAKE,OAAOuB,GAAP,EAAY;AACZ,YAAM1C,OAAO,CAAC0C,GAAD,EAAMxC,KAAK,CAACgG,qBAAZ,CAAb;AACD;AACF;AAED;;;;;;;;;;;AASA,QAAMzD,iBAAN,CAAyBe,UAAzB,EAAqChD,MAArC,EAA6C;AAC3C,UAAM2F,QAAQ,GAAG,IAAIvG,WAAW,CAACgE,QAAhB,CAAyBJ,UAAzB,CAAjB;AACA,UAAM3C,SAAS,GAAGiD,KAAK,CAACC,IAAN,CAAWvD,MAAM,CAACwD,IAAP,EAAX,CAAlB;AACAtE,IAAAA,GAAG,CAAC,4BAAD,EAA+BmB,SAA/B,CAAH;;AACA,QAAI;AACF,YAAM;AAAEqB,QAAAA,MAAF;AAAUI,QAAAA;AAAV,UAAuB,MAAM6D,QAAQ,CAACtC,MAAT,CAAgBhD,SAAhB,CAAnC;AACA,YAAMM,KAAK,GAAGX,MAAM,CAACoF,GAAP,CAAWtD,QAAX,CAAd;AACA,aAAO;AAAEJ,QAAAA,MAAF;AAAUf,QAAAA;AAAV,OAAP;AACD,KAJD,CAIE,OAAOuB,GAAP,EAAY;AACZ,YAAM1C,OAAO,CAAC0C,GAAD,EAAMxC,KAAK,CAACgG,qBAAZ,CAAb;AACD;AACF;;AAnYY;;AAsYfE,MAAM,CAACC,OAAP,GAAiBlG,QAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:upgrader')\nlog.error = debug('libp2p:upgrader:error')\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst pipe = require('it-pipe')\nconst errCode = require('err-code')\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef MultiaddrConnection\n * @property {function} sink\n * @property {AsyncIterator} source\n * @property {*} conn\n * @property {Multiaddr} remoteAddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {*} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {Metrics} options.metrics\n   * @param {Map<string, Crypto>} options.cryptos\n   * @param {Map<string, Muxer>} options.muxers\n   * @param {function(Connection)} options.onConnection Called when a connection is upgraded\n   * @param {function(Connection)} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    cryptos,\n    muxers,\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos || new Map()\n    this.muxers = muxers || new Map()\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (parseInt(Math.random() * 1e9)).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    let remotePeerId\n    try {\n      remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId())\n    } catch (err) {\n      log.error('multiaddr did not contain a valid peer id', err)\n    }\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (parseInt(Math.random() * 1e9)).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   * @private\n   * @param {object} options\n   * @param {string} cryptoProtocol The crypto protocol that was negotiated\n   * @param {string} direction One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} maConn The transport layer connection\n   * @param {*} upgradedConn A duplex connection returned from multiplexer and/or crypto selection\n   * @param {Muxer} Muxer The muxer to be used for muxing\n   * @param {PeerId} remotePeer The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    let muxer\n    let newStream\n    // eslint-disable-next-line prefer-const\n    let connection\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          connection.stat.status = 'closed'\n          this.onConnectionEnd(connection)\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED')\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed,\n      close: err => maConn.close(err)\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection The connection the stream belongs to\n   * @param {Stream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerId\n   * @param {*} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"]},"metadata":{},"sourceType":"script"}