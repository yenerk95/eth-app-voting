{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:upgrader');\nlog.error = debug('libp2p:upgrader:error');\n\nvar Multistream = require('multistream-select');\n\nvar _require = require('libp2p-interfaces/src/connection'),\n    Connection = _require.Connection;\n\nvar PeerId = require('peer-id');\n\nvar pipe = require('it-pipe');\n\nvar errCode = require('err-code');\n\nvar mutableProxy = require('mutable-proxy');\n\nvar _require2 = require('./errors'),\n    codes = _require2.codes;\n/**\n * @typedef MultiaddrConnection\n * @property {function} sink\n * @property {AsyncIterator} source\n * @property {*} conn\n * @property {Multiaddr} remoteAddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {*} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nvar Upgrader = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {Metrics} options.metrics\n   * @param {Map<string, Crypto>} options.cryptos\n   * @param {Map<string, Muxer>} options.muxers\n   * @param {function(Connection)} options.onConnection Called when a connection is upgraded\n   * @param {function(Connection)} options.onConnectionEnd\n   */\n  function Upgrader(_ref) {\n    var localPeer = _ref.localPeer,\n        metrics = _ref.metrics,\n        cryptos = _ref.cryptos,\n        muxers = _ref.muxers,\n        _ref$onConnectionEnd = _ref.onConnectionEnd,\n        onConnectionEnd = _ref$onConnectionEnd === void 0 ? function () {} : _ref$onConnectionEnd,\n        _ref$onConnection = _ref.onConnection,\n        onConnection = _ref$onConnection === void 0 ? function () {} : _ref$onConnection;\n\n    _classCallCheck(this, Upgrader);\n\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos || new Map();\n    this.muxers = muxers || new Map();\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  _createClass(Upgrader, [{\n    key: \"upgradeInbound\",\n    value: function () {\n      var _upgradeInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(maConn) {\n        var encryptedConn, remotePeer, upgradedConn, Muxer, cryptoProtocol, setPeer, proxyPeer, _mutableProxy, idString, protectedConn, _yield$this$_encryptI, _yield$this$_multiple;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.metrics) {\n                  _mutableProxy = mutableProxy();\n                  setPeer = _mutableProxy.setTarget;\n                  proxyPeer = _mutableProxy.proxy;\n                  idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n                  setPeer({\n                    toB58String: function toB58String() {\n                      return idString;\n                    }\n                  });\n                  maConn = this.metrics.trackStream({\n                    stream: maConn,\n                    remotePeer: proxyPeer\n                  });\n                }\n\n                log('Starting the inbound connection upgrade'); // Protect\n\n                protectedConn = maConn;\n\n                if (!this.protector) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 6;\n                return this.protector.protect(maConn);\n\n              case 6:\n                protectedConn = _context.sent;\n\n              case 7:\n                _context.prev = 7;\n                _context.next = 10;\n                return this._encryptInbound(this.localPeer, protectedConn, this.cryptos);\n\n              case 10:\n                _yield$this$_encryptI = _context.sent;\n                encryptedConn = _yield$this$_encryptI.conn;\n                remotePeer = _yield$this$_encryptI.remotePeer;\n                cryptoProtocol = _yield$this$_encryptI.protocol;\n\n                if (!this.muxers.size) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _context.next = 17;\n                return this._multiplexInbound(encryptedConn, this.muxers);\n\n              case 17:\n                _yield$this$_multiple = _context.sent;\n                upgradedConn = _yield$this$_multiple.stream;\n                Muxer = _yield$this$_multiple.Muxer;\n                _context.next = 23;\n                break;\n\n              case 22:\n                upgradedConn = encryptedConn;\n\n              case 23:\n                _context.next = 31;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](7);\n                log.error('Failed to upgrade inbound connection', _context.t0);\n                _context.next = 30;\n                return maConn.close(_context.t0);\n\n              case 30:\n                throw _context.t0;\n\n              case 31:\n                if (this.metrics) {\n                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n                  setPeer(remotePeer);\n                }\n\n                log('Successfully upgraded inbound connection');\n                return _context.abrupt(\"return\", this._createConnection({\n                  cryptoProtocol: cryptoProtocol,\n                  direction: 'inbound',\n                  maConn: maConn,\n                  upgradedConn: upgradedConn,\n                  Muxer: Muxer,\n                  remotePeer: remotePeer\n                }));\n\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 25]]);\n      }));\n\n      function upgradeInbound(_x) {\n        return _upgradeInbound.apply(this, arguments);\n      }\n\n      return upgradeInbound;\n    }()\n    /**\n     * Upgrades an outbound connection\n     * @async\n     * @param {MultiaddrConnection} maConn\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"upgradeOutbound\",\n    value: function () {\n      var _upgradeOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(maConn) {\n        var remotePeerId, encryptedConn, remotePeer, upgradedConn, cryptoProtocol, Muxer, setPeer, proxyPeer, _mutableProxy2, idString, protectedConn, _yield$this$_encryptO, _yield$this$_multiple2;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                try {\n                  remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId());\n                } catch (err) {\n                  log.error('multiaddr did not contain a valid peer id', err);\n                }\n\n                if (this.metrics) {\n                  _mutableProxy2 = mutableProxy();\n                  setPeer = _mutableProxy2.setTarget;\n                  proxyPeer = _mutableProxy2.proxy;\n                  idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n                  setPeer({\n                    toB58String: function toB58String() {\n                      return idString;\n                    }\n                  });\n                  maConn = this.metrics.trackStream({\n                    stream: maConn,\n                    remotePeer: proxyPeer\n                  });\n                }\n\n                log('Starting the outbound connection upgrade'); // Protect\n\n                protectedConn = maConn;\n\n                if (!this.protector) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this.protector.protect(maConn);\n\n              case 7:\n                protectedConn = _context2.sent;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos);\n\n              case 11:\n                _yield$this$_encryptO = _context2.sent;\n                encryptedConn = _yield$this$_encryptO.conn;\n                remotePeer = _yield$this$_encryptO.remotePeer;\n                cryptoProtocol = _yield$this$_encryptO.protocol;\n\n                if (!this.muxers.size) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                _context2.next = 18;\n                return this._multiplexOutbound(encryptedConn, this.muxers);\n\n              case 18:\n                _yield$this$_multiple2 = _context2.sent;\n                upgradedConn = _yield$this$_multiple2.stream;\n                Muxer = _yield$this$_multiple2.Muxer;\n                _context2.next = 24;\n                break;\n\n              case 23:\n                upgradedConn = encryptedConn;\n\n              case 24:\n                _context2.next = 32;\n                break;\n\n              case 26:\n                _context2.prev = 26;\n                _context2.t0 = _context2[\"catch\"](8);\n                log.error('Failed to upgrade outbound connection', _context2.t0);\n                _context2.next = 31;\n                return maConn.close(_context2.t0);\n\n              case 31:\n                throw _context2.t0;\n\n              case 32:\n                if (this.metrics) {\n                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n                  setPeer(remotePeer);\n                }\n\n                log('Successfully upgraded outbound connection');\n                return _context2.abrupt(\"return\", this._createConnection({\n                  cryptoProtocol: cryptoProtocol,\n                  direction: 'outbound',\n                  maConn: maConn,\n                  upgradedConn: upgradedConn,\n                  Muxer: Muxer,\n                  remotePeer: remotePeer\n                }));\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 26]]);\n      }));\n\n      function upgradeOutbound(_x2) {\n        return _upgradeOutbound.apply(this, arguments);\n      }\n\n      return upgradeOutbound;\n    }()\n    /**\n     * A convenience method for generating a new `Connection`\n     * @private\n     * @param {object} options\n     * @param {string} cryptoProtocol The crypto protocol that was negotiated\n     * @param {string} direction One of ['inbound', 'outbound']\n     * @param {MultiaddrConnection} maConn The transport layer connection\n     * @param {*} upgradedConn A duplex connection returned from multiplexer and/or crypto selection\n     * @param {Muxer} Muxer The muxer to be used for muxing\n     * @param {PeerId} remotePeer The peer the connection is with\n     * @returns {Connection}\n     */\n\n  }, {\n    key: \"_createConnection\",\n    value: function _createConnection(_ref2) {\n      var _this = this;\n\n      var cryptoProtocol = _ref2.cryptoProtocol,\n          direction = _ref2.direction,\n          maConn = _ref2.maConn,\n          upgradedConn = _ref2.upgradedConn,\n          Muxer = _ref2.Muxer,\n          remotePeer = _ref2.remotePeer;\n      var muxer;\n      var newStream; // eslint-disable-next-line prefer-const\n\n      var connection;\n\n      if (Muxer) {\n        // Create the muxer\n        muxer = new Muxer({\n          // Run anytime a remote stream is created\n          onStream: function () {\n            var _onStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(muxedStream) {\n              var mss, _yield$mss$handle, stream, protocol;\n\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      mss = new Multistream.Listener(muxedStream);\n                      _context3.prev = 1;\n                      _context3.next = 4;\n                      return mss.handle(Array.from(_this.protocols.keys()));\n\n                    case 4:\n                      _yield$mss$handle = _context3.sent;\n                      stream = _yield$mss$handle.stream;\n                      protocol = _yield$mss$handle.protocol;\n                      log('%s: incoming stream opened on %s', direction, protocol);\n                      if (_this.metrics) _this.metrics.trackStream({\n                        stream: stream,\n                        remotePeer: remotePeer,\n                        protocol: protocol\n                      });\n                      connection.addStream(muxedStream, {\n                        protocol: protocol\n                      });\n\n                      _this._onStream({\n                        connection: connection,\n                        stream: _objectSpread(_objectSpread({}, muxedStream), stream),\n                        protocol: protocol\n                      });\n\n                      _context3.next = 16;\n                      break;\n\n                    case 13:\n                      _context3.prev = 13;\n                      _context3.t0 = _context3[\"catch\"](1);\n                      log.error(_context3.t0);\n\n                    case 16:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[1, 13]]);\n            }));\n\n            function onStream(_x3) {\n              return _onStream2.apply(this, arguments);\n            }\n\n            return onStream;\n          }(),\n          // Run anytime a stream closes\n          onStreamEnd: function onStreamEnd(muxedStream) {\n            connection.removeStream(muxedStream.id);\n          }\n        });\n\n        newStream = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(protocols) {\n            var muxedStream, mss, _yield$mss$select, stream, protocol;\n\n            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    log('%s: starting new stream on %s', direction, protocols);\n                    muxedStream = muxer.newStream();\n                    mss = new Multistream.Dialer(muxedStream);\n                    _context4.prev = 3;\n                    _context4.next = 6;\n                    return mss.select(protocols);\n\n                  case 6:\n                    _yield$mss$select = _context4.sent;\n                    stream = _yield$mss$select.stream;\n                    protocol = _yield$mss$select.protocol;\n                    if (_this.metrics) _this.metrics.trackStream({\n                      stream: stream,\n                      remotePeer: remotePeer,\n                      protocol: protocol\n                    });\n                    return _context4.abrupt(\"return\", {\n                      stream: _objectSpread(_objectSpread({}, muxedStream), stream),\n                      protocol: protocol\n                    });\n\n                  case 13:\n                    _context4.prev = 13;\n                    _context4.t0 = _context4[\"catch\"](3);\n                    log.error('could not create new stream', _context4.t0);\n                    throw errCode(_context4.t0, codes.ERR_UNSUPPORTED_PROTOCOL);\n\n                  case 17:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[3, 13]]);\n          }));\n\n          return function newStream(_x4) {\n            return _ref3.apply(this, arguments);\n          };\n        }(); // Pipe all data through the muxer\n\n\n        pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n      }\n\n      var _timeline = maConn.timeline;\n      maConn.timeline = new Proxy(_timeline, {\n        set: function set() {\n          if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {\n            connection.stat.status = 'closed';\n\n            _this.onConnectionEnd(connection);\n          }\n\n          return Reflect.set.apply(Reflect, arguments);\n        }\n      });\n      maConn.timeline.upgraded = Date.now();\n\n      var errConnectionNotMultiplexed = function errConnectionNotMultiplexed() {\n        throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n      }; // Create the connection\n\n\n      connection = new Connection({\n        localAddr: maConn.localAddr,\n        remoteAddr: maConn.remoteAddr,\n        localPeer: this.localPeer,\n        remotePeer: remotePeer,\n        stat: {\n          direction: direction,\n          timeline: maConn.timeline,\n          multiplexer: Muxer && Muxer.multicodec,\n          encryption: cryptoProtocol\n        },\n        newStream: newStream || errConnectionNotMultiplexed,\n        getStreams: function getStreams() {\n          return muxer ? muxer.streams : errConnectionNotMultiplexed;\n        },\n        close: function close(err) {\n          return maConn.close(err);\n        }\n      });\n      this.onConnection(connection);\n      return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     * @private\n     * @param {object} options\n     * @param {Connection} options.connection The connection the stream belongs to\n     * @param {Stream} options.stream\n     * @param {string} options.protocol\n     */\n\n  }, {\n    key: \"_onStream\",\n    value: function _onStream(_ref4) {\n      var connection = _ref4.connection,\n          stream = _ref4.stream,\n          protocol = _ref4.protocol;\n      var handler = this.protocols.get(protocol);\n      handler({\n        connection: connection,\n        stream: stream,\n        protocol: protocol\n      });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n     * @private\n     * @async\n     * @param {PeerId} localPeer The initiators PeerId\n     * @param {*} connection\n     * @param {Map<string, Crypto>} cryptos\n     * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n     */\n\n  }, {\n    key: \"_encryptInbound\",\n    value: function () {\n      var _encryptInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(localPeer, connection, cryptos) {\n        var mss, protocols, _yield$mss$handle2, stream, protocol, crypto;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                mss = new Multistream.Listener(connection);\n                protocols = Array.from(cryptos.keys());\n                log('handling inbound crypto protocol selection', protocols);\n                _context5.prev = 3;\n                _context5.next = 6;\n                return mss.handle(protocols);\n\n              case 6:\n                _yield$mss$handle2 = _context5.sent;\n                stream = _yield$mss$handle2.stream;\n                protocol = _yield$mss$handle2.protocol;\n                crypto = cryptos.get(protocol);\n                log('encrypting inbound connection...');\n                _context5.t0 = _objectSpread;\n                _context5.t1 = _objectSpread;\n                _context5.t2 = {};\n                _context5.next = 16;\n                return crypto.secureInbound(localPeer, stream);\n\n              case 16:\n                _context5.t3 = _context5.sent;\n                _context5.t4 = (0, _context5.t1)(_context5.t2, _context5.t3);\n                _context5.t5 = {};\n                _context5.t6 = {\n                  protocol: protocol\n                };\n                return _context5.abrupt(\"return\", (0, _context5.t0)(_context5.t4, _context5.t5, _context5.t6));\n\n              case 23:\n                _context5.prev = 23;\n                _context5.t7 = _context5[\"catch\"](3);\n                throw errCode(_context5.t7, codes.ERR_ENCRYPTION_FAILED);\n\n              case 26:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[3, 23]]);\n      }));\n\n      function _encryptInbound(_x5, _x6, _x7) {\n        return _encryptInbound2.apply(this, arguments);\n      }\n\n      return _encryptInbound;\n    }()\n    /**\n     * Attempts to encrypt the given `connection` with the provided `cryptos`.\n     * The first `Crypto` module to succeed will be used\n     * @private\n     * @async\n     * @param {PeerId} localPeer The initiators PeerId\n     * @param {*} connection\n     * @param {PeerId} remotePeerId\n     * @param {Map<string, Crypto>} cryptos\n     * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n     */\n\n  }, {\n    key: \"_encryptOutbound\",\n    value: function () {\n      var _encryptOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(localPeer, connection, remotePeerId, cryptos) {\n        var mss, protocols, _yield$mss$select2, stream, protocol, crypto;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                mss = new Multistream.Dialer(connection);\n                protocols = Array.from(cryptos.keys());\n                log('selecting outbound crypto protocol', protocols);\n                _context6.prev = 3;\n                _context6.next = 6;\n                return mss.select(protocols);\n\n              case 6:\n                _yield$mss$select2 = _context6.sent;\n                stream = _yield$mss$select2.stream;\n                protocol = _yield$mss$select2.protocol;\n                crypto = cryptos.get(protocol);\n                log('encrypting outbound connection to %j', remotePeerId);\n                _context6.t0 = _objectSpread;\n                _context6.t1 = _objectSpread;\n                _context6.t2 = {};\n                _context6.next = 16;\n                return crypto.secureOutbound(localPeer, stream, remotePeerId);\n\n              case 16:\n                _context6.t3 = _context6.sent;\n                _context6.t4 = (0, _context6.t1)(_context6.t2, _context6.t3);\n                _context6.t5 = {};\n                _context6.t6 = {\n                  protocol: protocol\n                };\n                return _context6.abrupt(\"return\", (0, _context6.t0)(_context6.t4, _context6.t5, _context6.t6));\n\n              case 23:\n                _context6.prev = 23;\n                _context6.t7 = _context6[\"catch\"](3);\n                throw errCode(_context6.t7, codes.ERR_ENCRYPTION_FAILED);\n\n              case 26:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[3, 23]]);\n      }));\n\n      function _encryptOutbound(_x8, _x9, _x10, _x11) {\n        return _encryptOutbound2.apply(this, arguments);\n      }\n\n      return _encryptOutbound;\n    }()\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     * @private\n     * @async\n     * @param {*} connection A basic duplex connection to multiplex\n     * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n     * @returns {*} A muxed connection\n     */\n\n  }, {\n    key: \"_multiplexOutbound\",\n    value: function () {\n      var _multiplexOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(connection, muxers) {\n        var dialer, protocols, _yield$dialer$select, stream, protocol, Muxer;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                dialer = new Multistream.Dialer(connection);\n                protocols = Array.from(muxers.keys());\n                log('outbound selecting muxer %s', protocols);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return dialer.select(protocols);\n\n              case 6:\n                _yield$dialer$select = _context7.sent;\n                stream = _yield$dialer$select.stream;\n                protocol = _yield$dialer$select.protocol;\n                log('%s selected as muxer protocol', protocol);\n                Muxer = muxers.get(protocol);\n                return _context7.abrupt(\"return\", {\n                  stream: stream,\n                  Muxer: Muxer\n                });\n\n              case 14:\n                _context7.prev = 14;\n                _context7.t0 = _context7[\"catch\"](3);\n                throw errCode(_context7.t0, codes.ERR_MUXER_UNAVAILABLE);\n\n              case 17:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[3, 14]]);\n      }));\n\n      function _multiplexOutbound(_x12, _x13) {\n        return _multiplexOutbound2.apply(this, arguments);\n      }\n\n      return _multiplexOutbound;\n    }()\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     * @private\n     * @async\n     * @param {*} connection A basic duplex connection to multiplex\n     * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n     * @returns {*} A muxed connection\n     */\n\n  }, {\n    key: \"_multiplexInbound\",\n    value: function () {\n      var _multiplexInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connection, muxers) {\n        var listener, protocols, _yield$listener$handl, stream, protocol, Muxer;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                listener = new Multistream.Listener(connection);\n                protocols = Array.from(muxers.keys());\n                log('inbound handling muxers %s', protocols);\n                _context8.prev = 3;\n                _context8.next = 6;\n                return listener.handle(protocols);\n\n              case 6:\n                _yield$listener$handl = _context8.sent;\n                stream = _yield$listener$handl.stream;\n                protocol = _yield$listener$handl.protocol;\n                Muxer = muxers.get(protocol);\n                return _context8.abrupt(\"return\", {\n                  stream: stream,\n                  Muxer: Muxer\n                });\n\n              case 13:\n                _context8.prev = 13;\n                _context8.t0 = _context8[\"catch\"](3);\n                throw errCode(_context8.t0, codes.ERR_MUXER_UNAVAILABLE);\n\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[3, 13]]);\n      }));\n\n      function _multiplexInbound(_x14, _x15) {\n        return _multiplexInbound2.apply(this, arguments);\n      }\n\n      return _multiplexInbound;\n    }()\n  }]);\n\n  return Upgrader;\n}();\n\nmodule.exports = Upgrader;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/upgrader.js"],"names":["debug","require","log","error","Multistream","Connection","PeerId","pipe","errCode","mutableProxy","codes","Upgrader","localPeer","metrics","cryptos","muxers","onConnectionEnd","onConnection","Map","protector","protocols","maConn","setPeer","setTarget","proxyPeer","proxy","idString","parseInt","Math","random","toString","Date","now","toB58String","trackStream","stream","remotePeer","protectedConn","protect","_encryptInbound","encryptedConn","conn","cryptoProtocol","protocol","size","_multiplexInbound","upgradedConn","Muxer","close","updatePlaceholder","_createConnection","direction","remotePeerId","createFromB58String","remoteAddr","getPeerId","err","_encryptOutbound","_multiplexOutbound","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","Error","localAddr","multiplexer","multicodec","encryption","getStreams","streams","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:upgrader')\nlog.error = debug('libp2p:upgrader:error')\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst pipe = require('it-pipe')\nconst errCode = require('err-code')\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef MultiaddrConnection\n * @property {function} sink\n * @property {AsyncIterator} source\n * @property {*} conn\n * @property {Multiaddr} remoteAddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {*} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {Metrics} options.metrics\n   * @param {Map<string, Crypto>} options.cryptos\n   * @param {Map<string, Muxer>} options.muxers\n   * @param {function(Connection)} options.onConnection Called when a connection is upgraded\n   * @param {function(Connection)} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    cryptos,\n    muxers,\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos || new Map()\n    this.muxers = muxers || new Map()\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (parseInt(Math.random() * 1e9)).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    let remotePeerId\n    try {\n      remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId())\n    } catch (err) {\n      log.error('multiaddr did not contain a valid peer id', err)\n    }\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (parseInt(Math.random() * 1e9)).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   * @private\n   * @param {object} options\n   * @param {string} cryptoProtocol The crypto protocol that was negotiated\n   * @param {string} direction One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} maConn The transport layer connection\n   * @param {*} upgradedConn A duplex connection returned from multiplexer and/or crypto selection\n   * @param {Muxer} Muxer The muxer to be used for muxing\n   * @param {PeerId} remotePeer The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    let muxer\n    let newStream\n    // eslint-disable-next-line prefer-const\n    let connection\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          connection.stat.status = 'closed'\n          this.onConnectionEnd(connection)\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED')\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed,\n      close: err => maConn.close(err)\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection The connection the stream belongs to\n   * @param {Stream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerId\n   * @param {*} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"]},"metadata":{},"sourceType":"script"}