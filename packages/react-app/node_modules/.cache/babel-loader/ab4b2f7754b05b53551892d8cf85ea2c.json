{"ast":null,"code":"function _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _asyncIterator(iterable) {\n  var method;\n\n  if (typeof Symbol !== \"undefined\") {\n    if (Symbol.asyncIterator) {\n      method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      method = iterable[Symbol.iterator];\n      if (method != null) return method.call(iterable);\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nimport { Buffer } from \"buffer\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from \"./constants\"; // Returns generator that encrypts payload from the user\n\nexport function encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n          const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n            let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n            yield data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n} // Decrypt received payload to the user\n\nexport function decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const chunk = _value2;\n          const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n            let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const chunk = chunkBuffer.slice(i, end);\n            const {\n              plaintext: decrypted,\n              valid\n            } = yield _awaitAsyncGenerator(handshake.decrypt(chunk, handshake.session));\n\n            if (!valid) {\n              throw new Error(\"Failed to validate decrypted chunk\");\n            }\n\n            yield decrypted;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}","map":{"version":3,"sources":["../src/crypto.ts"],"names":["chunk","chunkBuffer","Buffer","i","end","data","handshake","plaintext","valid"],"mappings":"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","sourcesContent":["import { Buffer } from \"buffer\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG} from \"./constants\";\n\ninterface IReturnEncryptionWrapper {\n  (source: Iterable<Uint8Array>): AsyncIterableIterator<Uint8Array>;\n}\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  }\n}\n\n\n// Decrypt received payload to the user\nexport function decryptStream(handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n        const {plaintext: decrypted, valid} = await handshake.decrypt(chunk, handshake.session);\n        if(!valid) {\n          throw new Error(\"Failed to validate decrypted chunk\");\n        }\n        yield decrypted;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}