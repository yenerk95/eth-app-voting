{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar mkdir = require('./mkdir');\n\nvar stat = require('./stat');\n\nvar log = require('debug')('ipfs:mfs:cp');\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar addLink = require('./utils/add-link');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toSourcesAndDestination = require('./utils/to-sources-and-destination');\n\nvar toTrail = require('./utils/to-trail');\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  signal: undefined\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsCp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _len,\n          args,\n          _key,\n          _yield$toSourcesAndDe,\n          sources,\n          destination,\n          options,\n          missing,\n          destinationIsDirectory,\n          parentFolder,\n          destinationPath,\n          trail,\n          source,\n          destinationName,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = _args[_key];\n              }\n\n              _context.next = 3;\n              return toSourcesAndDestination(context, args, defaultOptions);\n\n            case 3:\n              _yield$toSourcesAndDe = _context.sent;\n              sources = _yield$toSourcesAndDe.sources;\n              destination = _yield$toSourcesAndDe.destination;\n              options = _yield$toSourcesAndDe.options;\n\n              if (sources.length) {\n                _context.next = 9;\n                break;\n              }\n\n              throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n\n            case 9:\n              options.parents = options.p || options.parents; // make sure all sources exist\n\n              missing = sources.find(function (source) {\n                return !source.exists;\n              });\n\n              if (!missing) {\n                _context.next = 13;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(missing.path, \" does not exist\")), 'ERR_INVALID_PARAMS');\n\n            case 13:\n              destinationIsDirectory = isDirectory(destination);\n\n              if (!destination.exists) {\n                _context.next = 20;\n                break;\n              }\n\n              log('Destination exists');\n\n              if (!(sources.length === 1 && !destinationIsDirectory)) {\n                _context.next = 18;\n                break;\n              }\n\n              throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n\n            case 18:\n              _context.next = 49;\n              break;\n\n            case 20:\n              log('Destination does not exist');\n\n              if (!(sources.length > 1)) {\n                _context.next = 31;\n                break;\n              }\n\n              if (options.parents) {\n                _context.next = 24;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 24:\n              _context.next = 26;\n              return mkdir(context)(destination.path, options);\n\n            case 26:\n              _context.next = 28;\n              return toMfsPath(context, destination.path, options);\n\n            case 28:\n              destination = _context.sent;\n              _context.next = 49;\n              break;\n\n            case 31:\n              if (!(destination.parts.length > 1)) {\n                _context.next = 49;\n                break;\n              }\n\n              // copying to a folder, create it if necessary\n              parentFolder = \"/\".concat(destination.parts.slice(0, -1).join('/'));\n              _context.prev = 33;\n              _context.next = 36;\n              return stat(context)(parentFolder, options);\n\n            case 36:\n              _context.next = 49;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](33);\n\n              if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n                _context.next = 42;\n                break;\n              }\n\n              throw _context.t0;\n\n            case 42:\n              if (options.parents) {\n                _context.next = 44;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 44:\n              _context.next = 46;\n              return mkdir(context)(parentFolder, options);\n\n            case 46:\n              _context.next = 48;\n              return toMfsPath(context, destination.path, options);\n\n            case 48:\n              destination = _context.sent;\n\n            case 49:\n              destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n              _context.next = 52;\n              return toTrail(context, destinationPath, options);\n\n            case 52:\n              trail = _context.sent;\n\n              if (!(sources.length === 1)) {\n                _context.next = 58;\n                break;\n              }\n\n              source = sources.pop();\n              destinationName = destinationIsDirectory ? source.name : destination.name;\n              log(\"Only one source, copying to destination \".concat(destinationIsDirectory ? 'directory' : 'file', \" \").concat(destinationName));\n              return _context.abrupt(\"return\", copyToFile(context, source, destinationName, trail, options));\n\n            case 58:\n              log('Multiple sources, wrapping in a directory');\n              return _context.abrupt(\"return\", copyToDirectory(context, sources, destination, trail, options));\n\n            case 60:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[33, 38]]);\n    }));\n\n    function mfsCp() {\n      return _mfsCp.apply(this, arguments);\n    }\n\n    return mfsCp;\n  }());\n};\n\nvar isDirectory = function isDirectory(destination) {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nvar copyToFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, source, destination, destinationTrail, options) {\n    var parent, newRootCid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            parent = destinationTrail.pop();\n            _context2.next = 3;\n            return addSourceToParent(context, source, destination, parent, options);\n\n          case 3:\n            parent = _context2.sent;\n            // update the tree with the new containing directory\n            destinationTrail.push(parent);\n            _context2.next = 7;\n            return updateTree(context, destinationTrail, options);\n\n          case 7:\n            newRootCid = _context2.sent;\n            _context2.next = 10;\n            return updateMfsRoot(context, newRootCid, options);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function copyToFile(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar copyToDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context, sources, destination, destinationTrail, options) {\n    var i, source, newRootCid;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context3.next = 9;\n              break;\n            }\n\n            source = sources[i];\n            _context3.next = 5;\n            return addSourceToParent(context, source, source.name, destination, options);\n\n          case 5:\n            destination = _context3.sent;\n\n          case 6:\n            i++;\n            _context3.next = 1;\n            break;\n\n          case 9:\n            // update the tree with the new containing directory\n            destinationTrail[destinationTrail.length - 1] = destination;\n            _context3.next = 12;\n            return updateTree(context, destinationTrail, options);\n\n          case 12:\n            newRootCid = _context3.sent;\n            _context3.next = 15;\n            return updateMfsRoot(context, newRootCid, options);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function copyToDirectory(_x6, _x7, _x8, _x9, _x10) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar addSourceToParent = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, source, childName, parent, options) {\n    var sourceBlock, _yield$addLink, node, cid;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return context.repo.blocks.get(source.cid);\n\n          case 2:\n            sourceBlock = _context4.sent;\n            _context4.next = 5;\n            return addLink(context, {\n              parentCid: parent.cid,\n              size: sourceBlock.data.length,\n              cid: source.cid,\n              name: childName,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            });\n\n          case 5:\n            _yield$addLink = _context4.sent;\n            node = _yield$addLink.node;\n            cid = _yield$addLink.cid;\n            parent.node = node;\n            parent.cid = cid;\n            parent.size = node.size;\n            return _context4.abrupt(\"return\", parent);\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function addSourceToParent(_x11, _x12, _x13, _x14, _x15) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/cp.js"],"names":["mkdir","require","stat","log","errCode","updateTree","updateMfsRoot","addLink","toMfsPath","toSourcesAndDestination","toTrail","withTimeoutOption","defaultOptions","parents","flush","hashAlg","cidVersion","shardSplitThreshold","signal","undefined","module","exports","context","args","sources","destination","options","length","Error","p","missing","find","source","exists","path","destinationIsDirectory","isDirectory","parts","parentFolder","slice","join","code","destinationPath","mfsPath","mfsDirectory","trail","pop","destinationName","name","copyToFile","copyToDirectory","mfsCp","unixfs","type","includes","destinationTrail","parent","addSourceToParent","push","newRootCid","i","childName","repo","blocks","get","cid","sourceBlock","parentCid","size","data","node"],"mappings":"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","sourcesContent":["'use strict'\n\nconst mkdir = require('./mkdir')\nconst stat = require('./stat')\nconst log = require('debug')('ipfs:mfs:cp')\nconst errCode = require('err-code')\nconst updateTree = require('./utils/update-tree')\nconst updateMfsRoot = require('./utils/update-mfs-root')\nconst addLink = require('./utils/add-link')\nconst toMfsPath = require('./utils/to-mfs-path')\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination')\nconst toTrail = require('./utils/to-trail')\nconst { withTimeoutOption } = require('../../utils')\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  signal: undefined\n}\n\nmodule.exports = (context) => {\n  return withTimeoutOption(async function mfsCp (...args) {\n    let {\n      sources,\n      destination,\n      options\n    } = await toSourcesAndDestination(context, args, defaultOptions)\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS')\n    }\n\n    options.parents = options.p || options.parents\n\n    // make sure all sources exist\n    const missing = sources.find(source => !source.exists)\n\n    if (missing) {\n      throw errCode(new Error(`${missing.path} does not exist`), 'ERR_INVALID_PARAMS')\n    }\n\n    const destinationIsDirectory = isDirectory(destination)\n\n    if (destination.exists) {\n      log('Destination exists')\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS')\n      }\n    } else {\n      log('Destination does not exist')\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n        }\n\n        await mkdir(context)(destination.path, options)\n        destination = await toMfsPath(context, destination.path, options)\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = `/${destination.parts.slice(0, -1).join('/')}`\n\n        try {\n          await stat(context)(parentFolder, options)\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS')\n          }\n\n          await mkdir(context)(parentFolder, options)\n          destination = await toMfsPath(context, destination.path, options)\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory\n    const trail = await toTrail(context, destinationPath, options)\n\n    if (sources.length === 1) {\n      const source = sources.pop()\n      const destinationName = destinationIsDirectory ? source.name : destination.name\n\n      log(`Only one source, copying to destination ${destinationIsDirectory ? 'directory' : 'file'} ${destinationName}`)\n\n      return copyToFile(context, source, destinationName, trail, options)\n    }\n\n    log('Multiple sources, wrapping in a directory')\n    return copyToDirectory(context, sources, destination, trail, options)\n  })\n}\n\nconst isDirectory = (destination) => {\n  return destination.unixfs &&\n    destination.unixfs.type &&\n    destination.unixfs.type.includes('directory')\n}\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop()\n\n  parent = await addSourceToParent(context, source, destination, parent, options)\n\n  // update the tree with the new containing directory\n  destinationTrail.push(parent)\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i]\n\n    destination = await addSourceToParent(context, source, source.name, destination, options)\n  }\n\n  // update the tree with the new containing directory\n  destinationTrail[destinationTrail.length - 1] = destination\n\n  const newRootCid = await updateTree(context, destinationTrail, options)\n\n  // Update the MFS record with the new CID for the root of the tree\n  await updateMfsRoot(context, newRootCid, options)\n}\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid)\n\n  const {\n    node,\n    cid\n  } = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  })\n\n  parent.node = node\n  parent.cid = cid\n  parent.size = node.size\n\n  return parent\n}\n"]},"metadata":{},"sourceType":"script"}