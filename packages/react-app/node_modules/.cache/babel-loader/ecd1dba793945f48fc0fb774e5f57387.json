{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar Key = require('interface-datastore').Key;\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _get = require('just-safe-get');\n\nvar _set = require('just-safe-set');\n\nvar errcode = require('err-code');\n\nvar errors = require('./errors');\n\nvar configKey = new Key('config');\n\nmodule.exports = function (store) {\n  var setQueue = new Queue({\n    concurrency: 1\n  });\n  var configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    getAll: function getAll() {\n      var _arguments = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n                return _context.abrupt(\"return\", configStore.get(undefined, options));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    get: function get(key) {\n      var _arguments2 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var options, encodedValue, config, value;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n\n                if (!key) {\n                  key = undefined;\n                }\n\n                _context2.next = 4;\n                return store.get(configKey);\n\n              case 4:\n                encodedValue = _context2.sent;\n\n                if (!(options.signal && options.signal.aborted)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                config = JSON.parse(encodedValue.toString());\n\n                if (!(key !== undefined && _get(config, key) === undefined)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw new errors.NotFoundError(\"Key \".concat(key, \" does not exist in config\"));\n\n              case 10:\n                value = key !== undefined ? _get(config, key) : config;\n                return _context2.abrupt(\"return\", value);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    set: function set(key, value) {\n      var _arguments3 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var options;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};\n\n                if (!(_arguments3.length === 1)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                value = key;\n                key = undefined;\n                _context3.next = 8;\n                break;\n\n              case 6:\n                if (!(!key || typeof key !== 'string')) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n\n              case 8:\n                if (!(value === undefined || Buffer.isBuffer(value))) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n\n              case 10:\n                return _context3.abrupt(\"return\", setQueue.add(function () {\n                  return _maybeDoSet({\n                    key: key,\n                    value: value\n                  }, options.signal);\n                }));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    replace: function replace(value) {\n      var _arguments4 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var options;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : {};\n\n                if (!(!value || Buffer.isBuffer(value))) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n\n              case 3:\n                return _context4.abrupt(\"return\", setQueue.add(function () {\n                  return _maybeDoSet({\n                    key: undefined,\n                    value: value\n                  }, options.signal);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    exists: function exists() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", store.has(configKey));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    }\n  };\n  return configStore;\n\n  function _maybeDoSet(_x, _x2) {\n    return _maybeDoSet2.apply(this, arguments);\n  }\n\n  function _maybeDoSet2() {\n    _maybeDoSet2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(m, signal) {\n      var key, value, config;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(signal && signal.aborted)) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 2:\n              key = m.key;\n              value = m.value;\n\n              if (!key) {\n                _context6.next = 10;\n                break;\n              }\n\n              _context6.next = 7;\n              return configStore.get();\n\n            case 7:\n              config = _context6.sent;\n\n              _set(config, key, value);\n\n              return _context6.abrupt(\"return\", _saveAll(config));\n\n            case 10:\n              return _context6.abrupt(\"return\", _saveAll(value));\n\n            case 11:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n    return _maybeDoSet2.apply(this, arguments);\n  }\n\n  function _saveAll(config) {\n    var buf = Buffer.from(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo/src/config.js"],"names":["require","Buffer","Key","Queue","default","_get","_set","errcode","errors","configKey","module","exports","store","setQueue","concurrency","configStore","getAll","options","get","undefined","key","encodedValue","signal","aborted","config","JSON","parse","toString","NotFoundError","value","set","arguments","length","Error","isBuffer","add","_maybeDoSet","replace","exists","has","m","_saveAll","buf","from","stringify","put"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Key = require('interface-datastore').Key\nconst { default: Queue } = require('p-queue')\nconst _get = require('just-safe-get')\nconst _set = require('just-safe-set')\nconst errcode = require('err-code')\nconst errors = require('./errors')\n\nconst configKey = new Key('config')\n\nmodule.exports = (store) => {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      return configStore.get(undefined, options)\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async get (key, options = {}) {\n      if (!key) {\n        key = undefined\n      }\n\n      const encodedValue = await store.get(configKey)\n\n      if (options.signal && options.signal.aborted) {\n        return\n      }\n\n      const config = JSON.parse(encodedValue.toString())\n      if (key !== undefined && _get(config, key) === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const value = key !== undefined ? _get(config, key) : config\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async set (key, value, options = {}) { // eslint-disable-line require-await\n      if (arguments.length === 1) {\n        value = key\n        key = undefined\n      } else if (!key || typeof key !== 'string') {\n        throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || Buffer.isBuffer(value)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async replace (value, options = {}) { // eslint-disable-line require-await\n      if (!value || Buffer.isBuffer(value)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    async exists () { // eslint-disable-line require-await\n      return store.has(configKey)\n    }\n  }\n\n  return configStore\n\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.get()\n      _set(config, key, value)\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  function _saveAll (config) {\n    const buf = Buffer.from(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}