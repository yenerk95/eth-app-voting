{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar getIterator = require('get-iterator');\n\nvar AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nvar toAbortableSource = function toAbortableSource(source, signal, options) {\n  return toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableSource = function toMultiAbortableSource(source, signals) {\n  source = getIterator(source);\n  signals = signals.map(function (_ref) {\n    var signal = _ref.signal,\n        options = _ref.options;\n    return {\n      signal: signal,\n      options: options || {}\n    };\n  });\n\n  function abortable() {\n    return _abortable.apply(this, arguments);\n  }\n\n  function _abortable() {\n    _abortable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var nextAbortHandler, abortHandler, _iterator, _step, _signal2, result, _iterator2, _step2, _step2$value, signal, options, abortMessage, abortCode, abort, _iterator3, _step3, _signal, aborter, isKnownAborter, _iterator4, _step4, _signal3;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              abortHandler = function abortHandler() {\n                if (nextAbortHandler) nextAbortHandler();\n              };\n\n              _iterator = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _signal2 = _step.value.signal;\n\n                  _signal2.addEventListener('abort', abortHandler);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n            case 3:\n              if (!true) {\n                _context.next = 52;\n                break;\n              }\n\n              result = void 0;\n              _context.prev = 5;\n              _iterator2 = _createForOfIteratorHelper(signals);\n              _context.prev = 7;\n\n              _iterator2.s();\n\n            case 9:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 16;\n                break;\n              }\n\n              _step2$value = _step2.value, signal = _step2$value.signal, options = _step2$value.options;\n\n              if (!signal.aborted) {\n                _context.next = 14;\n                break;\n              }\n\n              abortMessage = options.abortMessage, abortCode = options.abortCode;\n              throw new AbortError(abortMessage, abortCode);\n\n            case 14:\n              _context.next = 9;\n              break;\n\n            case 16:\n              _context.next = 21;\n              break;\n\n            case 18:\n              _context.prev = 18;\n              _context.t0 = _context[\"catch\"](7);\n\n              _iterator2.e(_context.t0);\n\n            case 21:\n              _context.prev = 21;\n\n              _iterator2.f();\n\n              return _context.finish(21);\n\n            case 24:\n              abort = new Promise(function (resolve, reject) {\n                nextAbortHandler = function nextAbortHandler() {\n                  var _signals$find = signals.find(function (_ref2) {\n                    var signal = _ref2.signal;\n                    return signal.aborted;\n                  }),\n                      options = _signals$find.options;\n\n                  var abortMessage = options.abortMessage,\n                      abortCode = options.abortCode;\n                  reject(new AbortError(abortMessage, abortCode));\n                };\n              }); // Race the iterator and the abort signals\n\n              _context.next = 27;\n              return _awaitAsyncGenerator(Promise.race([abort, source.next()]));\n\n            case 27:\n              result = _context.sent;\n              nextAbortHandler = null;\n              _context.next = 46;\n              break;\n\n            case 31:\n              _context.prev = 31;\n              _context.t1 = _context[\"catch\"](5);\n              _iterator3 = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _signal = _step3.value.signal;\n\n                  _signal.removeEventListener('abort', abortHandler);\n                } // Might not have been aborted by a known signal\n\n              } catch (err) {\n                _iterator3.e(_context.t1);\n              } finally {\n                _iterator3.f();\n              }\n\n              aborter = signals.find(function (_ref3) {\n                var signal = _ref3.signal;\n                return signal.aborted;\n              });\n              isKnownAborter = _context.t1.type === 'aborted' && aborter;\n\n              if (!(isKnownAborter && aborter.options.onAbort)) {\n                _context.next = 40;\n                break;\n              }\n\n              _context.next = 40;\n              return _awaitAsyncGenerator(aborter.options.onAbort(source));\n\n            case 40:\n              if (!(typeof source.return === 'function')) {\n                _context.next = 43;\n                break;\n              }\n\n              _context.next = 43;\n              return _awaitAsyncGenerator(source.return());\n\n            case 43:\n              if (!(isKnownAborter && aborter.options.returnOnAbort)) {\n                _context.next = 45;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 45:\n              throw _context.t1;\n\n            case 46:\n              if (!result.done) {\n                _context.next = 48;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 52);\n\n            case 48:\n              _context.next = 50;\n              return result.value;\n\n            case 50:\n              _context.next = 3;\n              break;\n\n            case 52:\n              _iterator4 = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  _signal3 = _step4.value.signal;\n\n                  _signal3.removeEventListener('abort', abortHandler);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n            case 54:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[5, 31], [7, 18, 21, 24]]);\n    }));\n    return _abortable.apply(this, arguments);\n  }\n\n  return abortable();\n};\n\nvar toAbortableSink = function toAbortableSink(sink, signal, options) {\n  return toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableSink = function toMultiAbortableSink(sink, signals) {\n  return function (source) {\n    return sink(toMultiAbortableSource(source, signals));\n  };\n};\n\nvar toAbortableDuplex = function toAbortableDuplex(duplex, signal, options) {\n  return toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableDuplex = function toMultiAbortableDuplex(duplex, signals) {\n  return {\n    sink: toMultiAbortableSink(duplex.sink, signals),\n    source: toMultiAbortableSource(duplex.source, signals)\n  };\n};\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/abortable-iterator/index.js"],"names":["getIterator","require","AbortError","toAbortableSource","source","signal","options","toMultiAbortableSource","Array","isArray","signals","map","abortable","abortHandler","nextAbortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","find","race","next","removeEventListener","aborter","isKnownAborter","type","onAbort","return","returnOnAbort","done","value","toAbortableSink","sink","toMultiAbortableSink","toAbortableDuplex","duplex","toMultiAbortableDuplex","module","exports","transform"],"mappings":"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","sourcesContent":["const getIterator = require('get-iterator')\nconst AbortError = require('./AbortError')\n\n// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\nconst toAbortableSource = (source, signal, options) => (\n  toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source)\n  signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }))\n\n  async function * abortable () {\n    let nextAbortHandler\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler()\n    }\n\n    for (const { signal } of signals) {\n      signal.addEventListener('abort', abortHandler)\n    }\n\n    while (true) {\n      let result\n      try {\n        for (const { signal, options } of signals) {\n          if (signal.aborted) {\n            const { abortMessage, abortCode } = options\n            throw new AbortError(abortMessage, abortCode)\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const { options } = signals.find(({ signal }) => signal.aborted)\n            const { abortMessage, abortCode } = options\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, source.next()])\n        nextAbortHandler = null\n      } catch (err) {\n        for (const { signal } of signals) {\n          signal.removeEventListener('abort', abortHandler)\n        }\n\n        // Might not have been aborted by a known signal\n        const aborter = signals.find(({ signal }) => signal.aborted)\n        const isKnownAborter = err.type === 'aborted' && aborter\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof source.return === 'function') {\n          await source.return()\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done) break\n      yield result.value\n    }\n\n    for (const { signal } of signals) {\n      signal.removeEventListener('abort', abortHandler)\n    }\n  }\n\n  return abortable()\n}\n\nconst toAbortableSink = (sink, signal, options) => (\n  toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSink = (sink, signals) => source => (\n  sink(toMultiAbortableSource(source, signals))\n)\n\nconst toAbortableDuplex = (duplex, signal, options) => (\n  toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n})\n\nmodule.exports = toAbortableSource\nmodule.exports.AbortError = AbortError\nmodule.exports.source = toAbortableSource\nmodule.exports.sink = toAbortableSink\nmodule.exports.transform = toAbortableSink\nmodule.exports.duplex = toAbortableDuplex\n"]},"metadata":{},"sourceType":"script"}