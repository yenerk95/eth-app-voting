{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar _require2 = require('./hamt-utils'),\n    generatePath = _require2.generatePath,\n    updateHamtDirectory = _require2.updateHamtDirectory;\n\nvar errCode = require('err-code');\n\nvar mc = require('multicodec');\n\nvar mh = require('multihashing-async').multihash;\n\nvar removeLink = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, options) {\n    var meta;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!options.parentCid && !options.parent)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n\n          case 2:\n            if (!(options.parentCid && !CID.isCID(options.parentCid))) {\n              _context.next = 4;\n              break;\n            }\n\n            throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n\n          case 4:\n            if (options.parent) {\n              _context.next = 9;\n              break;\n            }\n\n            log(\"Loading parent node \".concat(options.parentCid));\n            _context.next = 8;\n            return context.ipld.get(options.parentCid);\n\n          case 8:\n            options.parent = _context.sent;\n\n          case 9:\n            if (options.name) {\n              _context.next = 11;\n              break;\n            }\n\n            throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n\n          case 11:\n            meta = UnixFS.unmarshal(options.parent.Data);\n\n            if (!(meta.type === 'hamt-sharded-directory')) {\n              _context.next = 15;\n              break;\n            }\n\n            log(\"Removing \".concat(options.name, \" from sharded directory\"));\n            return _context.abrupt(\"return\", removeFromShardedDirectory(context, options));\n\n          case 15:\n            log(\"Removing link \".concat(options.name, \" regular directory\"));\n            return _context.abrupt(\"return\", removeFromDirectory(context, options));\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar removeFromDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, options) {\n    var hashAlg, cid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            hashAlg = mh.names[options.hashAlg];\n            options.parent.rmLink(options.name);\n            _context2.next = 4;\n            return context.ipld.put(options.parent, mc.DAG_PB, {\n              cidVersion: options.cidVersion,\n              hashAlg: hashAlg\n            });\n\n          case 4:\n            cid = _context2.sent;\n            log(\"Updated regular directory \".concat(cid));\n            return _context2.abrupt(\"return\", {\n              node: options.parent,\n              cid: cid\n            });\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context, options) {\n    var _yield$generatePath, rootBucket, path, _yield$updateShard, node;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return generatePath(context, options.name, options.parent);\n\n          case 2:\n            _yield$generatePath = _context3.sent;\n            rootBucket = _yield$generatePath.rootBucket;\n            path = _yield$generatePath.path;\n            _context3.next = 7;\n            return rootBucket.del(options.name);\n\n          case 7:\n            _context3.next = 9;\n            return updateShard(context, path, {\n              name: options.name,\n              cid: options.cid,\n              size: options.size,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            }, options);\n\n          case 9:\n            _yield$updateShard = _context3.sent;\n            node = _yield$updateShard.node;\n            return _context3.abrupt(\"return\", updateHamtDirectory(context, node.Links, rootBucket, options));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar updateShard = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, positions, child, options) {\n    var _positions$pop, bucket, prefix, node, link, result, newName, size;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _positions$pop = positions.pop(), bucket = _positions$pop.bucket, prefix = _positions$pop.prefix, node = _positions$pop.node;\n            link = node.Links.find(function (link) {\n              return link.Name.substring(0, 2) === prefix;\n            });\n\n            if (link) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(child.name)), 'ERR_NOT_FOUND');\n\n          case 4:\n            if (!(link.Name === \"\".concat(prefix).concat(child.name))) {\n              _context4.next = 10;\n              break;\n            }\n\n            log(\"Removing existing link \".concat(link.Name));\n            node.rmLink(link.Name);\n            _context4.next = 9;\n            return bucket.del(child.name);\n\n          case 9:\n            return _context4.abrupt(\"return\", updateHamtDirectory(context, node.Links, bucket, options));\n\n          case 10:\n            log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(child.name));\n            _context4.next = 13;\n            return updateShard(context, positions, child, options);\n\n          case 13:\n            result = _context4.sent;\n            newName = prefix;\n\n            if (result.node.Links.length === 1) {\n              log(\"Removing subshard for \".concat(prefix)); // convert shard back to normal dir\n\n              result.cid = result.node.Links[0].Hash;\n              result.node = result.node.Links[0];\n              newName = \"\".concat(prefix).concat(result.node.Name.substring(2));\n            }\n\n            log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n            size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n            return _context4.abrupt(\"return\", updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options));\n\n          case 19:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar updateShardParent = function updateShardParent(context, bucket, parent, oldName, newName, size, cid, options) {\n  parent.rmLink(oldName);\n  parent.addLink(new DAGLink(newName, size, cid));\n  return updateHamtDirectory(context, parent.Links, bucket, options);\n};\n\nmodule.exports = removeLink;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/utils/remove-link.js"],"names":["require","DAGNode","DAGLink","CID","log","UnixFS","generatePath","updateHamtDirectory","errCode","mc","mh","multihash","removeLink","context","options","parentCid","parent","Error","isCID","ipld","get","name","meta","unmarshal","Data","type","removeFromShardedDirectory","removeFromDirectory","hashAlg","names","rmLink","put","DAG_PB","cidVersion","cid","node","rootBucket","path","del","updateShard","size","flush","Links","positions","child","pop","bucket","prefix","link","find","Name","substring","result","newName","length","Hash","isDAGNode","Tsize","updateShardParent","oldName","addLink","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb')\nconst CID = require('cids')\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link')\nconst UnixFS = require('ipfs-unixfs')\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils')\nconst errCode = require('err-code')\nconst mc = require('multicodec')\nconst mh = require('multihashing-async').multihash\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT')\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID')\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`)\n\n    options.parent = await context.ipld.get(options.parentCid)\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME')\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`)\n\n    return removeFromShardedDirectory(context, options)\n  }\n\n  log(`Removing link ${options.name} regular directory`)\n\n  return removeFromDirectory(context, options)\n}\n\nconst removeFromDirectory = async (context, options) => {\n  const hashAlg = mh.names[options.hashAlg]\n\n  options.parent.rmLink(options.name)\n  const cid = await context.ipld.put(options.parent, mc.DAG_PB, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  })\n\n  log(`Updated regular directory ${cid}`)\n\n  return {\n    node: options.parent,\n    cid\n  }\n}\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket, path\n  } = await generatePath(context, options.name, options.parent)\n\n  await rootBucket.del(options.name)\n\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options)\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options)\n}\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop()\n\n  const link = node.Links\n    .find(link => link.Name.substring(0, 2) === prefix)\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND')\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`)\n\n    node.rmLink(link.Name)\n\n    await bucket.del(child.name)\n\n    return updateHamtDirectory(context, node.Links, bucket, options)\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`)\n\n  const result = await updateShard(context, positions, child, options)\n\n  let newName = prefix\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`)\n\n    // convert shard back to normal dir\n    result.cid = result.node.Links[0].Hash\n    result.node = result.node.Links[0]\n\n    newName = `${prefix}${result.node.Name.substring(2)}`\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`)\n\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize\n\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options)\n}\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName)\n  parent.addLink(new DAGLink(newName, size, cid))\n\n  return updateHamtDirectory(context, parent.Links, bucket, options)\n}\n\nmodule.exports = removeLink\n"]},"metadata":{},"sourceType":"script"}