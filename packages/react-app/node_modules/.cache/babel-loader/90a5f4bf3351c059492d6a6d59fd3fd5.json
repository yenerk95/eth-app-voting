{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst debug = require('debug');\n\nconst pb = require('it-protocol-buffers');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst {\n  collect,\n  take,\n  consume\n} = require('streaming-iterables');\n\nconst PeerId = require('peer-id');\n\nconst multiaddr = require('multiaddr');\n\nconst {\n  toBuffer\n} = require('it-buffer');\n\nconst Message = require('./message');\n\nconst log = debug('libp2p:identify');\nlog.error = debug('libp2p:identify:error');\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  AGENT_VERSION,\n  PROTOCOL_VERSION\n} = require('./consts');\n\nconst errCode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nclass IdentifyService {\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   * @param {Buffer|String} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr(addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return multiaddr(addr);\n      } catch (_) {\n        return null;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   */\n\n\n  constructor({\n    libp2p,\n    protocols\n  }) {\n    /**\n     * @property {PeerStore}\n     */\n    this.peerStore = libp2p.peerStore;\n    /**\n     * @property {ConnectionManager}\n     */\n\n    this.connectionManager = libp2p.connectionManager;\n    this.connectionManager.on('peer:connect', connection => {\n      const peerId = connection.remotePeer;\n      this.identify(connection, peerId).catch(log.error);\n    });\n    /**\n     * @property {PeerId}\n     */\n\n    this.peerId = libp2p.peerId;\n    /**\n     * @property {AddressManager}\n     */\n\n    this._libp2p = libp2p;\n    this._protocols = protocols;\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n\n\n  push(connections) {\n    const pushes = connections.map(async connection => {\n      try {\n        const {\n          stream\n        } = await connection.newStream(MULTICODEC_IDENTIFY_PUSH);\n        await pipe([{\n          listenAddrs: this._libp2p.multiaddrs.map(ma => ma.buffer),\n          protocols: Array.from(this._protocols.keys())\n        }], pb.encode(Message), stream, consume);\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err);\n      }\n    });\n    return Promise.all(pushes);\n  }\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   * @param {PeerStore} peerStore\n   */\n\n\n  pushToPeerStore(peerStore) {\n    const connections = [];\n    let connection;\n\n    for (const peer of peerStore.peers.values()) {\n      if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection);\n      }\n    }\n\n    this.push(connections);\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n\n\n  async identify(connection) {\n    const {\n      stream\n    } = await connection.newStream(MULTICODEC_IDENTIFY);\n    const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n    }\n\n    let message;\n\n    try {\n      message = Message.decode(data);\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE);\n    }\n\n    let {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr\n    } = message;\n    const id = await PeerId.createFromPubKey(publicKey);\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n    } // Get the observedAddr if there is one\n\n\n    observedAddr = IdentifyService.getCleanMultiaddr(observedAddr); // Update peers data in PeerStore\n\n    this.peerStore.addressBook.set(id, listenAddrs.map(addr => multiaddr(addr)));\n    this.peerStore.protoBook.set(id, protocols); // TODO: Track our observed address so that we can score it\n\n    log('received observed address of %s', observedAddr);\n  }\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {object} options\n   * @param {String} options.protocol\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  handleMessage({\n    connection,\n    stream,\n    protocol\n  }) {\n    switch (protocol) {\n      case MULTICODEC_IDENTIFY:\n        return this._handleIdentify({\n          connection,\n          stream\n        });\n\n      case MULTICODEC_IDENTIFY_PUSH:\n        return this._handlePush({\n          connection,\n          stream\n        });\n\n      default:\n        log.error('cannot handle unknown protocol %s', protocol);\n    }\n  }\n  /**\n   * Sends the `Identify` response to the requesting peer over the\n   * given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n\n\n  async _handleIdentify({\n    connection,\n    stream\n  }) {\n    let publicKey = Buffer.alloc(0);\n\n    if (this.peerId.pubKey) {\n      publicKey = this.peerId.pubKey.bytes;\n    }\n\n    const message = Message.encode({\n      protocolVersion: PROTOCOL_VERSION,\n      agentVersion: AGENT_VERSION,\n      publicKey,\n      listenAddrs: this._libp2p.multiaddrs.map(ma => ma.buffer),\n      observedAddr: connection.remoteAddr.buffer,\n      protocols: Array.from(this._protocols.keys())\n    });\n\n    try {\n      await pipe([message], lp.encode(), stream, consume);\n    } catch (err) {\n      log.error('could not respond to identify request', err);\n    }\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n\n\n  async _handlePush({\n    connection,\n    stream\n  }) {\n    let message;\n\n    try {\n      const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n      message = Message.decode(data);\n    } catch (err) {\n      return log.error('received invalid message', err);\n    } // Update peers data in PeerStore\n\n\n    const id = connection.remotePeer;\n\n    try {\n      this.peerStore.addressBook.set(id, message.listenAddrs.map(addr => multiaddr(addr)));\n    } catch (err) {\n      return log.error('received invalid listen addrs', err);\n    } // Update the protocols\n\n\n    this.peerStore.protoBook.set(id, message.protocols);\n  }\n\n}\n\nmodule.exports.IdentifyService = IdentifyService;\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\n\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nmodule.exports.Message = Message;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/identify/index.js"],"names":["Buffer","require","debug","pb","lp","pipe","collect","take","consume","PeerId","multiaddr","toBuffer","Message","log","error","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","AGENT_VERSION","PROTOCOL_VERSION","errCode","codes","IdentifyService","getCleanMultiaddr","addr","length","_","constructor","libp2p","protocols","peerStore","connectionManager","on","connection","peerId","remotePeer","identify","catch","_libp2p","_protocols","handleMessage","bind","push","connections","pushes","map","stream","newStream","listenAddrs","multiaddrs","ma","buffer","Array","from","keys","encode","err","Promise","all","pushToPeerStore","peer","peers","values","includes","get","id","data","decode","Error","ERR_CONNECTION_ENDED","message","ERR_INVALID_MESSAGE","publicKey","observedAddr","createFromPubKey","toB58String","ERR_INVALID_PEER","addressBook","set","protoBook","protocol","_handleIdentify","_handlePush","alloc","pubKey","bytes","protocolVersion","agentVersion","remoteAddr","module","exports","multicodecs","IDENTIFY","IDENTIFY_PUSH"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst debug = require('debug')\nconst pb = require('it-protocol-buffers')\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\nconst { collect, take, consume } = require('streaming-iterables')\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst { toBuffer } = require('it-buffer')\n\nconst Message = require('./message')\n\nconst log = debug('libp2p:identify')\nlog.error = debug('libp2p:identify:error')\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  AGENT_VERSION,\n  PROTOCOL_VERSION\n} = require('./consts')\n\nconst errCode = require('err-code')\nconst { codes } = require('../errors')\n\nclass IdentifyService {\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   * @param {Buffer|String} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr (addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return multiaddr(addr)\n      } catch (_) {\n        return null\n      }\n    }\n    return null\n  }\n\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   */\n  constructor ({ libp2p, protocols }) {\n    /**\n     * @property {PeerStore}\n     */\n    this.peerStore = libp2p.peerStore\n\n    /**\n     * @property {ConnectionManager}\n     */\n    this.connectionManager = libp2p.connectionManager\n\n    this.connectionManager.on('peer:connect', (connection) => {\n      const peerId = connection.remotePeer\n\n      this.identify(connection, peerId).catch(log.error)\n    })\n\n    /**\n     * @property {PeerId}\n     */\n    this.peerId = libp2p.peerId\n\n    /**\n     * @property {AddressManager}\n     */\n    this._libp2p = libp2p\n\n    this._protocols = protocols\n\n    this.handleMessage = this.handleMessage.bind(this)\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n  push (connections) {\n    const pushes = connections.map(async connection => {\n      try {\n        const { stream } = await connection.newStream(MULTICODEC_IDENTIFY_PUSH)\n\n        await pipe(\n          [{\n            listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.buffer),\n            protocols: Array.from(this._protocols.keys())\n          }],\n          pb.encode(Message),\n          stream,\n          consume\n        )\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      }\n    })\n\n    return Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   * @param {PeerStore} peerStore\n   */\n  pushToPeerStore (peerStore) {\n    const connections = []\n    let connection\n    for (const peer of peerStore.peers.values()) {\n      if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection)\n      }\n    }\n\n    this.push(connections)\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n  async identify (connection) {\n    const { stream } = await connection.newStream(MULTICODEC_IDENTIFY)\n    const [data] = await pipe(\n      [],\n      stream,\n      lp.decode(),\n      take(1),\n      toBuffer,\n      collect\n    )\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n    }\n\n    let message\n    try {\n      message = Message.decode(data)\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE)\n    }\n\n    let {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr\n    } = message\n\n    const id = await PeerId.createFromPubKey(publicKey)\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    observedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    // Update peers data in PeerStore\n    this.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)))\n    this.peerStore.protoBook.set(id, protocols)\n\n    // TODO: Track our observed address so that we can score it\n    log('received observed address of %s', observedAddr)\n  }\n\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {object} options\n   * @param {String} options.protocol\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  handleMessage ({ connection, stream, protocol }) {\n    switch (protocol) {\n      case MULTICODEC_IDENTIFY:\n        return this._handleIdentify({ connection, stream })\n      case MULTICODEC_IDENTIFY_PUSH:\n        return this._handlePush({ connection, stream })\n      default:\n        log.error('cannot handle unknown protocol %s', protocol)\n    }\n  }\n\n  /**\n   * Sends the `Identify` response to the requesting peer over the\n   * given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n  async _handleIdentify ({ connection, stream }) {\n    let publicKey = Buffer.alloc(0)\n    if (this.peerId.pubKey) {\n      publicKey = this.peerId.pubKey.bytes\n    }\n\n    const message = Message.encode({\n      protocolVersion: PROTOCOL_VERSION,\n      agentVersion: AGENT_VERSION,\n      publicKey,\n      listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.buffer),\n      observedAddr: connection.remoteAddr.buffer,\n      protocols: Array.from(this._protocols.keys())\n    })\n\n    try {\n      await pipe(\n        [message],\n        lp.encode(),\n        stream,\n        consume\n      )\n    } catch (err) {\n      log.error('could not respond to identify request', err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n  async _handlePush ({ connection, stream }) {\n    let message\n    try {\n      const [data] = await pipe(\n        [],\n        stream,\n        lp.decode(),\n        take(1),\n        toBuffer,\n        collect\n      )\n      message = Message.decode(data)\n    } catch (err) {\n      return log.error('received invalid message', err)\n    }\n\n    // Update peers data in PeerStore\n    const id = connection.remotePeer\n    try {\n      this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err) {\n      return log.error('received invalid listen addrs', err)\n    }\n\n    // Update the protocols\n    this.peerStore.protoBook.set(id, message.protocols)\n  }\n}\n\nmodule.exports.IdentifyService = IdentifyService\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\nmodule.exports.Message = Message\n"]},"metadata":{},"sourceType":"script"}