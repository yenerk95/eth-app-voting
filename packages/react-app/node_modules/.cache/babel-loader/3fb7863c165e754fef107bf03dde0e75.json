{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar mh = require('multihashes');\n\nvar CID = require('cids');\n\nvar cryptoKeys = require('libp2p-crypto/src/keys');\n\nvar withIs = require('class-is');\n\nvar _require2 = require('./proto'),\n    PeerIdProto = _require2.PeerIdProto;\n\nvar PeerId = /*#__PURE__*/function () {\n  function PeerId(id, privKey, pubKey) {\n    _classCallCheck(this, PeerId);\n\n    if (!Buffer.isBuffer(id)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !privKey.public.bytes.equals(pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  _createClass(PeerId, [{\n    key: \"marshalPubKey\",\n    // Return the protobuf version of the public key, matching go ipfs formatting\n    value: function marshalPubKey() {\n      if (this.pubKey) {\n        return cryptoKeys.marshalPublicKey(this.pubKey);\n      }\n    } // Return the protobuf version of the private key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPrivKey\",\n    value: function marshalPrivKey() {\n      if (this.privKey) {\n        return cryptoKeys.marshalPrivateKey(this.privKey);\n      }\n    } // Return the protobuf version of the peer-id\n\n  }, {\n    key: \"marshal\",\n    value: function marshal(excludePriv) {\n      return PeerIdProto.encode({\n        id: this.toBytes(),\n        pubKey: this.marshalPubKey(),\n        privKey: excludePriv ? null : this.marshalPrivKey()\n      });\n    }\n  }, {\n    key: \"toPrint\",\n    value: function toPrint() {\n      var pid = this.toB58String(); // All sha256 nodes start with Qm\n      // We can skip the Qm to make the peer.ID more useful\n\n      if (pid.startsWith('Qm')) {\n        pid = pid.slice(2);\n      }\n\n      var maxRunes = 6;\n\n      if (pid.length < maxRunes) {\n        maxRunes = pid.length;\n      }\n\n      return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n    } // return the jsonified version of the key, matching the formatting\n    // of go-ipfs for its config file\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.toB58String(),\n        privKey: toB64Opt(this.marshalPrivKey()),\n        pubKey: toB64Opt(this.marshalPubKey())\n      };\n    } // encode/decode functions\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return mh.toHexString(this.id);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.id;\n    }\n  }, {\n    key: \"toB58String\",\n    value: function toB58String() {\n      return this._idB58String;\n    } // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!this._idCIDString) {\n        var cid = new CID(1, 'libp2p-key', this.id, 'base32');\n        this._idCIDString = cid.toBaseEncodedString('base32');\n      }\n\n      return this._idCIDString;\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId.\n     * @param {Buffer|PeerId} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(id) {\n      if (Buffer.isBuffer(id)) {\n        return this.id.equals(id);\n      } else if (id.id) {\n        return this.id.equals(id.id);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId.\n     * @deprecated Use `.equals`\n     * @param {Buffer|PeerId} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(id) {\n      return this.equals(id);\n    }\n    /*\n     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      // TODO: needs better checking\n      return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes));\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(val) {\n      throw new Error('Id is immutable');\n    }\n  }, {\n    key: \"privKey\",\n    get: function get() {\n      return this._privKey;\n    },\n    set: function set(privKey) {\n      this._privKey = privKey;\n    }\n  }, {\n    key: \"pubKey\",\n    get: function get() {\n      if (this._pubKey) {\n        return this._pubKey;\n      }\n\n      if (this._privKey) {\n        return this._privKey.public;\n      }\n\n      try {\n        var decoded = mh.decode(this.id);\n\n        if (decoded.name === 'identity') {\n          this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n        }\n      } catch (_) {// Ignore, there is no valid public key\n      }\n\n      return this._pubKey;\n    },\n    set: function set(pubKey) {\n      this._pubKey = pubKey;\n    }\n  }]);\n\n  return PeerId;\n}();\n\nvar PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nvar computeDigest = function computeDigest(pubKey) {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity');\n  } else {\n    return pubKey.hash();\n  }\n};\n\nvar computePeerId = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privKey, pubKey) {\n    var digest;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return computeDigest(pubKey);\n\n          case 2:\n            digest = _context.sent;\n            return _context.abrupt(\"return\", new PeerIdWithIs(digest, privKey, pubKey));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function computePeerId(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // generation\n\n\nexports.create = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(opts) {\n    var key;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            opts = opts || {};\n            opts.bits = opts.bits || 2048;\n            opts.keyType = opts.keyType || 'RSA';\n            _context2.next = 5;\n            return cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n\n          case 5:\n            key = _context2.sent;\n            return _context2.abrupt(\"return\", computePeerId(key, key.public));\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return exports.createFromCID(str); // B58String is CIDv0\n};\n\nvar validMulticodec = function validMulticodec(cid) {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb';\n};\n\nexports.createFromCID = function (cid) {\n  cid = CID.isCID(cid) ? cid : new CID(cid);\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec);\n  return new PeerIdWithIs(cid.multihash);\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key) {\n    var buf, pubKey;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            buf = key;\n\n            if (typeof buf === 'string') {\n              buf = Buffer.from(key, 'base64');\n            }\n\n            if (Buffer.isBuffer(buf)) {\n              _context3.next = 4;\n              break;\n            }\n\n            throw new Error('Supplied key is neither a base64 string nor a buffer');\n\n          case 4:\n            _context3.next = 6;\n            return cryptoKeys.unmarshalPublicKey(buf);\n\n          case 6:\n            pubKey = _context3.sent;\n            return _context3.abrupt(\"return\", computePeerId(null, pubKey));\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Private key input will be a string\n\n\nexports.createFromPrivKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key) {\n    var buf, privKey;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            buf = key;\n\n            if (typeof buf === 'string') {\n              buf = Buffer.from(key, 'base64');\n            }\n\n            if (Buffer.isBuffer(buf)) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw new Error('Supplied key is neither a base64 string nor a buffer');\n\n          case 4:\n            _context4.next = 6;\n            return cryptoKeys.unmarshalPrivateKey(buf);\n\n          case 6:\n            privKey = _context4.sent;\n            return _context4.abrupt(\"return\", computePeerId(privKey, privKey.public));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.createFromJSON = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(obj) {\n    var id, rawPrivKey, rawPubKey, pub, privKey, privDigest, pubDigest;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            id = mh.fromB58String(obj.id);\n            rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n            rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n            _context5.t0 = rawPubKey;\n\n            if (!_context5.t0) {\n              _context5.next = 8;\n              break;\n            }\n\n            _context5.next = 7;\n            return cryptoKeys.unmarshalPublicKey(rawPubKey);\n\n          case 7:\n            _context5.t0 = _context5.sent;\n\n          case 8:\n            pub = _context5.t0;\n\n            if (rawPrivKey) {\n              _context5.next = 11;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", new PeerIdWithIs(id, null, pub));\n\n          case 11:\n            _context5.next = 13;\n            return cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n\n          case 13:\n            privKey = _context5.sent;\n            _context5.next = 16;\n            return computeDigest(privKey.public);\n\n          case 16:\n            privDigest = _context5.sent;\n\n            if (!pub) {\n              _context5.next = 21;\n              break;\n            }\n\n            _context5.next = 20;\n            return computeDigest(pub);\n\n          case 20:\n            pubDigest = _context5.sent;\n\n          case 21:\n            if (!(pub && !privDigest.equals(pubDigest))) {\n              _context5.next = 23;\n              break;\n            }\n\n            throw new Error('Public and private key do not match');\n\n          case 23:\n            if (!(id && !privDigest.equals(id))) {\n              _context5.next = 25;\n              break;\n            }\n\n            throw new Error('Id and private key do not match');\n\n          case 25:\n            return _context5.abrupt(\"return\", new PeerIdWithIs(id, privKey, pub));\n\n          case 26:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function (_x6) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(buf) {\n    var _PeerIdProto$decode, id, privKey, pubKey, pubDigest, privDigest;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (typeof buf === 'string') {\n              buf = Buffer.from(buf, 'hex');\n            }\n\n            _PeerIdProto$decode = PeerIdProto.decode(buf), id = _PeerIdProto$decode.id, privKey = _PeerIdProto$decode.privKey, pubKey = _PeerIdProto$decode.pubKey;\n\n            if (!privKey) {\n              _context6.next = 8;\n              break;\n            }\n\n            _context6.next = 5;\n            return cryptoKeys.unmarshalPrivateKey(privKey);\n\n          case 5:\n            _context6.t0 = _context6.sent;\n            _context6.next = 9;\n            break;\n\n          case 8:\n            _context6.t0 = false;\n\n          case 9:\n            privKey = _context6.t0;\n\n            if (!pubKey) {\n              _context6.next = 16;\n              break;\n            }\n\n            _context6.next = 13;\n            return cryptoKeys.unmarshalPublicKey(pubKey);\n\n          case 13:\n            _context6.t1 = _context6.sent;\n            _context6.next = 17;\n            break;\n\n          case 16:\n            _context6.t1 = false;\n\n          case 17:\n            pubKey = _context6.t1;\n\n            if (!privKey) {\n              _context6.next = 22;\n              break;\n            }\n\n            _context6.next = 21;\n            return computeDigest(privKey.public);\n\n          case 21:\n            privDigest = _context6.sent;\n\n          case 22:\n            if (!pubKey) {\n              _context6.next = 26;\n              break;\n            }\n\n            _context6.next = 25;\n            return computeDigest(pubKey);\n\n          case 25:\n            pubDigest = _context6.sent;\n\n          case 26:\n            if (!privKey) {\n              _context6.next = 31;\n              break;\n            }\n\n            if (!pubKey) {\n              _context6.next = 30;\n              break;\n            }\n\n            if (privDigest.equals(pubDigest)) {\n              _context6.next = 30;\n              break;\n            }\n\n            throw new Error('Public and private key do not match');\n\n          case 30:\n            return _context6.abrupt(\"return\", new PeerIdWithIs(privDigest, privKey, privKey.public));\n\n          case 31:\n            if (!pubKey) {\n              _context6.next = 33;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", new PeerIdWithIs(pubDigest, null, pubKey));\n\n          case 33:\n            if (!id) {\n              _context6.next = 35;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", new PeerIdWithIs(id));\n\n          case 35:\n            throw new Error('Protobuf did not contain any usable key material');\n\n          case 36:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function (_x7) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/peer-id/src/index.js"],"names":["require","Buffer","mh","CID","cryptoKeys","withIs","PeerIdProto","PeerId","id","privKey","pubKey","isBuffer","Error","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","marshalPublicKey","marshalPrivateKey","excludePriv","encode","toBytes","marshalPubKey","marshalPrivKey","pid","startsWith","slice","maxRunes","length","substr","toB64Opt","toHexString","_idCIDString","cid","toBaseEncodedString","Boolean","val","decoded","decode","name","unmarshalPublicKey","digest","_","PeerIdWithIs","className","symbolName","exports","module","computeDigest","hash","computePeerId","create","opts","bits","keyType","generateKeyPair","key","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","createFromCID","validMulticodec","codec","isCID","multihash","createFromPubKey","from","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","fromB58String","rawPrivKey","rawPubKey","pub","privDigest","pubDigest","createFromProtobuf","isPeerId","peerId","toString"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst { Buffer } = require('buffer')\nconst mh = require('multihashes')\nconst CID = require('cids')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst withIs = require('class-is')\nconst { PeerIdProto } = require('./proto')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    if (!Buffer.isBuffer(id)) {\n      throw new Error('invalid id provided')\n    }\n\n    if (privKey && pubKey && !privKey.public.bytes.equals(pubKey.bytes)) {\n      throw new Error('inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    try {\n      const decoded = mh.decode(this.id)\n\n      if (decoded.name === 'identity') {\n        this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      }\n    } catch (_) {\n      // Ignore, there is no valid public key\n    }\n\n    return this._pubKey\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // Return the protobuf version of the peer-id\n  marshal (excludePriv) {\n    return PeerIdProto.encode({\n      id: this.toBytes(),\n      pubKey: this.marshalPubKey(),\n      privKey: excludePriv ? null : this.marshalPrivKey()\n    })\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toString () {\n    if (!this._idCIDString) {\n      const cid = new CID(1, 'libp2p-key', this.id, 'base32')\n      this._idCIDString = cid.toBaseEncodedString('base32')\n    }\n    return this._idCIDString\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @param {Buffer|PeerId} id\n   * @returns {boolean}\n   */\n  equals (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId.\n   * @deprecated Use `.equals`\n   * @param {Buffer|PeerId} id\n   * @returns {boolean}\n   */\n  isEqual (id) {\n    return this.equals(id)\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid () {\n    // TODO: needs better checking\n    return Boolean(this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes))\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n})\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey) => {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity')\n  } else {\n    return pubKey.hash()\n  }\n}\n\nconst computePeerId = async (privKey, pubKey) => {\n  const digest = await computeDigest(pubKey)\n  return new PeerIdWithIs(digest, privKey, pubKey)\n}\n\n// generation\nexports.create = async (opts) => {\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits)\n  return computePeerId(key, key.public)\n}\n\nexports.createFromHexString = (str) => {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = (buf) => {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = (str) => {\n  return exports.createFromCID(str) // B58String is CIDv0\n}\n\nconst validMulticodec = (cid) => {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb'\n}\n\nexports.createFromCID = (cid) => {\n  cid = CID.isCID(cid) ? cid : new CID(cid)\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec)\n  return new PeerIdWithIs(cid.multihash)\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = Buffer.from(key, 'base64')\n  }\n\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Supplied key is neither a base64 string nor a buffer')\n  }\n\n  const pubKey = await cryptoKeys.unmarshalPublicKey(buf)\n  return computePeerId(null, pubKey)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = async (key) => {\n  let buf = key\n\n  if (typeof buf === 'string') {\n    buf = Buffer.from(key, 'base64')\n  }\n\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error('Supplied key is neither a base64 string nor a buffer')\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(buf)\n  return computePeerId(privKey, privKey.public)\n}\n\nexports.createFromJSON = async (obj) => {\n  const id = mh.fromB58String(obj.id)\n  const rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n  const rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n  const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey)\n\n  if (!rawPrivKey) {\n    return new PeerIdWithIs(id, null, pub)\n  }\n\n  const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey)\n  const privDigest = await computeDigest(privKey.public)\n\n  let pubDigest\n\n  if (pub) {\n    pubDigest = await computeDigest(pub)\n  }\n\n  if (pub && !privDigest.equals(pubDigest)) {\n    throw new Error('Public and private key do not match')\n  }\n\n  if (id && !privDigest.equals(id)) {\n    throw new Error('Id and private key do not match')\n  }\n\n  return new PeerIdWithIs(id, privKey, pub)\n}\n\nexports.createFromProtobuf = async (buf) => {\n  if (typeof buf === 'string') {\n    buf = Buffer.from(buf, 'hex')\n  }\n\n  let { id, privKey, pubKey } = PeerIdProto.decode(buf)\n\n  privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false\n  pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false\n\n  let pubDigest\n  let privDigest\n\n  if (privKey) {\n    privDigest = await computeDigest(privKey.public)\n  }\n\n  if (pubKey) {\n    pubDigest = await computeDigest(pubKey)\n  }\n\n  if (privKey) {\n    if (pubKey) {\n      if (!privDigest.equals(pubDigest)) {\n        throw new Error('Public and private key do not match')\n      }\n    }\n    return new PeerIdWithIs(privDigest, privKey, privKey.public)\n  }\n\n  // TODO: val id and pubDigest\n\n  if (pubKey) {\n    return new PeerIdWithIs(pubDigest, null, pubKey)\n  }\n\n  if (id) {\n    return new PeerIdWithIs(id)\n  }\n\n  throw new Error('Protobuf did not contain any usable key material')\n}\n\nexports.isPeerId = (peerId) => {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}