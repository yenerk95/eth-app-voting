{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst BufferList = require('bl/BufferList');\n\nconst varintDecode = require('./varint-decode'); // Maximum length of the length section of the message\n\n\nconst MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4;\nconst Empty = Buffer.alloc(0);\nconst ReadModes = {\n  LENGTH: 'readLength',\n  DATA: 'readData'\n};\nconst ReadHandlers = {\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk);\n    let dataLength;\n\n    try {\n      dataLength = options.lengthDecoder(buffer);\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, {\n          message: 'message length too long',\n          code: 'ERR_MSG_LENGTH_TOO_LONG'\n        });\n      }\n\n      if (err instanceof RangeError) {\n        return {\n          mode: ReadModes.LENGTH,\n          buffer\n        };\n      }\n\n      throw err;\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), {\n        code: 'ERR_MSG_DATA_TOO_LONG'\n      });\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes);\n    buffer = new BufferList();\n    if (options.onLength) options.onLength(dataLength);\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty);\n      return {\n        mode: ReadModes.LENGTH,\n        chunk,\n        buffer,\n        data: Empty\n      };\n    }\n\n    return {\n      mode: ReadModes.DATA,\n      chunk,\n      buffer,\n      state: {\n        dataLength\n      }\n    };\n  },\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk);\n\n    if (buffer.length < state.dataLength) {\n      return {\n        mode: ReadModes.DATA,\n        buffer,\n        state\n      };\n    }\n\n    const {\n      dataLength\n    } = state;\n    const data = buffer.shallowSlice(0, dataLength);\n    chunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : null;\n    buffer = new BufferList();\n    if (options.onData) options.onData(data);\n    return {\n      mode: ReadModes.LENGTH,\n      chunk,\n      buffer,\n      data\n    };\n  }\n};\n\nfunction decode(options) {\n  options = options || {};\n  options.lengthDecoder = options.lengthDecoder || varintDecode;\n  options.maxLengthLength = options.maxLengthLength || MAX_LENGTH_LENGTH;\n  options.maxDataLength = options.maxDataLength || MAX_DATA_LENGTH;\n  return source => async function* () {\n    let buffer = new BufferList();\n    let mode = ReadModes.LENGTH; // current parsing mode\n\n    let state; // accumulated state for the current mode\n\n    for await (let chunk of source) {\n      // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n      while (chunk) {\n        const result = ReadHandlers[mode](chunk, buffer, state, options);\n        ({\n          mode,\n          chunk,\n          buffer,\n          state\n        } = result);\n        if (result.data) yield result.data;\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), {\n        code: 'ERR_UNEXPECTED_EOF'\n      });\n    }\n  }();\n}\n\ndecode.fromReader = (reader, options) => {\n  options = options || {};\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: async () => {\n      try {\n        return await reader.next(byteLength);\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  }; // Once the length has been parsed, read chunk for that length\n\n  options.onLength = l => {\n    byteLength = l;\n  };\n\n  return decode(options)(varByteSource);\n};\n\nmodule.exports = decode;\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/it-length-prefixed/src/decode.js"],"names":["Buffer","require","BufferList","varintDecode","MAX_LENGTH_LENGTH","MAX_DATA_LENGTH","Empty","alloc","ReadModes","LENGTH","DATA","ReadHandlers","chunk","buffer","state","options","append","dataLength","lengthDecoder","err","length","maxLengthLength","Object","assign","message","code","RangeError","mode","maxDataLength","Error","shallowSlice","bytes","onLength","onData","data","decode","source","result","fromReader","reader","byteLength","varByteSource","Symbol","asyncIterator","next","done","value","l","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst BufferList = require('bl/BufferList')\nconst varintDecode = require('./varint-decode')\n\n// Maximum length of the length section of the message\nconst MAX_LENGTH_LENGTH = 8 // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4\n\nconst Empty = Buffer.alloc(0)\nconst ReadModes = { LENGTH: 'readLength', DATA: 'readData' }\n\nconst ReadHandlers = {\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk)\n\n    let dataLength\n    try {\n      dataLength = options.lengthDecoder(buffer)\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })\n      }\n      if (err instanceof RangeError) {\n        return { mode: ReadModes.LENGTH, buffer }\n      }\n      throw err\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes)\n    buffer = new BufferList()\n\n    if (options.onLength) options.onLength(dataLength)\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty)\n      return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty }\n    }\n\n    return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength } }\n  },\n\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk)\n\n    if (buffer.length < state.dataLength) {\n      return { mode: ReadModes.DATA, buffer, state }\n    }\n\n    const { dataLength } = state\n    const data = buffer.shallowSlice(0, dataLength)\n\n    chunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : null\n    buffer = new BufferList()\n\n    if (options.onData) options.onData(data)\n    return { mode: ReadModes.LENGTH, chunk, buffer, data }\n  }\n}\n\nfunction decode (options) {\n  options = options || {}\n  options.lengthDecoder = options.lengthDecoder || varintDecode\n  options.maxLengthLength = options.maxLengthLength || MAX_LENGTH_LENGTH\n  options.maxDataLength = options.maxDataLength || MAX_DATA_LENGTH\n\n  return source => (async function * () {\n    let buffer = new BufferList()\n    let mode = ReadModes.LENGTH // current parsing mode\n    let state // accumulated state for the current mode\n\n    for await (let chunk of source) {\n      // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n      while (chunk) {\n        const result = ReadHandlers[mode](chunk, buffer, state, options)\n        ;({ mode, chunk, buffer, state } = result)\n        if (result.data) yield result.data\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })\n    }\n  })()\n}\n\ndecode.fromReader = (reader, options) => {\n  options = options || {}\n\n  let byteLength = 1 // Read single byte chunks until the length is known\n  const varByteSource = {\n    [Symbol.asyncIterator] () { return this },\n    next: async () => {\n      try {\n        return await reader.next(byteLength)\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }\n\n  // Once the length has been parsed, read chunk for that length\n  options.onLength = l => { byteLength = l }\n  return decode(options)(varByteSource)\n}\n\nmodule.exports = decode\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH\n"]},"metadata":{},"sourceType":"script"}