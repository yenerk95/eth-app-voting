{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst Key = require('interface-datastore').Key;\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst _get = require('just-safe-get');\n\nconst _set = require('just-safe-set');\n\nconst errcode = require('err-code');\n\nconst errors = require('./errors');\n\nconst configKey = new Key('config');\n\nmodule.exports = store => {\n  const setQueue = new Queue({\n    concurrency: 1\n  });\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async getAll(options = {}) {\n      // eslint-disable-line require-await\n      return configStore.get(undefined, options);\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async get(key, options = {}) {\n      if (!key) {\n        key = undefined;\n      }\n\n      const encodedValue = await store.get(configKey);\n\n      if (options.signal && options.signal.aborted) {\n        return;\n      }\n\n      const config = JSON.parse(encodedValue.toString());\n\n      if (key !== undefined && _get(config, key) === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`);\n      }\n\n      const value = key !== undefined ? _get(config, key) : config;\n      return value;\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async set(key, value, options = {}) {\n      // eslint-disable-line require-await\n      if (arguments.length === 1) {\n        value = key;\n        key = undefined;\n      } else if (!key || typeof key !== 'string') {\n        throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n      }\n\n      if (value === undefined || Buffer.isBuffer(value)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async replace(value, options = {}) {\n      // eslint-disable-line require-await\n      if (!value || Buffer.isBuffer(value)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal));\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    async exists() {\n      // eslint-disable-line require-await\n      return store.has(configKey);\n    }\n\n  };\n  return configStore;\n\n  async function _maybeDoSet(m, signal) {\n    if (signal && signal.aborted) {\n      return;\n    }\n\n    const key = m.key;\n    const value = m.value;\n\n    if (key) {\n      const config = await configStore.get();\n\n      _set(config, key, value);\n\n      return _saveAll(config);\n    }\n\n    return _saveAll(value);\n  }\n\n  function _saveAll(config) {\n    const buf = Buffer.from(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-repo/src/config.js"],"names":["Buffer","require","Key","default","Queue","_get","_set","errcode","errors","configKey","module","exports","store","setQueue","concurrency","configStore","getAll","options","get","undefined","key","encodedValue","signal","aborted","config","JSON","parse","toString","NotFoundError","value","set","arguments","length","Error","isBuffer","add","_maybeDoSet","replace","exists","has","m","_saveAll","buf","from","stringify","put"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Key = require('interface-datastore').Key\nconst { default: Queue } = require('p-queue')\nconst _get = require('just-safe-get')\nconst _set = require('just-safe-set')\nconst errcode = require('err-code')\nconst errors = require('./errors')\n\nconst configKey = new Key('config')\n\nmodule.exports = (store) => {\n  const setQueue = new Queue({ concurrency: 1 })\n\n  const configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async getAll (options = {}) { // eslint-disable-line require-await\n      return configStore.get(undefined, options)\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    async get (key, options = {}) {\n      if (!key) {\n        key = undefined\n      }\n\n      const encodedValue = await store.get(configKey)\n\n      if (options.signal && options.signal.aborted) {\n        return\n      }\n\n      const config = JSON.parse(encodedValue.toString())\n      if (key !== undefined && _get(config, key) === undefined) {\n        throw new errors.NotFoundError(`Key ${key} does not exist in config`)\n      }\n\n      const value = key !== undefined ? _get(config, key) : config\n      return value\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async set (key, value, options = {}) { // eslint-disable-line require-await\n      if (arguments.length === 1) {\n        value = key\n        key = undefined\n      } else if (!key || typeof key !== 'string') {\n        throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY')\n      }\n\n      if (value === undefined || Buffer.isBuffer(value)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: key,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    async replace (value, options = {}) { // eslint-disable-line require-await\n      if (!value || Buffer.isBuffer(value)) {\n        throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE')\n      }\n\n      return setQueue.add(() => _maybeDoSet({\n        key: undefined,\n        value: value\n      }, options.signal))\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    async exists () { // eslint-disable-line require-await\n      return store.has(configKey)\n    }\n  }\n\n  return configStore\n\n  async function _maybeDoSet (m, signal) {\n    if (signal && signal.aborted) {\n      return\n    }\n\n    const key = m.key\n    const value = m.value\n    if (key) {\n      const config = await configStore.get()\n      _set(config, key, value)\n      return _saveAll(config)\n    }\n    return _saveAll(value)\n  }\n\n  function _saveAll (config) {\n    const buf = Buffer.from(JSON.stringify(config, null, 2))\n    return store.put(configKey, buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}