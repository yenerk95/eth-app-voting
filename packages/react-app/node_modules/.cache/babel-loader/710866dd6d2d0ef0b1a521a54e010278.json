{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar PeerDistanceList = require('../peer-list/peer-distance-list');\n\nvar EventEmitter = require('events');\n\nvar Path = require('./path');\n\nvar WorkerQueue = require('./workerQueue');\n\nvar utils = require('../utils');\n/**\n * Manages a single run of the query.\n */\n\n\nvar Run = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Run, _EventEmitter);\n\n  var _super = _createSuper(Run);\n\n  /**\n   * Creates a Run.\n   *\n   * @param {Query} query\n   */\n  function Run(query) {\n    var _this;\n\n    _classCallCheck(this, Run);\n\n    _this = _super.call(this);\n    _this.query = query;\n    _this.running = false;\n    _this.workers = []; // The peers that have been queried (including error responses)\n\n    _this.peersSeen = new Set(); // The errors received when querying peers\n\n    _this.errors = []; // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n\n    _this.peersQueried = null;\n    return _this;\n  }\n  /**\n   * Stop all the workers\n   */\n\n\n  _createClass(Run, [{\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) {\n        return;\n      }\n\n      this.running = false;\n\n      var _iterator = _createForOfIteratorHelper(this.workers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var worker = _step.value;\n          worker.stop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Execute the run with the given initial set of peers.\n     *\n     * @param {Array<PeerId>} peers\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peers) {\n        var paths, numPaths, i, res, _i, _paths, path;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                paths = []; // array of states per disjoint path\n                // Create disjoint paths\n\n                numPaths = Math.min(this.query.dht.disjointPaths, peers.length);\n\n                for (i = 0; i < numPaths; i++) {\n                  paths.push(new Path(this, this.query.makePath(i, numPaths)));\n                } // Assign peers to paths round-robin style\n\n\n                peers.forEach(function (peer, i) {\n                  paths[i % numPaths].addInitialPeer(peer);\n                }); // Execute the query along each disjoint path\n\n                _context.next = 6;\n                return this.executePaths(paths);\n\n              case 6:\n                res = {\n                  // The closest K peers we were able to query successfully\n                  finalSet: new Set(this.peersQueried.peers),\n                  paths: []\n                }; // Collect the results from each completed path\n\n                for (_i = 0, _paths = paths; _i < _paths.length; _i++) {\n                  path = _paths[_i];\n\n                  if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n                    path.res.success = true;\n                    res.paths.push(path.res);\n                  }\n                }\n\n                return _context.abrupt(\"return\", res);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute(_x) {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n    /**\n     * Execute all paths through the DHT.\n     *\n     * @param {Array<Path>} paths\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"executePaths\",\n    value: function () {\n      var _executePaths = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.running = true;\n                this.emit('start');\n                _context2.prev = 2;\n                _context2.next = 5;\n                return Promise.all(paths.map(function (path) {\n                  return path.execute();\n                }));\n\n              case 5:\n                _context2.prev = 5;\n                // Ensure all workers are stopped\n                this.stop(); // Completed the Run\n\n                this.emit('complete');\n                return _context2.finish(5);\n\n              case 9:\n                if (!(this.errors.length === this.peersSeen.size)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw this.errors[0];\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2,, 5, 9]]);\n      }));\n\n      function executePaths(_x2) {\n        return _executePaths.apply(this, arguments);\n      }\n\n      return executePaths;\n    }()\n    /**\n     * Initialize the list of queried peers, then start a worker queue for the\n     * given path.\n     *\n     * @param {Path} path\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"workerQueue\",\n    value: function () {\n      var _workerQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.init();\n\n              case 2:\n                _context3.next = 4;\n                return this.startWorker(path);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function workerQueue(_x3) {\n        return _workerQueue.apply(this, arguments);\n      }\n\n      return workerQueue;\n    }()\n    /**\n     * Create and start a worker queue for a particular path.\n     *\n     * @param {Path} path\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"startWorker\",\n    value: function () {\n      var _startWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path) {\n        var worker;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                worker = new WorkerQueue(this.query.dht, this, path, this.query._log);\n                this.workers.push(worker);\n                _context4.next = 4;\n                return worker.execute();\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function startWorker(_x4) {\n        return _startWorker.apply(this, arguments);\n      }\n\n      return startWorker;\n    }()\n    /**\n     * Initialize the list of closest peers we've queried - this is shared by all\n     * paths in the run.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.peersQueried) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 2:\n                if (!this.peersQueriedPromise) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 5;\n                return this.peersQueriedPromise;\n\n              case 5:\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                // This promise is temporarily stored so that others may await its completion\n                this.peersQueriedPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                  var dhtKey;\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.next = 2;\n                          return utils.convertBuffer(_this2.query.key);\n\n                        case 2:\n                          dhtKey = _context5.sent;\n                          _this2.peersQueried = new PeerDistanceList(dhtKey, _this2.query.dht.kBucketSize);\n\n                        case 4:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))(); // After PeerDistanceList is initialized, clean up\n\n                _context6.next = 9;\n                return this.peersQueriedPromise;\n\n              case 9:\n                delete this.peersQueriedPromise;\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n     * are all further from the key than the peers we've already queried, then we should\n     * stop querying on that `worker`.\n     *\n     * @param {WorkerQueue} worker\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"continueQuerying\",\n    value: function () {\n      var _continueQuerying = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(worker) {\n        var running, someCloser;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.peersQueried.length < this.peersQueried.capacity)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", true);\n\n              case 2:\n                // Get all the peers that are currently being queried.\n                // Note that this function gets called right after a peer has been popped\n                // off the head of the closest peers queue so it will include that peer.\n                running = worker.queue.workersList().map(function (i) {\n                  return i.data;\n                }); // Check if any of the peers that are currently being queried are closer\n                // to the key than the peers we've already queried\n\n                _context7.next = 5;\n                return this.peersQueried.anyCloser(running);\n\n              case 5:\n                someCloser = _context7.sent;\n\n                if (!someCloser) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", true);\n\n              case 8:\n                return _context7.abrupt(\"return\", false);\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function continueQuerying(_x5) {\n        return _continueQuerying.apply(this, arguments);\n      }\n\n      return continueQuerying;\n    }()\n  }]);\n\n  return Run;\n}(EventEmitter);\n\nmodule.exports = Run;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/query/run.js"],"names":["PeerDistanceList","require","EventEmitter","Path","WorkerQueue","utils","Run","query","running","workers","peersSeen","Set","errors","peersQueried","worker","stop","peers","paths","numPaths","Math","min","dht","disjointPaths","length","i","push","makePath","forEach","peer","addInitialPeer","executePaths","res","finalSet","path","pathComplete","queryComplete","success","emit","Promise","all","map","execute","size","init","startWorker","_log","peersQueriedPromise","convertBuffer","key","dhtKey","kBucketSize","capacity","queue","workersList","data","anyCloser","someCloser","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst PeerDistanceList = require('../peer-list/peer-distance-list')\nconst EventEmitter = require('events')\n\nconst Path = require('./path')\nconst WorkerQueue = require('./workerQueue')\nconst utils = require('../utils')\n\n/**\n * Manages a single run of the query.\n */\nclass Run extends EventEmitter {\n  /**\n   * Creates a Run.\n   *\n   * @param {Query} query\n   */\n  constructor (query) {\n    super()\n\n    this.query = query\n\n    this.running = false\n    this.workers = []\n\n    // The peers that have been queried (including error responses)\n    this.peersSeen = new Set()\n    // The errors received when querying peers\n    this.errors = []\n    // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n    this.peersQueried = null\n  }\n\n  /**\n   * Stop all the workers\n   */\n  stop () {\n    if (!this.running) {\n      return\n    }\n\n    this.running = false\n    for (const worker of this.workers) {\n      worker.stop()\n    }\n  }\n\n  /**\n   * Execute the run with the given initial set of peers.\n   *\n   * @param {Array<PeerId>} peers\n   * @returns {Promise}\n   */\n\n  async execute (peers) {\n    const paths = [] // array of states per disjoint path\n\n    // Create disjoint paths\n    const numPaths = Math.min(this.query.dht.disjointPaths, peers.length)\n    for (let i = 0; i < numPaths; i++) {\n      paths.push(new Path(this, this.query.makePath(i, numPaths)))\n    }\n\n    // Assign peers to paths round-robin style\n    peers.forEach((peer, i) => {\n      paths[i % numPaths].addInitialPeer(peer)\n    })\n\n    // Execute the query along each disjoint path\n    await this.executePaths(paths)\n\n    const res = {\n      // The closest K peers we were able to query successfully\n      finalSet: new Set(this.peersQueried.peers),\n      paths: []\n    }\n\n    // Collect the results from each completed path\n    for (const path of paths) {\n      if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n        path.res.success = true\n        res.paths.push(path.res)\n      }\n    }\n\n    return res\n  }\n\n  /**\n   * Execute all paths through the DHT.\n   *\n   * @param {Array<Path>} paths\n   * @returns {Promise<void>}\n   */\n  async executePaths (paths) {\n    this.running = true\n\n    this.emit('start')\n    try {\n      await Promise.all(paths.map(path => path.execute()))\n    } finally {\n      // Ensure all workers are stopped\n      this.stop()\n      // Completed the Run\n      this.emit('complete')\n    }\n\n    // If all queries errored out, something is seriously wrong, so callback\n    // with an error\n    if (this.errors.length === this.peersSeen.size) {\n      throw this.errors[0]\n    }\n  }\n\n  /**\n   * Initialize the list of queried peers, then start a worker queue for the\n   * given path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n  async workerQueue (path) {\n    await this.init()\n    await this.startWorker(path)\n  }\n\n  /**\n   * Create and start a worker queue for a particular path.\n   *\n   * @param {Path} path\n   * @returns {Promise<void>}\n   */\n  async startWorker (path) {\n    const worker = new WorkerQueue(this.query.dht, this, path, this.query._log)\n    this.workers.push(worker)\n    await worker.execute()\n  }\n\n  /**\n   * Initialize the list of closest peers we've queried - this is shared by all\n   * paths in the run.\n   *\n   * @returns {Promise<void>}\n   */\n  async init () {\n    if (this.peersQueried) {\n      return\n    }\n\n    // We only want to initialize the PeerDistanceList once for the run\n    if (this.peersQueriedPromise) {\n      await this.peersQueriedPromise\n      return\n    }\n\n    // This promise is temporarily stored so that others may await its completion\n    this.peersQueriedPromise = (async () => {\n      const dhtKey = await utils.convertBuffer(this.query.key)\n      this.peersQueried = new PeerDistanceList(dhtKey, this.query.dht.kBucketSize)\n    })()\n\n    // After PeerDistanceList is initialized, clean up\n    await this.peersQueriedPromise\n    delete this.peersQueriedPromise\n  }\n\n  /**\n   * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n   * are all further from the key than the peers we've already queried, then we should\n   * stop querying on that `worker`.\n   *\n   * @param {WorkerQueue} worker\n   * @returns {Promise<Boolean>}\n   */\n  async continueQuerying (worker) {\n    // If we haven't queried K peers yet, keep going\n    if (this.peersQueried.length < this.peersQueried.capacity) {\n      return true\n    }\n\n    // Get all the peers that are currently being queried.\n    // Note that this function gets called right after a peer has been popped\n    // off the head of the closest peers queue so it will include that peer.\n    const running = worker.queue.workersList().map(i => i.data)\n\n    // Check if any of the peers that are currently being queried are closer\n    // to the key than the peers we've already queried\n    const someCloser = await this.peersQueried.anyCloser(running)\n\n    // Some are closer, the worker should keep going\n    if (someCloser) {\n      return true\n    }\n\n    // None are closer, the worker can stop\n    return false\n  }\n}\n\nmodule.exports = Run\n"]},"metadata":{},"sourceType":"script"}