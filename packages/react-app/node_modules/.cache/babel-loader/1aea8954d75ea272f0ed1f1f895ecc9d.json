{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:webrtc-star:listener');\nlog.error = debug('libp2p:webrtc-star:listener:error');\n\nconst multiaddr = require('multiaddr');\n\nconst io = require('socket.io-client');\n\nconst SimplePeer = require('libp2p-webrtc-peer');\n\nconst pDefer = require('p-defer');\n\nconst toConnection = require('./socket-to-conn');\n\nconst {\n  cleanUrlSIO\n} = require('./utils');\n\nconst {\n  CODE_P2P\n} = require('./constants');\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n\nmodule.exports = ({\n  handler,\n  upgrader\n}, WebRTCStar, options = {}) => {\n  const listener = new EventEmitter();\n  let listeningAddr;\n  listener.__connections = [];\n\n  listener.listen = ma => {\n    const defer = pDefer();\n    listeningAddr = ma;\n\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      WebRTCStar._signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`);\n    } else {\n      WebRTCStar._signallingAddr = ma;\n    }\n\n    const sioUrl = cleanUrlSIO(ma);\n    log('Dialing to Signalling Server on: ' + sioUrl);\n    listener.io = io.connect(sioUrl, sioOptions);\n\n    const incommingDial = offer => {\n      if (offer.answer || offer.err) {\n        return;\n      }\n\n      const spOptions = {\n        trickle: false,\n        ...options\n      }; // Use custom WebRTC implementation\n\n      if (WebRTCStar.wrtc) {\n        spOptions.wrtc = WebRTCStar.wrtc;\n      }\n\n      const channel = new SimplePeer(spOptions);\n\n      const onError = err => {\n        log.error('incoming connectioned errored', err);\n      };\n\n      channel.on('error', onError);\n      channel.once('close', (...args) => {\n        channel.removeListener('error', onError);\n      });\n      channel.once('signal', signal => {\n        offer.signal = signal;\n        offer.answer = true;\n        listener.io.emit('ss-handshake', offer);\n      });\n      channel.signal(offer.signal);\n      channel.once('connect', async () => {\n        const maConn = toConnection(channel);\n        log('new inbound connection %s', maConn.remoteAddr);\n        let conn;\n\n        try {\n          conn = await upgrader.upgradeInbound(maConn);\n        } catch (err) {\n          log.error('inbound connection failed to upgrade', err);\n          return maConn.close();\n        }\n\n        if (!conn.remoteAddr) {\n          try {\n            conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`);\n          } catch (err) {\n            log.error('could not determine remote address', err);\n          }\n        }\n\n        log('inbound connection %s upgraded', maConn.remoteAddr);\n        trackConn(listener, maConn);\n        listener.emit('connection', conn);\n        handler(conn);\n      });\n    };\n\n    listener.io.once('connect_error', err => defer.reject(err));\n    listener.io.once('error', err => {\n      listener.emit('error', err);\n      listener.emit('close');\n    });\n    listener.io.on('ws-handshake', incommingDial);\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered);\n    listener.io.on('connect', () => {\n      listener.io.emit('ss-join', WebRTCStar._signallingAddr.toString());\n    });\n    listener.io.once('connect', () => {\n      listener.emit('listening');\n      defer.resolve();\n    });\n    return defer.promise;\n  };\n\n  listener.close = async () => {\n    listener.io && listener.io.emit('ss-leave');\n    await Promise.all(listener.__connections.map(maConn => maConn.close()));\n    listener.emit('close');\n  };\n\n  listener.getAddrs = () => {\n    return [listeningAddr];\n  };\n\n  WebRTCStar.listenersRefs[multiaddr.toString()] = listener;\n  return listener;\n};\n\nfunction trackConn(listener, maConn) {\n  listener.__connections.push(maConn);\n\n  const untrackConn = () => {\n    listener.__connections = listener.__connections.filter(c => c !== maConn);\n  };\n\n  maConn.conn.once('close', untrackConn);\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-webrtc-star/src/listener.js"],"names":["EventEmitter","require","debug","log","error","multiaddr","io","SimplePeer","pDefer","toConnection","cleanUrlSIO","CODE_P2P","sioOptions","transports","module","exports","handler","upgrader","WebRTCStar","options","listener","listeningAddr","__connections","listen","ma","defer","protoCodes","includes","localPeer","_signallingAddr","encapsulate","toB58String","sioUrl","connect","incommingDial","offer","answer","err","spOptions","trickle","wrtc","channel","onError","on","once","args","removeListener","signal","emit","maConn","remoteAddr","conn","upgradeInbound","close","decapsulateCode","remotePeer","trackConn","reject","_peerDiscovered","toString","resolve","promise","Promise","all","map","getAddrs","listenersRefs","push","untrackConn","filter","c"],"mappings":"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","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst debug = require('debug')\nconst log = debug('libp2p:webrtc-star:listener')\nlog.error = debug('libp2p:webrtc-star:listener:error')\n\nconst multiaddr = require('multiaddr')\n\nconst io = require('socket.io-client')\nconst SimplePeer = require('libp2p-webrtc-peer')\nconst pDefer = require('p-defer')\n\nconst toConnection = require('./socket-to-conn')\nconst { cleanUrlSIO } = require('./utils')\nconst { CODE_P2P } = require('./constants')\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n}\n\nmodule.exports = ({ handler, upgrader }, WebRTCStar, options = {}) => {\n  const listener = new EventEmitter()\n  let listeningAddr\n\n  listener.__connections = []\n  listener.listen = (ma) => {\n    const defer = pDefer()\n\n    listeningAddr = ma\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      WebRTCStar._signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`)\n    } else {\n      WebRTCStar._signallingAddr = ma\n    }\n\n    const sioUrl = cleanUrlSIO(ma)\n\n    log('Dialing to Signalling Server on: ' + sioUrl)\n    listener.io = io.connect(sioUrl, sioOptions)\n\n    const incommingDial = (offer) => {\n      if (offer.answer || offer.err) {\n        return\n      }\n\n      const spOptions = {\n        trickle: false,\n        ...options\n      }\n\n      // Use custom WebRTC implementation\n      if (WebRTCStar.wrtc) { spOptions.wrtc = WebRTCStar.wrtc }\n\n      const channel = new SimplePeer(spOptions)\n\n      const onError = (err) => {\n        log.error('incoming connectioned errored', err)\n      }\n\n      channel.on('error', onError)\n      channel.once('close', (...args) => {\n        channel.removeListener('error', onError)\n      })\n\n      channel.once('signal', (signal) => {\n        offer.signal = signal\n        offer.answer = true\n        listener.io.emit('ss-handshake', offer)\n      })\n\n      channel.signal(offer.signal)\n\n      channel.once('connect', async () => {\n        const maConn = toConnection(channel)\n        log('new inbound connection %s', maConn.remoteAddr)\n\n        let conn\n        try {\n          conn = await upgrader.upgradeInbound(maConn)\n        } catch (err) {\n          log.error('inbound connection failed to upgrade', err)\n          return maConn.close()\n        }\n\n        if (!conn.remoteAddr) {\n          try {\n            conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`)\n          } catch (err) {\n            log.error('could not determine remote address', err)\n          }\n        }\n\n        log('inbound connection %s upgraded', maConn.remoteAddr)\n\n        trackConn(listener, maConn)\n\n        listener.emit('connection', conn)\n        handler(conn)\n      })\n    }\n\n    listener.io.once('connect_error', (err) => defer.reject(err))\n    listener.io.once('error', (err) => {\n      listener.emit('error', err)\n      listener.emit('close')\n    })\n\n    listener.io.on('ws-handshake', incommingDial)\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered)\n\n    listener.io.on('connect', () => {\n      listener.io.emit('ss-join', WebRTCStar._signallingAddr.toString())\n    })\n\n    listener.io.once('connect', () => {\n      listener.emit('listening')\n      defer.resolve()\n    })\n\n    return defer.promise\n  }\n\n  listener.close = async () => {\n    listener.io && listener.io.emit('ss-leave')\n    await Promise.all(listener.__connections.map(maConn => maConn.close()))\n    listener.emit('close')\n  }\n\n  listener.getAddrs = () => {\n    return [listeningAddr]\n  }\n\n  WebRTCStar.listenersRefs[multiaddr.toString()] = listener\n  return listener\n}\n\nfunction trackConn (listener, maConn) {\n  listener.__connections.push(maConn)\n\n  const untrackConn = () => {\n    listener.__connections = listener.__connections.filter(c => c !== maConn)\n  }\n\n  maConn.conn.once('close', untrackConn)\n}\n"]},"metadata":{},"sourceType":"script"}