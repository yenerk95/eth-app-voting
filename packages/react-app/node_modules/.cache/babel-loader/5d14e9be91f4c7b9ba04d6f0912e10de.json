{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar EventEmitter = require('events');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:webrtc-star:listener');\nlog.error = debug('libp2p:webrtc-star:listener:error');\n\nvar multiaddr = require('multiaddr');\n\nvar io = require('socket.io-client');\n\nvar SimplePeer = require('libp2p-webrtc-peer');\n\nvar pDefer = require('p-defer');\n\nvar toConnection = require('./socket-to-conn');\n\nvar _require = require('./utils'),\n    cleanUrlSIO = _require.cleanUrlSIO;\n\nvar _require2 = require('./constants'),\n    CODE_P2P = _require2.CODE_P2P;\n\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n\nmodule.exports = function (_ref, WebRTCStar) {\n  var handler = _ref.handler,\n      upgrader = _ref.upgrader;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var listener = new EventEmitter();\n  var listeningAddr;\n  listener.__connections = [];\n\n  listener.listen = function (ma) {\n    var defer = pDefer();\n    listeningAddr = ma;\n\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      WebRTCStar._signallingAddr = ma.encapsulate(\"/p2p/\".concat(upgrader.localPeer.toB58String()));\n    } else {\n      WebRTCStar._signallingAddr = ma;\n    }\n\n    var sioUrl = cleanUrlSIO(ma);\n    log('Dialing to Signalling Server on: ' + sioUrl);\n    listener.io = io.connect(sioUrl, sioOptions);\n\n    var incommingDial = function incommingDial(offer) {\n      if (offer.answer || offer.err) {\n        return;\n      }\n\n      var spOptions = _objectSpread({\n        trickle: false\n      }, options); // Use custom WebRTC implementation\n\n\n      if (WebRTCStar.wrtc) {\n        spOptions.wrtc = WebRTCStar.wrtc;\n      }\n\n      var channel = new SimplePeer(spOptions);\n\n      var onError = function onError(err) {\n        log.error('incoming connectioned errored', err);\n      };\n\n      channel.on('error', onError);\n      channel.once('close', function () {\n        channel.removeListener('error', onError);\n      });\n      channel.once('signal', function (signal) {\n        offer.signal = signal;\n        offer.answer = true;\n        listener.io.emit('ss-handshake', offer);\n      });\n      channel.signal(offer.signal);\n      channel.once('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var maConn, conn;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                maConn = toConnection(channel);\n                log('new inbound connection %s', maConn.remoteAddr);\n                _context.prev = 2;\n                _context.next = 5;\n                return upgrader.upgradeInbound(maConn);\n\n              case 5:\n                conn = _context.sent;\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](2);\n                log.error('inbound connection failed to upgrade', _context.t0);\n                return _context.abrupt(\"return\", maConn.close());\n\n              case 12:\n                if (!conn.remoteAddr) {\n                  try {\n                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(\"/p2p/\".concat(conn.remotePeer.toB58String()));\n                  } catch (err) {\n                    log.error('could not determine remote address', err);\n                  }\n                }\n\n                log('inbound connection %s upgraded', maConn.remoteAddr);\n                trackConn(listener, maConn);\n                listener.emit('connection', conn);\n                handler(conn);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 8]]);\n      })));\n    };\n\n    listener.io.once('connect_error', function (err) {\n      return defer.reject(err);\n    });\n    listener.io.once('error', function (err) {\n      listener.emit('error', err);\n      listener.emit('close');\n    });\n    listener.io.on('ws-handshake', incommingDial);\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered);\n    listener.io.on('connect', function () {\n      listener.io.emit('ss-join', WebRTCStar._signallingAddr.toString());\n    });\n    listener.io.once('connect', function () {\n      listener.emit('listening');\n      defer.resolve();\n    });\n    return defer.promise;\n  };\n\n  listener.close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            listener.io && listener.io.emit('ss-leave');\n            _context2.next = 3;\n            return Promise.all(listener.__connections.map(function (maConn) {\n              return maConn.close();\n            }));\n\n          case 3:\n            listener.emit('close');\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  listener.getAddrs = function () {\n    return [listeningAddr];\n  };\n\n  WebRTCStar.listenersRefs[multiaddr.toString()] = listener;\n  return listener;\n};\n\nfunction trackConn(listener, maConn) {\n  listener.__connections.push(maConn);\n\n  var untrackConn = function untrackConn() {\n    listener.__connections = listener.__connections.filter(function (c) {\n      return c !== maConn;\n    });\n  };\n\n  maConn.conn.once('close', untrackConn);\n}","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-webrtc-star/src/listener.js"],"names":["EventEmitter","require","debug","log","error","multiaddr","io","SimplePeer","pDefer","toConnection","cleanUrlSIO","CODE_P2P","sioOptions","transports","module","exports","WebRTCStar","handler","upgrader","options","listener","listeningAddr","__connections","listen","ma","defer","protoCodes","includes","localPeer","_signallingAddr","encapsulate","toB58String","sioUrl","connect","incommingDial","offer","answer","err","spOptions","trickle","wrtc","channel","onError","on","once","removeListener","signal","emit","maConn","remoteAddr","upgradeInbound","conn","close","decapsulateCode","remotePeer","trackConn","reject","_peerDiscovered","toString","resolve","promise","Promise","all","map","getAddrs","listenersRefs","push","untrackConn","filter","c"],"mappings":"AAAA;;;;;;;;AAEA,IAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAA5B;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,IAAME,GAAG,GAAGD,KAAK,CAAC,6BAAD,CAAjB;AACAC,GAAG,CAACC,KAAJ,GAAYF,KAAK,CAAC,mCAAD,CAAjB;;AAEA,IAAMG,SAAS,GAAGJ,OAAO,CAAC,WAAD,CAAzB;;AAEA,IAAMK,EAAE,GAAGL,OAAO,CAAC,kBAAD,CAAlB;;AACA,IAAMM,UAAU,GAAGN,OAAO,CAAC,oBAAD,CAA1B;;AACA,IAAMO,MAAM,GAAGP,OAAO,CAAC,SAAD,CAAtB;;AAEA,IAAMQ,YAAY,GAAGR,OAAO,CAAC,kBAAD,CAA5B;;eACwBA,OAAO,CAAC,SAAD,C;IAAvBS,W,YAAAA,W;;gBACaT,OAAO,CAAC,aAAD,C;IAApBU,Q,aAAAA,Q;;AAER,IAAMC,UAAU,GAAG;AACjBC,EAAAA,UAAU,EAAE,CAAC,WAAD,CADK;AAEjB,0BAAwB;AAFP,CAAnB;;AAKAC,MAAM,CAACC,OAAP,GAAiB,gBAAwBC,UAAxB,EAAqD;AAAA,MAAlDC,OAAkD,QAAlDA,OAAkD;AAAA,MAAzCC,QAAyC,QAAzCA,QAAyC;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;AACpE,MAAMC,QAAQ,GAAG,IAAIpB,YAAJ,EAAjB;AACA,MAAIqB,aAAJ;AAEAD,EAAAA,QAAQ,CAACE,aAAT,GAAyB,EAAzB;;AACAF,EAAAA,QAAQ,CAACG,MAAT,GAAkB,UAACC,EAAD,EAAQ;AACxB,QAAMC,KAAK,GAAGjB,MAAM,EAApB;AAEAa,IAAAA,aAAa,GAAGG,EAAhB;;AACA,QAAI,CAACA,EAAE,CAACE,UAAH,GAAgBC,QAAhB,CAAyBhB,QAAzB,CAAD,IAAuCO,QAAQ,CAACU,SAApD,EAA+D;AAC7DZ,MAAAA,UAAU,CAACa,eAAX,GAA6BL,EAAE,CAACM,WAAH,gBAAuBZ,QAAQ,CAACU,SAAT,CAAmBG,WAAnB,EAAvB,EAA7B;AACD,KAFD,MAEO;AACLf,MAAAA,UAAU,CAACa,eAAX,GAA6BL,EAA7B;AACD;;AAED,QAAMQ,MAAM,GAAGtB,WAAW,CAACc,EAAD,CAA1B;AAEArB,IAAAA,GAAG,CAAC,sCAAsC6B,MAAvC,CAAH;AACAZ,IAAAA,QAAQ,CAACd,EAAT,GAAcA,EAAE,CAAC2B,OAAH,CAAWD,MAAX,EAAmBpB,UAAnB,CAAd;;AAEA,QAAMsB,aAAa,GAAG,SAAhBA,aAAgB,CAACC,KAAD,EAAW;AAC/B,UAAIA,KAAK,CAACC,MAAN,IAAgBD,KAAK,CAACE,GAA1B,EAA+B;AAC7B;AACD;;AAED,UAAMC,SAAS;AACbC,QAAAA,OAAO,EAAE;AADI,SAEVpB,OAFU,CAAf,CAL+B,CAU/B;;;AACA,UAAIH,UAAU,CAACwB,IAAf,EAAqB;AAAEF,QAAAA,SAAS,CAACE,IAAV,GAAiBxB,UAAU,CAACwB,IAA5B;AAAkC;;AAEzD,UAAMC,OAAO,GAAG,IAAIlC,UAAJ,CAAe+B,SAAf,CAAhB;;AAEA,UAAMI,OAAO,GAAG,SAAVA,OAAU,CAACL,GAAD,EAAS;AACvBlC,QAAAA,GAAG,CAACC,KAAJ,CAAU,+BAAV,EAA2CiC,GAA3C;AACD,OAFD;;AAIAI,MAAAA,OAAO,CAACE,EAAR,CAAW,OAAX,EAAoBD,OAApB;AACAD,MAAAA,OAAO,CAACG,IAAR,CAAa,OAAb,EAAsB,YAAa;AACjCH,QAAAA,OAAO,CAACI,cAAR,CAAuB,OAAvB,EAAgCH,OAAhC;AACD,OAFD;AAIAD,MAAAA,OAAO,CAACG,IAAR,CAAa,QAAb,EAAuB,UAACE,MAAD,EAAY;AACjCX,QAAAA,KAAK,CAACW,MAAN,GAAeA,MAAf;AACAX,QAAAA,KAAK,CAACC,MAAN,GAAe,IAAf;AACAhB,QAAAA,QAAQ,CAACd,EAAT,CAAYyC,IAAZ,CAAiB,cAAjB,EAAiCZ,KAAjC;AACD,OAJD;AAMAM,MAAAA,OAAO,CAACK,MAAR,CAAeX,KAAK,CAACW,MAArB;AAEAL,MAAAA,OAAO,CAACG,IAAR,CAAa,SAAb,wEAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAChBI,gBAAAA,MADgB,GACPvC,YAAY,CAACgC,OAAD,CADL;AAEtBtC,gBAAAA,GAAG,CAAC,2BAAD,EAA8B6C,MAAM,CAACC,UAArC,CAAH;AAFsB;AAAA;AAAA,uBAMP/B,QAAQ,CAACgC,cAAT,CAAwBF,MAAxB,CANO;;AAAA;AAMpBG,gBAAAA,IANoB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAQpBhD,gBAAAA,GAAG,CAACC,KAAJ,CAAU,sCAAV;AARoB,iDASb4C,MAAM,CAACI,KAAP,EATa;;AAAA;AAYtB,oBAAI,CAACD,IAAI,CAACF,UAAV,EAAsB;AACpB,sBAAI;AACFE,oBAAAA,IAAI,CAACF,UAAL,GAAkBzB,EAAE,CAAC6B,eAAH,CAAmB1C,QAAnB,EAA6BmB,WAA7B,gBAAiDqB,IAAI,CAACG,UAAL,CAAgBvB,WAAhB,EAAjD,EAAlB;AACD,mBAFD,CAEE,OAAOM,GAAP,EAAY;AACZlC,oBAAAA,GAAG,CAACC,KAAJ,CAAU,oCAAV,EAAgDiC,GAAhD;AACD;AACF;;AAEDlC,gBAAAA,GAAG,CAAC,gCAAD,EAAmC6C,MAAM,CAACC,UAA1C,CAAH;AAEAM,gBAAAA,SAAS,CAACnC,QAAD,EAAW4B,MAAX,CAAT;AAEA5B,gBAAAA,QAAQ,CAAC2B,IAAT,CAAc,YAAd,EAA4BI,IAA5B;AACAlC,gBAAAA,OAAO,CAACkC,IAAD,CAAP;;AAzBsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAxB;AA2BD,KA3DD;;AA6DA/B,IAAAA,QAAQ,CAACd,EAAT,CAAYsC,IAAZ,CAAiB,eAAjB,EAAkC,UAACP,GAAD;AAAA,aAASZ,KAAK,CAAC+B,MAAN,CAAanB,GAAb,CAAT;AAAA,KAAlC;AACAjB,IAAAA,QAAQ,CAACd,EAAT,CAAYsC,IAAZ,CAAiB,OAAjB,EAA0B,UAACP,GAAD,EAAS;AACjCjB,MAAAA,QAAQ,CAAC2B,IAAT,CAAc,OAAd,EAAuBV,GAAvB;AACAjB,MAAAA,QAAQ,CAAC2B,IAAT,CAAc,OAAd;AACD,KAHD;AAKA3B,IAAAA,QAAQ,CAACd,EAAT,CAAYqC,EAAZ,CAAe,cAAf,EAA+BT,aAA/B;AACAd,IAAAA,QAAQ,CAACd,EAAT,CAAYqC,EAAZ,CAAe,SAAf,EAA0B3B,UAAU,CAACyC,eAArC;AAEArC,IAAAA,QAAQ,CAACd,EAAT,CAAYqC,EAAZ,CAAe,SAAf,EAA0B,YAAM;AAC9BvB,MAAAA,QAAQ,CAACd,EAAT,CAAYyC,IAAZ,CAAiB,SAAjB,EAA4B/B,UAAU,CAACa,eAAX,CAA2B6B,QAA3B,EAA5B;AACD,KAFD;AAIAtC,IAAAA,QAAQ,CAACd,EAAT,CAAYsC,IAAZ,CAAiB,SAAjB,EAA4B,YAAM;AAChCxB,MAAAA,QAAQ,CAAC2B,IAAT,CAAc,WAAd;AACAtB,MAAAA,KAAK,CAACkC,OAAN;AACD,KAHD;AAKA,WAAOlC,KAAK,CAACmC,OAAb;AACD,GA/FD;;AAiGAxC,EAAAA,QAAQ,CAACgC,KAAT,yEAAiB;AAAA;AAAA;AAAA;AAAA;AACfhC,YAAAA,QAAQ,CAACd,EAAT,IAAec,QAAQ,CAACd,EAAT,CAAYyC,IAAZ,CAAiB,UAAjB,CAAf;AADe;AAAA,mBAETc,OAAO,CAACC,GAAR,CAAY1C,QAAQ,CAACE,aAAT,CAAuByC,GAAvB,CAA2B,UAAAf,MAAM;AAAA,qBAAIA,MAAM,CAACI,KAAP,EAAJ;AAAA,aAAjC,CAAZ,CAFS;;AAAA;AAGfhC,YAAAA,QAAQ,CAAC2B,IAAT,CAAc,OAAd;;AAHe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAjB;;AAMA3B,EAAAA,QAAQ,CAAC4C,QAAT,GAAoB,YAAM;AACxB,WAAO,CAAC3C,aAAD,CAAP;AACD,GAFD;;AAIAL,EAAAA,UAAU,CAACiD,aAAX,CAAyB5D,SAAS,CAACqD,QAAV,EAAzB,IAAiDtC,QAAjD;AACA,SAAOA,QAAP;AACD,CAlHD;;AAoHA,SAASmC,SAAT,CAAoBnC,QAApB,EAA8B4B,MAA9B,EAAsC;AACpC5B,EAAAA,QAAQ,CAACE,aAAT,CAAuB4C,IAAvB,CAA4BlB,MAA5B;;AAEA,MAAMmB,WAAW,GAAG,SAAdA,WAAc,GAAM;AACxB/C,IAAAA,QAAQ,CAACE,aAAT,GAAyBF,QAAQ,CAACE,aAAT,CAAuB8C,MAAvB,CAA8B,UAAAC,CAAC;AAAA,aAAIA,CAAC,KAAKrB,MAAV;AAAA,KAA/B,CAAzB;AACD,GAFD;;AAIAA,EAAAA,MAAM,CAACG,IAAP,CAAYP,IAAZ,CAAiB,OAAjB,EAA0BuB,WAA1B;AACD","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events')\nconst debug = require('debug')\nconst log = debug('libp2p:webrtc-star:listener')\nlog.error = debug('libp2p:webrtc-star:listener:error')\n\nconst multiaddr = require('multiaddr')\n\nconst io = require('socket.io-client')\nconst SimplePeer = require('libp2p-webrtc-peer')\nconst pDefer = require('p-defer')\n\nconst toConnection = require('./socket-to-conn')\nconst { cleanUrlSIO } = require('./utils')\nconst { CODE_P2P } = require('./constants')\n\nconst sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n}\n\nmodule.exports = ({ handler, upgrader }, WebRTCStar, options = {}) => {\n  const listener = new EventEmitter()\n  let listeningAddr\n\n  listener.__connections = []\n  listener.listen = (ma) => {\n    const defer = pDefer()\n\n    listeningAddr = ma\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      WebRTCStar._signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`)\n    } else {\n      WebRTCStar._signallingAddr = ma\n    }\n\n    const sioUrl = cleanUrlSIO(ma)\n\n    log('Dialing to Signalling Server on: ' + sioUrl)\n    listener.io = io.connect(sioUrl, sioOptions)\n\n    const incommingDial = (offer) => {\n      if (offer.answer || offer.err) {\n        return\n      }\n\n      const spOptions = {\n        trickle: false,\n        ...options\n      }\n\n      // Use custom WebRTC implementation\n      if (WebRTCStar.wrtc) { spOptions.wrtc = WebRTCStar.wrtc }\n\n      const channel = new SimplePeer(spOptions)\n\n      const onError = (err) => {\n        log.error('incoming connectioned errored', err)\n      }\n\n      channel.on('error', onError)\n      channel.once('close', (...args) => {\n        channel.removeListener('error', onError)\n      })\n\n      channel.once('signal', (signal) => {\n        offer.signal = signal\n        offer.answer = true\n        listener.io.emit('ss-handshake', offer)\n      })\n\n      channel.signal(offer.signal)\n\n      channel.once('connect', async () => {\n        const maConn = toConnection(channel)\n        log('new inbound connection %s', maConn.remoteAddr)\n\n        let conn\n        try {\n          conn = await upgrader.upgradeInbound(maConn)\n        } catch (err) {\n          log.error('inbound connection failed to upgrade', err)\n          return maConn.close()\n        }\n\n        if (!conn.remoteAddr) {\n          try {\n            conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`)\n          } catch (err) {\n            log.error('could not determine remote address', err)\n          }\n        }\n\n        log('inbound connection %s upgraded', maConn.remoteAddr)\n\n        trackConn(listener, maConn)\n\n        listener.emit('connection', conn)\n        handler(conn)\n      })\n    }\n\n    listener.io.once('connect_error', (err) => defer.reject(err))\n    listener.io.once('error', (err) => {\n      listener.emit('error', err)\n      listener.emit('close')\n    })\n\n    listener.io.on('ws-handshake', incommingDial)\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered)\n\n    listener.io.on('connect', () => {\n      listener.io.emit('ss-join', WebRTCStar._signallingAddr.toString())\n    })\n\n    listener.io.once('connect', () => {\n      listener.emit('listening')\n      defer.resolve()\n    })\n\n    return defer.promise\n  }\n\n  listener.close = async () => {\n    listener.io && listener.io.emit('ss-leave')\n    await Promise.all(listener.__connections.map(maConn => maConn.close()))\n    listener.emit('close')\n  }\n\n  listener.getAddrs = () => {\n    return [listeningAddr]\n  }\n\n  WebRTCStar.listenersRefs[multiaddr.toString()] = listener\n  return listener\n}\n\nfunction trackConn (listener, maConn) {\n  listener.__connections.push(maConn)\n\n  const untrackConn = () => {\n    listener.__connections = listener.__connections.filter(c => c !== maConn)\n  }\n\n  maConn.conn.once('close', untrackConn)\n}\n"]},"metadata":{},"sourceType":"script"}