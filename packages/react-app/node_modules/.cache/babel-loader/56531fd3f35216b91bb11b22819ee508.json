{"ast":null,"code":"'use strict';\n\nconst loadMfsRoot = require('./with-mfs-root');\n\nconst toPathComponents = require('./to-path-components');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst IPFS_PREFIX = 'ipfs';\n\nconst toMfsPath = async (context, path, options) => {\n  const outputArray = Array.isArray(path);\n  let paths = Array.isArray(path) ? path : [path];\n  const root = await loadMfsRoot(context, options);\n  paths = paths.map(path => {\n    path = (path || '').trim();\n    path = path.replace(/(\\/\\/+)/g, '/');\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1);\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(path.length - 1) === '/') {\n      path = path.substring(0, path.length - 1);\n    }\n\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory;\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`;\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  });\n  await Promise.all(paths.map(async path => {\n    const cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n\n    try {\n      const res = await exporter(cidPath, context.ipld);\n      path.cid = res.cid;\n      path.mfsPath = `/ipfs/${res.path}`;\n      path.unixfs = res.unixfs;\n      path.content = res.content;\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    path.exists = Boolean(path.cid);\n  }));\n\n  if (outputArray) {\n    return paths;\n  }\n\n  return paths[0];\n};\n\nmodule.exports = toMfsPath;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/utils/to-mfs-path.js"],"names":["loadMfsRoot","require","toPathComponents","exporter","errCode","IPFS_PREFIX","toMfsPath","context","path","options","outputArray","Array","isArray","paths","root","map","trim","replace","endsWith","length","substring","Error","pathComponents","mfsDirectory","join","slice","type","depth","mfsPath","parts","name","Promise","all","cidPath","res","ipld","cid","unixfs","content","err","code","exists","Boolean","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst loadMfsRoot = require('./with-mfs-root')\nconst toPathComponents = require('./to-path-components')\nconst exporter = require('ipfs-unixfs-exporter')\nconst errCode = require('err-code')\n\nconst IPFS_PREFIX = 'ipfs'\n\nconst toMfsPath = async (context, path, options) => {\n  const outputArray = Array.isArray(path)\n  let paths = Array.isArray(path) ? path : [path]\n  const root = await loadMfsRoot(context, options)\n\n  paths = paths.map(path => {\n    path = (path || '').trim()\n    path = path.replace(/(\\/\\/+)/g, '/')\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1)\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH')\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH')\n    }\n\n    if (path.substring(path.length - 1) === '/') {\n      path = path.substring(0, path.length - 1)\n    }\n\n    const pathComponents = toPathComponents(path)\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      }\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`\n\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    }\n  })\n\n  await Promise.all(\n    paths.map(async (path) => {\n      const cidPath = path.type === 'mfs' ? path.mfsPath : path.path\n\n      try {\n        const res = await exporter(cidPath, context.ipld)\n\n        path.cid = res.cid\n        path.mfsPath = `/ipfs/${res.path}`\n        path.unixfs = res.unixfs\n        path.content = res.content\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      path.exists = Boolean(path.cid)\n    })\n  )\n\n  if (outputArray) {\n    return paths\n  }\n\n  return paths[0]\n}\n\nmodule.exports = toMfsPath\n"]},"metadata":{},"sourceType":"script"}