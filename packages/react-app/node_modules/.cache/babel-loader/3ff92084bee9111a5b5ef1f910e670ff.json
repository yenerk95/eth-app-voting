{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar multiaddr = require('multiaddr');\n\nvar errCode = require('err-code');\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:dialer');\nlog.error = debug('libp2p:dialer:error');\n\nvar _require = require('./dial-request'),\n    DialRequest = _require.DialRequest;\n\nvar getPeer = require('../get-peer');\n\nvar _require2 = require('../errors'),\n    codes = _require2.codes;\n\nvar _require3 = require('../constants'),\n    DIAL_TIMEOUT = _require3.DIAL_TIMEOUT,\n    MAX_PARALLEL_DIALS = _require3.MAX_PARALLEL_DIALS,\n    MAX_PER_PEER_DIALS = _require3.MAX_PER_PEER_DIALS;\n\nvar Dialer = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {TransportManager} options.transportManager\n   * @param {Peerstore} peerStore\n   * @param {number} options.concurrency Number of max concurrent dials. Defaults to `MAX_PARALLEL_DIALS`\n   * @param {number} options.timeout How long a dial attempt is allowed to take. Defaults to `DIAL_TIMEOUT`\n   */\n  function Dialer(_ref) {\n    var transportManager = _ref.transportManager,\n        peerStore = _ref.peerStore,\n        _ref$concurrency = _ref.concurrency,\n        concurrency = _ref$concurrency === void 0 ? MAX_PARALLEL_DIALS : _ref$concurrency,\n        _ref$timeout = _ref.timeout,\n        timeout = _ref$timeout === void 0 ? DIAL_TIMEOUT : _ref$timeout,\n        _ref$perPeerLimit = _ref.perPeerLimit,\n        perPeerLimit = _ref$perPeerLimit === void 0 ? MAX_PER_PEER_DIALS : _ref$perPeerLimit;\n\n    _classCallCheck(this, Dialer);\n\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.concurrency = concurrency;\n    this.timeout = timeout;\n    this.perPeerLimit = perPeerLimit;\n    this.tokens = _toConsumableArray(new Array(concurrency)).map(function (_, index) {\n      return index;\n    });\n    this._pendingDials = new Map();\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator = _createForOfIteratorHelper(this._pendingDials.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dial = _step.value;\n\n          try {\n            dial.controller.abort();\n          } catch (err) {\n            log.error(err);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._pendingDials.clear();\n    }\n    /**\n     * Connects to a given `peer` by dialing all of its known addresses.\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used.\n     *\n     * @param {PeerId|Multiaddr|string} peer The peer to dial\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] An AbortController signal\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"connectToPeer\",\n    value: function () {\n      var _connectToPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer) {\n        var options,\n            dialTarget,\n            pendingDial,\n            connection,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                dialTarget = this._createDialTarget(peer);\n\n                if (dialTarget.addrs.length) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES);\n\n              case 4:\n                pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n                _context.prev = 5;\n                _context.next = 8;\n                return pendingDial.promise;\n\n              case 8:\n                connection = _context.sent;\n                log('dial succeeded to %s', dialTarget.id);\n                return _context.abrupt(\"return\", connection);\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](5);\n\n                // Error is a timeout\n                if (pendingDial.controller.signal.aborted) {\n                  _context.t0.code = codes.ERR_TIMEOUT;\n                }\n\n                log.error(_context.t0);\n                throw _context.t0;\n\n              case 18:\n                _context.prev = 18;\n                pendingDial.destroy();\n                return _context.finish(18);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 13, 18, 21]]);\n      }));\n\n      function connectToPeer(_x) {\n        return _connectToPeer.apply(this, arguments);\n      }\n\n      return connectToPeer;\n    }()\n    /**\n     * @typedef DialTarget\n     * @property {string} id\n     * @property {Multiaddr[]} addrs\n     */\n\n    /**\n     * Creates a DialTarget. The DialTarget is used to create and track\n     * the DialRequest to a given peer.\n     * If a multiaddr is received it should be the first address attempted.\n     * @private\n     * @param {PeerId|Multiaddr|string} peer A PeerId or Multiaddr\n     * @returns {DialTarget}\n     */\n\n  }, {\n    key: \"_createDialTarget\",\n    value: function _createDialTarget(peer) {\n      var _getPeer = getPeer(peer),\n          id = _getPeer.id,\n          multiaddrs = _getPeer.multiaddrs;\n\n      if (multiaddrs) {\n        this.peerStore.addressBook.add(id, multiaddrs);\n      }\n\n      var addrs = this.peerStore.addressBook.getMultiaddrsForPeer(id); // If received a multiaddr to dial, it should be the first to use\n      // But, if we know other multiaddrs for the peer, we should try them too.\n\n      if (multiaddr.isMultiaddr(peer)) {\n        addrs = addrs.filter(function (addr) {\n          return !peer.equals(addr);\n        });\n        addrs.unshift(peer);\n      }\n\n      return {\n        id: id.toB58String(),\n        addrs: addrs\n      };\n    }\n    /**\n     * @typedef PendingDial\n     * @property {DialRequest} dialRequest\n     * @property {TimeoutController} controller\n     * @property {Promise} promise\n     * @property {function():void} destroy\n     */\n\n    /**\n     * Creates a PendingDial that wraps the underlying DialRequest\n     * @private\n     * @param {DialTarget} dialTarget\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] An AbortController signal\n     * @returns {PendingDial}\n     */\n\n  }, {\n    key: \"_createPendingDial\",\n    value: function _createPendingDial(dialTarget, options) {\n      var _this = this;\n\n      var dialAction = function dialAction(addr, options) {\n        if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n        return _this.transportManager.dial(addr, options);\n      };\n\n      var dialRequest = new DialRequest({\n        addrs: dialTarget.addrs,\n        dialAction: dialAction,\n        dialer: this\n      }); // Combine the timeout signal and options.signal, if provided\n\n      var timeoutController = new TimeoutController(this.timeout);\n      var signals = [timeoutController.signal];\n      options.signal && signals.push(options.signal);\n      var signal = anySignal(signals);\n      var pendingDial = {\n        dialRequest: dialRequest,\n        controller: timeoutController,\n        promise: dialRequest.run(_objectSpread(_objectSpread({}, options), {}, {\n          signal: signal\n        })),\n        destroy: function destroy() {\n          timeoutController.clear();\n\n          _this._pendingDials.delete(dialTarget.id);\n        }\n      };\n\n      this._pendingDials.set(dialTarget.id, pendingDial);\n\n      return pendingDial;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function getTokens(num) {\n      var total = Math.min(num, this.perPeerLimit, this.tokens.length);\n      var tokens = this.tokens.splice(0, total);\n      log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n      return tokens;\n    }\n  }, {\n    key: \"releaseToken\",\n    value: function releaseToken(token) {\n      // Guard against duplicate releases\n      if (this.tokens.indexOf(token) > -1) return;\n      log('token %d released', token);\n      this.tokens.push(token);\n    }\n  }]);\n\n  return Dialer;\n}();\n\nmodule.exports = Dialer;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/dialer/index.js"],"names":["multiaddr","require","errCode","TimeoutController","anySignal","debug","log","error","DialRequest","getPeer","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","Dialer","transportManager","peerStore","concurrency","timeout","perPeerLimit","tokens","Array","map","_","index","_pendingDials","Map","values","dial","controller","abort","err","clear","peer","options","dialTarget","_createDialTarget","addrs","length","Error","ERR_NO_VALID_ADDRESSES","pendingDial","get","id","_createPendingDial","promise","connection","signal","aborted","code","ERR_TIMEOUT","destroy","multiaddrs","addressBook","add","getMultiaddrsForPeer","isMultiaddr","filter","addr","equals","unshift","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","push","run","delete","set","num","total","Math","min","splice","token","indexOf","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multiaddr = require('multiaddr')\nconst errCode = require('err-code')\nconst TimeoutController = require('timeout-abort-controller')\nconst anySignal = require('any-signal')\nconst debug = require('debug')\nconst log = debug('libp2p:dialer')\nlog.error = debug('libp2p:dialer:error')\n\nconst { DialRequest } = require('./dial-request')\nconst getPeer = require('../get-peer')\n\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS\n} = require('../constants')\n\nclass Dialer {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {TransportManager} options.transportManager\n   * @param {Peerstore} peerStore\n   * @param {number} options.concurrency Number of max concurrent dials. Defaults to `MAX_PARALLEL_DIALS`\n   * @param {number} options.timeout How long a dial attempt is allowed to take. Defaults to `DIAL_TIMEOUT`\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    concurrency = MAX_PARALLEL_DIALS,\n    timeout = DIAL_TIMEOUT,\n    perPeerLimit = MAX_PER_PEER_DIALS\n  }) {\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.concurrency = concurrency\n    this.timeout = timeout\n    this.perPeerLimit = perPeerLimit\n    this.tokens = [...new Array(concurrency)].map((_, index) => index)\n    this._pendingDials = new Map()\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const dialTarget = this._createDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * @typedef DialTarget\n   * @property {string} id\n   * @property {Multiaddr[]} addrs\n   */\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * @private\n   * @param {PeerId|Multiaddr|string} peer A PeerId or Multiaddr\n   * @returns {DialTarget}\n   */\n  _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let addrs = this.peerStore.addressBook.getMultiaddrsForPeer(id)\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (multiaddr.isMultiaddr(peer)) {\n      addrs = addrs.filter((addr) => !peer.equals(addr))\n      addrs.unshift(peer)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs\n    }\n  }\n\n  /**\n   * @typedef PendingDial\n   * @property {DialRequest} dialRequest\n   * @property {TimeoutController} controller\n   * @property {Promise} promise\n   * @property {function():void} destroy\n   */\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options) {\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n    return pendingDial\n  }\n\n  getTokens (num) {\n    const total = Math.min(num, this.perPeerLimit, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n}\n\nmodule.exports = Dialer\n"]},"metadata":{},"sourceType":"script"}