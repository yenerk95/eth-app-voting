{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar multibase = require('multibase');\n\nvar sha = require('multihashing-async/src/sha');\n\nmodule.exports = function (keysProtobuf, randomBytes, crypto) {\n  crypto = crypto || require('./secp256k1')(randomBytes);\n\n  var Secp256k1PublicKey = /*#__PURE__*/function () {\n    function Secp256k1PublicKey(key) {\n      _classCallCheck(this, Secp256k1PublicKey);\n\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    _createClass(Secp256k1PublicKey, [{\n      key: \"verify\",\n      value: function verify(data, sig) {\n        return crypto.hashAndVerify(this._key, sig, data);\n      }\n    }, {\n      key: \"marshal\",\n      value: function marshal() {\n        return crypto.compressPublicKey(this._key);\n      }\n    }, {\n      key: \"equals\",\n      value: function equals(key) {\n        return this.bytes.equals(key.bytes);\n      }\n    }, {\n      key: \"hash\",\n      value: function hash() {\n        return sha.multihashing(this.bytes, 'sha2-256');\n      }\n    }, {\n      key: \"bytes\",\n      get: function get() {\n        return keysProtobuf.PublicKey.encode({\n          Type: keysProtobuf.KeyType.Secp256k1,\n          Data: this.marshal()\n        });\n      }\n    }]);\n\n    return Secp256k1PublicKey;\n  }();\n\n  var Secp256k1PrivateKey = /*#__PURE__*/function () {\n    function Secp256k1PrivateKey(key, publicKey) {\n      _classCallCheck(this, Secp256k1PrivateKey);\n\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    _createClass(Secp256k1PrivateKey, [{\n      key: \"sign\",\n      value: function sign(message) {\n        return crypto.hashAndSign(this._key, message);\n      }\n    }, {\n      key: \"marshal\",\n      value: function marshal() {\n        return this._key;\n      }\n    }, {\n      key: \"equals\",\n      value: function equals(key) {\n        return this.bytes.equals(key.bytes);\n      }\n    }, {\n      key: \"hash\",\n      value: function hash() {\n        return sha.multihashing(this.bytes, 'sha2-256');\n      }\n      /**\n       * Gets the ID of the key.\n       *\n       * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n       * The public key is a protobuf encoding containing a type and the DER encoding\n       * of the PKCS SubjectPublicKeyInfo.\n       *\n       * @param {function(Error, id)} callback\n       * @returns {undefined}\n       */\n\n    }, {\n      key: \"id\",\n      value: function () {\n        var _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var hash;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.public.hash();\n\n                case 2:\n                  hash = _context.sent;\n                  return _context.abrupt(\"return\", multibase.encode('base58btc', hash).toString().slice(1));\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function id() {\n          return _id.apply(this, arguments);\n        }\n\n        return id;\n      }()\n    }, {\n      key: \"public\",\n      get: function get() {\n        return new Secp256k1PublicKey(this._publicKey);\n      }\n    }, {\n      key: \"bytes\",\n      get: function get() {\n        return keysProtobuf.PrivateKey.encode({\n          Type: keysProtobuf.KeyType.Secp256k1,\n          Data: this.marshal()\n        });\n      }\n    }]);\n\n    return Secp256k1PrivateKey;\n  }();\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  function generateKeyPair() {\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  function _generateKeyPair() {\n    _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var privateKeyBytes;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return crypto.generateKey();\n\n            case 2:\n              privateKeyBytes = _context2.sent;\n              return _context2.abrupt(\"return\", new Secp256k1PrivateKey(privateKeyBytes));\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  return {\n    Secp256k1PublicKey: Secp256k1PublicKey,\n    Secp256k1PrivateKey: Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey,\n    generateKeyPair: generateKeyPair\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-crypto/src/keys/secp256k1-class.js"],"names":["multibase","require","sha","module","exports","keysProtobuf","randomBytes","crypto","Secp256k1PublicKey","key","validatePublicKey","_key","data","sig","hashAndVerify","compressPublicKey","bytes","equals","multihashing","PublicKey","encode","Type","KeyType","Secp256k1","Data","marshal","Secp256k1PrivateKey","publicKey","_publicKey","computePublicKey","validatePrivateKey","message","hashAndSign","public","hash","toString","slice","PrivateKey","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","generateKey","privateKeyBytes"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multibase = require('multibase')\nconst sha = require('multihashing-async/src/sha')\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./secp256k1')(randomBytes)\n\n  class Secp256k1PublicKey {\n    constructor (key) {\n      crypto.validatePublicKey(key)\n      this._key = key\n    }\n\n    verify (data, sig) {\n      return crypto.hashAndVerify(this._key, sig, data)\n    }\n\n    marshal () {\n      return crypto.compressPublicKey(this._key)\n    }\n\n    get bytes () {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash () {\n      return sha.multihashing(this.bytes, 'sha2-256')\n    }\n  }\n\n  class Secp256k1PrivateKey {\n    constructor (key, publicKey) {\n      this._key = key\n      this._publicKey = publicKey || crypto.computePublicKey(key)\n      crypto.validatePrivateKey(this._key)\n      crypto.validatePublicKey(this._publicKey)\n    }\n\n    sign (message) {\n      return crypto.hashAndSign(this._key, message)\n    }\n\n    get public () {\n      return new Secp256k1PublicKey(this._publicKey)\n    }\n\n    marshal () {\n      return this._key\n    }\n\n    get bytes () {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash () {\n      return sha.multihashing(this.bytes, 'sha2-256')\n    }\n\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @param {function(Error, id)} callback\n     * @returns {undefined}\n     */\n    async id () {\n      const hash = await this.public.hash()\n      return multibase.encode('base58btc', hash).toString().slice(1)\n    }\n  }\n\n  function unmarshalSecp256k1PrivateKey (bytes) {\n    return new Secp256k1PrivateKey(bytes)\n  }\n\n  function unmarshalSecp256k1PublicKey (bytes) {\n    return new Secp256k1PublicKey(bytes)\n  }\n\n  async function generateKeyPair () {\n    const privateKeyBytes = await crypto.generateKey()\n    return new Secp256k1PrivateKey(privateKeyBytes)\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  }\n}\n"]},"metadata":{},"sourceType":"script"}