{"ast":null,"code":"'use strict';\n\nconst createLock = require('./utils/create-lock');\n\nconst isIpfs = require('is-ipfs'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nconst readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}; // These operations are asynchronous and manage their own locking\n\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nconst wrap = ({\n  options,\n  mfs,\n  operations,\n  lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nfunction createMfs(options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  };\n  const lock = createLock(repoOwner);\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n\nmodule.exports = ({\n  ipld,\n  block,\n  blockService,\n  repo,\n  preload,\n  options: constructorOptions\n}) => {\n  const methods = createMfs({\n    ipld,\n    block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  });\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n    if (paths.length) {\n      const options = args[args.length - 1];\n\n      if (options && options.preload !== false) {\n        paths.forEach(path => preload(path));\n      }\n    }\n\n    return fn(...args);\n  };\n\n  return { ...methods,\n\n    /**\n     * Change file mode\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {Object} mode - The mode to set the path\n     * @param {Object} [opts] - Options for modification.\n     * @param {boolean} [opts.recursive=false] - Whether to change modes recursively. (default: false)\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    chmod: methods.chmod,\n\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<string>}\n     */\n    cp: withPreload(methods.cp),\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<void>}\n     */\n    mkdir: methods.mkdir,\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @returns {Promise<StatOutput>}\n     */\n    stat: withPreload(methods.stat),\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @returns {Promise<void>}\n     */\n    rm: methods.rm,\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {AsyncIterable<Buffer>}\n     */\n    read: withPreload(methods.read),\n\n    /**\n     * Update modification time\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {number} mtime - Time to use as the new modification time in seconds since (+ve) or before (-ve) the Unix Epoch\n     * @param {Object} [opts] - Options for touch.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.cidVersion=0] - CID version to use with the newly updated node\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    touch: methods.touch,\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @returns {Promise<void>}\n     */\n    write: methods.write,\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @returns {Promise<void>}\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: withPreload(methods.mv),\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @returns {Promise<void>}\n     */\n    flush: methods.flush,\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {AsyncIterable<ListOutputFile>}\n     */\n    ls: withPreload(async function* (...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file,\n          size: file.size || 0\n        };\n      }\n    })\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/files/index.js"],"names":["createLock","require","isIpfs","readOperations","stat","writeOperations","chmod","cp","flush","mkdir","mv","rm","touch","unwrappedOperations","write","read","ls","wrap","options","mfs","operations","lock","Object","keys","forEach","key","defaultOptions","repoOwner","ipld","repo","createMfs","assign","blocks","datastore","readLock","operation","writeLock","module","exports","block","blockService","preload","constructorOptions","methods","root","withPreload","fn","args","paths","filter","arg","ipfsPath","cid","length","path","file","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst createLock = require('./utils/create-lock')\nconst isIpfs = require('is-ipfs')\n\n// These operations are read-locked at the function level and will execute simultaneously\nconst readOperations = {\n  stat: require('./stat')\n}\n\n// These operations are locked at the function level and will execute in series\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}\n\n// These operations are asynchronous and manage their own locking\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n}\n\nconst wrap = ({\n  options, mfs, operations, lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options))\n  })\n}\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n}\n\nfunction createMfs (options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options)\n\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  }\n\n  const lock = createLock(repoOwner)\n\n  const readLock = (operation) => {\n    return lock.readLock(operation)\n  }\n\n  const writeLock = (operation) => {\n    return lock.writeLock(operation)\n  }\n\n  const mfs = {}\n\n  wrap({\n    options, mfs, operations: readOperations, lock: readLock\n  })\n  wrap({\n    options, mfs, operations: writeOperations, lock: writeLock\n  })\n\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options)\n  })\n\n  return mfs\n}\n\nmodule.exports = ({ ipld, block, blockService, repo, preload, options: constructorOptions }) => {\n  const methods = createMfs({\n    ipld,\n    block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  })\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg))\n\n    if (paths.length) {\n      const options = args[args.length - 1]\n      if (options && options.preload !== false) {\n        paths.forEach(path => preload(path))\n      }\n    }\n\n    return fn(...args)\n  }\n\n  return {\n    ...methods,\n\n    /**\n     * Change file mode\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {Object} mode - The mode to set the path\n     * @param {Object} [opts] - Options for modification.\n     * @param {boolean} [opts.recursive=false] - Whether to change modes recursively. (default: false)\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    chmod: methods.chmod,\n\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<string>}\n     */\n    cp: withPreload(methods.cp),\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<void>}\n     */\n    mkdir: methods.mkdir,\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @returns {Promise<StatOutput>}\n     */\n    stat: withPreload(methods.stat),\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @returns {Promise<void>}\n     */\n    rm: methods.rm,\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {AsyncIterable<Buffer>}\n     */\n    read: withPreload(methods.read),\n\n    /**\n     * Update modification time\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {number} mtime - Time to use as the new modification time in seconds since (+ve) or before (-ve) the Unix Epoch\n     * @param {Object} [opts] - Options for touch.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.cidVersion=0] - CID version to use with the newly updated node\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    touch: methods.touch,\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @returns {Promise<void>}\n     */\n    write: methods.write,\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @returns {Promise<void>}\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: withPreload(methods.mv),\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @returns {Promise<void>}\n     */\n    flush: methods.flush,\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {AsyncIterable<ListOutputFile>}\n     */\n    ls: withPreload(async function * (...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file, size: file.size || 0 }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}