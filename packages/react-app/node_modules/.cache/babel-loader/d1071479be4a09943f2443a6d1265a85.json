{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar lp = require('it-length-prefixed');\n\nvar pipe = require('it-pipe');\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nvar Message = require('./types/message');\n\nvar CONSTANTS = require('./constants');\n\nvar logger = require('./utils').logger;\n\nvar BITSWAP100 = '/ipfs/bitswap/1.0.0';\nvar BITSWAP110 = '/ipfs/bitswap/1.1.0';\nvar BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nvar Network = /*#__PURE__*/function () {\n  function Network(libp2p, bitswap, options, stats) {\n    _classCallCheck(this, Network);\n\n    this._log = logger(libp2p.peerId, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this.protocols.unshift(BITSWAP110);\n      this.protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n  }\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n      this.libp2p.handle(this.protocols, this._onConnection); // register protocol with topology\n\n      var topology = new MulticodecTopology({\n        multicodecs: this.protocols,\n        handlers: {\n          onConnect: this._onPeerConnect,\n          onDisconnect: this._onPeerDisconnect\n        }\n      });\n      this._registrarId = this.libp2p.registrar.register(topology); // All existing connections are like new ones for us\n\n      var _iterator3 = _createForOfIteratorHelper(this.libp2p.peerStore.peers.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var peer = _step3.value;\n          var conn = this.libp2p.connectionManager.get(peer.id);\n          conn && this._onPeerConnect(conn);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n      this.libp2p.unhandle(this.protocols); // unregister protocol and handlers\n\n      this.libp2p.registrar.unregister(this._registrarId);\n    }\n    /**\n     * Handles both types of incoming bitswap messages\n     * @private\n     * @param {object} param0\n     * @param {string} param0.protocol The protocol the stream is running\n     * @param {Stream} param0.stream A duplex iterable stream\n     * @param {Connection} param0.connection A libp2p Connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onConnection\",\n    value: function () {\n      var _onConnection2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n        var _this = this;\n\n        var protocol, stream, connection;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                protocol = _ref.protocol, stream = _ref.stream, connection = _ref.connection;\n\n                if (this._running) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n                _context2.prev = 4;\n                _context2.next = 7;\n                return pipe(stream, lp.decode(), /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, data, message;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _iteratorNormalCompletion = true;\n                            _didIteratorError = false;\n                            _context.prev = 2;\n                            _iterator = _asyncIterator(source);\n\n                          case 4:\n                            _context.next = 6;\n                            return _iterator.next();\n\n                          case 6:\n                            _step = _context.sent;\n                            _iteratorNormalCompletion = _step.done;\n                            _context.next = 10;\n                            return _step.value;\n\n                          case 10:\n                            _value = _context.sent;\n\n                            if (_iteratorNormalCompletion) {\n                              _context.next = 28;\n                              break;\n                            }\n\n                            data = _value;\n                            _context.prev = 13;\n                            _context.next = 16;\n                            return Message.deserialize(data.slice());\n\n                          case 16:\n                            message = _context.sent;\n                            _context.next = 19;\n                            return _this.bitswap._receiveMessage(connection.remotePeer, message);\n\n                          case 19:\n                            _context.next = 25;\n                            break;\n\n                          case 21:\n                            _context.prev = 21;\n                            _context.t0 = _context[\"catch\"](13);\n\n                            _this.bitswap._receiveError(_context.t0);\n\n                            return _context.abrupt(\"break\", 28);\n\n                          case 25:\n                            _iteratorNormalCompletion = true;\n                            _context.next = 4;\n                            break;\n\n                          case 28:\n                            _context.next = 34;\n                            break;\n\n                          case 30:\n                            _context.prev = 30;\n                            _context.t1 = _context[\"catch\"](2);\n                            _didIteratorError = true;\n                            _iteratorError = _context.t1;\n\n                          case 34:\n                            _context.prev = 34;\n                            _context.prev = 35;\n\n                            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                              _context.next = 39;\n                              break;\n                            }\n\n                            _context.next = 39;\n                            return _iterator.return();\n\n                          case 39:\n                            _context.prev = 39;\n\n                            if (!_didIteratorError) {\n                              _context.next = 42;\n                              break;\n                            }\n\n                            throw _iteratorError;\n\n                          case 42:\n                            return _context.finish(39);\n\n                          case 43:\n                            return _context.finish(34);\n\n                          case 44:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[2, 30, 34, 44], [13, 21], [35,, 39, 43]]);\n                  }));\n\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n              case 7:\n                _context2.next = 12;\n                break;\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                this._log(_context2.t0);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 9]]);\n      }));\n\n      function _onConnection(_x) {\n        return _onConnection2.apply(this, arguments);\n      }\n\n      return _onConnection;\n    }()\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerId) {\n      this.bitswap._onPeerConnected(peerId);\n    }\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerId) {\n      this.bitswap._onPeerDisconnected(peerId);\n    }\n    /**\n     * Find providers given a `cid`.\n     *\n     * @param {CID} cid\n     * @param {number} maxProviders\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {AsyncIterable<PeerInfo>}\n     */\n\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(cid, maxProviders) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.libp2p.contentRouting.findProviders(cid, {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders,\n        signal: options.signal\n      });\n    }\n    /**\n     * Find the providers of a given `cid` and connect to them.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findAndConnect\",\n    value: function () {\n      var _findAndConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(cid, options) {\n        var connectAttempts, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, provider;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                connectAttempts = [];\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context3.prev = 3;\n                _iterator2 = _asyncIterator(this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options));\n\n              case 5:\n                _context3.next = 7;\n                return _iterator2.next();\n\n              case 7:\n                _step2 = _context3.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context3.next = 11;\n                return _step2.value;\n\n              case 11:\n                _value2 = _context3.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                provider = _value2;\n\n                this._log('connecting to providers', provider.id.toB58String());\n\n                connectAttempts.push(this.connectTo(provider, options));\n\n              case 16:\n                _iteratorNormalCompletion2 = true;\n                _context3.next = 5;\n                break;\n\n              case 19:\n                _context3.next = 25;\n                break;\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](3);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context3.t0;\n\n              case 25:\n                _context3.prev = 25;\n                _context3.prev = 26;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context3.next = 30;\n                  break;\n                }\n\n                _context3.next = 30;\n                return _iterator2.return();\n\n              case 30:\n                _context3.prev = 30;\n\n                if (!_didIteratorError2) {\n                  _context3.next = 33;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 33:\n                return _context3.finish(30);\n\n              case 34:\n                return _context3.finish(25);\n\n              case 35:\n                _context3.next = 37;\n                return Promise.all(connectAttempts);\n\n              case 37:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 21, 25, 35], [26,, 30, 34]]);\n      }));\n\n      function findAndConnect(_x3, _x4) {\n        return _findAndConnect.apply(this, arguments);\n      }\n\n      return findAndConnect;\n    }()\n    /**\n     * Tell the network we can provide content for the passed CID\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function () {\n      var _provide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.libp2p.contentRouting.provide(cid, options);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function provide(_x5, _x6) {\n        return _provide.apply(this, arguments);\n      }\n\n      return provide;\n    }() // Connect to the given peer\n    // Send the given msg (instance of Message) to the given peer\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(peer, msg) {\n        var stringId, _yield$this$_dialPeer, stream, protocol, serialized;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this._running) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('network isn\\'t running');\n\n              case 2:\n                stringId = peer.toB58String();\n\n                this._log('sendMessage to %s', stringId, msg);\n\n                _context5.next = 6;\n                return this._dialPeer(peer);\n\n              case 6:\n                _yield$this$_dialPeer = _context5.sent;\n                stream = _yield$this$_dialPeer.stream;\n                protocol = _yield$this$_dialPeer.protocol;\n                _context5.t0 = protocol;\n                _context5.next = _context5.t0 === BITSWAP100 ? 12 : _context5.t0 === BITSWAP110 ? 14 : _context5.t0 === BITSWAP120 ? 14 : 16;\n                break;\n\n              case 12:\n                serialized = msg.serializeToBitswap100();\n                return _context5.abrupt(\"break\", 17);\n\n              case 14:\n                serialized = msg.serializeToBitswap110();\n                return _context5.abrupt(\"break\", 17);\n\n              case 16:\n                throw new Error('Unknown protocol: ' + protocol);\n\n              case 17:\n                // Note: Don't wait for writeMessage() to complete\n                writeMessage(stream, serialized, this._log);\n\n                this._updateSentStats(peer, msg.blocks);\n\n              case 19:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendMessage(_x7, _x8) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Connects to another peer\n     *\n     * @param {PeerId|Multiaddr} peer\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"connectTo\",\n    value: function () {\n      var _connectTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peer, options) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this._running) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('network isn\\'t running');\n\n              case 2:\n                return _context6.abrupt(\"return\", this.libp2p.dial(peer, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function connectTo(_x9, _x10) {\n        return _connectTo.apply(this, arguments);\n      }\n\n      return connectTo;\n    }() // Dial to the peer and try to use the most recent Bitswap\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peer) {\n      return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100]);\n    }\n  }, {\n    key: \"_updateSentStats\",\n    value: function _updateSentStats(peer, blocks) {\n      var _this2 = this;\n\n      var peerId = peer.toB58String();\n\n      if (this._stats) {\n        blocks.forEach(function (block) {\n          return _this2._stats.push(peerId, 'dataSent', block.data.length);\n        });\n\n        this._stats.push(peerId, 'blocksSent', blocks.size);\n      }\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeMessage(_x11, _x12, _x13) {\n  return _writeMessage.apply(this, arguments);\n}\n\nfunction _writeMessage() {\n  _writeMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(stream, msg, log) {\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return pipe([msg], lp.encode(), stream);\n\n          case 3:\n            _context7.next = 8;\n            break;\n\n          case 5:\n            _context7.prev = 5;\n            _context7.t0 = _context7[\"catch\"](0);\n            log(_context7.t0);\n\n          case 8:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[0, 5]]);\n  }));\n  return _writeMessage.apply(this, arguments);\n}\n\nmodule.exports = Network;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/network.js"],"names":["lp","require","pipe","MulticodecTopology","Message","CONSTANTS","logger","BITSWAP100","BITSWAP110","BITSWAP120","Network","libp2p","bitswap","options","stats","_log","peerId","protocols","b100Only","unshift","_stats","_running","_onPeerConnect","bind","_onPeerDisconnect","_onConnection","handle","topology","multicodecs","handlers","onConnect","onDisconnect","_registrarId","registrar","register","peerStore","peers","values","peer","conn","connectionManager","get","id","unhandle","unregister","protocol","stream","connection","remotePeer","toB58String","decode","source","data","deserialize","slice","message","_receiveMessage","_receiveError","_onPeerConnected","_onPeerDisconnected","cid","maxProviders","contentRouting","findProviders","maxTimeout","providerRequestTimeout","maxNumProviders","signal","connectAttempts","maxProvidersPerRequest","provider","push","connectTo","Promise","all","provide","msg","Error","stringId","_dialPeer","serialized","serializeToBitswap100","serializeToBitswap110","writeMessage","_updateSentStats","blocks","dial","dialProtocol","forEach","block","length","size","log","encode","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology')\n\nconst Message = require('./types/message')\nconst CONSTANTS = require('./constants')\nconst logger = require('./utils').logger\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0'\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0'\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0'\n\nclass Network {\n  constructor (libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerId, 'network')\n    options = options || {}\n    this.libp2p = libp2p\n    this.bitswap = bitswap\n    this.protocols = [BITSWAP100]\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this.protocols.unshift(BITSWAP110)\n      this.protocols.unshift(BITSWAP120)\n    }\n\n    this._stats = stats\n    this._running = false\n\n    // bind event listeners\n    this._onPeerConnect = this._onPeerConnect.bind(this)\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this)\n    this._onConnection = this._onConnection.bind(this)\n  }\n\n  start () {\n    this._running = true\n    this.libp2p.handle(this.protocols, this._onConnection)\n\n    // register protocol with topology\n    const topology = new MulticodecTopology({\n      multicodecs: this.protocols,\n      handlers: {\n        onConnect: this._onPeerConnect,\n        onDisconnect: this._onPeerDisconnect\n      }\n    })\n    this._registrarId = this.libp2p.registrar.register(topology)\n\n    // All existing connections are like new ones for us\n    for (const peer of this.libp2p.peerStore.peers.values()) {\n      const conn = this.libp2p.connectionManager.get(peer.id)\n\n      conn && this._onPeerConnect(conn)\n    }\n  }\n\n  stop () {\n    this._running = false\n\n    // Unhandle both, libp2p doesn't care if it's not already handled\n    this.libp2p.unhandle(this.protocols)\n\n    // unregister protocol and handlers\n    this.libp2p.registrar.unregister(this._registrarId)\n  }\n\n  /**\n   * Handles both types of incoming bitswap messages\n   * @private\n   * @param {object} param0\n   * @param {string} param0.protocol The protocol the stream is running\n   * @param {Stream} param0.stream A duplex iterable stream\n   * @param {Connection} param0.connection A libp2p Connection\n   * @returns {void}\n   */\n  async _onConnection ({ protocol, stream, connection }) {\n    if (!this._running) { return }\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String())\n\n    try {\n      await pipe(\n        stream,\n        lp.decode(),\n        async (source) => {\n          for await (const data of source) {\n            try {\n              const message = await Message.deserialize(data.slice())\n              await this.bitswap._receiveMessage(connection.remotePeer, message)\n            } catch (err) {\n              this.bitswap._receiveError(err)\n              break\n            }\n          }\n        }\n      )\n    } catch (err) {\n      this._log(err)\n    }\n  }\n\n  _onPeerConnect (peerId) {\n    this.bitswap._onPeerConnected(peerId)\n  }\n\n  _onPeerDisconnect (peerId) {\n    this.bitswap._onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {AsyncIterable<PeerInfo>}\n   */\n  findProviders (cid, maxProviders, options = {}) {\n    return this.libp2p.contentRouting.findProviders(\n      cid,\n      {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders,\n        signal: options.signal\n      }\n    )\n  }\n\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {void}\n   */\n  async findAndConnect (cid, options) {\n    const connectAttempts = []\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log('connecting to providers', provider.id.toB58String())\n      connectAttempts.push(this.connectTo(provider, options))\n    }\n    await Promise.all(connectAttempts)\n  }\n\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<void>}\n   */\n  async provide (cid, options) {\n    await this.libp2p.contentRouting.provide(cid, options)\n  }\n\n  // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n  async sendMessage (peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running')\n\n    const stringId = peer.toB58String()\n    this._log('sendMessage to %s', stringId, msg)\n\n    const { stream, protocol } = await this._dialPeer(peer)\n\n    let serialized\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100()\n        break\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110()\n        break\n      default:\n        throw new Error('Unknown protocol: ' + protocol)\n    }\n\n    // Note: Don't wait for writeMessage() to complete\n    writeMessage(stream, serialized, this._log)\n\n    this._updateSentStats(peer, msg.blocks)\n  }\n\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Connection>}\n   */\n  async connectTo (peer, options) { // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running')\n    }\n\n    return this.libp2p.dial(peer, options)\n  }\n\n  // Dial to the peer and try to use the most recent Bitswap\n  _dialPeer (peer) {\n    return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100])\n  }\n\n  _updateSentStats (peer, blocks) {\n    const peerId = peer.toB58String()\n\n    if (this._stats) {\n      blocks.forEach((block) => this._stats.push(peerId, 'dataSent', block.data.length))\n      this._stats.push(peerId, 'blocksSent', blocks.size)\n    }\n  }\n}\n\nasync function writeMessage (stream, msg, log) {\n  try {\n    await pipe(\n      [msg],\n      lp.encode(),\n      stream\n    )\n  } catch (err) {\n    log(err)\n  }\n}\n\nmodule.exports = Network\n"]},"metadata":{},"sourceType":"script"}