{"ast":null,"code":"'use strict';\n\nconst protons = require('protons');\n\nconst pb = protons(require('./unixfs.proto'));\nconst unixfsData = pb.Data;\n\nconst errcode = require('err-code');\n\nconst types = ['raw', 'directory', 'file', 'metadata', 'symlink', 'hamt-sharded-directory'];\nconst dirTypes = ['directory', 'hamt-sharded-directory'];\nconst DEFAULT_FILE_MODE = parseInt('0644', 8);\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\n\nfunction parseArgs(args) {\n  if (args.length === 0) {\n    return {\n      type: 'file'\n    };\n  }\n\n  if (args.length === 2) {\n    // support old-style constructor\n    return {\n      type: args[0],\n      data: args[1]\n    };\n  }\n\n  if (typeof args[0] === 'string' || args[0] instanceof String) {\n    return {\n      type: args[0]\n    };\n  }\n\n  return args[0];\n}\n\nfunction parseMtime(mtime) {\n  if (mtime == null) {\n    return undefined;\n  } // { secs, nsecs }\n\n\n  if (Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    mtime = {\n      secs: mtime.secs,\n      nsecs: mtime.nsecs\n    };\n  } // UnixFS TimeSpec\n\n\n  if (Object.prototype.hasOwnProperty.call(mtime, 'Seconds')) {\n    mtime = {\n      secs: mtime.Seconds,\n      nsecs: mtime.FractionalNanoseconds\n    };\n  } // process.hrtime()\n\n\n  if (Array.isArray(mtime)) {\n    mtime = {\n      secs: mtime[0],\n      nsecs: mtime[1]\n    };\n  } // Javascript Date\n\n\n  if (mtime instanceof Date) {\n    const ms = mtime.getTime();\n    const secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n   // process.hrtime.bigint()\n  if (typeof mtime === 'bigint') {\n    const secs = mtime / BigInt(1e9)\n    const nsecs = mtime - (secs * BigInt(1e9))\n     mtime = {\n      secs: parseInt(secs),\n      nsecs: parseInt(nsecs)\n    }\n  }\n  */\n\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n\n  if (mtime.nsecs < 0 || mtime.nsecs > 999999999) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n\n  return mtime;\n}\n\nfunction parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n\n  if (typeof mode === 'string' || mode instanceof String) {\n    mode = parseInt(mode, 8);\n  }\n\n  return mode & 0xFFF;\n}\n\nclass Data {\n  // decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n  static unmarshal(marshaled) {\n    const decoded = unixfsData.decode(marshaled);\n    const data = new Data({\n      type: types[decoded.Type],\n      data: decoded.hasData() ? decoded.Data : undefined,\n      blockSizes: decoded.blocksizes,\n      mode: decoded.hasMode() ? decoded.mode : undefined,\n      mtime: decoded.hasMtime() ? decoded.mtime : undefined\n    }); // make sure we honor the original mode\n\n    data._originalMode = decoded.hasMode() ? decoded.mode : undefined;\n    return data;\n  }\n\n  constructor(...args) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = parseArgs(args);\n\n    if (!types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n\n    this.type = type;\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n    this.blockSizes = blockSizes || [];\n    const parsedMode = parseMode(mode);\n\n    if (parsedMode !== undefined) {\n      this.mode = parsedMode;\n    }\n\n    if (this.mode === undefined && type === 'file') {\n      this.mode = DEFAULT_FILE_MODE;\n    }\n\n    if (this.mode === undefined && this.isDirectory()) {\n      this.mode = DEFAULT_DIRECTORY_MODE;\n    }\n\n    const parsedMtime = parseMtime(mtime);\n\n    if (parsedMtime) {\n      this.mtime = parsedMtime;\n    }\n  }\n\n  isDirectory() {\n    return dirTypes.includes(this.type);\n  }\n\n  addBlockSize(size) {\n    this.blockSizes.push(size);\n  }\n\n  removeBlockSize(index) {\n    this.blockSizes.splice(index, 1);\n  } // data.length + blockSizes\n\n\n  fileSize() {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return undefined;\n    }\n\n    let sum = 0;\n    this.blockSizes.forEach(size => {\n      sum += size;\n    });\n\n    if (this.data) {\n      sum += this.data.length;\n    }\n\n    return sum;\n  } // encode to protobuf\n\n\n  marshal() {\n    let type;\n\n    switch (this.type) {\n      case 'raw':\n        type = unixfsData.DataType.Raw;\n        break;\n\n      case 'directory':\n        type = unixfsData.DataType.Directory;\n        break;\n\n      case 'file':\n        type = unixfsData.DataType.File;\n        break;\n\n      case 'metadata':\n        type = unixfsData.DataType.Metadata;\n        break;\n\n      case 'symlink':\n        type = unixfsData.DataType.Symlink;\n        break;\n\n      case 'hamt-sharded-directory':\n        type = unixfsData.DataType.HAMTShard;\n        break;\n\n      default:\n        throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n\n    let data = this.data;\n\n    if (!this.data || !this.data.length) {\n      data = undefined;\n    }\n\n    let blockSizes = this.blockSizes;\n\n    if (!this.blockSizes || !this.blockSizes.length) {\n      blockSizes = undefined;\n    }\n\n    let mode;\n\n    if (this.mode != null) {\n      mode = this._originalMode & 0xFFFFF000 | parseMode(this.mode);\n\n      if (mode === DEFAULT_FILE_MODE && this.type === 'file') {\n        mode = undefined;\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined;\n      }\n    }\n\n    let mtime;\n\n    if (this.mtime != null) {\n      const parsed = parseMtime(this.mtime);\n\n      if (parsed) {\n        mtime = {\n          Seconds: parsed.secs,\n          FractionalNanoseconds: parsed.nsecs\n        };\n\n        if (mtime.FractionalNanoseconds === 0) {\n          delete mtime.FractionalNanoseconds;\n        }\n      }\n    }\n\n    return unixfsData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.fileSize(),\n      blocksizes: blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    });\n  }\n\n}\n\nmodule.exports = Data;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-unixfs/src/index.js"],"names":["protons","require","pb","unixfsData","Data","errcode","types","dirTypes","DEFAULT_FILE_MODE","parseInt","DEFAULT_DIRECTORY_MODE","parseArgs","args","length","type","data","String","parseMtime","mtime","undefined","Object","prototype","hasOwnProperty","call","secs","nsecs","Seconds","FractionalNanoseconds","Array","isArray","Date","ms","getTime","Math","floor","Error","parseMode","mode","unmarshal","marshaled","decoded","decode","Type","hasData","blockSizes","blocksizes","hasMode","hasMtime","_originalMode","constructor","hashType","fanout","includes","parsedMode","isDirectory","parsedMtime","addBlockSize","size","push","removeBlockSize","index","splice","fileSize","sum","forEach","marshal","DataType","Raw","Directory","File","Metadata","Symlink","HAMTShard","parsed","encode","filesize","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst protons = require('protons')\nconst pb = protons(require('./unixfs.proto'))\nconst unixfsData = pb.Data\nconst errcode = require('err-code')\n\nconst types = [\n  'raw',\n  'directory',\n  'file',\n  'metadata',\n  'symlink',\n  'hamt-sharded-directory'\n]\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\nfunction parseArgs (args) {\n  if (args.length === 0) {\n    return {\n      type: 'file'\n    }\n  }\n\n  if (args.length === 2) {\n    // support old-style constructor\n    return {\n      type: args[0],\n      data: args[1]\n    }\n  }\n\n  if (typeof args[0] === 'string' || args[0] instanceof String) {\n    return {\n      type: args[0]\n    }\n  }\n\n  return args[0]\n}\n\nfunction parseMtime (mtime) {\n  if (mtime == null) {\n    return undefined\n  }\n\n  // { secs, nsecs }\n  if (Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    mtime = {\n      secs: mtime.secs,\n      nsecs: mtime.nsecs\n    }\n  }\n\n  // UnixFS TimeSpec\n  if (Object.prototype.hasOwnProperty.call(mtime, 'Seconds')) {\n    mtime = {\n      secs: mtime.Seconds,\n      nsecs: mtime.FractionalNanoseconds\n    }\n  }\n\n  // process.hrtime()\n  if (Array.isArray(mtime)) {\n    mtime = {\n      secs: mtime[0],\n      nsecs: mtime[1]\n    }\n  }\n\n  // Javascript Date\n  if (mtime instanceof Date) {\n    const ms = mtime.getTime()\n    const secs = Math.floor(ms / 1000)\n\n    mtime = {\n      secs: secs,\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n  }\n\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n\n  // process.hrtime.bigint()\n  if (typeof mtime === 'bigint') {\n    const secs = mtime / BigInt(1e9)\n    const nsecs = mtime - (secs * BigInt(1e9))\n\n    mtime = {\n      secs: parseInt(secs),\n      nsecs: parseInt(nsecs)\n    }\n  }\n  */\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined\n  }\n\n  if (mtime.nsecs < 0 || mtime.nsecs > 999999999) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS')\n  }\n\n  return mtime\n}\n\nfunction parseMode (mode) {\n  if (mode == null) {\n    return undefined\n  }\n\n  if (typeof mode === 'string' || mode instanceof String) {\n    mode = parseInt(mode, 8)\n  }\n\n  return mode & 0xFFF\n}\n\nclass Data {\n  // decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n  static unmarshal (marshaled) {\n    const decoded = unixfsData.decode(marshaled)\n\n    const data = new Data({\n      type: types[decoded.Type],\n      data: decoded.hasData() ? decoded.Data : undefined,\n      blockSizes: decoded.blocksizes,\n      mode: decoded.hasMode() ? decoded.mode : undefined,\n      mtime: decoded.hasMtime() ? decoded.mtime : undefined\n    })\n\n    // make sure we honor the original mode\n    data._originalMode = decoded.hasMode() ? decoded.mode : undefined\n\n    return data\n  }\n\n  constructor (...args) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = parseArgs(args)\n\n    if (!types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')\n    }\n\n    this.type = type\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes || []\n\n    const parsedMode = parseMode(mode)\n\n    if (parsedMode !== undefined) {\n      this.mode = parsedMode\n    }\n\n    if (this.mode === undefined && type === 'file') {\n      this.mode = DEFAULT_FILE_MODE\n    }\n\n    if (this.mode === undefined && this.isDirectory()) {\n      this.mode = DEFAULT_DIRECTORY_MODE\n    }\n\n    const parsedMtime = parseMtime(mtime)\n\n    if (parsedMtime) {\n      this.mtime = parsedMtime\n    }\n  }\n\n  isDirectory () {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size) {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index) {\n    this.blockSizes.splice(index, 1)\n  }\n\n  // data.length + blockSizes\n  fileSize () {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return undefined\n    }\n\n    let sum = 0\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data) {\n      sum += this.data.length\n    }\n\n    return sum\n  }\n\n  // encode to protobuf\n  marshal () {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = unixfsData.DataType.Raw; break\n      case 'directory': type = unixfsData.DataType.Directory; break\n      case 'file': type = unixfsData.DataType.File; break\n      case 'metadata': type = unixfsData.DataType.Metadata; break\n      case 'symlink': type = unixfsData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = unixfsData.DataType.HAMTShard; break\n      default:\n        throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')\n    }\n\n    let data = this.data\n\n    if (!this.data || !this.data.length) {\n      data = undefined\n    }\n\n    let blockSizes = this.blockSizes\n\n    if (!this.blockSizes || !this.blockSizes.length) {\n      blockSizes = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | parseMode(this.mode)\n\n      if (mode === DEFAULT_FILE_MODE && this.type === 'file') {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      const parsed = parseMtime(this.mtime)\n\n      if (parsed) {\n        mtime = {\n          Seconds: parsed.secs,\n          FractionalNanoseconds: parsed.nsecs\n        }\n\n        if (mtime.FractionalNanoseconds === 0) {\n          delete mtime.FractionalNanoseconds\n        }\n      }\n    }\n\n    return unixfsData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.fileSize(),\n      blocksizes: blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nmodule.exports = Data\n"]},"metadata":{},"sourceType":"script"}