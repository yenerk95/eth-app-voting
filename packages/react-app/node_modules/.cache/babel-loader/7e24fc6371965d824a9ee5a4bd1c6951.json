{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar CID = require('cids');\n\nvar Message = require('../types/message');\n\nvar WantType = Message.WantType;\n\nvar Wantlist = require('../types/wantlist');\n\nvar Ledger = require('./ledger');\n\nvar RequestQueue = require('./req-queue');\n\nvar TaskMerger = require('./task-merger');\n\nvar _require = require('../utils'),\n    logger = _require.logger; // The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\n\n\nvar TARGET_MESSAGE_SIZE = 16 * 1024; // If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\n\nvar MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;\n\nvar DecisionEngine = /*#__PURE__*/function () {\n  function DecisionEngine(peerId, blockstore, network, stats, opts) {\n    _classCallCheck(this, DecisionEngine);\n\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats;\n    this._opts = this._processOpts(opts); // A list of of ledgers by their partner id\n\n    this.ledgerMap = new Map();\n    this._running = false; // Queue of want-have / want-block per peer\n\n    this._requestQueue = new RequestQueue(TaskMerger);\n  }\n\n  _createClass(DecisionEngine, [{\n    key: \"_processOpts\",\n    value: function _processOpts(opts) {\n      return _objectSpread({\n        maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n        targetMessageSize: TARGET_MESSAGE_SIZE\n      }, opts);\n    }\n  }, {\n    key: \"_scheduleProcessTasks\",\n    value: function _scheduleProcessTasks() {\n      var _this = this;\n\n      setTimeout(function () {\n        _this._processTasks();\n      });\n    } // Pull tasks off the request queue and send a message to the corresponding\n    // peer\n\n  }, {\n    key: \"_processTasks\",\n    value: function () {\n      var _processTasks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this$_requestQueue$p, peerId, tasks, pendingSize, msg, blockCids, blockTasks, _iterator, _step, task, cid, blocks, _iterator2, _step2, _step2$value, topic, taskData, blk, _cid, _iterator3, _step3, block;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._running) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _this$_requestQueue$p = this._requestQueue.popTasks(this._opts.targetMessageSize), peerId = _this$_requestQueue$p.peerId, tasks = _this$_requestQueue$p.tasks, pendingSize = _this$_requestQueue$p.pendingSize;\n\n                if (!(tasks.length === 0)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 5:\n                // Create a new message\n                msg = new Message(false); // Amount of data in the request queue still waiting to be popped\n\n                msg.setPendingBytes(pendingSize); // Split out want-blocks, want-haves and DONT_HAVEs\n\n                blockCids = [];\n                blockTasks = new Map();\n                _iterator = _createForOfIteratorHelper(tasks);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    task = _step.value;\n                    cid = new CID(task.topic);\n\n                    if (task.data.haveBlock) {\n                      if (task.data.isWantBlock) {\n                        blockCids.push(cid);\n                        blockTasks.set(task.topic, task.data);\n                      } else {\n                        // Add HAVES to the message\n                        msg.addHave(cid);\n                      }\n                    } else {\n                      // Add DONT_HAVEs to the message\n                      msg.addDontHave(cid);\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context.next = 13;\n                return this._getBlocks(blockCids);\n\n              case 13:\n                blocks = _context.sent;\n                _iterator2 = _createForOfIteratorHelper(blockTasks);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _step2$value = _slicedToArray(_step2.value, 2), topic = _step2$value[0], taskData = _step2$value[1];\n                    blk = blocks.get(topic); // If the block was found (it has not been removed)\n\n                    if (blk) {\n                      // Add the block to the message\n                      msg.addBlock(blk);\n                    } else {\n                      // The block was not found. If the client requested DONT_HAVE,\n                      // add DONT_HAVE to the message.\n                      if (taskData.sendDontHave) {\n                        _cid = new CID(topic);\n                        msg.addDontHave(_cid);\n                      }\n                    }\n                  } // If there's nothing in the message, bail out\n\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                if (!msg.empty) {\n                  _context.next = 20;\n                  break;\n                }\n\n                this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n\n                this._scheduleProcessTasks();\n\n                return _context.abrupt(\"return\");\n\n              case 20:\n                _context.prev = 20;\n                _context.next = 23;\n                return this.network.sendMessage(peerId, msg);\n\n              case 23:\n                // Peform sent message accounting\n                _iterator3 = _createForOfIteratorHelper(blocks.values());\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    block = _step3.value;\n                    this.messageSent(peerId, block);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _context.next = 30;\n                break;\n\n              case 27:\n                _context.prev = 27;\n                _context.t0 = _context[\"catch\"](20);\n\n                this._log.error(_context.t0);\n\n              case 30:\n                // Free the tasks up from the request queue\n                this._requestQueue.tasksDone(peerId, tasks); // Trigger the next round of task processing\n\n\n                this._scheduleProcessTasks();\n\n              case 32:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[20, 27]]);\n      }));\n\n      function _processTasks() {\n        return _processTasks2.apply(this, arguments);\n      }\n\n      return _processTasks;\n    }()\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n\n      if (!this.ledgerMap.has(peerIdStr)) {\n        return new Map();\n      }\n\n      return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries();\n    }\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n      var ledger = this.ledgerMap.get(peerIdStr);\n\n      if (!ledger) {\n        return null;\n      }\n\n      return {\n        peer: ledger.partner.toPrint(),\n        value: ledger.debtRatio(),\n        sent: ledger.accounting.bytesSent,\n        recv: ledger.accounting.bytesRecv,\n        exchanged: ledger.exchangeCount\n      };\n    }\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return Array.from(this.ledgerMap.values()).map(function (l) {\n        return l.partner;\n      });\n    } // Receive blocks either from an incoming message from the network, or from\n    // blocks being added by the client on the localhost (eg IPFS add)\n\n  }, {\n    key: \"receivedBlocks\",\n    value: function receivedBlocks(blocks) {\n      var _this2 = this;\n\n      if (!blocks.length) {\n        return;\n      } // For each connected peer, check if it wants the block we received\n\n\n      this.ledgerMap.forEach(function (ledger) {\n        blocks.forEach(function (block) {\n          // Filter out blocks that we don't want\n          var want = ledger.wantlistContains(block.cid);\n\n          if (!want) {\n            return;\n          } // If the block is small enough, just send the block, even if the\n          // client asked for a HAVE\n\n\n          var blockSize = block.data.length;\n\n          var isWantBlock = _this2._sendAsBlock(want.wantType, blockSize);\n\n          var entrySize = blockSize;\n\n          if (!isWantBlock) {\n            entrySize = Message.blockPresenceSize(want.cid);\n          }\n\n          _this2._requestQueue.pushTasks(ledger.partner, [{\n            topic: want.cid.toString(),\n            priority: want.priority,\n            size: entrySize,\n            data: {\n              blockSize: blockSize,\n              isWantBlock: isWantBlock,\n              haveBlock: true,\n              sendDontHave: false\n            }\n          }]);\n        });\n      });\n\n      this._scheduleProcessTasks();\n    } // Handle incoming messages\n\n  }, {\n    key: \"messageReceived\",\n    value: function () {\n      var _messageReceived = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peerId, msg) {\n        var ledger, cancels, wants;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                ledger = this._findOrCreate(peerId);\n\n                if (!msg.empty) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                // If the message has a full wantlist, clear the current wantlist\n                if (msg.full) {\n                  ledger.wantlist = new Wantlist();\n                } // Record the amount of block data received\n\n\n                this._updateBlockAccounting(msg.blocks, ledger);\n\n                if (!(msg.wantlist.size === 0)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                this._scheduleProcessTasks();\n\n                return _context2.abrupt(\"return\");\n\n              case 8:\n                // Clear cancelled wants and add new wants to the ledger\n                cancels = [];\n                wants = [];\n                msg.wantlist.forEach(function (entry) {\n                  if (entry.cancel) {\n                    ledger.cancelWant(entry.cid);\n                    cancels.push(entry.cid);\n                  } else {\n                    ledger.wants(entry.cid, entry.priority, entry.wantType);\n                    wants.push(entry);\n                  }\n                });\n\n                this._cancelWants(peerId, cancels);\n\n                _context2.next = 14;\n                return this._addWants(peerId, wants);\n\n              case 14:\n                this._scheduleProcessTasks();\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function messageReceived(_x, _x2) {\n        return _messageReceived.apply(this, arguments);\n      }\n\n      return messageReceived;\n    }()\n  }, {\n    key: \"_cancelWants\",\n    value: function _cancelWants(peerId, cids) {\n      var _iterator4 = _createForOfIteratorHelper(cids),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var c = _step4.value;\n\n          this._requestQueue.remove(c.toString(), peerId);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_addWants\",\n    value: function () {\n      var _addWants2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId, wants) {\n        var blockSizes, tasks, _iterator5, _step5, want, id, blockSize, isWantBlock, entrySize;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._getBlockSizes(wants.map(function (w) {\n                  return w.cid;\n                }));\n\n              case 2:\n                blockSizes = _context3.sent;\n                tasks = [];\n                _iterator5 = _createForOfIteratorHelper(wants);\n\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    want = _step5.value;\n                    id = want.cid.toString();\n                    blockSize = blockSizes.get(id); // If the block was not found\n\n                    if (blockSize == null) {\n                      // Only add the task to the queue if the requester wants a DONT_HAVE\n                      if (want.sendDontHave) {\n                        tasks.push({\n                          topic: id,\n                          priority: want.priority,\n                          size: Message.blockPresenceSize(want.cid),\n                          data: {\n                            isWantBlock: want.wantType === WantType.Block,\n                            blockSize: 0,\n                            haveBlock: false,\n                            sendDontHave: want.sendDontHave\n                          }\n                        });\n                      }\n                    } else {\n                      // The block was found, add it to the queue\n                      // If the block is small enough, just send the block, even if the\n                      // client asked for a HAVE\n                      isWantBlock = this._sendAsBlock(want.wantType, blockSize); // entrySize is the amount of space the entry takes up in the\n                      // message we send to the recipient. If we're sending a block, the\n                      // entrySize is the size of the block. Otherwise it's the size of\n                      // a block presence entry.\n\n                      entrySize = blockSize;\n\n                      if (!isWantBlock) {\n                        entrySize = Message.blockPresenceSize(want.cid);\n                      }\n\n                      tasks.push({\n                        topic: id,\n                        priority: want.priority,\n                        size: entrySize,\n                        data: {\n                          isWantBlock: isWantBlock,\n                          blockSize: blockSize,\n                          haveBlock: true,\n                          sendDontHave: want.sendDontHave\n                        }\n                      });\n                    }\n\n                    this._requestQueue.pushTasks(peerId, tasks);\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _addWants(_x3, _x4) {\n        return _addWants2.apply(this, arguments);\n      }\n\n      return _addWants;\n    }()\n  }, {\n    key: \"_sendAsBlock\",\n    value: function _sendAsBlock(wantType, blockSize) {\n      return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;\n    }\n  }, {\n    key: \"_getBlockSizes\",\n    value: function () {\n      var _getBlockSizes2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cids) {\n        var blocks;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._getBlocks(cids);\n\n              case 2:\n                blocks = _context4.sent;\n                return _context4.abrupt(\"return\", new Map(_toConsumableArray(blocks).map(function (_ref) {\n                  var _ref2 = _slicedToArray(_ref, 2),\n                      k = _ref2[0],\n                      v = _ref2[1];\n\n                  return [k, v.data.length];\n                })));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _getBlockSizes(_x5) {\n        return _getBlockSizes2.apply(this, arguments);\n      }\n\n      return _getBlockSizes;\n    }()\n  }, {\n    key: \"_getBlocks\",\n    value: function () {\n      var _getBlocks2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(cids) {\n        var _this3 = this;\n\n        var res;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                res = new Map();\n                _context6.next = 3;\n                return Promise.all(cids.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(cid) {\n                    var block;\n                    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.prev = 0;\n                            _context5.next = 3;\n                            return _this3.blockstore.get(cid);\n\n                          case 3:\n                            block = _context5.sent;\n                            res.set(cid.toString(), block);\n                            _context5.next = 10;\n                            break;\n\n                          case 7:\n                            _context5.prev = 7;\n                            _context5.t0 = _context5[\"catch\"](0);\n\n                            if (_context5.t0.code !== 'ERR_NOT_FOUND') {\n                              _this3._log.error('failed to query blockstore for %s: %s', cid, _context5.t0);\n                            }\n\n                          case 10:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5, null, [[0, 7]]);\n                  }));\n\n                  return function (_x7) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 3:\n                return _context6.abrupt(\"return\", res);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function _getBlocks(_x6) {\n        return _getBlocks2.apply(this, arguments);\n      }\n\n      return _getBlocks;\n    }()\n  }, {\n    key: \"_updateBlockAccounting\",\n    value: function _updateBlockAccounting(blocksMap, ledger) {\n      var _this4 = this;\n\n      blocksMap.forEach(function (b) {\n        _this4._log('got block (%s bytes)', b.data.length);\n\n        ledger.receivedBytes(b.data.length);\n      });\n    } // Clear up all accounting things after message was sent\n\n  }, {\n    key: \"messageSent\",\n    value: function messageSent(peerId, block) {\n      var ledger = this._findOrCreate(peerId);\n\n      ledger.sentBytes(block ? block.data.length : 0);\n\n      if (block && block.cid) {\n        ledger.wantlist.remove(block.cid);\n      }\n    }\n  }, {\n    key: \"numBytesSentTo\",\n    value: function numBytesSentTo(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n  }, {\n    key: \"numBytesReceivedFrom\",\n    value: function numBytesReceivedFrom(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n  }, {\n    key: \"peerDisconnected\",\n    value: function peerDisconnected(peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n      //   this.ledgerMap.delete(peerId.toB58String())\n      // }\n      //\n      // TODO: figure out how to remove all other references\n      // in the peer request queue\n    }\n  }, {\n    key: \"_findOrCreate\",\n    value: function _findOrCreate(peerId) {\n      var peerIdStr = peerId.toB58String();\n\n      if (this.ledgerMap.has(peerIdStr)) {\n        return this.ledgerMap.get(peerIdStr);\n      }\n\n      var l = new Ledger(peerId);\n      this.ledgerMap.set(peerIdStr, l);\n\n      if (this._stats) {\n        this._stats.push(peerIdStr, 'peerCount', 1);\n      }\n\n      return l;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n    }\n  }]);\n\n  return DecisionEngine;\n}();\n\nmodule.exports = DecisionEngine;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/decision-engine/index.js"],"names":["CID","require","Message","WantType","Wantlist","Ledger","RequestQueue","TaskMerger","logger","TARGET_MESSAGE_SIZE","MAX_SIZE_REPLACE_HAS_WITH_BLOCK","DecisionEngine","peerId","blockstore","network","stats","opts","_log","_stats","_opts","_processOpts","ledgerMap","Map","_running","_requestQueue","maxSizeReplaceHasWithBlock","targetMessageSize","setTimeout","_processTasks","popTasks","tasks","pendingSize","length","msg","setPendingBytes","blockCids","blockTasks","task","cid","topic","data","haveBlock","isWantBlock","push","set","addHave","addDontHave","_getBlocks","blocks","taskData","blk","get","addBlock","sendDontHave","empty","tasksDone","_scheduleProcessTasks","sendMessage","values","block","messageSent","error","peerIdStr","toB58String","has","wantlist","sortedEntries","ledger","peer","partner","toPrint","value","debtRatio","sent","accounting","bytesSent","recv","bytesRecv","exchanged","exchangeCount","Array","from","map","l","forEach","want","wantlistContains","blockSize","_sendAsBlock","wantType","entrySize","blockPresenceSize","pushTasks","toString","priority","size","_findOrCreate","full","_updateBlockAccounting","cancels","wants","entry","cancel","cancelWant","_cancelWants","_addWants","cids","c","remove","_getBlockSizes","w","blockSizes","id","Block","k","v","res","Promise","all","code","blocksMap","b","receivedBytes","sentBytes","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\n\nconst Message = require('../types/message')\nconst WantType = Message.WantType\nconst Wantlist = require('../types/wantlist')\nconst Ledger = require('./ledger')\nconst RequestQueue = require('./req-queue')\nconst TaskMerger = require('./task-merger')\nconst { logger } = require('../utils')\n\n// The ideal size of the batched payload. We try to pop this much data off the\n// request queue, but\n// - if there isn't any more data in the queue we send whatever we have\n// - if there are several small items in the queue (eg HAVE response) followed\n//   by one big item (eg a block) that would exceed this target size, we\n//   include the big item in the message\nconst TARGET_MESSAGE_SIZE = 16 * 1024\n\n// If the client sends a want-have, and the engine has the corresponding block,\n// we check the size of the block and if it's small enough we send the block\n// itself, rather than sending a HAVE.\n// This constant defines the maximum size up to which we replace a HAVE with\n// a block.\nconst MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024\n\nclass DecisionEngine {\n  constructor (peerId, blockstore, network, stats, opts) {\n    this._log = logger(peerId, 'engine')\n    this.blockstore = blockstore\n    this.network = network\n    this._stats = stats\n    this._opts = this._processOpts(opts)\n\n    // A list of of ledgers by their partner id\n    this.ledgerMap = new Map()\n    this._running = false\n\n    // Queue of want-have / want-block per peer\n    this._requestQueue = new RequestQueue(TaskMerger)\n  }\n\n  _processOpts (opts) {\n    return {\n      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,\n      targetMessageSize: TARGET_MESSAGE_SIZE,\n      ...opts\n    }\n  }\n\n  _scheduleProcessTasks () {\n    setTimeout(() => {\n      this._processTasks()\n    })\n  }\n\n  // Pull tasks off the request queue and send a message to the corresponding\n  // peer\n  async _processTasks () {\n    if (!this._running) {\n      return\n    }\n\n    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize)\n\n    if (tasks.length === 0) {\n      return\n    }\n\n    // Create a new message\n    const msg = new Message(false)\n\n    // Amount of data in the request queue still waiting to be popped\n    msg.setPendingBytes(pendingSize)\n\n    // Split out want-blocks, want-haves and DONT_HAVEs\n    const blockCids = []\n    const blockTasks = new Map()\n    for (const task of tasks) {\n      const cid = new CID(task.topic)\n      if (task.data.haveBlock) {\n        if (task.data.isWantBlock) {\n          blockCids.push(cid)\n          blockTasks.set(task.topic, task.data)\n        } else {\n          // Add HAVES to the message\n          msg.addHave(cid)\n        }\n      } else {\n        // Add DONT_HAVEs to the message\n        msg.addDontHave(cid)\n      }\n    }\n\n    const blocks = await this._getBlocks(blockCids)\n    for (const [topic, taskData] of blockTasks) {\n      const blk = blocks.get(topic)\n      // If the block was found (it has not been removed)\n      if (blk) {\n        // Add the block to the message\n        msg.addBlock(blk)\n      } else {\n        // The block was not found. If the client requested DONT_HAVE,\n        // add DONT_HAVE to the message.\n        if (taskData.sendDontHave) {\n          const cid = new CID(topic)\n          msg.addDontHave(cid)\n        }\n      }\n    }\n\n    // If there's nothing in the message, bail out\n    if (msg.empty) {\n      this._requestQueue.tasksDone(peerId, tasks)\n\n      // Trigger the next round of task processing\n      this._scheduleProcessTasks()\n\n      return\n    }\n\n    try {\n      // Send the message\n      await this.network.sendMessage(peerId, msg)\n\n      // Peform sent message accounting\n      for (const block of blocks.values()) {\n        this.messageSent(peerId, block)\n      }\n    } catch (err) {\n      this._log.error(err)\n    }\n\n    // Free the tasks up from the request queue\n    this._requestQueue.tasksDone(peerId, tasks)\n\n    // Trigger the next round of task processing\n    this._scheduleProcessTasks()\n  }\n\n  wantlistForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (!this.ledgerMap.has(peerIdStr)) {\n      return new Map()\n    }\n\n    return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries()\n  }\n\n  ledgerForPeer (peerId) {\n    const peerIdStr = peerId.toB58String()\n\n    const ledger = this.ledgerMap.get(peerIdStr)\n    if (!ledger) {\n      return null\n    }\n    return {\n      peer: ledger.partner.toPrint(),\n      value: ledger.debtRatio(),\n      sent: ledger.accounting.bytesSent,\n      recv: ledger.accounting.bytesRecv,\n      exchanged: ledger.exchangeCount\n    }\n  }\n\n  peers () {\n    return Array.from(this.ledgerMap.values()).map((l) => l.partner)\n  }\n\n  // Receive blocks either from an incoming message from the network, or from\n  // blocks being added by the client on the localhost (eg IPFS add)\n  receivedBlocks (blocks) {\n    if (!blocks.length) {\n      return\n    }\n\n    // For each connected peer, check if it wants the block we received\n    this.ledgerMap.forEach((ledger) => {\n      blocks.forEach((block) => {\n        // Filter out blocks that we don't want\n        const want = ledger.wantlistContains(block.cid)\n        if (!want) {\n          return\n        }\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const blockSize = block.data.length\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        this._requestQueue.pushTasks(ledger.partner, [{\n          topic: want.cid.toString(),\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            blockSize,\n            isWantBlock,\n            haveBlock: true,\n            sendDontHave: false\n          }\n        }])\n      })\n    })\n\n    this._scheduleProcessTasks()\n  }\n\n  // Handle incoming messages\n  async messageReceived (peerId, msg) {\n    const ledger = this._findOrCreate(peerId)\n\n    if (msg.empty) {\n      return\n    }\n\n    // If the message has a full wantlist, clear the current wantlist\n    if (msg.full) {\n      ledger.wantlist = new Wantlist()\n    }\n\n    // Record the amount of block data received\n    this._updateBlockAccounting(msg.blocks, ledger)\n\n    if (msg.wantlist.size === 0) {\n      this._scheduleProcessTasks()\n      return\n    }\n\n    // Clear cancelled wants and add new wants to the ledger\n    const cancels = []\n    const wants = []\n    msg.wantlist.forEach((entry) => {\n      if (entry.cancel) {\n        ledger.cancelWant(entry.cid)\n        cancels.push(entry.cid)\n      } else {\n        ledger.wants(entry.cid, entry.priority, entry.wantType)\n        wants.push(entry)\n      }\n    })\n\n    this._cancelWants(peerId, cancels)\n    await this._addWants(peerId, wants)\n\n    this._scheduleProcessTasks()\n  }\n\n  _cancelWants (peerId, cids) {\n    for (const c of cids) {\n      this._requestQueue.remove(c.toString(), peerId)\n    }\n  }\n\n  async _addWants (peerId, wants) {\n    // Get the size of each wanted block\n    const blockSizes = await this._getBlockSizes(wants.map(w => w.cid))\n\n    const tasks = []\n    for (const want of wants) {\n      const id = want.cid.toString()\n      const blockSize = blockSizes.get(id)\n\n      // If the block was not found\n      if (blockSize == null) {\n        // Only add the task to the queue if the requester wants a DONT_HAVE\n        if (want.sendDontHave) {\n          tasks.push({\n            topic: id,\n            priority: want.priority,\n            size: Message.blockPresenceSize(want.cid),\n            data: {\n              isWantBlock: want.wantType === WantType.Block,\n              blockSize: 0,\n              haveBlock: false,\n              sendDontHave: want.sendDontHave\n            }\n          })\n        }\n      } else {\n        // The block was found, add it to the queue\n\n        // If the block is small enough, just send the block, even if the\n        // client asked for a HAVE\n        const isWantBlock = this._sendAsBlock(want.wantType, blockSize)\n\n        // entrySize is the amount of space the entry takes up in the\n        // message we send to the recipient. If we're sending a block, the\n        // entrySize is the size of the block. Otherwise it's the size of\n        // a block presence entry.\n        let entrySize = blockSize\n        if (!isWantBlock) {\n          entrySize = Message.blockPresenceSize(want.cid)\n        }\n\n        tasks.push({\n          topic: id,\n          priority: want.priority,\n          size: entrySize,\n          data: {\n            isWantBlock,\n            blockSize,\n            haveBlock: true,\n            sendDontHave: want.sendDontHave\n          }\n        })\n      }\n\n      this._requestQueue.pushTasks(peerId, tasks)\n    }\n  }\n\n  _sendAsBlock (wantType, blockSize) {\n    return wantType === WantType.Block ||\n      blockSize <= this._opts.maxSizeReplaceHasWithBlock\n  }\n\n  async _getBlockSizes (cids) {\n    const blocks = await this._getBlocks(cids)\n    return new Map([...blocks].map(([k, v]) => [k, v.data.length]))\n  }\n\n  async _getBlocks (cids) {\n    const res = new Map()\n    await Promise.all(cids.map(async (cid) => {\n      try {\n        const block = await this.blockstore.get(cid)\n        res.set(cid.toString(), block)\n      } catch (e) {\n        if (e.code !== 'ERR_NOT_FOUND') {\n          this._log.error('failed to query blockstore for %s: %s', cid, e)\n        }\n      }\n    }))\n    return res\n  }\n\n  _updateBlockAccounting (blocksMap, ledger) {\n    blocksMap.forEach(b => {\n      this._log('got block (%s bytes)', b.data.length)\n      ledger.receivedBytes(b.data.length)\n    })\n  }\n\n  // Clear up all accounting things after message was sent\n  messageSent (peerId, block) {\n    const ledger = this._findOrCreate(peerId)\n    ledger.sentBytes(block ? block.data.length : 0)\n    if (block && block.cid) {\n      ledger.wantlist.remove(block.cid)\n    }\n  }\n\n  numBytesSentTo (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesSent\n  }\n\n  numBytesReceivedFrom (peerId) {\n    return this._findOrCreate(peerId).accounting.bytesRecv\n  }\n\n  peerDisconnected (peerId) {\n    // if (this.ledgerMap.has(peerId.toB58String())) {\n    //   this.ledgerMap.delete(peerId.toB58String())\n    // }\n    //\n    // TODO: figure out how to remove all other references\n    // in the peer request queue\n  }\n\n  _findOrCreate (peerId) {\n    const peerIdStr = peerId.toB58String()\n    if (this.ledgerMap.has(peerIdStr)) {\n      return this.ledgerMap.get(peerIdStr)\n    }\n\n    const l = new Ledger(peerId)\n\n    this.ledgerMap.set(peerIdStr, l)\n    if (this._stats) {\n      this._stats.push(peerIdStr, 'peerCount', 1)\n    }\n\n    return l\n  }\n\n  start () {\n    this._running = true\n  }\n\n  stop () {\n    this._running = false\n  }\n}\n\nmodule.exports = DecisionEngine\n"]},"metadata":{},"sourceType":"script"}