{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar debug = require('debug');\n\nvar pb = require('it-protocol-buffers');\n\nvar lp = require('it-length-prefixed');\n\nvar pipe = require('it-pipe');\n\nvar _require2 = require('streaming-iterables'),\n    collect = _require2.collect,\n    take = _require2.take,\n    consume = _require2.consume;\n\nvar PeerId = require('peer-id');\n\nvar multiaddr = require('multiaddr');\n\nvar _require3 = require('it-buffer'),\n    toBuffer = _require3.toBuffer;\n\nvar Message = require('./message');\n\nvar log = debug('libp2p:identify');\nlog.error = debug('libp2p:identify:error');\n\nvar _require4 = require('./consts'),\n    MULTICODEC_IDENTIFY = _require4.MULTICODEC_IDENTIFY,\n    MULTICODEC_IDENTIFY_PUSH = _require4.MULTICODEC_IDENTIFY_PUSH,\n    AGENT_VERSION = _require4.AGENT_VERSION,\n    PROTOCOL_VERSION = _require4.PROTOCOL_VERSION;\n\nvar errCode = require('err-code');\n\nvar _require5 = require('../errors'),\n    codes = _require5.codes;\n\nvar IdentifyService = /*#__PURE__*/function () {\n  _createClass(IdentifyService, null, [{\n    key: \"getCleanMultiaddr\",\n\n    /**\n     * Takes the `addr` and converts it to a Multiaddr if possible\n     * @param {Buffer|String} addr\n     * @returns {Multiaddr|null}\n     */\n    value: function getCleanMultiaddr(addr) {\n      if (addr && addr.length > 0) {\n        try {\n          return multiaddr(addr);\n        } catch (_) {\n          return null;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * @constructor\n     * @param {object} options\n     * @param {Libp2p} options.libp2p\n     * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n     */\n\n  }]);\n\n  function IdentifyService(_ref) {\n    var _this = this;\n\n    var libp2p = _ref.libp2p,\n        protocols = _ref.protocols;\n\n    _classCallCheck(this, IdentifyService);\n\n    /**\n     * @property {PeerStore}\n     */\n    this.peerStore = libp2p.peerStore;\n    /**\n     * @property {ConnectionManager}\n     */\n\n    this.connectionManager = libp2p.connectionManager;\n    this.connectionManager.on('peer:connect', function (connection) {\n      var peerId = connection.remotePeer;\n\n      _this.identify(connection, peerId).catch(log.error);\n    });\n    /**\n     * @property {PeerId}\n     */\n\n    this.peerId = libp2p.peerId;\n    /**\n     * @property {AddressManager}\n     */\n\n    this._libp2p = libp2p;\n    this._protocols = protocols;\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(IdentifyService, [{\n    key: \"push\",\n    value: function push(connections) {\n      var _this2 = this;\n\n      var pushes = connections.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection) {\n          var _yield$connection$new, stream;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return connection.newStream(MULTICODEC_IDENTIFY_PUSH);\n\n                case 3:\n                  _yield$connection$new = _context.sent;\n                  stream = _yield$connection$new.stream;\n                  _context.next = 7;\n                  return pipe([{\n                    listenAddrs: _this2._libp2p.multiaddrs.map(function (ma) {\n                      return ma.buffer;\n                    }),\n                    protocols: Array.from(_this2._protocols.keys())\n                  }], pb.encode(Message), stream, consume);\n\n                case 7:\n                  _context.next = 12;\n                  break;\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](0);\n                  // Just log errors\n                  log.error('could not push identify update to peer', _context.t0);\n\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 9]]);\n        }));\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      return Promise.all(pushes);\n    }\n    /**\n     * Calls `push` for all peers in the `peerStore` that are connected\n     * @param {PeerStore} peerStore\n     */\n\n  }, {\n    key: \"pushToPeerStore\",\n    value: function pushToPeerStore(peerStore) {\n      var connections = [];\n      var connection;\n\n      var _iterator = _createForOfIteratorHelper(peerStore.peers.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var peer = _step.value;\n\n          if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {\n            connections.push(connection);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.push(connections);\n    }\n    /**\n     * Requests the `Identify` message from peer associated with the given `connection`.\n     * If the identified peer does not match the `PeerId` associated with the connection,\n     * an error will be thrown.\n     *\n     * @async\n     * @param {Connection} connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"identify\",\n    value: function () {\n      var _identify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection) {\n        var _yield$connection$new2, stream, _yield$pipe, _yield$pipe2, data, message, _message, publicKey, listenAddrs, protocols, observedAddr, id;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return connection.newStream(MULTICODEC_IDENTIFY);\n\n              case 2:\n                _yield$connection$new2 = _context2.sent;\n                stream = _yield$connection$new2.stream;\n                _context2.next = 6;\n                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n              case 6:\n                _yield$pipe = _context2.sent;\n                _yield$pipe2 = _slicedToArray(_yield$pipe, 1);\n                data = _yield$pipe2[0];\n\n                if (data) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n\n              case 11:\n                _context2.prev = 11;\n                message = Message.decode(data);\n                _context2.next = 18;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t0 = _context2[\"catch\"](11);\n                throw errCode(_context2.t0, codes.ERR_INVALID_MESSAGE);\n\n              case 18:\n                _message = message, publicKey = _message.publicKey, listenAddrs = _message.listenAddrs, protocols = _message.protocols, observedAddr = _message.observedAddr;\n                _context2.next = 21;\n                return PeerId.createFromPubKey(publicKey);\n\n              case 21:\n                id = _context2.sent;\n\n                if (!(connection.remotePeer.toB58String() !== id.toB58String())) {\n                  _context2.next = 24;\n                  break;\n                }\n\n                throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n\n              case 24:\n                // Get the observedAddr if there is one\n                observedAddr = IdentifyService.getCleanMultiaddr(observedAddr); // Update peers data in PeerStore\n\n                this.peerStore.addressBook.set(id, listenAddrs.map(function (addr) {\n                  return multiaddr(addr);\n                }));\n                this.peerStore.protoBook.set(id, protocols); // TODO: Track our observed address so that we can score it\n\n                log('received observed address of %s', observedAddr);\n\n              case 28:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[11, 15]]);\n      }));\n\n      function identify(_x2) {\n        return _identify.apply(this, arguments);\n      }\n\n      return identify;\n    }()\n    /**\n     * A handler to register with Libp2p to process identify messages.\n     *\n     * @param {object} options\n     * @param {String} options.protocol\n     * @param {*} options.stream\n     * @param {Connection} options.connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(_ref3) {\n      var connection = _ref3.connection,\n          stream = _ref3.stream,\n          protocol = _ref3.protocol;\n\n      switch (protocol) {\n        case MULTICODEC_IDENTIFY:\n          return this._handleIdentify({\n            connection: connection,\n            stream: stream\n          });\n\n        case MULTICODEC_IDENTIFY_PUSH:\n          return this._handlePush({\n            connection: connection,\n            stream: stream\n          });\n\n        default:\n          log.error('cannot handle unknown protocol %s', protocol);\n      }\n    }\n    /**\n     * Sends the `Identify` response to the requesting peer over the\n     * given `connection`\n     * @private\n     * @param {object} options\n     * @param {*} options.stream\n     * @param {Connection} options.connection\n     */\n\n  }, {\n    key: \"_handleIdentify\",\n    value: function () {\n      var _handleIdentify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {\n        var connection, stream, publicKey, message;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                connection = _ref4.connection, stream = _ref4.stream;\n                publicKey = Buffer.alloc(0);\n\n                if (this.peerId.pubKey) {\n                  publicKey = this.peerId.pubKey.bytes;\n                }\n\n                message = Message.encode({\n                  protocolVersion: PROTOCOL_VERSION,\n                  agentVersion: AGENT_VERSION,\n                  publicKey: publicKey,\n                  listenAddrs: this._libp2p.multiaddrs.map(function (ma) {\n                    return ma.buffer;\n                  }),\n                  observedAddr: connection.remoteAddr.buffer,\n                  protocols: Array.from(this._protocols.keys())\n                });\n                _context3.prev = 4;\n                _context3.next = 7;\n                return pipe([message], lp.encode(), stream, consume);\n\n              case 7:\n                _context3.next = 12;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](4);\n                log.error('could not respond to identify request', _context3.t0);\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 9]]);\n      }));\n\n      function _handleIdentify(_x3) {\n        return _handleIdentify2.apply(this, arguments);\n      }\n\n      return _handleIdentify;\n    }()\n    /**\n     * Reads the Identify Push message from the given `connection`\n     * @private\n     * @param {object} options\n     * @param {*} options.stream\n     * @param {Connection} options.connection\n     */\n\n  }, {\n    key: \"_handlePush\",\n    value: function () {\n      var _handlePush2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n        var connection, stream, message, _yield$pipe3, _yield$pipe4, data, id;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                connection = _ref5.connection, stream = _ref5.stream;\n                _context4.prev = 1;\n                _context4.next = 4;\n                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n              case 4:\n                _yield$pipe3 = _context4.sent;\n                _yield$pipe4 = _slicedToArray(_yield$pipe3, 1);\n                data = _yield$pipe4[0];\n                message = Message.decode(data);\n                _context4.next = 13;\n                break;\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](1);\n                return _context4.abrupt(\"return\", log.error('received invalid message', _context4.t0));\n\n              case 13:\n                // Update peers data in PeerStore\n                id = connection.remotePeer;\n                _context4.prev = 14;\n                this.peerStore.addressBook.set(id, message.listenAddrs.map(function (addr) {\n                  return multiaddr(addr);\n                }));\n                _context4.next = 21;\n                break;\n\n              case 18:\n                _context4.prev = 18;\n                _context4.t1 = _context4[\"catch\"](14);\n                return _context4.abrupt(\"return\", log.error('received invalid listen addrs', _context4.t1));\n\n              case 21:\n                // Update the protocols\n                this.peerStore.protoBook.set(id, message.protocols);\n\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 10], [14, 18]]);\n      }));\n\n      function _handlePush(_x4) {\n        return _handlePush2.apply(this, arguments);\n      }\n\n      return _handlePush;\n    }()\n  }]);\n\n  return IdentifyService;\n}();\n\nmodule.exports.IdentifyService = IdentifyService;\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\n\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nmodule.exports.Message = Message;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/identify/index.js"],"names":["require","Buffer","debug","pb","lp","pipe","collect","take","consume","PeerId","multiaddr","toBuffer","Message","log","error","MULTICODEC_IDENTIFY","MULTICODEC_IDENTIFY_PUSH","AGENT_VERSION","PROTOCOL_VERSION","errCode","codes","IdentifyService","addr","length","_","libp2p","protocols","peerStore","connectionManager","on","connection","peerId","remotePeer","identify","catch","_libp2p","_protocols","handleMessage","bind","connections","pushes","map","newStream","stream","listenAddrs","multiaddrs","ma","buffer","Array","from","keys","encode","Promise","all","peers","values","peer","includes","get","id","push","decode","data","Error","ERR_CONNECTION_ENDED","message","ERR_INVALID_MESSAGE","publicKey","observedAddr","createFromPubKey","toB58String","ERR_INVALID_PEER","getCleanMultiaddr","addressBook","set","protoBook","protocol","_handleIdentify","_handlePush","alloc","pubKey","bytes","protocolVersion","agentVersion","remoteAddr","module","exports","multicodecs","IDENTIFY","IDENTIFY_PUSH"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst debug = require('debug')\nconst pb = require('it-protocol-buffers')\nconst lp = require('it-length-prefixed')\nconst pipe = require('it-pipe')\nconst { collect, take, consume } = require('streaming-iterables')\n\nconst PeerId = require('peer-id')\nconst multiaddr = require('multiaddr')\nconst { toBuffer } = require('it-buffer')\n\nconst Message = require('./message')\n\nconst log = debug('libp2p:identify')\nlog.error = debug('libp2p:identify:error')\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  AGENT_VERSION,\n  PROTOCOL_VERSION\n} = require('./consts')\n\nconst errCode = require('err-code')\nconst { codes } = require('../errors')\n\nclass IdentifyService {\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   * @param {Buffer|String} addr\n   * @returns {Multiaddr|null}\n   */\n  static getCleanMultiaddr (addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return multiaddr(addr)\n      } catch (_) {\n        return null\n      }\n    }\n    return null\n  }\n\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   */\n  constructor ({ libp2p, protocols }) {\n    /**\n     * @property {PeerStore}\n     */\n    this.peerStore = libp2p.peerStore\n\n    /**\n     * @property {ConnectionManager}\n     */\n    this.connectionManager = libp2p.connectionManager\n\n    this.connectionManager.on('peer:connect', (connection) => {\n      const peerId = connection.remotePeer\n\n      this.identify(connection, peerId).catch(log.error)\n    })\n\n    /**\n     * @property {PeerId}\n     */\n    this.peerId = libp2p.peerId\n\n    /**\n     * @property {AddressManager}\n     */\n    this._libp2p = libp2p\n\n    this._protocols = protocols\n\n    this.handleMessage = this.handleMessage.bind(this)\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n  push (connections) {\n    const pushes = connections.map(async connection => {\n      try {\n        const { stream } = await connection.newStream(MULTICODEC_IDENTIFY_PUSH)\n\n        await pipe(\n          [{\n            listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.buffer),\n            protocols: Array.from(this._protocols.keys())\n          }],\n          pb.encode(Message),\n          stream,\n          consume\n        )\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err)\n      }\n    })\n\n    return Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   * @param {PeerStore} peerStore\n   */\n  pushToPeerStore (peerStore) {\n    const connections = []\n    let connection\n    for (const peer of peerStore.peers.values()) {\n      if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {\n        connections.push(connection)\n      }\n    }\n\n    this.push(connections)\n  }\n\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n  async identify (connection) {\n    const { stream } = await connection.newStream(MULTICODEC_IDENTIFY)\n    const [data] = await pipe(\n      [],\n      stream,\n      lp.decode(),\n      take(1),\n      toBuffer,\n      collect\n    )\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED)\n    }\n\n    let message\n    try {\n      message = Message.decode(data)\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE)\n    }\n\n    let {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr\n    } = message\n\n    const id = await PeerId.createFromPubKey(publicKey)\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER)\n    }\n\n    // Get the observedAddr if there is one\n    observedAddr = IdentifyService.getCleanMultiaddr(observedAddr)\n\n    // Update peers data in PeerStore\n    this.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)))\n    this.peerStore.protoBook.set(id, protocols)\n\n    // TODO: Track our observed address so that we can score it\n    log('received observed address of %s', observedAddr)\n  }\n\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {object} options\n   * @param {String} options.protocol\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n  handleMessage ({ connection, stream, protocol }) {\n    switch (protocol) {\n      case MULTICODEC_IDENTIFY:\n        return this._handleIdentify({ connection, stream })\n      case MULTICODEC_IDENTIFY_PUSH:\n        return this._handlePush({ connection, stream })\n      default:\n        log.error('cannot handle unknown protocol %s', protocol)\n    }\n  }\n\n  /**\n   * Sends the `Identify` response to the requesting peer over the\n   * given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n  async _handleIdentify ({ connection, stream }) {\n    let publicKey = Buffer.alloc(0)\n    if (this.peerId.pubKey) {\n      publicKey = this.peerId.pubKey.bytes\n    }\n\n    const message = Message.encode({\n      protocolVersion: PROTOCOL_VERSION,\n      agentVersion: AGENT_VERSION,\n      publicKey,\n      listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.buffer),\n      observedAddr: connection.remoteAddr.buffer,\n      protocols: Array.from(this._protocols.keys())\n    })\n\n    try {\n      await pipe(\n        [message],\n        lp.encode(),\n        stream,\n        consume\n      )\n    } catch (err) {\n      log.error('could not respond to identify request', err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n  async _handlePush ({ connection, stream }) {\n    let message\n    try {\n      const [data] = await pipe(\n        [],\n        stream,\n        lp.decode(),\n        take(1),\n        toBuffer,\n        collect\n      )\n      message = Message.decode(data)\n    } catch (err) {\n      return log.error('received invalid message', err)\n    }\n\n    // Update peers data in PeerStore\n    const id = connection.remotePeer\n    try {\n      this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => multiaddr(addr)))\n    } catch (err) {\n      return log.error('received invalid listen addrs', err)\n    }\n\n    // Update the protocols\n    this.peerStore.protoBook.set(id, message.protocols)\n  }\n}\n\nmodule.exports.IdentifyService = IdentifyService\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\nmodule.exports.Message = Message\n"]},"metadata":{},"sourceType":"script"}