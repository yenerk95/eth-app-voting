{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:peer-store:address-book');\nlog.error = debug('libp2p:peer-store:address-book:error');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst Book = require('./book');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('../errors');\n/**\n * The AddressBook is responsible for keeping the known multiaddrs\n * of a peer.\n */\n\n\nclass AddressBook extends Book {\n  /**\n   * Address object\n   * @typedef {Object} Address\n   * @property {Multiaddr} multiaddr peer multiaddr.\n   */\n\n  /**\n  * @constructor\n  * @param {PeerStore} peerStore\n  */\n  constructor(peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: data => data.map(address => address.multiaddr)\n    });\n    /**\n     * Map known peers to their known Addresses.\n     * @type {Map<string, Array<Address>>}\n     */\n\n    this.data = new Map();\n  }\n  /**\n   * Set known multiaddrs of a provided peer.\n   * @override\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  set(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs);\n\n    const id = peerId.toB58String();\n    const rec = this.data.get(id); // Not replace multiaddrs\n\n    if (!addresses.length) {\n      return this;\n    } // Already knows the peer\n\n\n    if (rec && rec.length === addresses.length) {\n      const intersection = rec.filter(mi => addresses.some(newMi => mi.multiaddr.equals(newMi.multiaddr))); // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n\n      if (intersection.length === rec.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`);\n        return this;\n      }\n    }\n\n    this._setData(peerId, addresses);\n\n    log(`stored provided multiaddrs for ${id}`); // Notify the existance of a new peer\n\n    if (!rec) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  add(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs);\n\n    const id = peerId.toB58String();\n    const rec = this.data.get(id); // Add recorded uniquely to the new array (Union)\n\n    rec && rec.forEach(mi => {\n      if (!addresses.find(r => r.multiaddr.equals(mi.multiaddr))) {\n        addresses.push(mi);\n      }\n    }); // If the recorded length is equal to the new after the unique union\n    // The content is the same, no need to update.\n\n    if (rec && rec.length === addresses.length) {\n      log(`the addresses provided to store are already stored for ${id}`);\n      return this;\n    }\n\n    this._setData(peerId, addresses);\n\n    log(`added provided multiaddrs for ${id}`); // Notify the existance of a new peer\n\n    if (!rec) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Transforms received multiaddrs into Address.\n   * @private\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {Array<Address>}\n   */\n\n\n  _toAddresses(multiaddrs) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data');\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);\n    } // create Address for each address\n\n\n    const addresses = [];\n    multiaddrs.forEach(addr => {\n      if (!multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`);\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS);\n      }\n\n      addresses.push({\n        multiaddr: addr\n      });\n    });\n    return addresses;\n  }\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  getMultiaddrsForPeer(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const record = this.data.get(peerId.toB58String());\n\n    if (!record) {\n      return undefined;\n    }\n\n    return record.map(address => {\n      const multiaddr = address.multiaddr;\n      const idString = multiaddr.getPeerId();\n      if (idString && idString === peerId.toB58String()) return multiaddr;\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);\n    });\n  }\n\n}\n\nmodule.exports = AddressBook;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/peer-store/address-book.js"],"names":["errcode","require","debug","log","error","multiaddr","PeerId","Book","codes","ERR_INVALID_PARAMETERS","AddressBook","constructor","peerStore","eventName","eventProperty","eventTransformer","data","map","address","Map","set","peerId","multiaddrs","isPeerId","Error","addresses","_toAddresses","id","toB58String","rec","get","length","intersection","filter","mi","some","newMi","equals","_setData","_ps","emit","add","forEach","find","r","push","addr","isMultiaddr","getMultiaddrsForPeer","record","undefined","idString","getPeerId","encapsulate","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst debug = require('debug')\nconst log = debug('libp2p:peer-store:address-book')\nlog.error = debug('libp2p:peer-store:address-book:error')\n\nconst multiaddr = require('multiaddr')\nconst PeerId = require('peer-id')\n\nconst Book = require('./book')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\n\n/**\n * The AddressBook is responsible for keeping the known multiaddrs\n * of a peer.\n */\nclass AddressBook extends Book {\n  /**\n   * Address object\n   * @typedef {Object} Address\n   * @property {Multiaddr} multiaddr peer multiaddr.\n   */\n\n  /**\n  * @constructor\n  * @param {PeerStore} peerStore\n  */\n  constructor (peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: (data) => data.map((address) => address.multiaddr)\n    })\n\n    /**\n     * Map known peers to their known Addresses.\n     * @type {Map<string, Array<Address>>}\n     */\n    this.data = new Map()\n  }\n\n  /**\n   * Set known multiaddrs of a provided peer.\n   * @override\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n  set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n    const rec = this.data.get(id)\n\n    // Not replace multiaddrs\n    if (!addresses.length) {\n      return this\n    }\n\n    // Already knows the peer\n    if (rec && rec.length === addresses.length) {\n      const intersection = rec.filter((mi) => addresses.some((newMi) => mi.multiaddr.equals(newMi.multiaddr)))\n\n      // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n      if (intersection.length === rec.length) {\n        log(`the addresses provided to store are equal to the already stored for ${id}`)\n        return this\n      }\n    }\n\n    this._setData(peerId, addresses)\n    log(`stored provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!rec) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   * @param {PeerId} peerId\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {AddressBook}\n   */\n  add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const addresses = this._toAddresses(multiaddrs)\n    const id = peerId.toB58String()\n    const rec = this.data.get(id)\n\n    // Add recorded uniquely to the new array (Union)\n    rec && rec.forEach((mi) => {\n      if (!addresses.find(r => r.multiaddr.equals(mi.multiaddr))) {\n        addresses.push(mi)\n      }\n    })\n\n    // If the recorded length is equal to the new after the unique union\n    // The content is the same, no need to update.\n    if (rec && rec.length === addresses.length) {\n      log(`the addresses provided to store are already stored for ${id}`)\n      return this\n    }\n\n    this._setData(peerId, addresses)\n\n    log(`added provided multiaddrs for ${id}`)\n\n    // Notify the existance of a new peer\n    if (!rec) {\n      this._ps.emit('peer', peerId)\n    }\n\n    return this\n  }\n\n  /**\n   * Transforms received multiaddrs into Address.\n   * @private\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {Array<Address>}\n   */\n  _toAddresses (multiaddrs) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data')\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS)\n    }\n\n    // create Address for each address\n    const addresses = []\n    multiaddrs.forEach((addr) => {\n      if (!multiaddr.isMultiaddr(addr)) {\n        log.error(`multiaddr ${addr} must be an instance of multiaddr`)\n        throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS)\n      }\n\n      addresses.push({\n        multiaddr: addr\n      })\n    })\n\n    return addresses\n  }\n\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * @param {PeerId} peerId\n   * @returns {Array<Multiaddr>}\n   */\n  getMultiaddrsForPeer (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const record = this.data.get(peerId.toB58String())\n\n    if (!record) {\n      return undefined\n    }\n\n    return record.map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\nmodule.exports = AddressBook\n"]},"metadata":{},"sourceType":"script"}