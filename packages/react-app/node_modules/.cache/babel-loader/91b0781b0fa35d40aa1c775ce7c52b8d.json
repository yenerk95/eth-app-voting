{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(cborCids);\n\nvar multihashes = require('multihashing-async').multihash;\n\nvar CID = require('cids');\n\nvar protobuf = require('protons');\n\nvar fnv1a = require('fnv1a');\n\nvar varint = require('varint');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar multicodec = require('multicodec');\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar dagCborLinks = require('dag-cbor-links');\n\nvar log = require('debug')('ipfs:pin:pin-set');\n\nvar pbSchema = require('./pin.proto');\n\nvar _require3 = require('buffer'),\n    Buffer = _require3.Buffer;\n\nvar emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n';\nvar emptyKey = multihashes.fromB58String(emptyKeyHash);\nvar defaultFanout = 256;\nvar maxItems = 8192;\nvar pb = protobuf(pbSchema);\nvar HAS_DESCENDANT_CONCURRENCY = 100;\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  var rootData = rootNode.Data;\n  var hdrLength = varint.decode(rootData);\n  var vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  var hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  var header = pb.Set.decode(hdrSlice);\n\n  if (header.version !== 1) {\n    throw new Error(\"Unsupported Set version: \".concat(header.version));\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(seed, 0);\n  var data = Buffer.concat([buf, Buffer.from(toB58String(key))]);\n  return fnv1a(data.toString('binary'));\n}\n\nfunction cborCids(node) {\n  var _iterator, _step, _step$value, _, cid;\n\n  return _regeneratorRuntime.wrap(function cborCids$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator = _createForOfIteratorHelper(dagCborLinks(node));\n          _context.prev = 1;\n\n          _iterator.s();\n\n        case 3:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 9;\n            break;\n          }\n\n          _step$value = _slicedToArray(_step.value, 2), _ = _step$value[0], cid = _step$value[1];\n          _context.next = 7;\n          return cid;\n\n        case 7:\n          _context.next = 3;\n          break;\n\n        case 9:\n          _context.next = 14;\n          break;\n\n        case 11:\n          _context.prev = 11;\n          _context.t0 = _context[\"catch\"](1);\n\n          _iterator.e(_context.t0);\n\n        case 14:\n          _context.prev = 14;\n\n          _iterator.f();\n\n          return _context.finish(14);\n\n        case 17:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 11, 14, 17]]);\n}\n\nexports = module.exports = function (dag) {\n  var pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: function () {\n      var _hasDescendant = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(parentCid, childhash) {\n        var _yield$dag$get, root, queue, found, seen, searchChild, searchChildren;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                searchChildren = function _searchChildren(cid, node) {\n                  var links = [];\n\n                  if (cid.codec === 'dag-pb') {\n                    links = node.Links;\n                  } else if (cid.codec === 'dag-cbor') {\n                    links = cborCids(node);\n                  }\n\n                  var _iterator2 = _createForOfIteratorHelper(links),\n                      _step2;\n\n                  try {\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      var link = _step2.value;\n                      var linkCid = cid.codec === 'dag-pb' ? link.Hash : link[1];\n                      var bs58Link = toB58String(linkCid);\n\n                      if (bs58Link === childhash) {\n                        queue.clear();\n                        found = true;\n                        return;\n                      }\n\n                      if (seen[bs58Link]) {\n                        continue;\n                      }\n\n                      seen[bs58Link] = true;\n\n                      if (linkCid.codec !== 'dag-pb' && linkCid.codec !== 'dag-cbor') {\n                        continue;\n                      }\n\n                      queue.add(searchChild(linkCid));\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                };\n\n                searchChild = function _searchChild(linkCid) {\n                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var _yield$dag$get2, childNode;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            if (!found) {\n                              _context2.next = 2;\n                              break;\n                            }\n\n                            return _context2.abrupt(\"return\");\n\n                          case 2:\n                            _context2.prev = 2;\n                            _context2.next = 5;\n                            return dag.get(linkCid, {\n                              preload: false\n                            });\n\n                          case 5:\n                            _yield$dag$get2 = _context2.sent;\n                            childNode = _yield$dag$get2.value;\n                            searchChildren(linkCid, childNode);\n                            _context2.next = 13;\n                            break;\n\n                          case 10:\n                            _context2.prev = 10;\n                            _context2.t0 = _context2[\"catch\"](2);\n                            log(_context2.t0);\n\n                          case 13:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee, null, [[2, 10]]);\n                  }));\n                };\n\n                if (!(parentCid.codec !== 'dag-pb' && parentCid.codec !== 'dag-cbor')) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", false);\n\n              case 4:\n                _context3.next = 6;\n                return dag.get(parentCid, {\n                  preload: false\n                });\n\n              case 6:\n                _yield$dag$get = _context3.sent;\n                root = _yield$dag$get.value;\n                queue = new Queue({\n                  concurrency: HAS_DESCENDANT_CONCURRENCY\n                });\n\n                if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n                  childhash = toB58String(childhash);\n                }\n\n                found = false;\n                seen = {};\n                searchChildren(parentCid, root);\n                _context3.next = 15;\n                return queue.onIdle();\n\n              case 15:\n                return _context3.abrupt(\"return\", found);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function hasDescendant(_x, _x2) {\n        return _hasDescendant.apply(this, arguments);\n      }\n\n      return hasDescendant;\n    }(),\n    storeSet: function () {\n      var _storeSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(keys) {\n        var pins, rootNode, cid;\n        return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                pins = keys.map(function (key) {\n                  if (typeof key === 'string' || Buffer.isBuffer(key)) {\n                    key = new CID(key);\n                  }\n\n                  return {\n                    key: key,\n                    data: null\n                  };\n                });\n                _context4.next = 3;\n                return pinSet.storeItems(pins);\n\n              case 3:\n                rootNode = _context4.sent;\n                _context4.next = 6;\n                return dag.put(rootNode, {\n                  version: 0,\n                  format: multicodec.DAG_PB,\n                  hashAlg: multicodec.SHA2_256,\n                  preload: false\n                });\n\n              case 6:\n                cid = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  node: rootNode,\n                  cid: cid\n                });\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function storeSet(_x3) {\n        return _storeSet.apply(this, arguments);\n      }\n\n      return storeSet;\n    }(),\n    storeItems: function () {\n      var _storeItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(items) {\n        var storePins, _storePins;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _storePins = function _storePins3() {\n                  _storePins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(pins, depth) {\n                    var pbHeader, headerBuf, fanoutLinks, i, nodes, rootLinks, rootData, bins, idx, _iterator3, _step3, bin, child, storeChild, _storeChild;\n\n                    return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _storeChild = function _storeChild3() {\n                              _storeChild = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(child, binIdx) {\n                                var opts, cid;\n                                return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n                                  while (1) {\n                                    switch (_context5.prev = _context5.next) {\n                                      case 0:\n                                        opts = {\n                                          version: 0,\n                                          format: multicodec.DAG_PB,\n                                          hashAlg: multicodec.SHA2_256,\n                                          preload: false\n                                        };\n                                        _context5.next = 3;\n                                        return dag.put(child, opts);\n\n                                      case 3:\n                                        cid = _context5.sent;\n                                        fanoutLinks[binIdx] = new DAGLink('', child.size, cid);\n\n                                      case 5:\n                                      case \"end\":\n                                        return _context5.stop();\n                                    }\n                                  }\n                                }, _callee4);\n                              }));\n                              return _storeChild.apply(this, arguments);\n                            };\n\n                            storeChild = function _storeChild2(_x7, _x8) {\n                              return _storeChild.apply(this, arguments);\n                            };\n\n                            pbHeader = pb.Set.encode({\n                              version: 1,\n                              fanout: defaultFanout,\n                              seed: depth\n                            });\n                            headerBuf = Buffer.concat([Buffer.from(varint.encode(pbHeader.length)), pbHeader]);\n                            fanoutLinks = [];\n\n                            for (i = 0; i < defaultFanout; i++) {\n                              fanoutLinks.push(new DAGLink('', 1, emptyKey));\n                            }\n\n                            if (!(pins.length <= maxItems)) {\n                              _context6.next = 13;\n                              break;\n                            }\n\n                            nodes = pins.map(function (item) {\n                              return {\n                                link: new DAGLink('', 1, item.key),\n                                data: item.data || Buffer.alloc(0)\n                              };\n                            }) // sorting makes any ordering of `pins` produce the same DAGNode\n                            .sort(function (a, b) {\n                              return Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer);\n                            });\n                            rootLinks = fanoutLinks.concat(nodes.map(function (item) {\n                              return item.link;\n                            }));\n                            rootData = Buffer.concat([headerBuf].concat(nodes.map(function (item) {\n                              return item.data;\n                            })));\n                            return _context6.abrupt(\"return\", new DAGNode(rootData, rootLinks));\n\n                          case 13:\n                            // If the array of pins is > maxItems, we:\n                            //  - distribute the pins among `defaultFanout` bins\n                            //    - create a DAGNode for each bin\n                            //      - add each pin as a DAGLink to that bin\n                            //  - create a root DAGNode\n                            //    - add each bin as a DAGLink\n                            //  - send that root DAGNode via callback\n                            // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n                            // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n                            bins = pins.reduce(function (bins, pin) {\n                              var n = hash(depth, pin.key) % defaultFanout;\n                              bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n                              return bins;\n                            }, []);\n                            idx = 0;\n                            _iterator3 = _createForOfIteratorHelper(bins);\n                            _context6.prev = 16;\n\n                            _iterator3.s();\n\n                          case 18:\n                            if ((_step3 = _iterator3.n()).done) {\n                              _context6.next = 28;\n                              break;\n                            }\n\n                            bin = _step3.value;\n                            _context6.next = 22;\n                            return storePins(bin, depth + 1);\n\n                          case 22:\n                            child = _context6.sent;\n                            _context6.next = 25;\n                            return storeChild(child, idx);\n\n                          case 25:\n                            idx++;\n\n                          case 26:\n                            _context6.next = 18;\n                            break;\n\n                          case 28:\n                            _context6.next = 33;\n                            break;\n\n                          case 30:\n                            _context6.prev = 30;\n                            _context6.t0 = _context6[\"catch\"](16);\n\n                            _iterator3.e(_context6.t0);\n\n                          case 33:\n                            _context6.prev = 33;\n\n                            _iterator3.f();\n\n                            return _context6.finish(33);\n\n                          case 36:\n                            return _context6.abrupt(\"return\", new DAGNode(headerBuf, fanoutLinks));\n\n                          case 37:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee5, null, [[16, 30, 33, 36]]);\n                  }));\n                  return _storePins.apply(this, arguments);\n                };\n\n                storePins = function _storePins2(_x5, _x6) {\n                  return _storePins.apply(this, arguments);\n                };\n\n                return _context7.abrupt(\"return\", storePins(items, 0));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function storeItems(_x4) {\n        return _storeItems.apply(this, arguments);\n      }\n\n      return storeItems;\n    }(),\n    loadSet: function () {\n      var _loadSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(rootNode, name) {\n        var link, res, keys, stepPin;\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                link = rootNode.Links.find(function (l) {\n                  return l.Name === name;\n                });\n\n                if (link) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw new Error('No link found with name ' + name);\n\n              case 3:\n                _context8.next = 5;\n                return dag.get(link.Hash, '', {\n                  preload: false\n                });\n\n              case 5:\n                res = _context8.sent;\n                keys = [];\n\n                stepPin = function stepPin(link) {\n                  return keys.push(link.Hash);\n                };\n\n                _context8.next = 10;\n                return pinSet.walkItems(res.value, {\n                  stepPin: stepPin\n                });\n\n              case 10:\n                return _context8.abrupt(\"return\", keys);\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function loadSet(_x9, _x10) {\n        return _loadSet.apply(this, arguments);\n      }\n\n      return loadSet;\n    }(),\n    walkItems: function () {\n      var _walkItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(node, _ref2) {\n        var _ref2$stepPin, stepPin, _ref2$stepBin, stepBin, pbh, idx, _iterator4, _step4, link, linkHash, res;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _ref2$stepPin = _ref2.stepPin, stepPin = _ref2$stepPin === void 0 ? function () {} : _ref2$stepPin, _ref2$stepBin = _ref2.stepBin, stepBin = _ref2$stepBin === void 0 ? function () {} : _ref2$stepBin;\n                pbh = readHeader(node);\n                idx = 0;\n                _iterator4 = _createForOfIteratorHelper(node.Links);\n                _context9.prev = 4;\n\n                _iterator4.s();\n\n              case 6:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                link = _step4.value;\n\n                if (!(idx < pbh.header.fanout)) {\n                  _context9.next = 19;\n                  break;\n                }\n\n                // the first pbh.header.fanout links are fanout bins\n                // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n                linkHash = link.Hash.buffer;\n\n                if (emptyKey.equals(linkHash)) {\n                  _context9.next = 17;\n                  break;\n                }\n\n                stepBin(link, idx, pbh.data); // walk the links of this fanout bin\n\n                _context9.next = 14;\n                return dag.get(linkHash, '', {\n                  preload: false\n                });\n\n              case 14:\n                res = _context9.sent;\n                _context9.next = 17;\n                return pinSet.walkItems(res.value, {\n                  stepPin: stepPin,\n                  stepBin: stepBin\n                });\n\n              case 17:\n                _context9.next = 20;\n                break;\n\n              case 19:\n                // otherwise, the link is a pin\n                stepPin(link, idx, pbh.data);\n\n              case 20:\n                idx++;\n\n              case 21:\n                _context9.next = 6;\n                break;\n\n              case 23:\n                _context9.next = 28;\n                break;\n\n              case 25:\n                _context9.prev = 25;\n                _context9.t0 = _context9[\"catch\"](4);\n\n                _iterator4.e(_context9.t0);\n\n              case 28:\n                _context9.prev = 28;\n\n                _iterator4.f();\n\n                return _context9.finish(28);\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee8, null, [[4, 25, 28, 31]]);\n      }));\n\n      function walkItems(_x11, _x12) {\n        return _walkItems.apply(this, arguments);\n      }\n\n      return walkItems;\n    }(),\n    getInternalCids: function () {\n      var _getInternalCids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(rootNode) {\n        var cids, stepBin, _iterator5, _step5, topLevelLink, res;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                // \"Empty block\" used by the pinner\n                cids = [new CID(emptyKey)];\n\n                stepBin = function stepBin(link) {\n                  return cids.push(link.Hash);\n                };\n\n                _iterator5 = _createForOfIteratorHelper(rootNode.Links);\n                _context10.prev = 3;\n\n                _iterator5.s();\n\n              case 5:\n                if ((_step5 = _iterator5.n()).done) {\n                  _context10.next = 15;\n                  break;\n                }\n\n                topLevelLink = _step5.value;\n                cids.push(topLevelLink.Hash);\n                _context10.next = 10;\n                return dag.get(topLevelLink.Hash, '', {\n                  preload: false\n                });\n\n              case 10:\n                res = _context10.sent;\n                _context10.next = 13;\n                return pinSet.walkItems(res.value, {\n                  stepBin: stepBin\n                });\n\n              case 13:\n                _context10.next = 5;\n                break;\n\n              case 15:\n                _context10.next = 20;\n                break;\n\n              case 17:\n                _context10.prev = 17;\n                _context10.t0 = _context10[\"catch\"](3);\n\n                _iterator5.e(_context10.t0);\n\n              case 20:\n                _context10.prev = 20;\n\n                _iterator5.f();\n\n                return _context10.finish(20);\n\n              case 23:\n                return _context10.abrupt(\"return\", cids);\n\n              case 24:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee9, null, [[3, 17, 20, 23]]);\n      }));\n\n      function getInternalCids(_x13) {\n        return _getInternalCids.apply(this, arguments);\n      }\n\n      return getInternalCids;\n    }()\n  };\n  return pinSet;\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/pin/pin-set.js"],"names":["cborCids","multihashes","require","multihash","CID","protobuf","fnv1a","varint","DAGNode","DAGLink","multicodec","Queue","default","dagCborLinks","log","pbSchema","Buffer","emptyKeyHash","emptyKey","fromB58String","defaultFanout","maxItems","pb","HAS_DESCENDANT_CONCURRENCY","toB58String","hash","toBaseEncodedString","readHeader","rootNode","rootData","Data","hdrLength","decode","vBytes","bytes","Error","length","hdrSlice","slice","header","Set","version","fanout","Links","data","seed","key","buf","alloc","writeUInt32LE","concat","from","toString","node","_","cid","exports","module","dag","pinSet","hasDescendant","parentCid","childhash","searchChild","searchChildren","links","codec","link","linkCid","Hash","bs58Link","queue","clear","found","seen","add","get","preload","childNode","value","root","concurrency","isCID","isBuffer","onIdle","storeSet","keys","pins","map","storeItems","put","format","DAG_PB","hashAlg","SHA2_256","items","storePins","depth","storeChild","child","binIdx","opts","fanoutLinks","size","pbHeader","encode","headerBuf","i","push","nodes","item","sort","a","b","compare","buffer","rootLinks","bins","reduce","pin","n","idx","bin","loadSet","name","find","l","Name","res","stepPin","walkItems","stepBin","pbh","linkHash","equals","getInternalCids","cids","topLevelLink"],"mappings":"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","sourcesContent":["'use strict'\n\nconst multihashes = require('multihashing-async').multihash\nconst CID = require('cids')\nconst protobuf = require('protons')\nconst fnv1a = require('fnv1a')\nconst varint = require('varint')\nconst { DAGNode, DAGLink } = require('ipld-dag-pb')\nconst multicodec = require('multicodec')\nconst { default: Queue } = require('p-queue')\nconst dagCborLinks = require('dag-cbor-links')\nconst log = require('debug')('ipfs:pin:pin-set')\nconst pbSchema = require('./pin.proto')\nconst { Buffer } = require('buffer')\n\nconst emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'\nconst emptyKey = multihashes.fromB58String(emptyKeyHash)\nconst defaultFanout = 256\nconst maxItems = 8192\nconst pb = protobuf(pbSchema)\n\nconst HAS_DESCENDANT_CONCURRENCY = 100\n\nfunction toB58String (hash) {\n  return new CID(hash).toBaseEncodedString()\n}\n\nfunction readHeader (rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  const rootData = rootNode.Data\n  const hdrLength = varint.decode(rootData)\n  const vBytes = varint.decode.bytes\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length')\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length')\n  }\n\n  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes)\n  const header = pb.Set.decode(hdrSlice)\n\n  if (header.version !== 1) {\n    throw new Error(`Unsupported Set version: ${header.version}`)\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout')\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  }\n}\n\nfunction hash (seed, key) {\n  const buf = Buffer.alloc(4)\n  buf.writeUInt32LE(seed, 0)\n  const data = Buffer.concat([\n    buf, Buffer.from(toB58String(key))\n  ])\n  return fnv1a(data.toString('binary'))\n}\n\nfunction * cborCids (node) {\n  for (const [_, cid] of dagCborLinks(node)) { // eslint-disable-line no-unused-vars\n    yield cid\n  }\n}\n\nexports = module.exports = function (dag) {\n  const pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: async (parentCid, childhash) => {\n      if (parentCid.codec !== 'dag-pb' && parentCid.codec !== 'dag-cbor') {\n        return false\n      }\n\n      const { value: root } = await dag.get(parentCid, { preload: false })\n      const queue = new Queue({\n        concurrency: HAS_DESCENDANT_CONCURRENCY\n      })\n\n      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n        childhash = toB58String(childhash)\n      }\n\n      let found = false\n      const seen = {}\n\n      function searchChild (linkCid) {\n        return async () => {\n          if (found) {\n            return\n          }\n\n          try {\n            const { value: childNode } = await dag.get(linkCid, { preload: false })\n\n            searchChildren(linkCid, childNode)\n          } catch (err) {\n            log(err)\n          }\n        }\n      }\n\n      function searchChildren (cid, node) {\n        let links = []\n\n        if (cid.codec === 'dag-pb') {\n          links = node.Links\n        } else if (cid.codec === 'dag-cbor') {\n          links = cborCids(node)\n        }\n\n        for (const link of links) {\n          const linkCid = cid.codec === 'dag-pb' ? link.Hash : link[1]\n          const bs58Link = toB58String(linkCid)\n\n          if (bs58Link === childhash) {\n            queue.clear()\n            found = true\n\n            return\n          }\n\n          if (seen[bs58Link]) {\n            continue\n          }\n\n          seen[bs58Link] = true\n\n          if (linkCid.codec !== 'dag-pb' && linkCid.codec !== 'dag-cbor') {\n            continue\n          }\n\n          queue.add(searchChild(linkCid))\n        }\n      }\n\n      searchChildren(parentCid, root)\n\n      await queue.onIdle()\n\n      return found\n    },\n\n    storeSet: async (keys) => {\n      const pins = keys.map(key => {\n        if (typeof key === 'string' || Buffer.isBuffer(key)) {\n          key = new CID(key)\n        }\n\n        return {\n          key: key,\n          data: null\n        }\n      })\n\n      const rootNode = await pinSet.storeItems(pins)\n      const cid = await dag.put(rootNode, {\n        version: 0,\n        format: multicodec.DAG_PB,\n        hashAlg: multicodec.SHA2_256,\n        preload: false\n      })\n\n      return {\n        node: rootNode,\n        cid\n      }\n    },\n\n    storeItems: async (items) => { // eslint-disable-line require-await\n      return storePins(items, 0)\n\n      async function storePins (pins, depth) {\n        const pbHeader = pb.Set.encode({\n          version: 1,\n          fanout: defaultFanout,\n          seed: depth\n        })\n        const headerBuf = Buffer.concat([\n          Buffer.from(varint.encode(pbHeader.length)), pbHeader\n        ])\n        const fanoutLinks = []\n\n        for (let i = 0; i < defaultFanout; i++) {\n          fanoutLinks.push(new DAGLink('', 1, emptyKey))\n        }\n\n        if (pins.length <= maxItems) {\n          const nodes = pins\n            .map(item => {\n              return ({\n                link: new DAGLink('', 1, item.key),\n                data: item.data || Buffer.alloc(0)\n              })\n            })\n            // sorting makes any ordering of `pins` produce the same DAGNode\n            .sort((a, b) => Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer))\n\n          const rootLinks = fanoutLinks.concat(nodes.map(item => item.link))\n          const rootData = Buffer.concat(\n            [headerBuf].concat(nodes.map(item => item.data))\n          )\n\n          return new DAGNode(rootData, rootLinks)\n        } else {\n          // If the array of pins is > maxItems, we:\n          //  - distribute the pins among `defaultFanout` bins\n          //    - create a DAGNode for each bin\n          //      - add each pin as a DAGLink to that bin\n          //  - create a root DAGNode\n          //    - add each bin as a DAGLink\n          //  - send that root DAGNode via callback\n          // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n\n          const bins = pins.reduce((bins, pin) => {\n            const n = hash(depth, pin.key) % defaultFanout\n            bins[n] = n in bins ? bins[n].concat([pin]) : [pin]\n            return bins\n          }, [])\n\n          let idx = 0\n          for (const bin of bins) {\n            const child = await storePins(bin, depth + 1)\n\n            await storeChild(child, idx)\n\n            idx++\n          }\n\n          return new DAGNode(headerBuf, fanoutLinks)\n        }\n\n        async function storeChild (child, binIdx) {\n          const opts = {\n            version: 0,\n            format: multicodec.DAG_PB,\n            hashAlg: multicodec.SHA2_256,\n            preload: false\n          }\n\n          const cid = await dag.put(child, opts)\n\n          fanoutLinks[binIdx] = new DAGLink('', child.size, cid)\n        }\n      }\n    },\n\n    loadSet: async (rootNode, name) => {\n      const link = rootNode.Links.find(l => l.Name === name)\n\n      if (!link) {\n        throw new Error('No link found with name ' + name)\n      }\n\n      const res = await dag.get(link.Hash, '', { preload: false })\n      const keys = []\n      const stepPin = link => keys.push(link.Hash)\n\n      await pinSet.walkItems(res.value, { stepPin })\n\n      return keys\n    },\n\n    walkItems: async (node, { stepPin = () => {}, stepBin = () => {} }) => {\n      const pbh = readHeader(node)\n      let idx = 0\n\n      for (const link of node.Links) {\n        if (idx < pbh.header.fanout) {\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          const linkHash = link.Hash.buffer\n\n          if (!emptyKey.equals(linkHash)) {\n            stepBin(link, idx, pbh.data)\n\n            // walk the links of this fanout bin\n            const res = await dag.get(linkHash, '', { preload: false })\n\n            await pinSet.walkItems(res.value, { stepPin, stepBin })\n          }\n        } else {\n          // otherwise, the link is a pin\n          stepPin(link, idx, pbh.data)\n        }\n\n        idx++\n      }\n    },\n\n    getInternalCids: async (rootNode) => {\n      // \"Empty block\" used by the pinner\n      const cids = [new CID(emptyKey)]\n      const stepBin = link => cids.push(link.Hash)\n\n      for (const topLevelLink of rootNode.Links) {\n        cids.push(topLevelLink.Hash)\n\n        const res = await dag.get(topLevelLink.Hash, '', { preload: false })\n\n        await pinSet.walkItems(res.value, { stepBin })\n      }\n\n      return cids\n    }\n  }\n\n  return pinSet\n}\n"]},"metadata":{},"sourceType":"script"}