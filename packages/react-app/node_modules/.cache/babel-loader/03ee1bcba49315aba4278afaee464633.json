{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar Big = require('bignumber.js');\n\nvar parseDuration = require('parse-duration');\n\nvar errCode = require('err-code');\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nfunction getBandwidthStats(libp2p, opts) {\n  var stats;\n\n  if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer);\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto);\n  } else {\n    stats = libp2p.metrics.global;\n  }\n\n  if (!stats) {\n    return {\n      totalIn: new Big(0),\n      totalOut: new Big(0),\n      rateIn: new Big(0),\n      rateOut: new Big(0)\n    };\n  }\n\n  var _stats = stats,\n      movingAverages = _stats.movingAverages,\n      snapshot = _stats.snapshot;\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: new Big(movingAverages.dataReceived[60000].movingAverage() / 60),\n    rateOut: new Big(movingAverages.dataSent[60000].movingAverage() / 60)\n  };\n}\n\nmodule.exports = function (_ref2) {\n  var libp2p = _ref2.libp2p;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n      var interval, timeoutId;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = options || {};\n\n              if (options.poll) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return getBandwidthStats(libp2p, options);\n\n            case 4:\n              return _context.abrupt(\"return\");\n\n            case 5:\n              interval = options.interval || 1000;\n              _context.prev = 6;\n              interval = typeof interval === 'string' ? parseDuration(interval) : interval;\n\n              if (!(!interval || interval < 0)) {\n                _context.next = 10;\n                break;\n              }\n\n              throw new Error('invalid poll interval');\n\n            case 10:\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](6);\n              throw errCode(_context.t0, 'ERR_INVALID_POLL_INTERVAL');\n\n            case 15:\n              _context.prev = 15;\n\n            case 16:\n              if (!true) {\n                _context.next = 23;\n                break;\n              }\n\n              _context.next = 19;\n              return getBandwidthStats(libp2p, options);\n\n            case 19:\n              _context.next = 21;\n              return _awaitAsyncGenerator(new Promise(function (resolve) {\n                timeoutId = setTimeout(resolve, interval);\n              }));\n\n            case 21:\n              _context.next = 16;\n              break;\n\n            case 23:\n              _context.prev = 23;\n              clearTimeout(timeoutId);\n              return _context.finish(23);\n\n            case 26:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[6, 12], [15,, 23, 26]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/stats/bw.js"],"names":["Big","require","parseDuration","errCode","withTimeoutOption","getBandwidthStats","libp2p","opts","stats","peer","metrics","forPeer","proto","forProtocol","global","totalIn","totalOut","rateIn","rateOut","movingAverages","snapshot","dataReceived","dataSent","movingAverage","module","exports","options","poll","interval","Error","Promise","resolve","timeoutId","setTimeout","clearTimeout"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Big = require('bignumber.js')\nconst parseDuration = require('parse-duration')\nconst errCode = require('err-code')\nconst { withTimeoutOption } = require('../../utils')\n\nfunction getBandwidthStats (libp2p, opts) {\n  let stats\n\n  if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer)\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto)\n  } else {\n    stats = libp2p.metrics.global\n  }\n\n  if (!stats) {\n    return {\n      totalIn: new Big(0),\n      totalOut: new Big(0),\n      rateIn: new Big(0),\n      rateOut: new Big(0)\n    }\n  }\n\n  const { movingAverages, snapshot } = stats\n\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: new Big(movingAverages.dataReceived[60000].movingAverage() / 60),\n    rateOut: new Big(movingAverages.dataSent[60000].movingAverage() / 60)\n  }\n}\n\nmodule.exports = ({ libp2p }) => {\n  return withTimeoutOption(async function * (options) {\n    options = options || {}\n\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options)\n      return\n    }\n\n    let interval = options.interval || 1000\n    try {\n      interval = typeof interval === 'string' ? parseDuration(interval) : interval\n      if (!interval || interval < 0) throw new Error('invalid poll interval')\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL')\n    }\n\n    let timeoutId\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options)\n        // eslint-disable-next-line no-loop-func\n        await new Promise(resolve => { timeoutId = setTimeout(resolve, interval) })\n      }\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}