{"ast":null,"code":"'use strict';\n/**\n * SortedMap is a Map whose iterator order can be defined by the user\n */\n\nclass SortedMap extends Map {\n  /**\n   * @param {Array<k, v>} [entries]\n   * @param {function(a, b)} [cmp] compares [k1, v1] to [k2, v2]\n   */\n  constructor(entries, cmp) {\n    super();\n    this._cmp = cmp || this._defaultSort;\n    this._keys = [];\n\n    for (const [k, v] of entries || []) {\n      this.set(k, v);\n    }\n  }\n  /**\n   * Call update to update the position of the key when it should change.\n   * For example if the compare function sorts by the priority field, and the\n   * priority changes, call update.\n   * Call indexOf() to get the index _before_ the change happens.\n   *\n   * @param {Object} i - the index of entry whose position should be updated.\n   */\n\n\n  update(i) {\n    if (i < 0 || i >= this._keys.length) {\n      return;\n    }\n\n    const k = this._keys[i];\n\n    this._keys.splice(i, 1);\n\n    const newIdx = this._find(k);\n\n    this._keys.splice(newIdx, 0, k);\n  }\n\n  set(k, v) {\n    // If the key is already in the map, remove it from the ordering and\n    // re-insert it below\n    if (this.has(k)) {\n      const i = this.indexOf(k);\n\n      this._keys.splice(i, 1);\n    } // Update / insert the k/v into the map\n\n\n    super.set(k, v); // Find the correct position of the newly inserted k/v in the order\n\n    const i = this._find(k);\n\n    this._keys.splice(i, 0, k);\n  }\n\n  clear() {\n    super.clear();\n    this._keys = [];\n  }\n\n  delete(k) {\n    if (!this.has(k)) {\n      return;\n    }\n\n    const i = this.indexOf(k);\n\n    this._keys.splice(i, 1);\n\n    super.delete(k);\n  }\n\n  indexOf(k) {\n    if (!this.has(k)) {\n      return -1;\n    }\n\n    const i = this._find(k);\n\n    if (this._keys[i] === k) {\n      return i;\n    } // There may be more than one key with the same ordering\n    // eg { k1: <priority 5>, k2: <priority 5> }\n    // so scan outwards until the key matches\n\n\n    for (let j = 1; j < this._keys.length; j++) {\n      if (this._keys[i + j] === k) return i + j;\n      if (this._keys[i - j] === k) return i - j;\n    }\n\n    return -1; // should never happen for existing key\n  }\n\n  _find(k) {\n    let lower = 0;\n    let upper = this._keys.length;\n\n    while (lower < upper) {\n      const pivot = lower + upper >>> 1; // lower + (upper - lower) / 2\n\n      const cmp = this._kCmp(this._keys[pivot], k); // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n\n\n      if (cmp < 0) {\n        // pivot < k\n        lower = pivot + 1;\n      } else if (cmp > 0) {\n        // pivot > k\n        upper = pivot;\n      } else {\n        // pivot == k\n        return pivot;\n      }\n    }\n\n    return lower;\n  }\n\n  *keys() {\n    for (const k of this._keys) {\n      yield k;\n    }\n  }\n\n  *values() {\n    for (const k of this._keys) {\n      yield this.get(k);\n    }\n  }\n\n  *entries() {\n    for (const k of this._keys) {\n      yield [k, this.get(k)];\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.entries();\n  }\n\n  forEach(cb, thisArg) {\n    if (!cb) {\n      return;\n    }\n\n    for (const k of this._keys) {\n      cb.apply(thisArg, [[k, this.get(k)]]);\n    }\n  }\n\n  _defaultSort(a, b) {\n    if (a[0] < b[0]) return -1;\n    if (b[0] < a[0]) return 1;\n    return 0;\n  }\n\n  _kCmp(a, b) {\n    return this._cmp([a, this.get(a)], [b, this.get(b)]);\n  }\n\n}\n\nmodule.exports = SortedMap;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs-bitswap/src/utils/sorted-map.js"],"names":["SortedMap","Map","constructor","entries","cmp","_cmp","_defaultSort","_keys","k","v","set","update","i","length","splice","newIdx","_find","has","indexOf","clear","delete","j","lower","upper","pivot","_kCmp","keys","values","get","Symbol","iterator","forEach","cb","thisArg","apply","a","b","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * SortedMap is a Map whose iterator order can be defined by the user\n */\nclass SortedMap extends Map {\n  /**\n   * @param {Array<k, v>} [entries]\n   * @param {function(a, b)} [cmp] compares [k1, v1] to [k2, v2]\n   */\n  constructor (entries, cmp) {\n    super()\n    this._cmp = cmp || this._defaultSort\n    this._keys = []\n    for (const [k, v] of entries || []) {\n      this.set(k, v)\n    }\n  }\n\n  /**\n   * Call update to update the position of the key when it should change.\n   * For example if the compare function sorts by the priority field, and the\n   * priority changes, call update.\n   * Call indexOf() to get the index _before_ the change happens.\n   *\n   * @param {Object} i - the index of entry whose position should be updated.\n   */\n  update (i) {\n    if (i < 0 || i >= this._keys.length) {\n      return\n    }\n\n    const k = this._keys[i]\n    this._keys.splice(i, 1)\n    const newIdx = this._find(k)\n    this._keys.splice(newIdx, 0, k)\n  }\n\n  set (k, v) {\n    // If the key is already in the map, remove it from the ordering and\n    // re-insert it below\n    if (this.has(k)) {\n      const i = this.indexOf(k)\n      this._keys.splice(i, 1)\n    }\n\n    // Update / insert the k/v into the map\n    super.set(k, v)\n\n    // Find the correct position of the newly inserted k/v in the order\n    const i = this._find(k)\n    this._keys.splice(i, 0, k)\n  }\n\n  clear () {\n    super.clear()\n    this._keys = []\n  }\n\n  delete (k) {\n    if (!this.has(k)) {\n      return\n    }\n\n    const i = this.indexOf(k)\n    this._keys.splice(i, 1)\n    super.delete(k)\n  }\n\n  indexOf (k) {\n    if (!this.has(k)) {\n      return -1\n    }\n\n    const i = this._find(k)\n    if (this._keys[i] === k) {\n      return i\n    }\n\n    // There may be more than one key with the same ordering\n    // eg { k1: <priority 5>, k2: <priority 5> }\n    // so scan outwards until the key matches\n    for (let j = 1; j < this._keys.length; j++) {\n      if (this._keys[i + j] === k) return i + j\n      if (this._keys[i - j] === k) return i - j\n    }\n\n    return -1 // should never happen for existing key\n  }\n\n  _find (k) {\n    let lower = 0\n    let upper = this._keys.length\n    while (lower < upper) {\n      const pivot = (lower + upper) >>> 1 // lower + (upper - lower) / 2\n      const cmp = this._kCmp(this._keys[pivot], k)\n      // console.log(`  _find ${lower}:${upper}[${pivot}] ${cmp}`)\n      if (cmp < 0) { // pivot < k\n        lower = pivot + 1\n      } else if (cmp > 0) { // pivot > k\n        upper = pivot\n      } else { // pivot == k\n        return pivot\n      }\n    }\n    return lower\n  }\n\n  * keys () {\n    for (const k of this._keys) {\n      yield k\n    }\n  }\n\n  * values () {\n    for (const k of this._keys) {\n      yield this.get(k)\n    }\n  }\n\n  * entries () {\n    for (const k of this._keys) {\n      yield [k, this.get(k)]\n    }\n  }\n\n  * [Symbol.iterator] () {\n    yield * this.entries()\n  }\n\n  forEach (cb, thisArg) {\n    if (!cb) {\n      return\n    }\n\n    for (const k of this._keys) {\n      cb.apply(thisArg, [[k, this.get(k)]])\n    }\n  }\n\n  _defaultSort (a, b) {\n    if (a[0] < b[0]) return -1\n    if (b[0] < a[0]) return 1\n    return 0\n  }\n\n  _kCmp (a, b) {\n    return this._cmp(\n      [a, this.get(a)],\n      [b, this.get(b)]\n    )\n  }\n}\n\nmodule.exports = SortedMap\n"]},"metadata":{},"sourceType":"script"}