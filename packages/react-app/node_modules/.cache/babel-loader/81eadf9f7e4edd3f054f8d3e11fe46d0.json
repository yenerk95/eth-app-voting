{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  cidToString\n} = require('../../utils/cid');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n/**\n * @typedef {Object} ResolveOptions\n * @prop {string} cidBase - Multibase codec name the CID in the resolved path will be encoded with\n * @prop {boolean} [recursive=true] - Resolve until the result is an IPFS name\n *\n */\n\n/** @typedef {(path: string, options?: ResolveOptions) => Promise<string>} Resolve */\n\n/**\n * IPFS Resolve factory\n *\n * @param {Object} config\n * @param {IPLD} config.ipld - An instance of IPLD\n * @param {NameApi} [config.name] - An IPFS core interface name API\n * @returns {Resolve}\n */\n\n\nmodule.exports = ({\n  ipld,\n  name\n}) => {\n  return withTimeoutOption(async function resolve(path, opts) {\n    opts = opts || {};\n\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      if (!name) {\n        throw new Error('failed to resolve IPNS path: name API unavailable');\n      }\n\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n\n    const [,, hash, ...rest] = path.split('/'); // ['', 'ipfs', 'hash', ...path]\n\n    const cid = new CID(hash); // nothing to resolve return the input\n\n    if (rest.length === 0) {\n      return `/ipfs/${cidToString(cid, {\n        base: opts.cidBase\n      })}`;\n    }\n\n    path = rest.join('/');\n    const results = ipld.resolve(cid, path);\n    let value = cid;\n    let remainderPath = path;\n\n    for await (const result of results) {\n      if (CID.isCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n\n    return `/ipfs/${cidToString(value, {\n      base: opts.cidBase\n    })}${remainderPath ? '/' + remainderPath : ''}`;\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipfs/src/core/components/resolve.js"],"names":["isIpfs","require","CID","cidToString","withTimeoutOption","module","exports","ipld","name","resolve","path","opts","Error","ipnsPath","resolvedPath","hash","rest","split","cid","length","base","cidBase","join","results","value","remainderPath","result","isCID"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,MAAD,CAAnB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAkBF,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAwBH,OAAO,CAAC,UAAD,CAArC;AAEA;;;;;;;AAOA;;AAEA;;;;;;;;;;AAQAI,MAAM,CAACC,OAAP,GAAiB,CAAC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAAD,KAAoB;AACnC,SAAOJ,iBAAiB,CAAC,eAAeK,OAAf,CAAwBC,IAAxB,EAA8BC,IAA9B,EAAoC;AAC3DA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AAEA,QAAI,CAACX,MAAM,CAACU,IAAP,CAAYA,IAAZ,CAAL,EAAwB;AACtB,YAAM,IAAIE,KAAJ,CAAU,sBAAsBF,IAAhC,CAAN;AACD;;AAED,QAAIV,MAAM,CAACa,QAAP,CAAgBH,IAAhB,CAAJ,EAA2B;AACzB,UAAI,CAACF,IAAL,EAAW;AACT,cAAM,IAAII,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,iBAAW,MAAME,YAAjB,IAAiCN,IAAI,CAACC,OAAL,CAAaC,IAAb,EAAmBC,IAAnB,CAAjC,EAA2D;AACzDD,QAAAA,IAAI,GAAGI,YAAP;AACD;AACF;;AAED,UAAM,IAAKC,IAAL,EAAW,GAAGC,IAAd,IAAsBN,IAAI,CAACO,KAAL,CAAW,GAAX,CAA5B,CAjB2D,CAiBf;;AAC5C,UAAMC,GAAG,GAAG,IAAIhB,GAAJ,CAAQa,IAAR,CAAZ,CAlB2D,CAoB3D;;AACA,QAAIC,IAAI,CAACG,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAQ,SAAQhB,WAAW,CAACe,GAAD,EAAM;AAAEE,QAAAA,IAAI,EAAET,IAAI,CAACU;AAAb,OAAN,CAA8B,EAAzD;AACD;;AAEDX,IAAAA,IAAI,GAAGM,IAAI,CAACM,IAAL,CAAU,GAAV,CAAP;AAEA,UAAMC,OAAO,GAAGhB,IAAI,CAACE,OAAL,CAAaS,GAAb,EAAkBR,IAAlB,CAAhB;AACA,QAAIc,KAAK,GAAGN,GAAZ;AACA,QAAIO,aAAa,GAAGf,IAApB;;AAEA,eAAW,MAAMgB,MAAjB,IAA2BH,OAA3B,EAAoC;AAClC,UAAIrB,GAAG,CAACyB,KAAJ,CAAUD,MAAM,CAACF,KAAjB,CAAJ,EAA6B;AAC3BA,QAAAA,KAAK,GAAGE,MAAM,CAACF,KAAf;AACAC,QAAAA,aAAa,GAAGC,MAAM,CAACD,aAAvB;AACD;AACF;;AAED,WAAQ,SAAQtB,WAAW,CAACqB,KAAD,EAAQ;AAAEJ,MAAAA,IAAI,EAAET,IAAI,CAACU;AAAb,KAAR,CAAgC,GAAEI,aAAa,GAAG,MAAMA,aAAT,GAAyB,EAAG,EAAtG;AACD,GAvCuB,CAAxB;AAwCD,CAzCD","sourcesContent":["'use strict'\n\nconst isIpfs = require('is-ipfs')\nconst CID = require('cids')\nconst { cidToString } = require('../../utils/cid')\nconst { withTimeoutOption } = require('../utils')\n\n/**\n * @typedef {Object} ResolveOptions\n * @prop {string} cidBase - Multibase codec name the CID in the resolved path will be encoded with\n * @prop {boolean} [recursive=true] - Resolve until the result is an IPFS name\n *\n */\n\n/** @typedef {(path: string, options?: ResolveOptions) => Promise<string>} Resolve */\n\n/**\n * IPFS Resolve factory\n *\n * @param {Object} config\n * @param {IPLD} config.ipld - An instance of IPLD\n * @param {NameApi} [config.name] - An IPFS core interface name API\n * @returns {Resolve}\n */\nmodule.exports = ({ ipld, name }) => {\n  return withTimeoutOption(async function resolve (path, opts) {\n    opts = opts || {}\n\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path)\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      if (!name) {\n        throw new Error('failed to resolve IPNS path: name API unavailable')\n      }\n\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath\n      }\n    }\n\n    const [, , hash, ...rest] = path.split('/') // ['', 'ipfs', 'hash', ...path]\n    const cid = new CID(hash)\n\n    // nothing to resolve return the input\n    if (rest.length === 0) {\n      return `/ipfs/${cidToString(cid, { base: opts.cidBase })}`\n    }\n\n    path = rest.join('/')\n\n    const results = ipld.resolve(cid, path)\n    let value = cid\n    let remainderPath = path\n\n    for await (const result of results) {\n      if (CID.isCID(result.value)) {\n        value = result.value\n        remainderPath = result.remainderPath\n      }\n    }\n\n    return `/ipfs/${cidToString(value, { base: opts.cidBase })}${remainderPath ? '/' + remainderPath : ''}`\n  })\n}\n"]},"metadata":{},"sourceType":"script"}