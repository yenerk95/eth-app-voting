{"ast":null,"code":"const getIterator = require('get-iterator');\n\nconst AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nconst toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source);\n  signals = signals.map(({\n    signal,\n    options\n  }) => ({\n    signal,\n    options: options || {}\n  }));\n\n  async function* abortable() {\n    let nextAbortHandler;\n\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler();\n    };\n\n    for (const {\n      signal\n    } of signals) {\n      signal.addEventListener('abort', abortHandler);\n    }\n\n    while (true) {\n      let result;\n\n      try {\n        for (const {\n          signal,\n          options\n        } of signals) {\n          if (signal.aborted) {\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            throw new AbortError(abortMessage, abortCode);\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const {\n              options\n            } = signals.find(({\n              signal\n            }) => signal.aborted);\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            reject(new AbortError(abortMessage, abortCode));\n          };\n        }); // Race the iterator and the abort signals\n\n        result = await Promise.race([abort, source.next()]);\n        nextAbortHandler = null;\n      } catch (err) {\n        for (const {\n          signal\n        } of signals) {\n          signal.removeEventListener('abort', abortHandler);\n        } // Might not have been aborted by a known signal\n\n\n        const aborter = signals.find(({\n          signal\n        }) => signal.aborted);\n        const isKnownAborter = err.type === 'aborted' && aborter;\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source);\n        } // End the iterator if it is a generator\n\n\n        if (typeof source.return === 'function') {\n          await source.return();\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return;\n        }\n\n        throw err;\n      }\n\n      if (result.done) break;\n      yield result.value;\n    }\n\n    for (const {\n      signal\n    } of signals) {\n      signal.removeEventListener('abort', abortHandler);\n    }\n  }\n\n  return abortable();\n};\n\nconst toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSink = (sink, signals) => source => sink(toMultiAbortableSource(source, signals));\n\nconst toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n});\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/abortable-iterator/index.js"],"names":["getIterator","require","AbortError","toAbortableSource","source","signal","options","toMultiAbortableSource","Array","isArray","signals","map","abortable","nextAbortHandler","abortHandler","addEventListener","result","aborted","abortMessage","abortCode","abort","Promise","resolve","reject","find","race","next","err","removeEventListener","aborter","isKnownAborter","type","onAbort","return","returnOnAbort","done","value","toAbortableSink","sink","toMultiAbortableSink","toAbortableDuplex","duplex","toMultiAbortableDuplex","module","exports","transform"],"mappings":"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","sourcesContent":["const getIterator = require('get-iterator')\nconst AbortError = require('./AbortError')\n\n// Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\nconst toAbortableSource = (source, signal, options) => (\n  toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source)\n  signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }))\n\n  async function * abortable () {\n    let nextAbortHandler\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler()\n    }\n\n    for (const { signal } of signals) {\n      signal.addEventListener('abort', abortHandler)\n    }\n\n    while (true) {\n      let result\n      try {\n        for (const { signal, options } of signals) {\n          if (signal.aborted) {\n            const { abortMessage, abortCode } = options\n            throw new AbortError(abortMessage, abortCode)\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const { options } = signals.find(({ signal }) => signal.aborted)\n            const { abortMessage, abortCode } = options\n            reject(new AbortError(abortMessage, abortCode))\n          }\n        })\n\n        // Race the iterator and the abort signals\n        result = await Promise.race([abort, source.next()])\n        nextAbortHandler = null\n      } catch (err) {\n        for (const { signal } of signals) {\n          signal.removeEventListener('abort', abortHandler)\n        }\n\n        // Might not have been aborted by a known signal\n        const aborter = signals.find(({ signal }) => signal.aborted)\n        const isKnownAborter = err.type === 'aborted' && aborter\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source)\n        }\n\n        // End the iterator if it is a generator\n        if (typeof source.return === 'function') {\n          await source.return()\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return\n        }\n\n        throw err\n      }\n\n      if (result.done) break\n      yield result.value\n    }\n\n    for (const { signal } of signals) {\n      signal.removeEventListener('abort', abortHandler)\n    }\n  }\n\n  return abortable()\n}\n\nconst toAbortableSink = (sink, signal, options) => (\n  toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableSink = (sink, signals) => source => (\n  sink(toMultiAbortableSource(source, signals))\n)\n\nconst toAbortableDuplex = (duplex, signal, options) => (\n  toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }])\n)\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n})\n\nmodule.exports = toAbortableSource\nmodule.exports.AbortError = AbortError\nmodule.exports.source = toAbortableSource\nmodule.exports.sink = toAbortableSink\nmodule.exports.transform = toAbortableSink\nmodule.exports.duplex = toAbortableDuplex\n"]},"metadata":{},"sourceType":"script"}