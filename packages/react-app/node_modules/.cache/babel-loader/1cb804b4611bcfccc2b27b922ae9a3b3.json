{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar NanoDate = require('timestamp-nano');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar multihash = require('multihashes');\n\nvar errCode = require('err-code');\n\nvar _require2 = require('buffer'),\n    Buffer = _require2.Buffer;\n\nvar multibase = require('multibase');\n\nvar debug = require('debug');\n\nvar log = debug('jsipns');\nlog.error = debug('jsipns:error');\n\nvar ipnsEntryProto = require('./pb/ipns.proto');\n\nvar _require3 = require('./utils'),\n    parseRFC3339 = _require3.parseRFC3339;\n\nvar ERRORS = require('./errors');\n\nvar ID_MULTIHASH_CODE = multihash.names.id;\nvar namespace = '/ipns/';\n/**\n * IPNS entry\n * @typedef {Object} IpnsEntry\n * @property {string} value - value to be stored in the record\n * @property {Buffer} signature - signature of the record\n * @property {number} validityType - Type of validation being used\n * @property {string} validity - expiration datetime for the record in RFC3339 format\n * @property {number} sequence - number representing the version of the record\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @returns {Promise<IpnsEntry>} entry\n */\n\nvar create = function create(privateKey, value, seq, lifetime) {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  var isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString();\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, isoValidity, validityType);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @returns {Promise<IpnsEntry>} entry\n */\n\n\nvar createWithExpiration = function createWithExpiration(privateKey, value, seq, expiration) {\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, expiration, validityType);\n};\n\nvar _create = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privateKey, value, seq, isoValidity, validityType) {\n    var signature, entry;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return sign(privateKey, value, validityType, isoValidity);\n\n          case 2:\n            signature = _context.sent;\n            entry = {\n              value: value,\n              signature: signature,\n              validityType: validityType,\n              validity: isoValidity,\n              sequence: seq\n            };\n            log(\"ipns entry for \".concat(value, \" created\"));\n            return _context.abrupt(\"return\", entry);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function _create(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Promise}\n */\n\n\nvar _validate = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(publicKey, entry) {\n    var value, validityType, validity, dataForSignature, isValid, validityDate;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            value = entry.value, validityType = entry.validityType, validity = entry.validity;\n            dataForSignature = ipnsEntryDataForSig(value, validityType, validity); // Validate Signature\n\n            _context2.prev = 2;\n            _context2.next = 5;\n            return publicKey.verify(dataForSignature, entry.signature);\n\n          case 5:\n            isValid = _context2.sent;\n            _context2.next = 11;\n            break;\n\n          case 8:\n            _context2.prev = 8;\n            _context2.t0 = _context2[\"catch\"](2);\n            isValid = false;\n\n          case 11:\n            if (isValid) {\n              _context2.next = 14;\n              break;\n            }\n\n            log.error('record signature verification failed');\n            throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n\n          case 14:\n            if (!(validityType === ipnsEntryProto.ValidityType.EOL)) {\n              _context2.next = 28;\n              break;\n            }\n\n            _context2.prev = 15;\n            validityDate = parseRFC3339(validity.toString());\n            _context2.next = 23;\n            break;\n\n          case 19:\n            _context2.prev = 19;\n            _context2.t1 = _context2[\"catch\"](15);\n            log.error('unrecognized validity format (not an rfc3339 format)');\n            throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n\n          case 23:\n            if (!(validityDate < Date.now())) {\n              _context2.next = 26;\n              break;\n            }\n\n            log.error('record has expired');\n            throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n\n          case 26:\n            _context2.next = 31;\n            break;\n\n          case 28:\n            if (!validityType) {\n              _context2.next = 31;\n              break;\n            }\n\n            log.error('unrecognized validity type');\n            throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n\n          case 31:\n            log(\"ipns entry for \".concat(value, \" is valid\"));\n\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 8], [15, 19]]);\n  }));\n\n  return function validate(_x6, _x7) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @return {IpnsEntry} entry with public key embedded\n */\n\n\nvar embedPublicKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(publicKey, entry) {\n    var error, peerId, extractedPublicKey;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(!publicKey || !publicKey.bytes || !entry)) {\n              _context3.next = 4;\n              break;\n            }\n\n            error = new Error('one or more of the provided parameters are not defined');\n            log.error(error);\n            throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n\n          case 4:\n            _context3.prev = 4;\n            _context3.next = 7;\n            return PeerId.createFromPubKey(publicKey.bytes);\n\n          case 7:\n            peerId = _context3.sent;\n            _context3.next = 13;\n            break;\n\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3[\"catch\"](4);\n            throw errCode(_context3.t0, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n\n          case 13:\n            _context3.prev = 13;\n            extractedPublicKey = extractPublicKeyFromId(peerId);\n            _context3.next = 21;\n            break;\n\n          case 17:\n            _context3.prev = 17;\n            _context3.t1 = _context3[\"catch\"](13);\n            log.error(_context3.t1);\n            throw errCode(_context3.t1, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n\n          case 21:\n            if (!extractedPublicKey) {\n              _context3.next = 23;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 23:\n            _context3.prev = 23;\n            entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n            _context3.next = 31;\n            break;\n\n          case 27:\n            _context3.prev = 27;\n            _context3.t2 = _context3[\"catch\"](23);\n            log.error(_context3.t2);\n            throw _context3.t2;\n\n          case 31:\n            return _context3.abrupt(\"return\", entry);\n\n          case 32:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 10], [13, 17], [23, 27]]);\n  }));\n\n  return function embedPublicKey(_x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Object} the public key\n */\n\n\nvar extractPublicKey = function extractPublicKey(peerId, entry) {\n  if (!entry || !peerId) {\n    var error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  if (entry.pubKey) {\n    var pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return pubKey;\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey;\n  }\n\n  throw Object.assign(new Error('no public key is available'), {\n    code: ERRORS.ERR_UNDEFINED_PARAMETER\n  });\n}; // rawStdEncoding with RFC4648\n\n\nvar rawStdEncoding = function rawStdEncoding(key) {\n  return multibase.encode('base32', key).toString().slice(1).toUpperCase();\n};\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\n\n\nvar getLocalKey = function getLocalKey(key) {\n  return new Key(\"/ipns/\".concat(rawStdEncoding(key)));\n};\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\n\n\nvar getIdKeys = function getIdKeys(pid) {\n  var pkBuffer = Buffer.from('/pk/');\n  var ipnsBuffer = Buffer.from('/ipns/');\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  };\n}; // Sign ipns record data\n\n\nvar sign = function sign(privateKey, value, validityType, validity) {\n  try {\n    var dataForSignature = ipnsEntryDataForSig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n}; // Utility for getting the validity type code name of a validity\n\n\nvar getValidityType = function getValidityType(validityType) {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  var error = new Error(\"unrecognized validity type \".concat(validityType.toString()));\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n}; // Utility for creating the record data for being signed\n\n\nvar ipnsEntryDataForSig = function ipnsEntryDataForSig(value, validityType, validity) {\n  var valueBuffer = Buffer.from(value);\n  var validityTypeBuffer = Buffer.from(getValidityType(validityType));\n  var validityBuffer = Buffer.from(validity);\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer]);\n}; // Utility for extracting the public key from a peer-id\n\n\nvar extractPublicKeyFromId = function extractPublicKeyFromId(peerId) {\n  var decodedId = multihash.decode(peerId.id);\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest);\n};\n\nvar marshal = ipnsEntryProto.encode;\nvar unmarshal = ipnsEntryProto.decode;\nvar validator = {\n  validate: function () {\n    var _validate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(marshalledData, key) {\n      var receivedEntry, bufferId, peerId, pubKey;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              receivedEntry = unmarshal(marshalledData);\n              bufferId = key.slice('/ipns/'.length);\n              peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n              pubKey = extractPublicKey(peerId, receivedEntry); // Record validation\n\n              _context4.next = 6;\n              return _validate(pubKey, receivedEntry);\n\n            case 6:\n              return _context4.abrupt(\"return\", true);\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    function validate(_x10, _x11) {\n      return _validate2.apply(this, arguments);\n    }\n\n    return validate;\n  }(),\n  select: function select(dataA, dataB) {\n    var entryA = unmarshal(dataA);\n    var entryB = unmarshal(dataB);\n    return entryA.sequence > entryB.sequence ? 0 : 1;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create: create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration: createWithExpiration,\n  // validate ipns entry record\n  validate: _validate,\n  // embed public key in the record\n  embedPublicKey: embedPublicKey,\n  // extract public key from the record\n  extractPublicKey: extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey: getLocalKey,\n  // get keys for routing\n  getIdKeys: getIdKeys,\n  // marshal\n  marshal: marshal,\n  // unmarshal\n  unmarshal: unmarshal,\n  // validator\n  validator: validator,\n  // namespace\n  namespace: namespace,\n  namespaceLength: namespace.length\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/ipns/src/index.js"],"names":["NanoDate","require","Key","crypto","PeerId","multihash","errCode","Buffer","multibase","debug","log","error","ipnsEntryProto","parseRFC3339","ERRORS","ID_MULTIHASH_CODE","names","id","namespace","create","privateKey","value","seq","lifetime","isoValidity","Date","now","Number","toString","validityType","ValidityType","EOL","_create","createWithExpiration","expiration","sign","signature","entry","validity","sequence","validate","publicKey","dataForSignature","ipnsEntryDataForSig","verify","isValid","Error","ERR_SIGNATURE_VERIFICATION","validityDate","ERR_UNRECOGNIZED_FORMAT","ERR_IPNS_EXPIRED_RECORD","ERR_UNRECOGNIZED_VALIDITY","embedPublicKey","bytes","ERR_UNDEFINED_PARAMETER","createFromPubKey","peerId","ERR_PEER_ID_FROM_PUBLIC_KEY","extractedPublicKey","extractPublicKeyFromId","ERR_PUBLIC_KEY_FROM_ID","pubKey","keys","marshalPublicKey","extractPublicKey","unmarshalPublicKey","err","Object","assign","code","rawStdEncoding","key","encode","slice","toUpperCase","getLocalKey","getIdKeys","pid","pkBuffer","from","ipnsBuffer","routingPubKey","concat","pkKey","routingKey","ipnsKey","message","ERR_SIGNATURE_CREATION","getValidityType","valueBuffer","validityTypeBuffer","validityBuffer","decodedId","decode","digest","marshal","unmarshal","validator","marshalledData","receivedEntry","bufferId","length","createFromBytes","select","dataA","dataB","entryA","entryB","module","exports","namespaceLength"],"mappings":"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","sourcesContent":["'use strict'\n\nconst NanoDate = require('timestamp-nano')\nconst { Key } = require('interface-datastore')\nconst crypto = require('libp2p-crypto')\nconst PeerId = require('peer-id')\nconst multihash = require('multihashes')\nconst errCode = require('err-code')\nconst { Buffer } = require('buffer')\nconst multibase = require('multibase')\n\nconst debug = require('debug')\nconst log = debug('jsipns')\nlog.error = debug('jsipns:error')\n\nconst ipnsEntryProto = require('./pb/ipns.proto')\nconst { parseRFC3339 } = require('./utils')\nconst ERRORS = require('./errors')\n\nconst ID_MULTIHASH_CODE = multihash.names.id\n\nconst namespace = '/ipns/'\n\n/**\n * IPNS entry\n * @typedef {Object} IpnsEntry\n * @property {string} value - value to be stored in the record\n * @property {Buffer} signature - signature of the record\n * @property {number} validityType - Type of validation being used\n * @property {string} validity - expiration datetime for the record in RFC3339 format\n * @property {number} sequence - number representing the version of the record\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @returns {Promise<IpnsEntry>} entry\n */\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString()\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  return _create(privateKey, value, seq, isoValidity, validityType)\n}\n\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @returns {Promise<IpnsEntry>} entry\n */\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const validityType = ipnsEntryProto.ValidityType.EOL\n  return _create(privateKey, value, seq, expiration, validityType)\n}\n\nconst _create = async (privateKey, value, seq, isoValidity, validityType) => {\n  const signature = await sign(privateKey, value, validityType, isoValidity)\n\n  const entry = {\n    value: value,\n    signature: signature,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq\n  }\n\n  log(`ipns entry for ${value} created`)\n  return entry\n}\n\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Promise}\n */\nconst validate = async (publicKey, entry) => {\n  const { value, validityType, validity } = entry\n  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)\n\n  // Validate Signature\n  let isValid\n  try {\n    isValid = await publicKey.verify(dataForSignature, entry.signature)\n  } catch (err) {\n    isValid = false\n  }\n  if (!isValid) {\n    log.error('record signature verification failed')\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION)\n  }\n\n  // Validate according to the validity type\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate\n\n    try {\n      validityDate = parseRFC3339(validity.toString())\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)')\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT)\n    }\n\n    if (validityDate < Date.now()) {\n      log.error('record has expired')\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD)\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type')\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n  }\n\n  log(`ipns entry for ${value} is valid`)\n}\n\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @return {IpnsEntry} entry with public key embedded\n */\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined')\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  // Create a peer id from the public key.\n  let peerId\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes)\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY)\n  }\n\n  // Try to extract the public key from the ID. If we can, no need to embed it\n  let extractedPublicKey\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId)\n  } catch (err) {\n    log.error(err)\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID)\n  }\n\n  if (extractedPublicKey) {\n    return null\n  }\n\n  // If we failed to extract the public key from the peer ID, embed it in the record.\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey)\n  } catch (err) {\n    log.error(err)\n    throw err\n  }\n  return entry\n}\n\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Object} the public key\n */\nconst extractPublicKey = (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined')\n\n    log.error(error)\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER)\n  }\n\n  if (entry.pubKey) {\n    let pubKey\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey)\n    } catch (err) {\n      log.error(err)\n      throw err\n    }\n    return pubKey\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey\n  }\n  throw Object.assign(new Error('no public key is available'), { code: ERRORS.ERR_UNDEFINED_PARAMETER })\n}\n\n// rawStdEncoding with RFC4648\nconst rawStdEncoding = (key) => multibase.encode('base32', key).toString().slice(1).toUpperCase()\n\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\nconst getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`)\n\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\nconst getIdKeys = (pid) => {\n  const pkBuffer = Buffer.from('/pk/')\n  const ipnsBuffer = Buffer.from('/ipns/')\n\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid]), false), // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  }\n}\n\n// Sign ipns record data\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForSig(value, validityType, validity)\n\n    return privateKey.sign(dataForSignature)\n  } catch (error) {\n    log.error('record signature creation failed')\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION)\n  }\n}\n\n// Utility for getting the validity type code name of a validity\nconst getValidityType = (validityType) => {\n  if (validityType.toString() === '0') {\n    return 'EOL'\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`)\n  log.error(error)\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY)\n}\n\n// Utility for creating the record data for being signed\nconst ipnsEntryDataForSig = (value, validityType, validity) => {\n  const valueBuffer = Buffer.from(value)\n  const validityTypeBuffer = Buffer.from(getValidityType(validityType))\n  const validityBuffer = Buffer.from(validity)\n\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer])\n}\n\n// Utility for extracting the public key from a peer-id\nconst extractPublicKeyFromId = (peerId) => {\n  const decodedId = multihash.decode(peerId.id)\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest)\n}\n\nconst marshal = ipnsEntryProto.encode\n\nconst unmarshal = ipnsEntryProto.decode\n\nconst validator = {\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData)\n    const bufferId = key.slice('/ipns/'.length)\n    const peerId = PeerId.createFromBytes(bufferId)\n\n    // extract public key\n    const pubKey = extractPublicKey(peerId, receivedEntry)\n\n    // Record validation\n    await validate(pubKey, receivedEntry)\n    return true\n  },\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA)\n    const entryB = unmarshal(dataB)\n\n    return entryA.sequence > entryB.sequence ? 0 : 1\n  }\n}\n\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n}\n"]},"metadata":{},"sourceType":"script"}