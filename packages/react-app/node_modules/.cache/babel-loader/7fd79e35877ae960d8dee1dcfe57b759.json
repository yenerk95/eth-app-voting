{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:hop');\nlog.error = debug('libp2p:circuit:hop:error');\n\nvar PeerId = require('peer-id');\n\nvar _require = require('./utils'),\n    validateAddrs = _require.validateAddrs;\n\nvar StreamHandler = require('./stream-handler');\n\nvar _require2 = require('../protocol'),\n    CircuitPB = _require2.CircuitRelay;\n\nvar pipe = require('it-pipe');\n\nvar errCode = require('err-code');\n\nvar _require3 = require('../../errors'),\n    Errors = _require3.codes;\n\nvar _require4 = require('./stop'),\n    stop = _require4.stop;\n\nvar multicodec = require('./../multicodec');\n\nmodule.exports.handleHop = /*#__PURE__*/function () {\n  var _handleHop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var connection, request, streamHandler, circuit, destinationPeer, destinationConnection, stopRequest, destinationStream, sourceStream;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            connection = _ref.connection, request = _ref.request, streamHandler = _ref.streamHandler, circuit = _ref.circuit;\n\n            if (circuit._options.hop.enabled) {\n              _context.next = 4;\n              break;\n            }\n\n            log('HOP request received but we are not acting as a relay');\n            return _context.abrupt(\"return\", streamHandler.end({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n            }));\n\n          case 4:\n            _context.prev = 4;\n            validateAddrs(request, streamHandler);\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](4);\n            return _context.abrupt(\"return\", log.error('invalid hop request via peer %s', connection.remotePeer.toB58String(), _context.t0));\n\n          case 11:\n            // Get the connection to the destination (stop) peer\n            destinationPeer = new PeerId(request.dstPeer.id);\n            destinationConnection = circuit._connectionManager.get(destinationPeer);\n\n            if (!(!destinationConnection && !circuit._options.hop.active)) {\n              _context.next = 16;\n              break;\n            }\n\n            log('HOP request received but we are not connected to the destination peer');\n            return _context.abrupt(\"return\", streamHandler.end({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n            }));\n\n          case 16:\n            // TODO: Handle being an active relay\n            // Handle the incoming HOP request by performing a STOP request\n            stopRequest = {\n              type: CircuitPB.Type.STOP,\n              dstPeer: request.dstPeer,\n              srcPeer: request.srcPeer\n            };\n            _context.prev = 17;\n            _context.next = 20;\n            return stop({\n              connection: destinationConnection,\n              request: stopRequest,\n              circuit: circuit\n            });\n\n          case 20:\n            destinationStream = _context.sent;\n            _context.next = 26;\n            break;\n\n          case 23:\n            _context.prev = 23;\n            _context.t1 = _context[\"catch\"](17);\n            return _context.abrupt(\"return\", log.error(_context.t1));\n\n          case 26:\n            log('hop request from %s is valid', connection.remotePeer.toB58String());\n            streamHandler.write({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.SUCCESS\n            });\n            sourceStream = streamHandler.rest(); // Short circuit the two streams to create the relayed connection\n\n            return _context.abrupt(\"return\", pipe(sourceStream, destinationStream, sourceStream));\n\n          case 30:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 8], [17, 23]]);\n  }));\n\n  function handleHop(_x) {\n    return _handleHop.apply(this, arguments);\n  }\n\n  return handleHop;\n}();\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n *\n * @param {object} options\n * @param {Connection} options.connection Connection to the relay\n * @param {*} options.request\n * @param {Circuit} options.circuit\n * @returns {Promise<Connection>}\n */\n\n\nmodule.exports.hop = /*#__PURE__*/function () {\n  var _hop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var connection, request, _yield$connection$new, stream, streamHandler, response;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            connection = _ref2.connection, request = _ref2.request;\n            _context2.next = 3;\n            return connection.newStream([multicodec.relay]);\n\n          case 3:\n            _yield$connection$new = _context2.sent;\n            stream = _yield$connection$new.stream;\n            // Send the HOP request\n            streamHandler = new StreamHandler({\n              stream: stream\n            });\n            streamHandler.write(request);\n            _context2.next = 9;\n            return streamHandler.read();\n\n          case 9:\n            response = _context2.sent;\n\n            if (!(response.code === CircuitPB.Status.SUCCESS)) {\n              _context2.next = 13;\n              break;\n            }\n\n            log('hop request was successful');\n            return _context2.abrupt(\"return\", streamHandler.rest());\n\n          case 13:\n            log('hop request failed with code %d, closing stream', response.code);\n            streamHandler.close();\n            throw errCode(new Error(\"HOP request failed with code \".concat(response.code)), Errors.ERR_HOP_REQUEST_FAILED);\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  function hop(_x2) {\n    return _hop.apply(this, arguments);\n  }\n\n  return hop;\n}();\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n * @private\n */\n\n\nmodule.exports.handleCanHop = function handleCanHop(_ref3) {\n  var connection = _ref3.connection,\n      streamHandler = _ref3.streamHandler,\n      circuit = _ref3.circuit;\n  var canHop = circuit._options.hop.enabled;\n  log('can hop (%s) request from %s', canHop, connection.remotePeer.toB58String());\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p/src/circuit/circuit/hop.js"],"names":["debug","require","log","error","PeerId","validateAddrs","StreamHandler","CircuitPB","CircuitRelay","pipe","errCode","Errors","codes","stop","multicodec","module","exports","handleHop","connection","request","streamHandler","circuit","_options","hop","enabled","end","type","Type","STATUS","code","Status","HOP_CANT_SPEAK_RELAY","remotePeer","toB58String","destinationPeer","dstPeer","id","destinationConnection","_connectionManager","get","active","HOP_NO_CONN_TO_DST","stopRequest","STOP","srcPeer","destinationStream","write","SUCCESS","sourceStream","rest","newStream","relay","stream","read","response","close","Error","ERR_HOP_REQUEST_FAILED","handleCanHop","canHop"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = debug('libp2p:circuit:hop')\nlog.error = debug('libp2p:circuit:hop:error')\n\nconst PeerId = require('peer-id')\nconst { validateAddrs } = require('./utils')\nconst StreamHandler = require('./stream-handler')\nconst { CircuitRelay: CircuitPB } = require('../protocol')\nconst pipe = require('it-pipe')\nconst errCode = require('err-code')\nconst { codes: Errors } = require('../../errors')\n\nconst { stop } = require('./stop')\n\nconst multicodec = require('./../multicodec')\n\nmodule.exports.handleHop = async function handleHop ({\n  connection,\n  request,\n  streamHandler,\n  circuit\n}) {\n  // Ensure hop is enabled\n  if (!circuit._options.hop.enabled) {\n    log('HOP request received but we are not acting as a relay')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n    })\n  }\n\n  // Validate the HOP request has the required input\n  try {\n    validateAddrs(request, streamHandler)\n  } catch (err) {\n    return log.error('invalid hop request via peer %s', connection.remotePeer.toB58String(), err)\n  }\n\n  // Get the connection to the destination (stop) peer\n  const destinationPeer = new PeerId(request.dstPeer.id)\n\n  const destinationConnection = circuit._connectionManager.get(destinationPeer)\n  if (!destinationConnection && !circuit._options.hop.active) {\n    log('HOP request received but we are not connected to the destination peer')\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    })\n  }\n\n  // TODO: Handle being an active relay\n\n  // Handle the incoming HOP request by performing a STOP request\n  const stopRequest = {\n    type: CircuitPB.Type.STOP,\n    dstPeer: request.dstPeer,\n    srcPeer: request.srcPeer\n  }\n\n  let destinationStream\n  try {\n    destinationStream = await stop({\n      connection: destinationConnection,\n      request: stopRequest,\n      circuit\n    })\n  } catch (err) {\n    return log.error(err)\n  }\n\n  log('hop request from %s is valid', connection.remotePeer.toB58String())\n  streamHandler.write({\n    type: CircuitPB.Type.STATUS,\n    code: CircuitPB.Status.SUCCESS\n  })\n  const sourceStream = streamHandler.rest()\n\n  // Short circuit the two streams to create the relayed connection\n  return pipe(\n    sourceStream,\n    destinationStream,\n    sourceStream\n  )\n}\n\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n *\n * @param {object} options\n * @param {Connection} options.connection Connection to the relay\n * @param {*} options.request\n * @param {Circuit} options.circuit\n * @returns {Promise<Connection>}\n */\nmodule.exports.hop = async function hop ({\n  connection,\n  request\n}) {\n  // Create a new stream to the relay\n  const { stream } = await connection.newStream([multicodec.relay])\n  // Send the HOP request\n  const streamHandler = new StreamHandler({ stream })\n  streamHandler.write(request)\n\n  const response = await streamHandler.read()\n\n  if (response.code === CircuitPB.Status.SUCCESS) {\n    log('hop request was successful')\n    return streamHandler.rest()\n  }\n\n  log('hop request failed with code %d, closing stream', response.code)\n  streamHandler.close()\n  throw errCode(new Error(`HOP request failed with code ${response.code}`), Errors.ERR_HOP_REQUEST_FAILED)\n}\n\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n * @private\n */\nmodule.exports.handleCanHop = function handleCanHop ({\n  connection,\n  streamHandler,\n  circuit\n}) {\n  const canHop = circuit._options.hop.enabled\n  log('can hop (%s) request from %s', canHop, connection.remotePeer.toB58String())\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  })\n}\n"]},"metadata":{},"sourceType":"script"}