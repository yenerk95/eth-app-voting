{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SparseArray = require('sparse-array');\n\nvar wrapHash = require('./consumable-hash');\n\nvar defaultOptions = {\n  bits: 8\n};\n\nvar Bucket = /*#__PURE__*/function () {\n  function Bucket(options, parent, posAtParent) {\n    _classCallCheck(this, Bucket);\n\n    this._options = Object.assign({}, defaultOptions, options);\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    if (!this._options.hashFn) {\n      throw new Error('please define an options.hashFn');\n    } // make sure we only wrap options.hashFn once in the whole tree\n\n\n    if (!this._options.hash) {\n      this._options.hash = wrapHash(this._options.hashFn);\n    }\n\n    this._children = new SparseArray();\n  }\n\n  _createClass(Bucket, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, value) {\n        var place;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._findNewBucketAndPos(key);\n\n              case 2:\n                place = _context.sent;\n                _context.next = 5;\n                return place.bucket._putAt(place, key, value);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n        var child;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._findChild(key);\n\n              case 2:\n                child = _context2.sent;\n\n                if (!child) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", child.value);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"del\",\n    value: function () {\n      var _del = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key) {\n        var place, child;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._findPlace(key);\n\n              case 2:\n                place = _context3.sent;\n                child = place.bucket._at(place.pos);\n\n                if (child && child.key === key) {\n                  place.bucket._delAt(place.pos);\n                }\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function del(_x4) {\n        return _del.apply(this, arguments);\n      }\n\n      return del;\n    }()\n  }, {\n    key: \"leafCount\",\n    value: function leafCount() {\n      return this._children.compactArray().reduce(function (acc, child) {\n        if (child instanceof Bucket) {\n          return acc + child.leafCount();\n        }\n\n        return acc + 1;\n      }, 0);\n    }\n  }, {\n    key: \"childrenCount\",\n    value: function childrenCount() {\n      return this._children.length;\n    }\n  }, {\n    key: \"onlyChild\",\n    value: function onlyChild() {\n      return this._children.get(0);\n    }\n  }, {\n    key: \"eachLeafSeries\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function eachLeafSeries() {\n      var children, _iterator, _step, child, _iterator2, _step2, c2;\n\n      return _regeneratorRuntime.wrap(function eachLeafSeries$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              children = this._children.compactArray();\n              _iterator = _createForOfIteratorHelper(children);\n              _context4.prev = 2;\n\n              _iterator.s();\n\n            case 4:\n              if ((_step = _iterator.n()).done) {\n                _context4.next = 30;\n                break;\n              }\n\n              child = _step.value;\n\n              if (!(child instanceof Bucket)) {\n                _context4.next = 26;\n                break;\n              }\n\n              _iterator2 = _createForOfIteratorHelper(child.eachLeafSeries());\n              _context4.prev = 8;\n\n              _iterator2.s();\n\n            case 10:\n              if ((_step2 = _iterator2.n()).done) {\n                _context4.next = 16;\n                break;\n              }\n\n              c2 = _step2.value;\n              _context4.next = 14;\n              return c2;\n\n            case 14:\n              _context4.next = 10;\n              break;\n\n            case 16:\n              _context4.next = 21;\n              break;\n\n            case 18:\n              _context4.prev = 18;\n              _context4.t0 = _context4[\"catch\"](8);\n\n              _iterator2.e(_context4.t0);\n\n            case 21:\n              _context4.prev = 21;\n\n              _iterator2.f();\n\n              return _context4.finish(21);\n\n            case 24:\n              _context4.next = 28;\n              break;\n\n            case 26:\n              _context4.next = 28;\n              return child;\n\n            case 28:\n              _context4.next = 4;\n              break;\n\n            case 30:\n              _context4.next = 35;\n              break;\n\n            case 32:\n              _context4.prev = 32;\n              _context4.t1 = _context4[\"catch\"](2);\n\n              _iterator.e(_context4.t1);\n\n            case 35:\n              _context4.prev = 35;\n\n              _iterator.f();\n\n              return _context4.finish(35);\n\n            case 38:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, eachLeafSeries, this, [[2, 32, 35, 38], [8, 18, 21, 24]]);\n    })\n  }, {\n    key: \"serialize\",\n    value: function serialize(map, reduce) {\n      // serialize to a custom non-sparse representation\n      return reduce(this._children.reduce(function (acc, child, index) {\n        if (child) {\n          if (child instanceof Bucket) {\n            acc.push(child.serialize(map, reduce));\n          } else {\n            acc.push(map(child, index));\n          }\n        }\n\n        return acc;\n      }, []));\n    }\n  }, {\n    key: \"asyncTransform\",\n    value: function asyncTransform(asyncMap, asyncReduce) {\n      return asyncTransformBucket(this, asyncMap, asyncReduce);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.serialize(mapNode, reduceNodes);\n    }\n  }, {\n    key: \"prettyPrint\",\n    value: function prettyPrint() {\n      return JSON.stringify(this.toJSON(), null, '  ');\n    }\n  }, {\n    key: \"tableSize\",\n    value: function tableSize() {\n      return Math.pow(2, this._options.bits);\n    }\n  }, {\n    key: \"_findChild\",\n    value: function () {\n      var _findChild2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key) {\n        var result, child;\n        return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._findPlace(key);\n\n              case 2:\n                result = _context5.sent;\n                child = result.bucket._at(result.pos);\n\n                if (!(child && child.key === key)) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", child);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _findChild(_x5) {\n        return _findChild2.apply(this, arguments);\n      }\n\n      return _findChild;\n    }()\n  }, {\n    key: \"_findPlace\",\n    value: function () {\n      var _findPlace2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key) {\n        var hashValue, index, child;\n        return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                hashValue = this._options.hash(key);\n                _context6.next = 3;\n                return hashValue.take(this._options.bits);\n\n              case 3:\n                index = _context6.sent;\n                child = this._children.get(index);\n\n                if (!(child instanceof Bucket)) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", child._findPlace(hashValue));\n\n              case 7:\n                return _context6.abrupt(\"return\", {\n                  bucket: this,\n                  pos: index,\n                  hash: hashValue\n                });\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _findPlace(_x6) {\n        return _findPlace2.apply(this, arguments);\n      }\n\n      return _findPlace;\n    }()\n  }, {\n    key: \"_findNewBucketAndPos\",\n    value: function () {\n      var _findNewBucketAndPos2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(key) {\n        var place, child, bucket, newPlace;\n        return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._findPlace(key);\n\n              case 2:\n                place = _context7.sent;\n                child = place.bucket._at(place.pos);\n\n                if (!(child && child.key !== key)) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                // conflict\n                bucket = new Bucket(this._options, place.bucket, place.pos);\n\n                place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n                _context7.next = 9;\n                return bucket._findPlace(child.hash);\n\n              case 9:\n                newPlace = _context7.sent;\n\n                newPlace.bucket._putAt(newPlace, child.key, child.value);\n\n                return _context7.abrupt(\"return\", bucket._findNewBucketAndPos(place.hash));\n\n              case 12:\n                return _context7.abrupt(\"return\", place);\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _findNewBucketAndPos(_x7) {\n        return _findNewBucketAndPos2.apply(this, arguments);\n      }\n\n      return _findNewBucketAndPos;\n    }()\n  }, {\n    key: \"_putAt\",\n    value: function _putAt(place, key, value) {\n      this._putObjectAt(place.pos, {\n        key: key,\n        value: value,\n        hash: place.hash\n      });\n    }\n  }, {\n    key: \"_putObjectAt\",\n    value: function _putObjectAt(pos, object) {\n      if (!this._children.get(pos)) {\n        this._popCount++;\n      }\n\n      this._children.set(pos, object);\n    }\n  }, {\n    key: \"_delAt\",\n    value: function _delAt(pos) {\n      if (this._children.get(pos)) {\n        this._popCount--;\n      }\n\n      this._children.unset(pos);\n\n      this._level();\n    }\n  }, {\n    key: \"_level\",\n    value: function _level() {\n      if (this._parent && this._popCount <= 1) {\n        if (this._popCount === 1) {\n          // remove myself from parent, replacing me with my only child\n          var onlyChild = this._children.find(exists);\n\n          if (!(onlyChild instanceof Bucket)) {\n            var hash = onlyChild.hash;\n            hash.untake(this._options.bits);\n            var place = {\n              pos: this._posAtParent,\n              hash: hash\n            };\n\n            this._parent._putAt(place, onlyChild.key, onlyChild.value);\n          }\n        } else {\n          this._parent._delAt(this._posAtParent);\n        }\n      }\n    }\n  }, {\n    key: \"_at\",\n    value: function _at(index) {\n      return this._children.get(index);\n    }\n  }], [{\n    key: \"isBucket\",\n    value: function isBucket(o) {\n      return o instanceof Bucket;\n    }\n  }]);\n\n  return Bucket;\n}();\n\nfunction exists(o) {\n  return Boolean(o);\n}\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\nfunction asyncTransformBucket(_x8, _x9, _x10) {\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nfunction _asyncTransformBucket() {\n  _asyncTransformBucket = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(bucket, asyncMap, asyncReduce) {\n    var output, _iterator3, _step3, child, mappedChildren;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            output = [];\n            _iterator3 = _createForOfIteratorHelper(bucket._children.compactArray());\n            _context8.prev = 2;\n\n            _iterator3.s();\n\n          case 4:\n            if ((_step3 = _iterator3.n()).done) {\n              _context8.next = 18;\n              break;\n            }\n\n            child = _step3.value;\n\n            if (!(child instanceof Bucket)) {\n              _context8.next = 11;\n              break;\n            }\n\n            _context8.next = 9;\n            return asyncTransformBucket(child, asyncMap, asyncReduce);\n\n          case 9:\n            _context8.next = 15;\n            break;\n\n          case 11:\n            _context8.next = 13;\n            return asyncMap(child);\n\n          case 13:\n            mappedChildren = _context8.sent;\n            output.push({\n              bitField: bucket._children.bitField(),\n              children: mappedChildren\n            });\n\n          case 15:\n            return _context8.abrupt(\"return\", asyncReduce(output));\n\n          case 16:\n            _context8.next = 4;\n            break;\n\n          case 18:\n            _context8.next = 23;\n            break;\n\n          case 20:\n            _context8.prev = 20;\n            _context8.t0 = _context8[\"catch\"](2);\n\n            _iterator3.e(_context8.t0);\n\n          case 23:\n            _context8.prev = 23;\n\n            _iterator3.f();\n\n            return _context8.finish(23);\n\n          case 26:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee7, null, [[2, 20, 23, 26]]);\n  }));\n  return _asyncTransformBucket.apply(this, arguments);\n}\n\nmodule.exports = Bucket;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/hamt-sharding/src/bucket.js"],"names":["SparseArray","require","wrapHash","defaultOptions","bits","Bucket","options","parent","posAtParent","_options","Object","assign","_popCount","_parent","_posAtParent","hashFn","Error","hash","_children","key","value","_findNewBucketAndPos","place","bucket","_putAt","_findChild","child","_findPlace","_at","pos","_delAt","compactArray","reduce","acc","leafCount","length","get","children","eachLeafSeries","c2","map","index","push","serialize","asyncMap","asyncReduce","asyncTransformBucket","mapNode","reduceNodes","JSON","stringify","toJSON","Math","pow","result","hashValue","take","_putObjectAt","newPlace","object","set","unset","_level","onlyChild","find","exists","untake","o","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst SparseArray = require('sparse-array')\nconst wrapHash = require('./consumable-hash')\n\nconst defaultOptions = {\n  bits: 8\n}\n\nclass Bucket {\n  constructor (options, parent, posAtParent) {\n    this._options = Object.assign({}, defaultOptions, options)\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    if (!this._options.hashFn) {\n      throw new Error('please define an options.hashFn')\n    }\n\n    // make sure we only wrap options.hashFn once in the whole tree\n    if (!this._options.hash) {\n      this._options.hash = wrapHash(this._options.hashFn)\n    }\n    this._children = new SparseArray()\n  }\n\n  static isBucket (o) {\n    return o instanceof Bucket\n  }\n\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount () {\n    return this._children.compactArray().reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        for (const c2 of child.eachLeafSeries()) {\n          yield c2\n        }\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize (map, reduce) {\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, []))\n  }\n\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key) {\n    const hashValue = this._options.hash(key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue\n    }\n  }\n\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key !== key) {\n      // conflict\n\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(child.hash)\n      newPlace.bucket._putAt(newPlace, child.key, child.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos) {\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (!(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o) {\n  return Boolean(o)\n}\n\nfunction mapNode (node, index) {\n  return node.key\n}\n\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n\n    return asyncReduce(output)\n  }\n}\n\nmodule.exports = Bucket\n"]},"metadata":{},"sourceType":"script"}