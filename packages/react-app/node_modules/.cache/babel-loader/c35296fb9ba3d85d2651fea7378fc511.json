{"ast":null,"code":"/*!\n * elliptic.js - elliptic curves for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/elliptic:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/elliptic\n *\n * Formulas from DJB and Tanja Lange [EFD].\n *\n * References:\n *\n *   [GECC] Guide to Elliptic Curve Cryptography\n *     D. Hankerson, A. Menezes, and S. Vanstone\n *     https://tinyurl.com/guide-to-ecc\n *\n *   [GLV] Faster Point Multiplication on Elliptic Curves\n *     R. Gallant, R. Lambert, and S. Vanstone\n *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf\n *\n *   [MONT1] Montgomery curves and the Montgomery ladder\n *     Daniel J. Bernstein, Tanja Lange\n *     https://eprint.iacr.org/2017/293.pdf\n *\n *   [COZ] Scalar Multiplication on Elliptic Curves from Co-Z Arithmetic\n *     R. Goundar, M. Joye, A. Miyaji, M. Rivain, A. Venelli\n *     https://www.matthieurivain.com/files/jcen11b.pdf\n *\n *   [SQUARED] Elligator Squared\n *     Mehdi Tibouchi\n *     https://eprint.iacr.org/2014/043.pdf\n *\n *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group\n *     Certicom Research\n *     https://www.secg.org/sec1-v2.pdf\n *\n *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters\n *     Certicom Research\n *     https://www.secg.org/sec2-v2.pdf\n *\n *   [SIDE1] Elliptic Curves and Side-Channel Attacks\n *     Marc Joye\n *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf\n *\n *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications\n *     B. Feix, M. Roussellet, A. Venelli\n *     https://eprint.iacr.org/2014/191.pdf\n *\n *   [ALT] Alternative Elliptic Curve Representations\n *     R. Struik\n *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html\n *\n *   [ARITH1] Arithmetic of Elliptic Curves\n *     Christophe Doche, Tanja Lange\n *     Handbook of Elliptic and Hyperelliptic Curve Cryptography\n *     Page 267, Section 13 (978-1-58488-518-4)\n *     https://hyperelliptic.org/HEHCC/index.html\n *\n *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition\n *     Joseph H. Silverman\n *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf\n *\n *   [EFD] Explicit-Formulas Database\n *     Daniel J. Bernstein, Tanja Lange\n *     https://hyperelliptic.org/EFD/index.html\n *\n *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography\n *     Daniel J. Bernstein\n *     https://safecurves.cr.yp.to/\n *\n *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves\n *     Hairong Yi, Yuqing Zhu, and Dongdai Lin\n *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf\n *\n *   [ICART] How to Hash into Elliptic Curves\n *     Thomas Icart\n *     https://eprint.iacr.org/2009/226.pdf\n *\n *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\n *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi\n *     https://eprint.iacr.org/2009/340.pdf\n *\n *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields\n *     Maciej Ulas\n *     https://arxiv.org/abs/0706.1448\n *\n *   [H2EC] Hashing to Elliptic Curves\n *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood\n *     https://git.io/JeWz6\n *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve\n *\n *   [SVDW1] Construction of Rational Points on Elliptic Curves\n *     A. Shallue, C. E. van de Woestijne\n *     https://works.bepress.com/andrew_shallue/1/download/\n *\n *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves\n *     Pierre-Alain Fouque, Mehdi Tibouchi\n *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf\n *\n *   [SVDW3] Covert ECDH over secp256k1\n *     Pieter Wuille\n *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039\n *\n *   [MONT2] Montgomery Curve (wikipedia)\n *     https://en.wikipedia.org/wiki/Montgomery_curve\n *\n *   [SIDE2] Weierstrass Elliptic Curves and Side-Channel Attacks\n *     Eric Brier, Marc Joye\n *     http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.2.273&rep=rep1&type=pdf\n *\n *   [SIDE3] Unified Point Addition Formulae and Side-Channel Attacks\n *     Douglas Stebila, Nicolas Theriault\n *     https://eprint.iacr.org/2005/419.pdf\n *\n *   [MONT3] Montgomery Curves and their arithmetic\n *     C. Costello, B. Smith\n *     https://eprint.iacr.org/2017/212.pdf\n *\n *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings\n *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange\n *     https://elligator.cr.yp.to/elligator-20130828.pdf\n *\n *   [RFC7748] Elliptic Curves for Security\n *     A. Langley, M. Hamburg, S. Turner\n *     https://tools.ietf.org/html/rfc7748\n *\n *   [TWISTED] Twisted Edwards Curves\n *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters\n *     https://eprint.iacr.org/2008/013.pdf\n *\n *   [ELL1] Injective Encodings to Elliptic Curves\n *     P. Fouque, A. Joux, M. Tibouchi\n *     https://eprint.iacr.org/2013/373.pdf\n *\n *   [ISOGENY] Twisting Edwards curves with isogenies\n *     Mike Hamburg\n *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf\n *\n *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)\n *     S. Josefsson, SJD AB, I. Liusvaara\n *     https://tools.ietf.org/html/rfc8032\n *\n *   [TIMING] Remote Timing Attacks are Still Practical\n *     B. Brumley, N. Tuveri\n *     https://eprint.iacr.org/2011/232.pdf\n *\n *   [SCHNORR] Schnorr Signatures for secp256k1\n *     Pieter Wuille\n *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki\n *\n *   [BIP340] Schnorr Signatures for secp256k1\n *     Pieter Wuille, Jonas Nick, Tim Ruffing\n *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography\n *            on Sensor Networks Using the MSP430X Microcontroller\n *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez\n *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf\n *\n *   [FIPS186] Federal Information Processing Standards Publication\n *     National Institute of Standards and Technology\n *     https://tinyurl.com/fips-186-3\n *\n *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool\n *             Standard Curves and Curve Generation\n *     M. Lochter, BSI, J. Merkle\n *     https://tools.ietf.org/html/rfc5639\n *\n *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence\n *     Christopher Jeffrey\n *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc\n *\n *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)\n *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication\n */\n'use strict';\n\nvar _construct = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/construct\");\n\nvar _createForOfIteratorHelper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _get = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _slicedToArray = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('../internal/custom'),\n    custom = _require.custom;\n\nvar BN = require('../bn');\n/*\n * Constants\n */\n\n\nvar types = {\n  AFFINE: 0,\n  JACOBIAN: 1,\n  PROJECTIVE: 2,\n  EXTENDED: 3\n};\nvar jsfIndex = [-3, // -1 -1\n-1, // -1 0\n-5, // -1 1\n-7, // 0 -1\n0, // 0 0\n7, // 0 1\n5, // 1 -1\n1, // 1 0\n3 // 1 1\n];\nvar USE_FIXED = false;\n/**\n * Curve\n */\n\nvar Curve = /*#__PURE__*/function () {\n  function Curve(Point, type, conf) {\n    _classCallCheck(this, Curve);\n\n    this.Point = null;\n    this.id = null;\n    this.ossl = null;\n    this.type = 'base';\n    this.endian = 'be';\n    this.hash = null;\n    this.prefix = null;\n    this.context = false;\n    this.prime = null;\n    this.p = null;\n    this.red = null;\n    this.fieldSize = 0;\n    this.fieldBits = 0;\n    this.adjustedSize = 0;\n    this.signBit = 0;\n    this.n = null;\n    this.h = null;\n    this.q = null;\n    this.z = null;\n    this.g = null;\n    this.nh = null;\n    this.scalarSize = 0;\n    this.scalarBits = 0;\n    this.mask = null;\n    this.zero = null;\n    this.one = null;\n    this.two = null;\n    this.three = null;\n    this.four = null;\n    this.i2 = null;\n    this.i3 = null;\n    this.i4 = null;\n    this.i6 = null;\n    this.torsion = null;\n    this.endo = null;\n    this.hi = null;\n\n    this._init(Point, type, conf);\n  }\n\n  _createClass(Curve, [{\n    key: \"_init\",\n    value: function _init(Point, type, conf) {\n      assert(typeof Point === 'function');\n      assert(typeof type === 'string');\n      assert(conf && typeof conf === 'object');\n      assert(conf.red == null || conf.red instanceof BN.Red);\n      assert(conf.p != null, 'Must pass a prime.');\n      assert(conf.id == null || typeof conf.id === 'string');\n      assert(conf.ossl == null || typeof conf.ossl === 'string');\n      assert(conf.endian == null || typeof conf.endian === 'string');\n      assert(conf.hash == null || typeof conf.hash === 'string');\n      assert(conf.prefix == null || typeof conf.prefix === 'string');\n      assert(conf.context == null || typeof conf.context === 'boolean');\n      assert(conf.prime == null || typeof conf.prime === 'string');\n      assert(conf.torsion == null || Array.isArray(conf.torsion)); // Point class.\n\n      this.Point = Point; // Meta.\n\n      this.id = conf.id || null;\n      this.ossl = conf.ossl || null;\n      this.type = type;\n      this.endian = conf.endian || (type === 'short' ? 'be' : 'le');\n      this.hash = conf.hash || null;\n      this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;\n      this.context = conf.context || false;\n      this.prime = conf.prime || null; // Prime.\n\n      this.p = BN.fromJSON(conf.p); // Reduction.\n\n      if (conf.red) {\n        this.red = conf.red;\n      } else {\n        // Use Montgomery when there is no fast reduction for the prime.\n        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n        this.red.precompute();\n      } // Precalculate encoding length.\n\n\n      this.fieldSize = this.p.byteLength();\n      this.fieldBits = this.p.bitLength();\n      this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);\n      this.signBit = this.adjustedSize * 8 - 1; // Curve configuration, optional.\n\n      this.n = BN.fromJSON(conf.n || '0');\n      this.h = BN.fromJSON(conf.h || '1');\n      this.q = this.n.mul(this.h);\n      this.z = BN.fromJSON(conf.z || '0').toRed(this.red);\n      this.g = null;\n      this.nh = this.n.ushrn(1);\n      this.scalarSize = this.n.byteLength();\n      this.scalarBits = this.n.bitLength();\n      this.mask = null; // Useful for many curves.\n\n      this.zero = new BN(0).toRed(this.red);\n      this.one = new BN(1).toRed(this.red);\n      this.two = new BN(2).toRed(this.red);\n      this.three = new BN(3).toRed(this.red);\n      this.four = new BN(4).toRed(this.red); // Inverses.\n\n      this.i2 = this.two.redInvert();\n      this.i3 = this.three.redInvert();\n      this.i4 = this.i2.redSqr();\n      this.i6 = this.i2.redMul(this.i3); // Torsion.\n\n      this.torsion = new Array(this.h.word(0));\n\n      for (var i = 0; i < this.torsion.length; i++) {\n        this.torsion[i] = this.point();\n      } // Endomorphism.\n\n\n      this.endo = null; // Cache.\n\n      this.hi = null; // Memoize.\n\n      this._scale = memoize(this._scale, this);\n      this.isIsomorphic = memoize(this.isIsomorphic, this);\n      this.isIsogenous = memoize(this.isIsogenous, this); // Sanity checks.\n\n      assert(this.p.sign() > 0 && this.p.isOdd());\n      assert(this.n.sign() >= 0);\n      assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);\n      assert(this.endian === 'be' || this.endian === 'le');\n      return this;\n    }\n  }, {\n    key: \"_finalize\",\n    value: function _finalize(conf) {\n      assert(conf && typeof conf === 'object'); // Create mask.\n\n      this.mask = new Mask(this); // Create base point.\n\n      this.g = conf.g ? this.pointFromJSON(conf.g) : this.point(); // Parse small order points.\n\n      if (conf.torsion) {\n        assert(conf.torsion.length === this.torsion.length);\n\n        for (var i = 0; i < this.torsion.length; i++) {\n          this.torsion[i] = this.pointFromJSON(conf.torsion[i]);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_simpleMul\",\n    value: function _simpleMul(p, k) {\n      // Left-to-right point multiplication.\n      //\n      // [GECC] Algorithm 3.27, Page 97, Section 3.3.\n      //        Algorithm 3.26, Page 96, Section 3.3.\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      assert(!k.red); // We prefer left-to-right since it\n      // allows us to repeatedly add an\n      // affine point to the accumulator.\n\n      var bits = k.bitLength(); // Flip sign if necessary.\n\n      if (k.isNeg()) p = p.neg(); // Multiply.\n\n      var acc = this.jpoint();\n\n      for (var i = bits - 1; i >= 0; i--) {\n        var bit = k.bit(i);\n        acc = acc.dbl();\n        if (bit === 1) acc = acc.add(p);\n      }\n\n      return acc;\n    }\n  }, {\n    key: \"_simpleMulAdd\",\n    value: function _simpleMulAdd(points, coeffs) {\n      // Multiple point multiplication, also known\n      // as \"Shamir's trick\".\n      //\n      // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n      assert(Array.isArray(points));\n      assert(Array.isArray(coeffs));\n      assert(points.length === coeffs.length);\n      var len = points.length;\n      var npoints = new Array(len);\n      var ncoeffs = coeffs; // Check arrays and calculate size.\n\n      var max = 0;\n\n      for (var i = 0; i < len; i++) {\n        var point = points[i];\n        var coeff = coeffs[i];\n        assert(point instanceof Point);\n        assert(coeff instanceof BN);\n        assert(!coeff.red);\n        if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.'); // Flip signs if necessary.\n\n        npoints[i] = coeff.isNeg() ? point.neg() : point; // Compute max scalar size.\n\n        max = Math.max(max, coeff.bitLength());\n      } // Multiply and add.\n\n\n      var acc = this.jpoint();\n\n      for (var _i = max - 1; _i >= 0; _i--) {\n        acc = acc.dbl();\n\n        for (var j = 0; j < len; j++) {\n          var _point = npoints[j];\n          var _coeff = ncoeffs[j];\n\n          var bit = _coeff.bit(_i);\n\n          if (bit === 1) acc = acc.add(_point);\n        }\n      }\n\n      return acc;\n    }\n  }, {\n    key: \"_constMul\",\n    value: function _constMul(p, k, rng) {\n      assert(p instanceof Point); // Must have order.\n\n      if (this.n.isZero()) return this._simpleMul(p, k); // Use Co-Z arithmetic for Weierstrass (h=1).\n\n      if (this.type === 'short' && this.h.cmpn(1) === 0) return this._coZLadderMul(p, k); // Otherwise, a regular ladder.\n\n      return this._ladderMul(p, k);\n    }\n  }, {\n    key: \"_ladderMul\",\n    value: function _ladderMul(p, k) {\n      // Generalized Montgomery Ladder.\n      //\n      // [MONT1] Page 24, Section 4.6.2.\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      assert(!k.red); // Curve must expose some form of unified\n      // addition (this is easier said than done\n      // for Weierstrass curves). This ensures\n      // both branches of the ladder consume\n      // the same power and number of cycles.\n      //\n      // We implement the ladder as a branchless\n      // function with a constant time swap.\n      //\n      // Current cost:\n      //\n      //   N * (14M + 14S + 11A + 2*a + 1*8 + 3*4 + 2*3 + 4*2)\n      //\n      //   N=256 => 3584M + 3584S + 2816A + 512*a\n      //          + 256*8 + 768*4 + 512*3 + 1024*2\n\n      var _getLadderBits = getLadderBits(k, this.q),\n          _getLadderBits2 = _slicedToArray(_getLadderBits, 3),\n          sign = _getLadderBits2[0],\n          bits = _getLadderBits2[1],\n          exp = _getLadderBits2[2]; // Clone points (for safe swapping).\n\n\n      var a = p.toJ().clone();\n      var b = this.jpoint().clone();\n      var swap = 0; // Climb the ladder.\n\n      for (var i = bits - 1; i >= 0; i--) {\n        var bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.\n\n        a.swap(b, swap ^ bit); // Unified addition.\n\n        a = a.uadd(b);\n        b = b.udbl();\n        swap = bit;\n      } // Finalize loop.\n\n\n      a.swap(b, swap); // Flip sign retroactively.\n\n      b.swap(b.neg(), sign);\n      return b;\n    }\n  }, {\n    key: \"_coZLadderMul\",\n    value: function _coZLadderMul(p, k) {\n      // Co-Z Montgomery Ladder.\n      //\n      // [COZ] Algorithm 9, Page 6, Section 4.\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      assert(!k.red); // Multiply with Co-Z arithmetic. This method is\n      // 2x faster than our regular unified addition\n      // ladder. However, there are some problems with\n      // leakage of the scalar length.\n      //\n      // There are three issues with this algorithm:\n      //\n      //   1. The amount of steps in the ladder is not\n      //      constant, since we must assume k[n-1]=1\n      //      (it follows that k[n]=0). A side effect\n      //      of this is that we cannot handle a point\n      //      at infinity (k[n-1]=0).\n      //\n      //   2. On the off chance we pass in a \"low\"\n      //      scalar (lacking several hi bits), there\n      //      will be a noticeable difference in cycles.\n      //\n      //   3. The algorithm cannot handle k = -1 mod n.\n      //      It will overflow to infinity.\n      //\n      // To avoid two of these issues, we _negate_ the\n      // scalar in the event that bits(k) < bits(-k). If\n      // we do end up negating a scalar, we negate the\n      // resulting point in constant time at the end.\n      //\n      // Doing this not only solves the point at infinity\n      // issue (i.e. N-0=N=0), but it also ensures a scalar\n      // is within at least 1 bit of the order (usually).\n      //\n      // The final edge case can be solved with a\n      // comparison and subsequent constant-time swap at\n      // the end.\n      //\n      // Note that our scalar recoding here disallows\n      // the possibility of curves with a cofactor > 1.\n      //\n      // A possibility for a perf improvement involves\n      // using the ZACAU method. This is faster assuming\n      // a cost of 1S < 1M, but our squaring impl. is\n      // identical to our multiplication impl., so we\n      // wouldn't get any real benefit.\n      //\n      // Current cost:\n      //\n      //   1M + 5S + 8A + 4*2 + 1*8\n      //   N * (11M + 3S + 21A + 1*2)\n      //\n      //   N=256 => 2817M + 773S + 5384A + 256*2 + 4*2 + 1*8\n\n      var c = p.toJ().clone();\n\n      var _getCOZBits = getCOZBits(k, this.n),\n          _getCOZBits2 = _slicedToArray(_getCOZBits, 4),\n          sign = _getCOZBits2[0],\n          bits = _getCOZBits2[1],\n          exp = _getCOZBits2[2],\n          m1 = _getCOZBits2[3]; // Initial double (we assume k[n-1] == 1).\n\n\n      var _c$zdblu = c.zdblu(),\n          _c$zdblu2 = _slicedToArray(_c$zdblu, 2),\n          a = _c$zdblu2[0],\n          b = _c$zdblu2[1];\n\n      var swap = 0; // Climb the ladder.\n\n      for (var i = bits - 2; i >= 0; i--) {\n        var bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.\n\n        a.swap(b, swap ^ bit); // Co-Z addition.\n\n        var _b$zaddc = b.zaddc(a);\n\n        var _b$zaddc2 = _slicedToArray(_b$zaddc, 2);\n\n        a = _b$zaddc2[0];\n        b = _b$zaddc2[1];\n\n        var _a$zaddu = a.zaddu(b);\n\n        var _a$zaddu2 = _slicedToArray(_a$zaddu, 2);\n\n        b = _a$zaddu2[0];\n        a = _a$zaddu2[1];\n        swap = bit;\n      } // Finalize loop.\n\n\n      a.swap(b, swap); // Final edge case.\n\n      b.swap(c.neg(), m1); // Adjust sign.\n\n      b.swap(b.neg(), sign);\n      return b;\n    }\n  }, {\n    key: \"_fixedMul\",\n    value: function _fixedMul(p, k) {\n      // Fixed-base method for point multiplication.\n      //\n      // [ECPM] \"Windowed method\".\n      // [GECC] Page 95, Section 3.3.\n      //\n      // Windows are appropriately shifted to avoid any\n      // doublings. This reduces a 256 bit multiplication\n      // down to 64 additions with a window size of 4.\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      assert(p.pre && p.pre.windows); // Get precomputed windows.\n\n      var _p$_getWindows = p._getWindows(0, 0),\n          width = _p$_getWindows.width,\n          bits = _p$_getWindows.bits,\n          points = _p$_getWindows.points; // Recompute window size.\n\n\n      var size = 1 << width; // Recompute steps.\n\n      var steps = (bits + width - 1) / width >>> 0; // Multiply.\n\n      var acc = this.jpoint();\n\n      for (var i = 0; i < steps; i++) {\n        var _bits = k.bits(i * width, width);\n\n        acc = acc.add(points[i * size + _bits]);\n      } // Adjust sign.\n\n\n      if (k.isNeg()) acc = acc.neg();\n      return acc;\n    }\n  }, {\n    key: \"_fixedNafMul\",\n    value: function _fixedNafMul(p, k) {\n      // Fixed-base NAF windowing method for point multiplication.\n      //\n      // [GECC] Algorithm 3.42, Page 105, Section 3.3.\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      assert(p.pre && p.pre.doubles); // Get precomputed doubles.\n\n      var _p$_getDoubles = p._getDoubles(0, 0),\n          step = _p$_getDoubles.step,\n          points = _p$_getDoubles.points; // Get fixed NAF (in a more windowed form).\n\n\n      var naf = getFixedNAF(k, 1, k.bitLength() + 1, step); // Compute steps.\n\n      var I = ((1 << step + 1) - (step % 2 === 0 ? 2 : 1)) / 3; // Multiply.\n\n      var a = this.jpoint();\n      var b = this.jpoint();\n\n      for (var i = I; i > 0; i--) {\n        for (var j = 0; j < naf.length; j++) {\n          var nafW = naf[j];\n          if (nafW === i) b = b.add(points[j]);else if (nafW === -i) b = b.sub(points[j]);\n        }\n\n        a = a.add(b);\n      }\n\n      return a;\n    }\n  }, {\n    key: \"_windowMul\",\n    value: function _windowMul(width, p, k) {\n      // Windowed method for point multiplication.\n      //\n      // [ECPM] \"Windowed method\".\n      // [GECC] Page 95, Section 3.3.\n      assert(width >>> 0 === width);\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      var size = 1 << width;\n      var bits = Math.max(k.bitLength(), this.n.bitLength());\n      var steps = (bits + width - 1) / width >>> 0;\n      var wnd = new Array(size);\n      var point = p.toJ(); // Precompute.\n\n      wnd[0] = this.jpoint();\n      wnd[1] = point;\n\n      for (var i = 2; i < size; i += 2) {\n        wnd[i + 0] = wnd[i >> 1].dbl();\n        wnd[i + 1] = wnd[i].add(point);\n      } // Multiply.\n\n\n      var acc = this.jpoint();\n\n      for (var _i2 = steps - 1; _i2 >= 0; _i2--) {\n        var _bits2 = k.bits(_i2 * width, width);\n\n        if (_i2 === steps - 1) {\n          acc = wnd[_bits2];\n        } else {\n          acc = acc.dblp(width);\n          acc = acc.add(wnd[_bits2]);\n        }\n      } // Adjust sign.\n\n\n      if (k.isNeg()) acc = acc.neg();\n      return acc;\n    }\n  }, {\n    key: \"_slideMul\",\n    value: function _slideMul(width, p, k) {\n      // Sliding window method for point multiplication.\n      //\n      // [ECPM] \"Sliding-window method\".\n      // [GECC] Algorithm 3.38, Page 101, Section 3.3.\n      assert(width >>> 0 === width);\n      assert(p instanceof Point);\n      assert(k instanceof BN);\n      var size = 1 << width - 1;\n      var wnd = new Array(size);\n      var point = p.toJ(); // Precompute.\n\n      wnd[0] = point.dblp(width - 1);\n      wnd[1] = wnd[0].add(point);\n\n      for (var _i3 = 2; _i3 < size; _i3++) {\n        wnd[_i3] = wnd[_i3 - 1].add(point);\n      } // Multiply.\n\n\n      var i = k.bitLength();\n      var r = this.jpoint();\n\n      while (i >= width) {\n        var pos = i - width;\n        var bits = k.bits(pos, width);\n\n        if (bits < size) {\n          r = r.dbl();\n          i -= 1;\n          continue;\n        }\n\n        r = r.dblp(width);\n        r = r.add(wnd[bits & ~size]);\n        i = pos;\n      } // Finish.\n\n\n      if (i > 0) {\n        var _bits3 = k.bits(0, i);\n\n        while (i--) {\n          r = r.dbl();\n          if (_bits3 >> i & 1) r = r.add(p);\n        }\n      } // Adjust sign.\n\n\n      if (k.isNeg()) r = r.neg();\n      return r;\n    }\n  }, {\n    key: \"_wnafMul\",\n    value: function _wnafMul(w, p, k) {\n      // Window NAF method for point multiplication.\n      //\n      // [GECC] Algorithm 3.36, Page 100, Section 3.3.\n      assert(p instanceof Point);\n      assert(k instanceof BN); // Precompute window.\n\n      var _p$_safeNAF = p._safeNAF(w),\n          width = _p$_safeNAF.width,\n          points = _p$_safeNAF.points; // Get NAF form.\n\n\n      var naf = getNAF(k, width, k.bitLength() + 1); // Add `this`*(N+1) for every w-NAF index.\n\n      var acc = this.jpoint();\n\n      for (var i = naf.length - 1; i >= 0; i--) {\n        var z = naf[i];\n        if (i !== naf.length - 1) acc = acc.dbl();\n        if (z > 0) acc = acc.add(points[z - 1 >> 1]);else if (z < 0) acc = acc.sub(points[-z - 1 >> 1]);\n      }\n\n      return acc;\n    }\n  }, {\n    key: \"_wnafMulAdd\",\n    value: function _wnafMulAdd(w, points, coeffs) {\n      // Multiple point multiplication, also known\n      // as \"Shamir's trick\" (with interleaved NAFs).\n      //\n      // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n      //        Algorithm 3.51, Page 112, Section 3.3.\n      //\n      // This is particularly useful for signature\n      // verifications and mutiplications after an\n      // endomorphism split.\n      assert(w >>> 0 === w);\n      assert(Array.isArray(points));\n      assert(Array.isArray(coeffs));\n      assert(points.length === coeffs.length);\n      var length = points.length;\n      var wnd = new Array(length);\n      var naf = new Array(length); // Check arrays and calculate size.\n\n      var max = 0;\n\n      for (var i = 0; i < length; i++) {\n        var point = points[i];\n        var coeff = coeffs[i];\n        assert(point instanceof Point);\n        assert(coeff instanceof BN);\n        if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.'); // Avoid sparse arrays.\n\n        wnd[i] = null;\n        naf[i] = null; // Compute max scalar size.\n\n        max = Math.max(max, coeff.bitLength() + 1);\n      } // Compute NAFs.\n\n\n      var ppoint = null;\n      var pcoeff = null;\n      var len = 0;\n\n      for (var _i4 = 0; _i4 < length; _i4++) {\n        var _point2 = points[_i4];\n        var _coeff2 = coeffs[_i4];\n\n        var pre = _point2._getNAF(0); // Use precomputation if available.\n\n\n        if (pre) {\n          wnd[len] = pre.points;\n          naf[len] = getNAF(_coeff2, pre.width, max);\n          len += 1;\n          continue;\n        } // Save last non-precomputed point.\n\n\n        if (!ppoint) {\n          ppoint = _point2;\n          pcoeff = _coeff2;\n          continue;\n        } // Compute JSF in NAF form.\n\n\n        wnd[len] = ppoint._getJNAF(_point2);\n        naf[len] = getJNAF(pcoeff, _coeff2, max);\n        ppoint = null;\n        pcoeff = null;\n        len += 1;\n      } // Regular NAF for odd points.\n\n\n      if (ppoint) {\n        var nafw = ppoint._safeNAF(w);\n\n        wnd[len] = nafw.points;\n        naf[len] = getNAF(pcoeff, nafw.width, max);\n        len += 1;\n      } // Multiply and add.\n\n\n      var acc = this.jpoint();\n\n      for (var _i5 = max - 1; _i5 >= 0; _i5--) {\n        if (_i5 !== max - 1) acc = acc.dbl();\n\n        for (var j = 0; j < len; j++) {\n          var z = naf[j][_i5];\n          if (z > 0) acc = acc.add(wnd[j][z - 1 >> 1]);else if (z < 0) acc = acc.sub(wnd[j][-z - 1 >> 1]);\n        }\n      }\n\n      return acc;\n    }\n  }, {\n    key: \"_endoWnafMulAdd\",\n    value: function _endoWnafMulAdd(points, coeffs) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"_scale\",\n    value: function _scale(curve, invert) {\n      assert(curve instanceof Curve);\n      assert(curve.p.eq(this.p));\n\n      switch (curve.type) {\n        case 'short':\n          return this._scaleShort(curve, invert);\n\n        case 'mont':\n          return this._scaleMont(curve, invert);\n\n        case 'edwards':\n          return this._scaleEdwards(curve, invert);\n\n        default:\n          throw new Error('Not implemented.');\n      }\n    }\n  }, {\n    key: \"_scaleShort\",\n    value: function _scaleShort(curve, invert) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"_scaleMont\",\n    value: function _scaleMont(curve, invert) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"_scaleEdwards\",\n    value: function _scaleEdwards(curve, invert) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isElliptic\",\n    value: function isElliptic() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"jinv\",\n    value: function jinv() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return false;\n    }\n  }, {\n    key: \"precompute\",\n    value: function precompute(rng) {\n      assert(!this.g.isInfinity(), 'Must have base point.');\n      assert(!this.n.isZero(), 'Must have order.');\n      this.g.precompute(this.n.bitLength(), rng);\n      return this;\n    }\n  }, {\n    key: \"scalar\",\n    value: function scalar(num, base, endian) {\n      var k = new BN(num, base, endian);\n      assert(!k.red);\n      if (this.n.isZero()) return k;\n      return k.imod(this.n);\n    }\n  }, {\n    key: \"field\",\n    value: function field(num, base, endian) {\n      var x = BN.cast(num, base, endian);\n      if (x.red) return x.forceRed(this.red);\n      return x.toRed(this.red);\n    }\n  }, {\n    key: \"point\",\n    value: function point(x, y) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"jpoint\",\n    value: function jpoint(x, y, z) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"xpoint\",\n    value: function xpoint(x, z) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"cpoint\",\n    value: function cpoint(xx, xz, yy, yz) {\n      assert(xx instanceof BN);\n      assert(xz instanceof BN);\n      assert(yy instanceof BN);\n      assert(yz instanceof BN);\n      if (xz.isZero() || yz.isZero()) return this.point();\n      var z = xz.redMul(yz).redInvert();\n      var x = xx.redMul(yz).redMul(z);\n      var y = yy.redMul(xz).redMul(z);\n      return this.point(x, y);\n    }\n  }, {\n    key: \"solveX2\",\n    value: function solveX2(y) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"solveX\",\n    value: function solveX(y) {\n      return this.solveX2(y).redSqrt();\n    }\n  }, {\n    key: \"solveY2\",\n    value: function solveY2(x) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"solveY\",\n    value: function solveY(x) {\n      return this.solveY2(x).redSqrt();\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromX\",\n    value: function pointFromX(x, sign) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromY\",\n    value: function pointFromY(y, sign) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isIsomorphic\",\n    value: function isIsomorphic(curve) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isIsogenous\",\n    value: function isIsogenous(curve) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromShort\",\n    value: function pointFromShort(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromMont\",\n    value: function pointFromMont(point, sign) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromEdwards\",\n    value: function pointFromEdwards(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromUniform\",\n    value: function pointFromUniform(u) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointToUniform\",\n    value: function pointToUniform(p) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromHash\",\n    value: function pointFromHash(bytes) {\n      var pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // [H2EC] \"Roadmap\".\n      assert(Buffer.isBuffer(bytes));\n      assert(typeof pake === 'boolean');\n      if (bytes.length !== this.fieldSize * 2) throw new Error('Invalid hash size.'); // Random oracle encoding.\n      // Ensure a proper distribution.\n\n      var s1 = bytes.slice(0, this.fieldSize);\n      var s2 = bytes.slice(this.fieldSize);\n      var u1 = this.decodeUniform(s1);\n      var u2 = this.decodeUniform(s2);\n      var p1 = this.pointFromUniform(u1);\n      var p2 = this.pointFromUniform(u2);\n      var p3 = p1.uadd(p2);\n      return pake ? p3.mulH() : p3;\n    }\n  }, {\n    key: \"pointToHash\",\n    value: function pointToHash(p, subgroup, rng) {\n      // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n      assert(p instanceof this.Point);\n      assert(subgroup >>> 0 === subgroup); // Add a random torsion component.\n\n      var i = subgroup % this.torsion.length;\n      var p0 = p.add(this.torsion[i]); // Average Cost (R = sqrt):\n      //\n      //   SSWU (~4 iterations) => 8I + 16R\n      //   SVDW (~4 iterations) => 12I + 28R\n      //   Elligator 1 (~2 iterations) => 6I + 10R\n      //   Elligator 2 (~2 iterations) => 4I + 6R\n      //   Ristretto (~1 iteration) => 1I + 2R + h*1R\n\n      for (;;) {\n        var u1 = this.randomField(rng);\n        var p1 = this.pointFromUniform(u1); // Avoid 2-torsion points:\n        //   Short Weierstrass: ((A / 3) / B, 0)\n        //   Montgomery: (0, 0)\n        //   Twisted Edwards: (0, -1)\n\n        if (p1.neg().eq(p1)) continue;\n        var p2 = p0.usub(p1);\n        var hint = randomInt(rng);\n        var u2 = void 0;\n\n        try {\n          u2 = this.pointToUniform(p2, hint & 15);\n        } catch (e) {\n          if (e.message === 'Invalid point.') continue;\n          throw e;\n        }\n\n        var s1 = this.encodeUniform(u1, hint >>> 8);\n        var s2 = this.encodeUniform(u2, hint >>> 16);\n        return Buffer.concat([s1, s2]);\n      }\n    }\n  }, {\n    key: \"randomScalar\",\n    value: function randomScalar(rng) {\n      var max = this.n.isZero() ? this.p : this.n;\n      return BN.random(rng, 1, max);\n    }\n  }, {\n    key: \"randomField\",\n    value: function randomField(rng) {\n      return BN.random(rng, 1, this.p).toRed(this.red);\n    }\n  }, {\n    key: \"randomPoint\",\n    value: function randomPoint(rng) {\n      var p;\n\n      for (;;) {\n        var x = this.randomField(rng);\n        var sign = (randomInt(rng) & 1) !== 0;\n\n        try {\n          p = this.pointFromX(x, sign);\n        } catch (e) {\n          continue;\n        }\n\n        assert(p.validate());\n        return p.mulH();\n      }\n    }\n  }, {\n    key: \"mulAll\",\n    value: function mulAll(points, coeffs) {\n      return this.jmulAll(points, coeffs);\n    }\n  }, {\n    key: \"mulAllSimple\",\n    value: function mulAllSimple(points, coeffs) {\n      return this.jmulAllSimple(points, coeffs);\n    }\n  }, {\n    key: \"jmulAll\",\n    value: function jmulAll(points, coeffs) {\n      assert(Array.isArray(points));\n      assert(points.length === 0 || points[0] instanceof Point); // Multiply with endomorphism if we're using affine points.\n\n      if (this.endo && points.length > 0 && points[0].type === types.AFFINE) return this._endoWnafMulAdd(points, coeffs); // Otherwise, a regular Shamir's trick.\n\n      return this._wnafMulAdd(4, points, coeffs);\n    }\n  }, {\n    key: \"jmulAllSimple\",\n    value: function jmulAllSimple(points, coeffs) {\n      return this._simpleMulAdd(points, coeffs);\n    }\n  }, {\n    key: \"mulH\",\n    value: function mulH(k) {\n      assert(k instanceof BN);\n      return this.imulH(k.clone());\n    }\n  }, {\n    key: \"imulH\",\n    value: function imulH(k) {\n      assert(k instanceof BN);\n      assert(!k.red);\n      var word = this.h.word(0); // Optimize for powers of two.\n\n      if ((word & word - 1) === 0) {\n        var bits = this.h.bitLength();\n        return k.iushln(bits - 1).imod(this.n);\n      }\n\n      return k.imuln(word).imod(this.n);\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(k) {\n      return this.mask.reduce(k);\n    }\n  }, {\n    key: \"splitHash\",\n    value: function splitHash(bytes) {\n      return this.mask.splitHash(bytes);\n    }\n  }, {\n    key: \"clamp\",\n    value: function clamp(bytes) {\n      return this.mask.clamp(bytes);\n    }\n  }, {\n    key: \"encodeField\",\n    value: function encodeField(x) {\n      // [SEC1] Page 12, Section 2.3.5.\n      assert(x instanceof BN);\n      assert(!x.red);\n      return x.encode(this.endian, this.fieldSize);\n    }\n  }, {\n    key: \"decodeField\",\n    value: function decodeField(bytes) {\n      // [SEC1] Page 13, Section 2.3.6.\n      assert(Buffer.isBuffer(bytes));\n      if (bytes.length !== this.fieldSize) throw new Error('Invalid field element size.');\n      return BN.decode(bytes, this.endian);\n    }\n  }, {\n    key: \"encodeAdjusted\",\n    value: function encodeAdjusted(x) {\n      assert(x instanceof BN);\n      assert(!x.red);\n      return x.encode(this.endian, this.adjustedSize);\n    }\n  }, {\n    key: \"decodeAdjusted\",\n    value: function decodeAdjusted(bytes) {\n      assert(Buffer.isBuffer(bytes));\n      if (bytes.length !== this.adjustedSize) throw new Error('Invalid field element size.');\n      return BN.decode(bytes, this.endian);\n    }\n  }, {\n    key: \"encodeScalar\",\n    value: function encodeScalar(k) {\n      // [SEC1] Page 13, Section 2.3.7.\n      assert(k instanceof BN);\n      assert(!k.red);\n      return k.encode(this.endian, this.scalarSize);\n    }\n  }, {\n    key: \"decodeScalar\",\n    value: function decodeScalar(bytes) {\n      // [SEC1] Page 14, Section 2.3.8.\n      assert(Buffer.isBuffer(bytes));\n      if (bytes.length !== this.scalarSize) throw new Error('Invalid scalar size.');\n      return BN.decode(bytes, this.endian);\n    }\n  }, {\n    key: \"encodeUniform\",\n    value: function encodeUniform(r, bits) {\n      assert(r instanceof BN);\n      assert(bits >>> 0 === bits);\n      var mask = 0xff;\n      if ((this.fieldBits & 7) !== 0) mask = (1 << (this.fieldBits & 7)) - 1;\n      var x = r.fromRed();\n      var i = this.endian === 'le' ? this.fieldSize - 1 : 0;\n      var out = x.encode(this.endian, this.fieldSize);\n      out[i] |= bits & ~mask & 0xff;\n      return out;\n    }\n  }, {\n    key: \"decodeUniform\",\n    value: function decodeUniform(bytes) {\n      assert(Buffer.isBuffer(bytes));\n      if (bytes.length !== this.fieldSize) throw new Error('Invalid field size.');\n      var x = BN.decode(bytes, this.endian);\n      x.iumaskn(this.fieldBits);\n      return x.toRed(this.red);\n    }\n  }, {\n    key: \"encodePoint\",\n    value: function encodePoint(point, compact) {\n      assert(point instanceof Point);\n      return point.encode(compact);\n    }\n  }, {\n    key: \"decodePoint\",\n    value: function decodePoint(bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"encodeX\",\n    value: function encodeX(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"decodeX\",\n    value: function decodeX(bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"decodeEven\",\n    value: function decodeEven(bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"decodeSquare\",\n    value: function decodeSquare(bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toShort\",\n    value: function toShort() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toMont\",\n    value: function toMont(b0) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toEdwards\",\n    value: function toEdwards(a0) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointToJSON\",\n    value: function pointToJSON(point, pre) {\n      assert(point instanceof Point);\n      return point.toJSON(pre);\n    }\n  }, {\n    key: \"pointFromJSON\",\n    value: function pointFromJSON(json) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      var prefix, context;\n      var n, z, endo;\n\n      if (this.type === 'edwards') {\n        prefix = this.prefix ? this.prefix.toString() : null;\n        context = this.context;\n      }\n\n      if (!this.n.isZero()) n = this.n.toJSON();\n\n      if (!this.z.isZero()) {\n        z = this.z.fromRed();\n        if (this.z.redIsHigh()) z.isub(this.p);\n        z = z.toString(16);\n      }\n\n      if (this.endo) endo = this.endo.toJSON();\n      return {\n        id: this.id,\n        ossl: this.ossl,\n        type: this.type,\n        endian: this.endian,\n        hash: this.hash,\n        prefix: prefix,\n        context: context,\n        prime: this.prime,\n        p: this.p.toJSON(),\n        a: undefined,\n        b: undefined,\n        d: undefined,\n        n: n,\n        h: this.h.toString(16),\n        s: undefined,\n        z: z,\n        c: undefined,\n        g: this.g.toJSON(pre),\n        endo: endo\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return new this(json);\n    }\n  }]);\n\n  return Curve;\n}();\n/**\n * Point\n */\n\n\nvar Point = /*#__PURE__*/function () {\n  function Point(curve, type) {\n    _classCallCheck(this, Point);\n\n    assert(curve instanceof Curve);\n    assert(type >>> 0 === type);\n    this.curve = curve;\n    this.type = type;\n    this.pre = null;\n  }\n\n  _createClass(Point, [{\n    key: \"_init\",\n    value: function _init() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"_getNAF\",\n    value: function _getNAF(width) {\n      assert(width >>> 0 === width);\n      if (this.pre && this.pre.naf) return this.pre.naf;\n      if (width === 0) return null;\n      var size = 1 << width - 1;\n      var points = new Array(size);\n      var dbl = size === 1 ? null : this.dbl();\n      points[0] = this;\n\n      for (var i = 1; i < size; i++) {\n        points[i] = points[i - 1].add(dbl);\n      }\n\n      return new NAF(width, points);\n    }\n  }, {\n    key: \"_safeNAF\",\n    value: function _safeNAF(width) {\n      return this._getNAF(width);\n    }\n  }, {\n    key: \"_getWindows\",\n    value: function _getWindows(width, bits) {\n      assert(width >>> 0 === width);\n      assert(bits >>> 0 === bits);\n      if (this.pre && this.pre.windows) return this.pre.windows;\n      if (width === 0) return null;\n      var size = 1 << width;\n      var steps = (bits + width - 1) / width >>> 0;\n      var points = new Array(steps * size);\n      var g = this.toP();\n\n      for (var i = 0; i < steps; i++) {\n        points[i * size] = this.curve.point();\n\n        for (var j = 1; j < size; j++) {\n          points[i * size + j] = points[i * size + j - 1].add(g);\n        }\n\n        g = g.dblp(width);\n      }\n\n      return new Windows(width, bits, points);\n    }\n  }, {\n    key: \"_getDoubles\",\n    value: function _getDoubles(step, power) {\n      assert(step >>> 0 === step);\n      assert(power >>> 0 === power);\n      if (this.pre && this.pre.doubles) return this.pre.doubles;\n      if (step === 0) return null;\n      var len = Math.ceil(power / step) + 1;\n      var points = new Array(len);\n      var acc = this;\n      var k = 0;\n      points[k++] = acc;\n\n      for (var i = 0; i < power; i += step) {\n        for (var j = 0; j < step; j++) {\n          acc = acc.dbl();\n        }\n\n        points[k++] = acc;\n      }\n\n      assert(k === len);\n      return new Doubles(step, points);\n    }\n  }, {\n    key: \"_getBeta\",\n    value: function _getBeta() {\n      return null;\n    }\n  }, {\n    key: \"_getBlinding\",\n    value: function _getBlinding(rng) {\n      if (this.pre && this.pre.blinding) return this.pre.blinding;\n      if (!rng) return null;\n      if (this.curve.n.isZero()) return null; // Pregenerate a random blinding value:\n      //\n      //   blind = random integer in [1,n-1]\n      //   unblind = G * blind\n      //\n      // We intend to subtract the blinding value\n      // from scalars before multiplication. We\n      // can add the unblinding point once the\n      // multiplication is complete.\n\n      var blind = this.curve.randomScalar(rng);\n      var unblind = this.mul(blind);\n      return new Blinding(blind, unblind);\n    }\n  }, {\n    key: \"_hasWindows\",\n    value: function _hasWindows(k) {\n      assert(k instanceof BN);\n      if (!this.pre || !this.pre.windows) return false;\n      var bits = this.pre.windows.bits;\n      return bits >= k.bitLength();\n    }\n  }, {\n    key: \"_hasDoubles\",\n    value: function _hasDoubles(k) {\n      assert(k instanceof BN);\n      if (!this.pre || !this.pre.doubles) return false;\n      var _this$pre$doubles = this.pre.doubles,\n          step = _this$pre$doubles.step,\n          points = _this$pre$doubles.points;\n      var power = k.bitLength() + 1;\n      return points.length >= Math.ceil(power / step) + 1;\n    }\n  }, {\n    key: \"_getJNAF\",\n    value: function _getJNAF(point) {\n      assert(point instanceof Point);\n      assert(point.type === this.type); // Create comb for JSF.\n\n      return [this, // 1\n      this.add(point), // 3\n      this.sub(point), // 5\n      point // 7\n      ];\n    }\n  }, {\n    key: \"_blind\",\n    value: function _blind(k, rng) {\n      // [SIDE1] Page 5, Section 4.\n      // [BLIND] Page 20, Section 7.\n      assert(k instanceof BN);\n      assert(!k.red); // Scalar splitting (requires precomputation).\n      //\n      // Blind a multiplication by first subtracting\n      // a blinding value from the scalar. Example:\n      //\n      //   b = random integer in [1,n-1]\n      //   B = P * b (precomputed)\n      //   Q = P * (k - b) + B\n      //\n      // Note that Joye describes a different method\n      // (multiplier randomization) which computes:\n      //\n      //   B = random point in E\n      //   Q = (P + B) * k - B * k\n      //\n      // Our method is more similar to the \"scalar\n      // splitting\" technique described in the\n      // second source above.\n      //\n      // The blinding value and its corresponding\n      // point are randomly generated and computed\n      // on boot. As long as an attacker is not\n      // able to observe the boot, this should give\n      // a decent bit of protection against various\n      // channel attacks.\n\n      if (this.pre && this.pre.blinding) {\n        var _this$pre$blinding = this.pre.blinding,\n            blind = _this$pre$blinding.blind,\n            unblind = _this$pre$blinding.unblind;\n        var t = k.sub(blind);\n        return [this, t, unblind];\n      } // Randomization is not possible without\n      // an RNG. Do a normal multiplication.\n\n\n      if (!rng) return [this, k, null]; // If we have no precomputed blinding\n      // factor, there are two possibilities\n      // for randomization:\n      //\n      // 1. Randomize the multiplier by adding\n      //    a random multiple of `n`.\n      //\n      // 2. Re-scale the point itself by a\n      //    random factor.\n      //\n      // The first option can be accomplished\n      // with some like:\n      //\n      //   a = random integer in [1,n-1]\n      //   r = a * n\n      //   Q = P * (k + r)\n      //\n      // The second is accomplished with:\n      //\n      //   a = random element in F(p)\n      //   R = (x * a^2, y * a^3, z * a)\n      //   Q = R * k\n      //\n      // If we have precomputed doubles / naf\n      // points, we opt for the first method\n      // to avoid randomizing everything.\n\n      if (this.pre) {\n        if (this.curve.n.isZero()) return [this, k, null];\n        var a = this.curve.randomScalar(rng);\n        var r = a.mul(this.curve.n);\n\n        var _t = r.iadd(k);\n\n        return [this, _t, null];\n      } // If there is no precomputation _at all_,\n      // we opt for the second method.\n\n\n      var p = this.randomize(rng);\n      return [p, k, null];\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(point, flag) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"precompute\",\n    value: function precompute(bits, rng) {\n      assert(bits >>> 0 === bits);\n      if (!this.pre) this.pre = new Precomp();\n      if (!this.pre.naf) this.pre.naf = this._getNAF(8);\n      if (USE_FIXED && !this.pre.windows) this.pre.windows = this._getWindows(4, bits);\n      if (!this.pre.doubles) this.pre.doubles = this._getDoubles(4, bits + 1);\n      if (!this.pre.beta) this.pre.beta = this._getBeta();\n      if (!this.pre.blinding) this.pre.blinding = this._getBlinding(rng);\n      return this;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      return this.curve.validate(this);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"randomize\",\n    value: function randomize(rng) {\n      var z = this.curve.randomField(rng);\n      return this.scale(z);\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"add\",\n    value: function add(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(point) {\n      assert(point instanceof Point);\n      return this.add(point.neg());\n    }\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"dblp\",\n    value: function dblp(pow) {\n      // Repeated doubling. This can\n      // be optimized by child classes.\n      assert(pow >>> 0 === pow);\n      var r = this;\n\n      for (var i = 0; i < pow; i++) {\n        r = r.dbl();\n      }\n\n      return r;\n    }\n  }, {\n    key: \"uadd\",\n    value: function uadd(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"usub\",\n    value: function usub(point) {\n      assert(point instanceof Point);\n      return this.uadd(point.neg());\n    }\n  }, {\n    key: \"udbl\",\n    value: function udbl() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"zaddu\",\n    value: function zaddu(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"zaddc\",\n    value: function zaddc(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"zdblu\",\n    value: function zdblu() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"diffAdd\",\n    value: function diffAdd(p, q) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"diffAddDbl\",\n    value: function diffAddDbl(p, q) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"recover\",\n    value: function recover() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(point) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isSquare\",\n    value: function isSquare() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"eqX\",\n    value: function eqX(x) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"eqXToP\",\n    value: function eqXToP(x) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"isSmall\",\n    value: function isSmall() {\n      // Test whether the point is of small order.\n      if (this.isInfinity()) return false; // P * h = O\n\n      return this.jmulH().isInfinity();\n    }\n  }, {\n    key: \"hasTorsion\",\n    value: function hasTorsion() {\n      // Test whether the point is in another subgroup.\n      if (this.isInfinity()) return false; // P * n != O\n\n      return !this.jmul(this.curve.n).isInfinity();\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(k) {\n      return this.jmul(k);\n    }\n  }, {\n    key: \"muln\",\n    value: function muln(k) {\n      return this.jmuln(k);\n    }\n  }, {\n    key: \"mulSimple\",\n    value: function mulSimple(k) {\n      return this.jmulSimple(k);\n    }\n  }, {\n    key: \"mulBlind\",\n    value: function mulBlind(k, rng) {\n      return this.jmulBlind(k, rng);\n    }\n  }, {\n    key: \"mulConst\",\n    value: function mulConst(k, rng) {\n      return this.jmulConst(k, rng);\n    }\n  }, {\n    key: \"mulAdd\",\n    value: function mulAdd(k1, p2, k2) {\n      return this.jmulAdd(k1, p2, k2);\n    }\n  }, {\n    key: \"mulAddSimple\",\n    value: function mulAddSimple(k1, p2, k2) {\n      return this.jmulAddSimple(k1, p2, k2);\n    }\n  }, {\n    key: \"mulH\",\n    value: function mulH() {\n      return this.jmulH();\n    }\n  }, {\n    key: \"div\",\n    value: function div(k) {\n      return this.jdiv(k);\n    }\n  }, {\n    key: \"divn\",\n    value: function divn(k) {\n      return this.jdivn(k);\n    }\n  }, {\n    key: \"divH\",\n    value: function divH() {\n      return this.jdivH();\n    }\n  }, {\n    key: \"jmul\",\n    value: function jmul(k) {\n      if (USE_FIXED && this._hasWindows(k)) return this.curve._fixedMul(this, k);\n      if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);\n      if (this.curve.endo && this.type === types.AFFINE) return this.curve._endoWnafMulAdd([this], [k]);\n      return this.curve._wnafMul(4, this, k);\n    }\n  }, {\n    key: \"jmuln\",\n    value: function jmuln(k) {\n      assert((k | 0) === k);\n      return this.jmulSimple(new BN(k));\n    }\n  }, {\n    key: \"jmulSimple\",\n    value: function jmulSimple(k) {\n      return this.curve._simpleMul(this, k);\n    }\n  }, {\n    key: \"jmulBlind\",\n    value: function jmulBlind(k) {\n      var rng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var _this$_blind = this._blind(k, rng),\n          _this$_blind2 = _slicedToArray(_this$_blind, 3),\n          p = _this$_blind2[0],\n          t = _this$_blind2[1],\n          unblind = _this$_blind2[2];\n\n      var q = p.jmul(t);\n      if (unblind) return q.add(unblind);\n      return q;\n    }\n  }, {\n    key: \"jmulConst\",\n    value: function jmulConst(k) {\n      var rng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var _this$_blind3 = this._blind(k, rng),\n          _this$_blind4 = _slicedToArray(_this$_blind3, 3),\n          p = _this$_blind4[0],\n          t = _this$_blind4[1],\n          unblind = _this$_blind4[2];\n\n      var q = this.curve._constMul(p, t, rng);\n\n      if (unblind) return q.uadd(unblind);\n      return q;\n    }\n  }, {\n    key: \"jmulAdd\",\n    value: function jmulAdd(k1, p2, k2) {\n      if (this.curve.endo && this.type === types.AFFINE) return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);\n      return this.curve._wnafMulAdd(4, [this, p2], [k1, k2]);\n    }\n  }, {\n    key: \"jmulAddSimple\",\n    value: function jmulAddSimple(k1, p2, k2) {\n      return this.curve._simpleMulAdd([this, p2], [k1, k2]);\n    }\n  }, {\n    key: \"jmulH\",\n    value: function jmulH() {\n      var word = this.curve.h.word(0); // Optimize for powers of two.\n\n      if ((word & word - 1) === 0) {\n        var bits = this.curve.h.bitLength();\n        return this.toJ().dblp(bits - 1);\n      }\n\n      return this.jmulSimple(this.curve.h);\n    }\n  }, {\n    key: \"jdiv\",\n    value: function jdiv(k) {\n      assert(k instanceof BN);\n      assert(!k.red);\n      return this.jmul(k.invert(this.curve.n));\n    }\n  }, {\n    key: \"jdivn\",\n    value: function jdivn(k) {\n      assert(!this.curve.n.isZero());\n      if (this.curve.h.cmpn(k) === 0) return this.jdivH();\n      return this.jdiv(new BN(k));\n    }\n  }, {\n    key: \"jdivH\",\n    value: function jdivH() {\n      if (this.curve.n.isZero()) return this.toJ();\n      if (this.curve.h.cmpn(1) === 0) return this.toJ();\n      if (this.curve.hi === null) this.curve.hi = this.curve.h.invert(this.curve.n);\n      return this.jmul(this.curve.hi);\n    }\n  }, {\n    key: \"ladder\",\n    value: function ladder(k) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"ladderSimple\",\n    value: function ladderSimple(k) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"ladderBlind\",\n    value: function ladderBlind(k, rng) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"ladderConst\",\n    value: function ladderConst(k, rng) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toP\",\n    value: function toP() {\n      return this.normalize();\n    }\n  }, {\n    key: \"toJ\",\n    value: function toJ() {\n      return this;\n    }\n  }, {\n    key: \"toX\",\n    value: function toX() {\n      return this;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(compact) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"encodeX\",\n    value: function encodeX() {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      return '<Point>';\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(curve, bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"decodeX\",\n    value: function decodeX(curve, bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"decodeEven\",\n    value: function decodeEven(curve, bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"decodeSquare\",\n    value: function decodeSquare(curve, bytes) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      throw new Error('Not implemented.');\n    }\n  }]);\n\n  return Point;\n}();\n/**\n * ShortCurve\n */\n\n\nvar ShortCurve = /*#__PURE__*/function (_Curve) {\n  _inherits(ShortCurve, _Curve);\n\n  var _super = _createSuper(ShortCurve);\n\n  function ShortCurve(conf) {\n    var _this;\n\n    _classCallCheck(this, ShortCurve);\n\n    _this = _super.call(this, ShortPoint, 'short', conf);\n    _this.a = BN.fromJSON(conf.a).toRed(_this.red);\n    _this.b = BN.fromJSON(conf.b).toRed(_this.red);\n    _this.c = BN.fromJSON(conf.c || '0').toRed(_this.red);\n    _this.ai = _this.a.isZero() ? _this.zero : _this.a.redInvert();\n    _this.zi = _this.z.isZero() ? _this.zero : _this.z.redInvert();\n    _this.zeroA = _this.a.isZero();\n    _this.threeA = _this.a.eq(_this.three.redNeg());\n    _this.redN = _this.n.toRed(_this.red);\n    _this.pmodn = _this.p.clone();\n    _this.highOrder = _this.n.cmp(_this.p) >= 0;\n    _this.smallGap = false;\n\n    _this._finalize(conf);\n\n    return _this;\n  }\n\n  _createClass(ShortCurve, [{\n    key: \"_finalize\",\n    value: function _finalize(conf) {\n      _get(_getPrototypeOf(ShortCurve.prototype), \"_finalize\", this).call(this, conf); // Precalculate endomorphism.\n\n\n      if (conf.endo != null) this.endo = Endo.fromJSON(this, conf.endo);else this.endo = this._getEndomorphism();\n\n      if (!this.n.isZero()) {\n        this.pmodn = this.p.mod(this.n); // Check for Maxwell's trick (see eqXToP).\n\n        this.smallGap = this.p.div(this.n).cmpn(1) <= 0;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_short\",\n    value: function _short(a0, odd) {\n      return ShortCurve._isomorphism(this.a, this.b, a0, odd);\n    }\n  }, {\n    key: \"_mont\",\n    value: function _mont(b0, odd) {\n      // Short Weierstrass->Montgomery Equivalence.\n      //\n      // [ARITH1] Page 286, Section 13.2.3.c.\n      // [SAFE] \"Ladders\".\n      //\n      // Transformation:\n      //\n      //   r = A / (3 * B)\n      //   s = +-sqrt(3 * r^2 + a)\n      //   A = 3 * r / s\n      //   B = 1 / s\n      var _this$_findRS = this._findRS(odd),\n          _this$_findRS2 = _slicedToArray(_this$_findRS, 2),\n          r = _this$_findRS2[0],\n          s = _this$_findRS2[1];\n\n      var b = s.redInvert();\n      var a = r.redMuln(3).redMul(b);\n      if (b0 != null) return MontCurve._isomorphism(a, b, b0);\n      return [a, b];\n    }\n  }, {\n    key: \"_edwards\",\n    value: function _edwards(a0, odd) {\n      // Short Weierstrass->Twisted Edwards Equivalence.\n      //\n      // [TWISTEQ] Section 1.\n      //\n      // Transformation:\n      //\n      //   r = (a' + d') / 6\n      //   s = +-sqrt(3 * r^2 + a)\n      //   a' = 3 * r + 2 * s\n      //   d' = 3 * r - 2 * s\n      var _this$_findRS3 = this._findRS(odd),\n          _this$_findRS4 = _slicedToArray(_this$_findRS3, 2),\n          r = _this$_findRS4[0],\n          s = _this$_findRS4[1];\n\n      var r3 = r.redMuln(3);\n      var s2 = s.redMuln(2);\n      var a = r3.redAdd(s2);\n      var d = r3.redSub(s2);\n      if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);\n      return [a, d];\n    }\n  }, {\n    key: \"_findRS\",\n    value: function _findRS(sign) {\n      // Find `r` and `s` for equivalence.\n      //\n      // [ARITH1] Page 286, Section 13.2.3.c.\n      // [SAFE] \"Ladders\".\n      //\n      // Computation:\n      //\n      //   r = solve(r^3 + a * r + b == 0, r)\n      //   s = +-sqrt(3 * r^2 + a)\n      //\n      // Computing `r` is non-trivial. We need\n      // to solve `r^3 + a * r + b = 0`, but we\n      // don't have a polynomial solver, so we\n      // loop over random points until we find\n      // one with 2-torsion. Multiplying by the\n      // subgroup order should yield a point of\n      // ((A / 3) / B, 0) which is a solution.\n      assert(sign == null || typeof sign === 'boolean');\n      assert(this.h.word(0) >= 4);\n      assert(!this.n.isZero());\n      var x = this.one.redNeg();\n      var p;\n\n      for (;;) {\n        x.redIAdd(this.one);\n\n        try {\n          p = this.pointFromX(x);\n        } catch (e) {\n          continue;\n        }\n\n        p = p.mul(this.n);\n        if (p.isInfinity()) continue;\n        if (!p.y.isZero()) continue;\n        break;\n      }\n\n      var r = p.x;\n      var r2 = r.redSqr();\n      var s = r2.redMuln(3).redIAdd(this.a).redSqrt();\n\n      if (sign != null) {\n        if (s.redIsOdd() !== sign) s.redINeg();\n      }\n\n      return [r, s];\n    }\n  }, {\n    key: \"_scale0\",\n    value: function _scale0(a, b) {\n      // We can extract the isomorphism factors with:\n      //\n      //   u4 = a' / a\n      //   u6 = b' / b\n      //   u2 = +-sqrt(u4)\n      //   u = +-sqrt(u2)\n      //   u3 = u2 * u\n      //\n      // `u2` should be picked such that `u4 * u2 = u6`.\n      var u4 = this.a.redDiv(this.field(a));\n      var u6 = this.b.redDiv(this.field(b));\n      var u2 = u4.redSqrt();\n      if (!u4.redMul(u2).eq(u6)) u2.redINeg();\n      assert(u4.redMul(u2).eq(u6));\n      var u = u2.redSqrt();\n      var u3 = u2.redMul(u);\n      assert(!u.isZero());\n      return [u2, u3];\n    }\n  }, {\n    key: \"_scale1\",\n    value: function _scale1(x, y) {\n      // If base points are available, it is much\n      // easier, with:\n      //\n      //   u2 = x' / x\n      //   u3 = y' / y\n      //   u = +-sqrt(u2)\n      //\n      // `u` should be picked such that `u2 * u = u3`.\n      var u2 = this.g.x.redDiv(this.field(x));\n      var u3 = this.g.y.redDiv(this.field(y));\n      var u = u2.redSqrt();\n      if (!u2.redMul(u).eq(u3)) u.redINeg();\n      assert(u2.redMul(u).eq(u3));\n      assert(!u.isZero());\n      return [u2, u3];\n    }\n  }, {\n    key: \"_scaleShort\",\n    value: function _scaleShort(curve) {\n      assert(curve instanceof ShortCurve);\n      if (this.g.isInfinity() || curve.g.isInfinity()) return this._scale0(curve.a, curve.b);\n      return this._scale1(curve.g.x, curve.g.y);\n    }\n  }, {\n    key: \"_scaleMont\",\n    value: function _scaleMont(curve) {\n      assert(curve instanceof MontCurve);\n\n      if (this.g.isInfinity() || curve.g.isInfinity()) {\n        var _curve$_short = curve._short(),\n            _curve$_short2 = _slicedToArray(_curve$_short, 2),\n            a = _curve$_short2[0],\n            b = _curve$_short2[1];\n\n        return this._scale0(a, b);\n      }\n\n      var _curve$g = curve.g,\n          x = _curve$g.x,\n          y = _curve$g.y;\n      var nx = x.redAdd(curve.a3).redMul(curve.bi);\n      var ny = y.redMul(curve.bi);\n      return this._scale1(nx, ny);\n    }\n  }, {\n    key: \"_scaleEdwards\",\n    value: function _scaleEdwards(curve) {\n      assert(curve instanceof EdwardsCurve);\n\n      if (this.g.isInfinity() || curve.g.isInfinity()) {\n        var _curve$_short3 = curve._short(),\n            _curve$_short4 = _slicedToArray(_curve$_short3, 2),\n            a = _curve$_short4[0],\n            b = _curve$_short4[1];\n\n        return this._scale0(a, b);\n      }\n\n      var _curve$g2 = curve.g,\n          x = _curve$g2.x,\n          y = _curve$g2.y,\n          z = _curve$g2.z;\n      var a5 = curve.a.redMuln(5);\n      var d5 = curve.d.redMuln(5);\n      var dma = curve.d.redSub(curve.a);\n      var d5a = d5.redSub(curve.a);\n      var da5 = curve.d.redSub(a5);\n      var ypz = y.redAdd(z);\n      var ymz = y.redSub(z);\n      var xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n      var xz = ymz.redMuln(12);\n      var yy = dma.redMul(ypz).redMul(z);\n      var yz = ymz.redMul(x).redIMuln(4);\n      var zi = xz.redMul(yz).redInvert();\n      var nx = xx.redMul(yz).redMul(zi);\n      var ny = yy.redMul(xz).redMul(zi);\n      return this._scale1(nx, ny);\n    }\n  }, {\n    key: \"_getEndomorphism\",\n    value: function _getEndomorphism() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // Compute endomorphism.\n      //\n      // [GECC] Example 3.76, Page 128, Section 3.5.\n      // No curve params.\n      if (this.n.isZero() || this.g.isInfinity()) return null; // No efficient endomorphism.\n\n      if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1) return null; // Solve beta^3 mod p = 1.\n\n      var _this$_getEndoRoots = this._getEndoRoots(this.p),\n          _this$_getEndoRoots2 = _slicedToArray(_this$_getEndoRoots, 2),\n          b1 = _this$_getEndoRoots2[0],\n          b2 = _this$_getEndoRoots2[1]; // Choose the smallest beta by default.\n\n\n      var beta = [b1, b2][index & 1].toRed(this.red); // Solve lambda^3 mod n = 1.\n\n      var _this$_getEndoRoots3 = this._getEndoRoots(this.n),\n          _this$_getEndoRoots4 = _slicedToArray(_this$_getEndoRoots3, 2),\n          l1 = _this$_getEndoRoots4[0],\n          l2 = _this$_getEndoRoots4[1]; // Choose the lambda matching selected beta.\n      // Note that P * lambda = (x * beta, y).\n\n\n      var p = this.point(this.g.x.redMul(beta), this.g.y);\n      var lambda;\n\n      if (this.g.mul(l1).eq(p)) {\n        lambda = l1;\n      } else {\n        assert(this.g.mul(l2).eq(p));\n        lambda = l2;\n      } // Get basis vectors.\n\n\n      var basis = this._getEndoBasis(lambda); // Precompute `g1` and `g2`.\n\n\n      var pre = this._getEndoPrecomp(basis);\n\n      return new Endo(beta, lambda, basis, pre);\n    }\n  }, {\n    key: \"_getEndoRoots\",\n    value: function _getEndoRoots(num) {\n      // Find roots for x^2 + x + 1 in F.\n      //\n      // [GECC] Example 3.76, Page 128, Section 3.5.\n      // [GLV] Page 192, Section 2 (Endomorphisms).\n      //\n      // The above document doesn't fully explain how\n      // to derive these and only \"hints\" at it, as\n      // mentioned by Hal Finney[1], but we're basically\n      // computing two possible cube roots of 1 here.\n      //\n      // Note that we could also compute[2]:\n      //\n      //   beta = 2^((p - 1) / 3) mod p\n      //   lambda = 3^((n - 1) / 3) mod n\n      //\n      // As an extension of Fermat's little theorem:\n      //\n      //   g^(p - 1) mod p == 1\n      //\n      // It is suspected[3] this is how Hal Finney[4]\n      // computed his original endomorphism roots.\n      //\n      // @indutny's method for computing cube roots\n      // of unity[5] appears to be the method described\n      // on wikipedia[6][7].\n      //\n      // Sage produces the same solution:\n      //\n      //   sage: solve(x^2 + x + 1 == 0, x)\n      //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]\n      //\n      // This can be reduced to:\n      //\n      //   x = (+-sqrt(-3) - 1) / 2\n      //\n      // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565\n      // [2] https://crypto.stackexchange.com/a/22739\n      // [3] https://bitcoin.stackexchange.com/a/35872\n      // [4] https://github.com/halfinney/bitcoin/commit/dc411b5\n      // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity\n      // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example\n      // [7] http://mathworld.wolfram.com/SplittingField.html\n      var red = num === this.p ? this.red : BN.mont(num);\n      var two = new BN(2).toRed(red);\n      var three = new BN(3).toRed(red);\n      var i2 = two.redInvert(); // S1 = sqrt(-3) / 2\n\n      var s1 = three.redNeg().redSqrt().redMul(i2); // S2 = -S1\n\n      var s2 = s1.redNeg(); // R1 = S1 - 1 / 2\n\n      var r1 = s1.redSub(i2).fromRed(); // R2 = S2 - 1 / 2\n\n      var r2 = s2.redSub(i2).fromRed();\n      return [r1, r2].sort(BN.cmp);\n    }\n  }, {\n    key: \"_getEndoBasis\",\n    value: function _getEndoBasis(lambda) {\n      // Compute endomorphic basis.\n      //\n      // This essentially computes Cornacchia's algorithm\n      // for solving x^2 + d * y^2 = m (d = lambda, m = order).\n      //\n      // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm\n      //\n      // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n      // [GLV] Page 196, Section 4 (Decomposing K).\n      //\n      // Balanced length-two representation of a multiplier.\n      //\n      // 1. Run the extended euclidean algorithm with inputs n\n      //    and lambda. The algorithm produces a sequence of\n      //    equations si*n + ti*lam = ri where s0=1, t0=0,\n      //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri\n      //    and are non-negative and strictly decreasing. Let\n      //    l be the greatest index for which rl >= sqrt(n).\n      var _this$_egcdSqrt = this._egcdSqrt(lambda),\n          _this$_egcdSqrt2 = _slicedToArray(_this$_egcdSqrt, 6),\n          rl = _this$_egcdSqrt2[0],\n          tl = _this$_egcdSqrt2[1],\n          rl1 = _this$_egcdSqrt2[2],\n          tl1 = _this$_egcdSqrt2[3],\n          rl2 = _this$_egcdSqrt2[4],\n          tl2 = _this$_egcdSqrt2[5]; // 2. Set (a1, b1) <- (rl+1, -tl+1).\n\n\n      var a1 = rl1;\n      var b1 = tl1.neg(); // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)\n      //    then set (a2, b2) <- (rl, -tl).\n      //    else set (a2, b2) <- (rl+2, -tl+2).\n\n      var lhs = rl.sqr().iadd(tl.sqr());\n      var rhs = rl2.sqr().iadd(tl2.sqr());\n      var a2, b2;\n\n      if (lhs.cmp(rhs) <= 0) {\n        a2 = rl;\n        b2 = tl.neg();\n      } else {\n        a2 = rl2;\n        b2 = tl2.neg();\n      }\n\n      return [new Vector(a1, b1), new Vector(a2, b2)];\n    }\n  }, {\n    key: \"_egcdSqrt\",\n    value: function _egcdSqrt(lambda) {\n      // Extended Euclidean algorithm for integers.\n      //\n      // [GECC] Algorithm 2.19, Page 40, Section 2.2.\n      // [GLV] Page 196, Section 4 (Decomposing K).\n      assert(lambda instanceof BN);\n      assert(!lambda.red);\n      assert(lambda.sign() > 0);\n      assert(this.n.sign() > 0); // Note that we insert the approximate square\n      // root checks as described in algorithm 3.74.\n      //\n      // Algorithm 2.19 is defined as:\n      //\n      // 1. u <- a\n      //    v <- b\n      //\n      // 2. x1 <- 1\n      //    y1 <- 0\n      //    x2 <- 0\n      //    y2 <- 1\n      //\n      // 3. while u != 0 do\n      //\n      // 3.1. q <- floor(v / u)\n      //      r <- v - q * u\n      //      x <- x2 - q * x1\n      //      y <- y2 - q * y1\n      //\n      // 3.2. v <- u\n      //      u <- r\n      //      x2 <- x1\n      //      x1 <- x\n      //      y2 <- y1\n      //      y1 <- y\n      //\n      // 4. d <- v\n      //    x <- x2\n      //    y <- y2\n      //\n      // 5. Return (d, x, y).\n      // Start with an approximate square root of n.\n\n      var sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);\n      var u = lambda; // r1\n\n      var v = this.n.clone(); // r0\n\n      var x1 = new BN(1); // t1\n\n      var y1 = new BN(0); // t0\n\n      var x2 = new BN(0); // s1\n\n      var y2 = new BN(1); // s0\n      // All vectors are roots of: a + b * lambda = 0 (mod n).\n\n      var rl, tl; // First vector.\n\n      var rl1, tl1; // Inner.\n\n      var i = 0;\n      var j = 0;\n      var p; // Compute EGCD.\n\n      while (!u.isZero() && i < 2) {\n        var q = v.quo(u);\n        var r = v.sub(q.mul(u));\n        var x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1)); // Check for r < sqrt(n).\n\n        if (j === 0 && r.cmp(sqrtn) < 0) {\n          rl = p;\n          tl = x1;\n          rl1 = r;\n          tl1 = x;\n          j = 1; // 1 more round.\n        }\n\n        p = r;\n        v = u;\n        u = r;\n        x2 = x1;\n        x1 = x;\n        y2 = y1;\n        y1 = y;\n        i += j;\n      } // Should never happen.\n\n\n      assert(j !== 0, 'Could not find r < sqrt(n).'); // Second vector.\n\n      var rl2 = x2;\n      var tl2 = x1;\n      return [rl, tl, rl1, tl1, rl2, tl2];\n    }\n  }, {\n    key: \"_getEndoPrecomp\",\n    value: function _getEndoPrecomp(basis) {\n      // Precompute `g1` and `g2` to avoid round division.\n      //\n      // [JCEN12] Page 5, Section 4.3.\n      //\n      // Computation:\n      //\n      //   d = a1 * b2 - b1 * a2\n      //   t = ceil(log2(d+1)) + 16\n      //   g1 = round((2^t * b2) / d)\n      //   g2 = round((2^t * b1) / d)\n      //\n      // Where `d` is equal to `n`.\n      //\n      // As far as `t` goes, the paper above adds 2,\n      // whereas libsecp256k1 adds 16 (a total of 272).\n      assert(Array.isArray(basis));\n      assert(basis.length === 2);\n      assert(basis[0] instanceof Vector);\n      assert(basis[1] instanceof Vector);\n\n      var _basis = _slicedToArray(basis, 2),\n          v1 = _basis[0],\n          v2 = _basis[1];\n\n      var d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));\n      var shift = d.bitLength() + 16;\n      var pow = BN.shift(1, shift);\n      var g1 = pow.mul(v2.b).divRound(d);\n      var g2 = pow.mul(v1.b).divRound(d);\n      assert(d.eq(this.n));\n      return [g1, g2];\n    }\n  }, {\n    key: \"_endoSplit\",\n    value: function _endoSplit(k) {\n      // Balanced length-two representation of a multiplier.\n      //\n      // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n      //\n      // Also note that it is possible to precompute[1]\n      // values in order to avoid the division[2][3][4].\n      //\n      // This involves precomputing `g1` and `g2 (see\n      // above). `c1` and `c2` can then be computed as\n      // follows:\n      //\n      //   t = ceil(log2(n+1)) + 16\n      //   c1 = (k * g1) >> t\n      //   c2 = -((k * g2) >> t)\n      //\n      // Where `>>` is an _unsigned_ right shift. Also\n      // note that the last bit discarded in the shift\n      // must be stored. If it is 1, then add 1 to the\n      // scalar (absolute addition).\n      //\n      // It's worth noting that libsecp256k1 uses a\n      // different calculation along the lines of:\n      //\n      //   t = ceil(log2(n+1)) + 16\n      //   c1 = ((k * g1) >> t) * -b1\n      //   c2 = ((k * -g2) >> t) * -b2\n      //   k2 = c1 + c2\n      //   k1 = k2 * -lambda + k\n      //\n      // So, in the future, we can consider changing\n      // step 4 to:\n      //\n      //   4. Compute c1 = (k * g1) >> t\n      //          and c2 = -((k * g2) >> t).\n      //\n      //   const shift = this.scalarBits + 16;\n      //   const [g1, g2] = this.endo.pre;\n      //   const c1 = k.mulShift(g1, shift);\n      //   const c2 = k.mulShift(g2, shift).ineg();\n      //\n      // Once we're brave enough, that is.\n      //\n      // [1] [JCEN12] Page 5, Section 4.3.\n      // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259\n      // [3] https://github.com/bitcoin-core/secp256k1/pull/21\n      // [4] https://github.com/bitcoin-core/secp256k1/pull/127\n      assert(k instanceof BN);\n      assert(!k.red);\n      assert(!this.n.isZero());\n\n      var _this$endo$basis = _slicedToArray(this.endo.basis, 2),\n          v1 = _this$endo$basis[0],\n          v2 = _this$endo$basis[1]; // 4. Compute c1 = round(b2 * k / n)\n      //        and c2 = round(-b1 * k / n).\n\n\n      var c1 = v2.b.mul(k).divRound(this.n);\n      var c2 = v1.b.neg().mul(k).divRound(this.n); // 5. Compute k1 = k - c1 * a1 - c2 * a2\n      //        and k2 = -c1 * b1 - c2 * b2.\n\n      var p1 = c1.mul(v1.a);\n      var p2 = c2.mul(v2.a);\n      var q1 = c1.ineg().mul(v1.b);\n      var q2 = c2.mul(v2.b); // Calculate answer.\n\n      var k1 = k.sub(p1).isub(p2);\n      var k2 = q1.isub(q2); // 6. Return (k1, k2).\n\n      return [k1, k2];\n    }\n  }, {\n    key: \"_endoBeta\",\n    value: function _endoBeta(point) {\n      assert(point instanceof ShortPoint);\n      return [point, point._getBeta()];\n    }\n  }, {\n    key: \"_endoWnafMulAdd\",\n    value: function _endoWnafMulAdd(points, coeffs) {\n      // Point multiplication with efficiently computable endomorphisms.\n      //\n      // [GECC] Algorithm 3.77, Page 129, Section 3.5.\n      // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).\n      //\n      // Note it may be possible to do this 4-dimensionally [4GLV].\n      assert(Array.isArray(points));\n      assert(Array.isArray(coeffs));\n      assert(points.length === coeffs.length);\n      assert(this.endo != null);\n      var len = points.length;\n      var npoints = new Array(len * 2);\n      var ncoeffs = new Array(len * 2);\n\n      for (var i = 0; i < len; i++) {\n        var _this$_endoBeta = this._endoBeta(points[i]),\n            _this$_endoBeta2 = _slicedToArray(_this$_endoBeta, 2),\n            p1 = _this$_endoBeta2[0],\n            p2 = _this$_endoBeta2[1];\n\n        var _this$_endoSplit = this._endoSplit(coeffs[i]),\n            _this$_endoSplit2 = _slicedToArray(_this$_endoSplit, 2),\n            k1 = _this$_endoSplit2[0],\n            k2 = _this$_endoSplit2[1];\n\n        npoints[i * 2 + 0] = p1;\n        ncoeffs[i * 2 + 0] = k1;\n        npoints[i * 2 + 1] = p2;\n        ncoeffs[i * 2 + 1] = k2;\n      }\n\n      return this._wnafMulAdd(4, npoints, ncoeffs);\n    }\n  }, {\n    key: \"_icart\",\n    value: function _icart(u0) {\n      // Icart's Method.\n      //\n      // Distribution: 5/8.\n      //\n      // [ICART] Page 4, Section 2.\n      // [H2EC] \"Icart Method\".\n      //\n      // Assumptions:\n      //\n      //   - p = 2 (mod 3).\n      //   - u != 0.\n      //\n      // Map:\n      //\n      //   u = 1, if u = 0\n      //   v = (3 * a - u^4) / (6 * u)\n      //   w = (2 * p - 1) / 3\n      //   x = (v^2 - b - u^6 / 27)^w + u^2 / 3\n      //   y = u * x + v\n      var a = this.a,\n          b = this.b,\n          i3 = this.i3,\n          one = this.one;\n      var i27 = i3.redSqr().redMul(i3);\n      var w = this.p.ushln(1).isubn(1).idivn(3);\n      var u = u0.clone();\n      u.cinject(one, u.czero());\n      var u2 = u.redSqr();\n      var u4 = u2.redSqr();\n      var u6 = u4.redMul(u2);\n      var u6i = u.redMuln(6).redFermat();\n      var v = a.redMuln(3).redISub(u4).redMul(u6i);\n      var v2 = v.redSqr();\n      var u6d27 = u6.redMul(i27);\n      var u2d3 = u2.redMul(i3);\n      var x = v2.redISub(b).redISub(u6d27).redPow(w).redIAdd(u2d3);\n      var y = u.redMul(x).redIAdd(v);\n      return this.point(x, y);\n    }\n  }, {\n    key: \"_sswu\",\n    value: function _sswu(u) {\n      // Simplified Shallue-Woestijne-Ulas Method.\n      //\n      // Distribution: 3/8.\n      //\n      // [SSWU1] Page 15-16, Section 7. Appendix G.\n      // [SSWU2] Page 5, Theorem 2.3.\n      // [H2EC] \"Simplified Shallue-van de Woestijne-Ulas Method\".\n      //\n      // Assumptions:\n      //\n      //   - a != 0, b != 0.\n      //   - Let z be a non-square in F(p).\n      //   - z != -1.\n      //   - The polynomial g(x) - z is irreducible over F(p).\n      //   - g(b / (z * a)) is square in F(p).\n      //   - u != 0, u != +-sqrt(-1 / z).\n      //\n      // Map:\n      //\n      //   g(x) = x^3 + a * x + b\n      //   t1 = 1 / (z^2 * u^4 + z * u^2)\n      //   x1 = (-b / a) * (1 + t1)\n      //   x1 = b / (z * a), if t1 = 0\n      //   x2 = z * u^2 * x1\n      //   x = x1, if g(x1) is square\n      //     = x2, otherwise\n      //   y = sign(u) * abs(sqrt(g(x)))\n      var b = this.b,\n          z = this.z,\n          ai = this.ai,\n          zi = this.zi,\n          one = this.one;\n      var e = this.p.subn(2);\n      var z2 = z.redSqr();\n      var ba = b.redNeg().redMul(ai);\n      var bza = b.redMul(zi).redMul(ai);\n      var u2 = u.redSqr();\n      var u4 = u2.redSqr();\n      var t1 = z2.redMul(u4).redIAdd(z.redMul(u2)).redPow(e);\n      var x1 = ba.redMul(one.redAdd(t1));\n      x1.cinject(bza, t1.czero());\n      var x2 = z.redMul(u2).redMul(x1);\n      var y1 = this.solveY2(x1);\n      var y2 = this.solveY2(x2);\n      var alpha = y1.redIsSquare() | 0;\n      var x = x1.cinject(x2, alpha ^ 1);\n      var y = y1.cinject(y2, alpha ^ 1).redSqrt();\n      y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());\n      return this.point(x, y);\n    }\n  }, {\n    key: \"_sswui\",\n    value: function _sswui(p, hint) {\n      // Inverting the Map (Simplified Shallue-Woestijne-Ulas).\n      //\n      // Assumptions:\n      //\n      //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).\n      //   - If r < 3 then x != -b / a.\n      //\n      // Unlike SVDW, the preimages here are evenly\n      // distributed (more or less). SSWU covers ~3/8\n      // of the curve points. Each preimage has a 1/2\n      // chance of mapping to either x1 or x2.\n      //\n      // Assuming the point is within that set, each\n      // point has a 1/4 chance of inverting to any\n      // of the preimages. This means we can simply\n      // randomly select a preimage if one exists.\n      //\n      // However, the [SVDW2] sampling method seems\n      // slighly faster in practice for [SQUARED].\n      //\n      // Map:\n      //\n      //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)\n      //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)\n      //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)\n      //   u3 = -(a * x + b - c) / (2 * b * z)\n      //   u4 = -(a * x + b + c) / (2 * b * z)\n      //   r = random integer in [1,4]\n      //   u = sign(y) * abs(sqrt(ur))\n      var a = this.a,\n          b = this.b,\n          z = this.z;\n      var x = p.x,\n          y = p.y;\n      var r = hint & 3;\n      var a2x2 = a.redSqr().redMul(x.redSqr());\n      var abx2 = a.redMul(b).redMul(x).redIMuln(2);\n      var b23 = b.redSqr().redMuln(3);\n      var axb = a.redMul(x).redIAdd(b);\n\n      var _sqrt = sqrt(a2x2.redISub(abx2).redISub(b23)),\n          _sqrt2 = _slicedToArray(_sqrt, 2),\n          s0 = _sqrt2[0],\n          c = _sqrt2[1];\n\n      var n0 = axb.redSub(c).redINeg();\n      var n1 = axb.redAdd(c).redINeg();\n      var d0 = axb.redMul(z).redIMuln(2);\n      var d1 = b.redMul(z).redIMuln(2);\n      n0.cinject(n1, r & 1); // r = 1 or 3\n\n      d0.cinject(d1, r >>> 1); // r = 2 or 3\n\n      var _divSqrt = divSqrt(n0, d0),\n          _divSqrt2 = _slicedToArray(_divSqrt, 2),\n          s1 = _divSqrt2[0],\n          u = _divSqrt2[1];\n\n      u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());\n      if (!(s0 & s1)) throw new Error('Invalid point.');\n      return u;\n    }\n  }, {\n    key: \"_svdwf\",\n    value: function _svdwf(u) {\n      // Shallue-van de Woestijne Method.\n      //\n      // Distribution: 9/16.\n      //\n      // [SVDW1] Section 5.\n      // [SVDW2] Page 8, Section 3.\n      //         Page 15, Section 6, Algorithm 1.\n      // [H2EC] \"Shallue-van de Woestijne Method\".\n      //\n      // Assumptions:\n      //\n      //   - p = 1 (mod 3).\n      //   - a = 0, b != 0.\n      //   - Let z be a unique element in F(p).\n      //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).\n      //   - u != 0, u != +-sqrt(-g(z)).\n      //\n      // Map:\n      //\n      //   g(x) = x^3 + b\n      //   c = sqrt(-3 * z^2)\n      //   t1 = u^2 + g(z)\n      //   t2 = 1 / (u^2 * t1)\n      //   t3 = u^4 * t2 * c\n      //   x1 = (c - z) / 2 - t3\n      //   x2 = t3 - (c + z) / 2\n      //   x3 = z - t1^3 * t2 / (3 * z^2)\n      //   x = x1, if g(x1) is square\n      //     = x2, if g(x2) is square\n      //     = x3, otherwise\n      //   y = sign(u) * abs(sqrt(g(x)))\n      var c = this.c,\n          z = this.z,\n          zi = this.zi,\n          i2 = this.i2,\n          i3 = this.i3;\n      var e = this.p.subn(2);\n      var gz = this.solveY2(z);\n      var z3 = i3.redMul(zi.redSqr());\n      var u2 = u.redSqr();\n      var u4 = u2.redSqr();\n      var t1 = u2.redAdd(gz);\n      var t2 = u2.redMul(t1).redPow(e);\n      var t3 = u4.redMul(t2).redMul(c);\n      var t4 = t1.redSqr().redMul(t1);\n      var x1 = c.redSub(z).redMul(i2).redISub(t3);\n      var x2 = t3.redSub(c.redAdd(z).redMul(i2));\n      var x3 = z.redSub(t4.redMul(t2).redMul(z3));\n      var y1 = this.solveY2(x1);\n      var y2 = this.solveY2(x2);\n      var y3 = this.solveY2(x3);\n      var alpha = y1.redIsSquare() | 0;\n      var beta = y2.redIsSquare() | 0;\n      x1.cinject(x2, (alpha ^ 1) & beta);\n      y1.cinject(y2, (alpha ^ 1) & beta);\n      x1.cinject(x3, (alpha ^ 1) & (beta ^ 1));\n      y1.cinject(y3, (alpha ^ 1) & (beta ^ 1));\n      return [x1, y1];\n    }\n  }, {\n    key: \"_svdw\",\n    value: function _svdw(u) {\n      var _this$_svdwf = this._svdwf(u),\n          _this$_svdwf2 = _slicedToArray(_this$_svdwf, 2),\n          x = _this$_svdwf2[0],\n          yy = _this$_svdwf2[1];\n\n      var y = yy.redSqrt();\n      y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());\n      return this.point(x, y);\n    }\n  }, {\n    key: \"_svdwi\",\n    value: function _svdwi(p, hint) {\n      // Inverting the Map (Shallue-van de Woestijne).\n      //\n      // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n      // [SVDW2] Page 12, Section 5.\n      // [SVDW3] \"Inverting the map\".\n      //\n      // Assumptions:\n      //\n      //   - If r = 1 then x != -(c + z) / 2.\n      //   - If r = 2 then x != (c - z) / 2.\n      //   - If r > 2 then (t0 - t1 + t2) is square in F(p).\n      //   - f(f^-1(x)) = x where f is the map function.\n      //\n      // We use the sampling method from [SVDW2],\n      // _not_ [SQUARED]. This seems to have a\n      // better distribution in practice.\n      //\n      // Note that [SVDW3] also appears to be\n      // incorrect in terms of distribution.\n      //\n      // The distribution of f(u), assuming u is\n      // random, is (1/2, 1/4, 1/4).\n      //\n      // To mirror this, f^-1(x) should simply\n      // pick (1/2, 1/4, 1/8, 1/8).\n      //\n      // To anyone running the forward map, our\n      // strings will appear to be random.\n      //\n      // Map:\n      //\n      //   g(x) = x^3 + b\n      //   c = sqrt(-3 * z^2)\n      //   t0 = 9 * (x^2 * z^2 + z^4)\n      //   t1 = 18 * x * z^3\n      //   t2 = 12 * g(z) * (x - z)\n      //   t3 = sqrt(t0 - t1 + t2)\n      //   t4 = t3 * z\n      //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)\n      //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)\n      //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2\n      //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2\n      //   r = random integer in [1,4]\n      //   u = sign(y) * abs(sqrt(ur))\n      var b = this.b,\n          c = this.c,\n          z = this.z,\n          two = this.two;\n      var x = p.x,\n          y = p.y;\n      var r = hint & 3;\n      var z2 = z.redSqr();\n      var z3 = z2.redMul(z);\n      var z4 = z2.redSqr();\n      var gz = z3.redAdd(b);\n      var gz2 = gz.redMuln(2);\n      var xx = x.redSqr();\n      var x2z = x.redMuln(2).redIAdd(z);\n      var xz2 = x.redMul(z2);\n      var c0 = c.redSub(x2z);\n      var c1 = c.redAdd(x2z);\n      var t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);\n      var t1 = x.redMul(z3).redIMuln(18);\n      var t2 = gz.redMul(x.redSub(z)).redIMuln(12);\n\n      var _sqrt3 = sqrt(t0.redISub(t1).redIAdd(t2)),\n          _sqrt4 = _slicedToArray(_sqrt3, 2),\n          s0 = _sqrt4[0],\n          t3 = _sqrt4[1];\n\n      var s1 = r - 2 >>> 31 | s0;\n      var t4 = t3.redMul(z);\n      var t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);\n      var n0 = gz.redMul(c0);\n      var n1 = gz.redMul(c1);\n      var n2 = t5.redAdd(t4);\n      var n3 = t5.redSub(t4);\n      var d0 = two.clone();\n      n0.cinject(n1, (r ^ 1) - 1 >>> 31); // r = 1\n\n      n0.cinject(n2, (r ^ 2) - 1 >>> 31); // r = 2\n\n      n0.cinject(n3, (r ^ 3) - 1 >>> 31); // r = 3\n\n      d0.cinject(c1, (r ^ 0) - 1 >>> 31); // r = 0\n\n      d0.cinject(c0, (r ^ 1) - 1 >>> 31); // r = 1\n\n      var _divSqrt3 = divSqrt(n0, d0),\n          _divSqrt4 = _slicedToArray(_divSqrt3, 2),\n          s2 = _divSqrt4[0],\n          u = _divSqrt4[1];\n\n      var _this$_svdwf3 = this._svdwf(u),\n          _this$_svdwf4 = _slicedToArray(_this$_svdwf3, 1),\n          x0 = _this$_svdwf4[0];\n\n      var s3 = x0.ceq(x);\n      u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());\n      if (!(s1 & s2 & s3)) throw new Error('Invalid point.');\n      return u;\n    }\n  }, {\n    key: \"isElliptic\",\n    value: function isElliptic() {\n      var a = this.a,\n          b = this.b;\n      var a2 = a.redSqr();\n      var a3 = a2.redMul(a);\n      var b2 = b.redSqr();\n      var d = b2.redMuln(27).redIAdd(a3.redMuln(4)); // 4 * a^3 + 27 * b^2 != 0\n\n      return !d.isZero();\n    }\n  }, {\n    key: \"jinv\",\n    value: function jinv() {\n      // [ARITH1] Page 71, Section 4.4.\n      // http://mathworld.wolfram.com/j-Invariant.html\n      var a = this.a,\n          b = this.b;\n      var a2 = a.redSqr();\n      var a3 = a2.redMul(a);\n      var b2 = b.redSqr();\n      var t0 = a3.redMuln(4);\n      var lhs = t0.redMuln(1728);\n      var rhs = b2.redMuln(27).redIAdd(t0);\n      if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)\n\n      return lhs.redDiv(rhs).fromRed();\n    }\n  }, {\n    key: \"point\",\n    value: function point(x, y) {\n      var inf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return new ShortPoint(this, x, y, inf);\n    }\n  }, {\n    key: \"jpoint\",\n    value: function jpoint(x, y, z) {\n      return new JPoint(this, x, y, z);\n    }\n  }, {\n    key: \"solveY2\",\n    value: function solveY2(x) {\n      // [GECC] Page 89, Section 3.2.2.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw.html\n      assert(x instanceof BN); // y^2 = x^3 + a * x + b\n\n      var x3 = x.redSqr().redMul(x);\n      var y2 = x3.redIAdd(this.b);\n\n      if (!this.zeroA) {\n        // Save some cycles for a = -3.\n        if (this.threeA) y2.redIAdd(x.redMuln(-3));else y2.redIAdd(this.a.redMul(x));\n      }\n\n      return y2;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(point) {\n      assert(point instanceof ShortPoint);\n      if (point.inf) return true;\n      var x = point.x,\n          y = point.y;\n      var y2 = this.solveY2(x);\n      return y.redSqr().eq(y2);\n    }\n  }, {\n    key: \"pointFromX\",\n    value: function pointFromX(x) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      assert(x instanceof BN);\n      assert(sign == null || typeof sign === 'boolean');\n      if (!x.red) x = x.toRed(this.red);\n      var y = this.solveY(x);\n\n      if (sign != null) {\n        if (y.redIsOdd() !== sign) y.redINeg();\n      }\n\n      return this.point(x, y);\n    }\n  }, {\n    key: \"isIsomorphic\",\n    value: function isIsomorphic(curve) {\n      // [GECC] Page 84, Section 3.1.5.\n      // [ARITH1] Page 286, Section 13.2.3.c.\n      assert(curve instanceof Curve);\n      if (!curve.p.eq(this.p)) return false;\n      var u2, u3;\n\n      try {\n        var _this$_scale = this._scale(curve);\n\n        var _this$_scale2 = _slicedToArray(_this$_scale, 2);\n\n        u2 = _this$_scale2[0];\n        u3 = _this$_scale2[1];\n      } catch (e) {\n        return false;\n      } // E(a,b) <-> E(au^4,bu^6)\n\n\n      if (curve.type === 'short') {\n        // a' = a * u^4, b' = b * u^6\n        var a = this.field(curve.a).redMul(u2.redSqr());\n        var b = this.field(curve.b).redMul(u3.redSqr());\n        return this.a.eq(a) && this.b.eq(b);\n      } // E(a,b) <-> M(A,B)\n\n\n      if (curve.type === 'mont') {\n        // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0\n        var a3 = curve.a3,\n            bi = curve.bi;\n        var x = this.field(a3.redMul(bi)).redMul(u2);\n        var y2 = this.solveY2(x);\n        return y2.isZero();\n      } // E(a,b) <-> E(a,d)\n\n\n      if (curve.type === 'edwards') {\n        // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0\n        var _x = this.field(curve.ad6).redMul(u2);\n\n        var _y = this.solveY2(_x);\n\n        return _y.isZero();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isIsogenous\",\n    value: function isIsogenous(curve) {\n      assert(curve instanceof Curve);\n      return false;\n    }\n  }, {\n    key: \"pointFromShort\",\n    value: function pointFromShort(point) {\n      // [GECC] Page 84, Section 3.1.5.\n      // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n      assert(point instanceof ShortPoint);\n\n      if (this.isIsomorphic(point.curve)) {\n        // Isomorphic maps for E(a,b)<->E(au^4,bu^6):\n        //\n        //   x' = x * u^2\n        //   y' = y * u^3\n        //\n        // Where a * u^4 = a' and b * u^6 = b'.\n        if (point.isInfinity()) return this.point();\n\n        var _this$_scale3 = this._scale(point.curve),\n            _this$_scale4 = _slicedToArray(_this$_scale3, 2),\n            u2 = _this$_scale4[0],\n            u3 = _this$_scale4[1];\n\n        var x = this.field(point.x);\n        var y = this.field(point.y);\n        var nx = x.redMul(u2);\n        var ny = y.redMul(u3);\n        return this.point(nx, ny);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromMont\",\n    value: function pointFromMont(point) {\n      // [ALT] Appendix E.2 (Switching between Alternative Representations).\n      // [MONT2] \"Equivalence with Weierstrass curves\"\n      assert(point instanceof MontPoint);\n\n      if (this.isIsomorphic(point.curve)) {\n        // Equivalence for M(A,B)->E(a,b):\n        //\n        //   x = (u + A / 3) / B\n        //   y = v / B\n        //\n        // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n        if (point.isInfinity()) return this.point();\n        var _point$curve = point.curve,\n            a3 = _point$curve.a3,\n            bi = _point$curve.bi;\n\n        var _this$_scale5 = this._scale(point.curve),\n            _this$_scale6 = _slicedToArray(_this$_scale5, 2),\n            u2 = _this$_scale6[0],\n            u3 = _this$_scale6[1];\n\n        var nx = point.x.redAdd(a3).redMul(bi);\n        var ny = point.y.redMul(bi);\n        return this.point(this.field(nx).redMul(u2), this.field(ny).redMul(u3));\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromEdwards\",\n    value: function pointFromEdwards(point) {\n      // [TWISTEQ] Section 2.\n      assert(point instanceof EdwardsPoint);\n\n      if (this.isIsomorphic(point.curve)) {\n        // Equivalence for E(a,d)->E(a',b'):\n        //\n        //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))\n        //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))\n        //\n        // Undefined for x = 0 or y = 1.\n        //\n        // Exceptional Cases:\n        //   - (0, 1) -> O\n        //   - (0, -1) -> ((a + d) / 6, 0)\n        //\n        // Unexceptional Cases:\n        //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))\n        var _point$curve2 = point.curve,\n            a = _point$curve2.a,\n            d = _point$curve2.d,\n            ad6 = _point$curve2.ad6;\n\n        var _this$_scale7 = this._scale(point.curve),\n            _this$_scale8 = _slicedToArray(_this$_scale7, 2),\n            u2 = _this$_scale8[0],\n            u3 = _this$_scale8[1];\n\n        if (point.isInfinity()) return this.point();\n\n        if (point.x.isZero()) {\n          var _x2 = this.field(ad6).redMul(u2);\n\n          return this.point(_x2, this.zero);\n        }\n\n        var x = point.x,\n            y = point.y,\n            z = point.z;\n        var a5 = a.redMuln(5);\n        var d5 = d.redMuln(5);\n        var dma = d.redSub(a);\n        var d5a = d5.redSub(a);\n        var da5 = d.redSub(a5);\n        var ypz = y.redAdd(z);\n        var ymz = y.redSub(z);\n        var xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n        var xz = ymz.redMuln(12);\n        var yy = dma.redMul(ypz).redMul(z);\n        var yz = ymz.redMul(x).redIMuln(4);\n        return this.cpoint(this.field(xx).redMul(u2), this.field(xz), this.field(yy).redMul(u3), this.field(yz));\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromUniform\",\n    value: function pointFromUniform(u) {\n      assert(u instanceof BN); // z = 0 or b = 0\n\n      if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.'); // a != 0, b != 0\n\n      if (!this.a.isZero()) return this._sswu(u); // p = 1 mod 3, a = 0, b != 0\n\n      if (!this.c.isZero()) return this._svdw(u);\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointToUniform\",\n    value: function pointToUniform(p, hint) {\n      assert(p instanceof ShortPoint);\n      assert(hint >>> 0 === hint); // z = 0 or b = 0\n\n      if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.'); // P = O\n\n      if (p.isInfinity()) throw new Error('Invalid point.'); // Add a random torsion component.\n\n      var i = (hint >>> 4 & 15) % this.torsion.length;\n      var q = p.add(this.torsion[i]); // a != 0, b != 0\n\n      if (!this.a.isZero()) return this._sswui(q, hint); // p = 1 mod 3, a = 0, b != 0\n\n      if (!this.c.isZero()) return this._svdwi(q, hint);\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"mulAll\",\n    value: function mulAll(points, coeffs) {\n      return _get(_getPrototypeOf(ShortCurve.prototype), \"mulAll\", this).call(this, points, coeffs).toP();\n    }\n  }, {\n    key: \"mulAllSimple\",\n    value: function mulAllSimple(points, coeffs) {\n      return _get(_getPrototypeOf(ShortCurve.prototype), \"mulAllSimple\", this).call(this, points, coeffs).toP();\n    }\n  }, {\n    key: \"decodePoint\",\n    value: function decodePoint(bytes) {\n      return ShortPoint.decode(this, bytes);\n    }\n  }, {\n    key: \"encodeX\",\n    value: function encodeX(point) {\n      assert(point instanceof Point);\n      return point.encodeX();\n    }\n  }, {\n    key: \"decodeEven\",\n    value: function decodeEven(bytes) {\n      return ShortPoint.decodeEven(this, bytes);\n    }\n  }, {\n    key: \"decodeSquare\",\n    value: function decodeSquare(bytes) {\n      return ShortPoint.decodeSquare(this, bytes);\n    }\n  }, {\n    key: \"toShort\",\n    value: function toShort(a0, odd) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_short = this._short(a0, odd),\n          _this$_short2 = _slicedToArray(_this$_short, 2),\n          a = _this$_short2[0],\n          b = _this$_short2[1];\n\n      var curve = new ShortCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        b: b,\n        n: this.n,\n        h: this.h\n      });\n\n      if (sign != null) {\n        var _curve$_scale = curve._scale(this),\n            _curve$_scale2 = _slicedToArray(_curve$_scale, 2),\n            u3 = _curve$_scale2[1];\n\n        if (u3.redIsOdd() !== sign) u3.redINeg();\n      }\n\n      if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);\n\n      for (var i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"toMont\",\n    value: function toMont(b0, odd) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_mont = this._mont(b0, odd),\n          _this$_mont2 = _slicedToArray(_this$_mont, 2),\n          a = _this$_mont2[0],\n          b = _this$_mont2[1];\n\n      var curve = new MontCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        b: b,\n        n: this.n,\n        h: this.h\n      });\n\n      if (sign != null) {\n        var _this$_scale9 = this._scale(curve),\n            _this$_scale10 = _slicedToArray(_this$_scale9, 2),\n            u3 = _this$_scale10[1];\n\n        if (u3.redIsOdd() !== sign) u3.redINeg();\n      }\n\n      if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);\n\n      for (var i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"toEdwards\",\n    value: function toEdwards(a0, odd) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_edwards = this._edwards(a0, odd),\n          _this$_edwards2 = _slicedToArray(_this$_edwards, 2),\n          a = _this$_edwards2[0],\n          d = _this$_edwards2[1];\n\n      var curve = new EdwardsCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        d: d,\n        n: this.n,\n        h: this.h\n      });\n\n      if (sign != null) {\n        var _this$_scale11 = this._scale(curve),\n            _this$_scale12 = _slicedToArray(_this$_scale11, 2),\n            u3 = _this$_scale12[1];\n\n        if (u3.redIsOdd() !== sign) u3.redINeg();\n      }\n\n      if (!this.g.isInfinity()) {\n        curve.g = curve.pointFromShort(this.g);\n        curve.g.normalize();\n      }\n\n      if (curve.isComplete()) {\n        for (var i = 0; i < this.h; i++) {\n          curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n          curve.torsion[i].normalize();\n        }\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"pointFromJSON\",\n    value: function pointFromJSON(json) {\n      return ShortPoint.fromJSON(this, json);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      var json = _get(_getPrototypeOf(ShortCurve.prototype), \"toJSON\", this).call(this, pre);\n\n      json.a = this.a.fromRed().toJSON();\n      json.b = this.b.fromRed().toJSON();\n      if (!this.c.isZero()) json.c = this.c.fromRed().toJSON();\n      return json;\n    }\n  }], [{\n    key: \"_isomorphism\",\n    value: function _isomorphism(curveA, curveB, customA, odd) {\n      // Short Weierstrass Isomorphism.\n      //\n      // [GECC] Page 84, Section 3.1.5.\n      // [ARITH1] Page 274, Section 13.1.5.\n      // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n      //\n      // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.\n      //\n      // Transformation:\n      //\n      //   u4 = a' / a\n      //   u2 = +-sqrt(u4)\n      //   u6 = u4 * u2\n      //   a' = a * u4\n      //   b' = b * u6\n      //\n      // Where `u2` is any root that is square.\n      assert(curveA instanceof BN);\n      assert(curveB instanceof BN);\n      assert(customA instanceof BN);\n      assert(odd == null || typeof odd === 'boolean');\n      assert(!curveA.isZero() && !curveB.isZero());\n      var u4 = customA.redDiv(curveA);\n      var u2 = u4.redSqrt();\n\n      if (odd != null) {\n        if (u2.redIsOdd() !== odd) u2.redINeg();\n      } else {\n        if (u2.redJacobi() !== 1) u2.redINeg();\n      }\n\n      if (u2.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');\n      var u6 = u4.redMul(u2);\n      var a = curveA.redMul(u4);\n      var b = curveB.redMul(u6);\n      assert(a.eq(customA));\n      return [a, b];\n    }\n  }]);\n\n  return ShortCurve;\n}(Curve);\n/**\n * ShortPoint\n */\n\n\nvar ShortPoint = /*#__PURE__*/function (_Point) {\n  _inherits(ShortPoint, _Point);\n\n  var _super2 = _createSuper(ShortPoint);\n\n  function ShortPoint(curve, x, y, inf) {\n    var _this2;\n\n    _classCallCheck(this, ShortPoint);\n\n    assert(curve instanceof ShortCurve);\n    _this2 = _super2.call(this, curve, types.AFFINE);\n    _this2.x = _this2.curve.zero;\n    _this2.y = _this2.curve.zero;\n    _this2.inf = 1;\n    if (x != null) _this2._init(x, y, inf);\n    return _this2;\n  }\n\n  _createClass(ShortPoint, [{\n    key: \"_init\",\n    value: function _init(x, y, inf) {\n      assert(x instanceof BN);\n      assert(y instanceof BN);\n      this.x = x;\n      this.y = y;\n      if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n      if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n      this.inf = inf | 0;\n    }\n  }, {\n    key: \"_safeNAF\",\n    value: function _safeNAF(width) {\n      assert(width >>> 0 === width);\n      if (this.pre && this.pre.naf) return this.pre.naf; // Avoid inversions.\n\n      if (width > 1) return this.toJ()._getNAF(width);\n      return this._getNAF(width);\n    }\n  }, {\n    key: \"_getBeta\",\n    value: function _getBeta() {\n      var _this3 = this;\n\n      if (!this.curve.endo) return null;\n      if (this.pre && this.pre.beta) return this.pre.beta; // Augment the point with our beta value.\n      // This is the counterpart to `k2` after\n      // the endomorphism split of `k`.\n      //\n      // Note that if we have precomputation,\n      // we have to clone and update all of the\n      // precomputed points below.\n\n      var xb = this.x.redMul(this.curve.endo.beta);\n      var beta = this.curve.point(xb, this.y);\n\n      if (this.pre) {\n        beta.pre = this.pre.map(function (point) {\n          var xb = point.x.redMul(_this3.curve.endo.beta);\n          return _this3.curve.point(xb, point.y);\n        });\n        this.pre.beta = beta;\n      }\n\n      return beta;\n    }\n  }, {\n    key: \"_getJNAF\",\n    value: function _getJNAF(point) {\n      assert(point instanceof ShortPoint);\n      if (this.inf | point.inf) return _get(_getPrototypeOf(ShortPoint.prototype), \"_getJNAF\", this).call(this, point); // Create comb for JSF.\n\n      var comb = [this, // 1\n      null, // 3\n      null, // 5\n      point // 7\n      ]; // Try to avoid Jacobian points, if possible.\n\n      if (this.y.eq(point.y)) {\n        comb[1] = this.add(point);\n        comb[2] = this.toJ().sub(point);\n      } else if (this.y.eq(point.y.redNeg())) {\n        comb[1] = this.toJ().add(point);\n        comb[2] = this.sub(point);\n      } else {\n        comb[1] = this.toJ().add(point);\n        comb[2] = this.toJ().sub(point);\n      }\n\n      return comb;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.curve.point(this.x.clone(), this.y.clone(), this.inf);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(point, flag) {\n      assert(point instanceof ShortPoint);\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var inf1 = this.inf;\n      var inf2 = point.inf;\n      this.x.cswap(point.x, flag);\n      this.y.cswap(point.y, flag);\n      this.inf = inf1 & (cond ^ 1) | inf2 & cond;\n      point.inf = inf2 & (cond ^ 1) | inf1 & cond;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a) {\n      return this.toJ().scale(a);\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      // P = O\n      if (this.inf) return this; // -(X1, Y1) = (X1, -Y1)\n\n      return this.curve.point(this.x, this.y.redNeg());\n    }\n  }, {\n    key: \"add\",\n    value: function add(p) {\n      // [GECC] Page 80, Section 3.1.2.\n      //\n      // Addition Law:\n      //\n      //   l = (y1 - y2) / (x1 - x2)\n      //   x3 = l^2 - x1 - x2\n      //   y3 = l * (x1 - x3) - y1\n      //\n      // 1I + 2M + 1S + 6A\n      assert(p instanceof ShortPoint); // O + P = P\n\n      if (this.inf) return p; // P + O = P\n\n      if (p.inf) return this; // P + P, P + -P\n\n      if (this.x.eq(p.x)) {\n        // P + -P = O\n        if (!this.y.eq(p.y)) return this.curve.point(); // P + P = 2P\n\n        return this.dbl();\n      } // X1 != X2, Y1 = Y2\n\n\n      if (this.y.eq(p.y)) {\n        // X3 = -X1 - X2\n        var _nx = this.x.redNeg().redISub(p.x); // Y3 = -Y1\n\n\n        var _ny = this.y.redNeg(); // Skip the inverse.\n\n\n        return this.curve.point(_nx, _ny);\n      } // H = X1 - X2\n\n\n      var h = this.x.redSub(p.x); // R = Y1 - Y2\n\n      var r = this.y.redSub(p.y); // L = R / H\n\n      var l = r.redDiv(h); // X3 = L^2 - X1 - X2\n\n      var nx = l.redSqr().redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n      var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      // [GECC] Page 80, Section 3.1.2.\n      //\n      // Addition Law (doubling):\n      //\n      //   l = (3 * x1^2 + a) / (2 * y1)\n      //   x3 = l^2 - 2 * x1\n      //   y3 = l * (x1 - x3) - y1\n      //\n      // 1I + 2M + 2S + 3A + 2*2 + 1*3\n      // P = O\n      if (this.inf) return this; // Y1 = 0\n\n      if (this.y.isZero()) return this.curve.point(); // XX = X1^2\n\n      var xx = this.x.redSqr(); // M = 3 * XX + a\n\n      var m = xx.redIMuln(3).redIAdd(this.curve.a); // Z = 2 * Y1\n\n      var z = this.y.redMuln(2); // L = M / Z\n\n      var l = m.redDiv(z); // X3 = L^2 - 2 * X1\n\n      var nx = l.redSqr().redISub(this.x).redISub(this.x); // Y3 = L * (X1 - X3) - Y1\n\n      var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }\n  }, {\n    key: \"dblp\",\n    value: function dblp(pow) {\n      return this.toJ().dblp(pow).toP();\n    }\n  }, {\n    key: \"uadd\",\n    value: function uadd(p) {\n      // [SIDE2] Page 5, Section 3.\n      // [SIDE3] Page 4, Section 3.\n      //\n      // Addition Law (unified):\n      //\n      //   l = ((x1 + x2)^2 - (x1 * x2) + a) / (y1 + y2)\n      //   x3 = l^2 - x1 - x2\n      //   y3 = l * (x1 - x3) - y1\n      //\n      // If x1 != x2 and y1 = -y2, we switch\n      // back to the regular addition lambda:\n      //\n      //   l = (y1 - y2) / (x1 - x2)\n      //\n      // 1I + 3M + 2S + 10A\n      assert(p instanceof ShortPoint); // M = Y1 + Y2\n\n      var m = this.y.redAdd(p.y); // A = (X1 + X2)^2\n\n      var a = this.x.redAdd(p.x).redSqr(); // B = X1 * X2\n\n      var b = this.x.redMul(p.x); // R = A - B + a\n\n      var r = a.redISub(b).redIAdd(this.curve.a); // Check for degenerate case (X1 != X2, Y1 = -Y2).\n\n      var degenerate = m.czero() & r.czero(); // M = X1 - X2 (if degenerate)\n\n      m.cinject(this.x.redSub(p.x), degenerate); // R = Y1 - Y2 (if degenerate)\n\n      r.cinject(this.y.redSub(p.y), degenerate); // Check for negation (X1 = X2, Y1 = -Y2).\n\n      var negated = m.czero() & ((this.inf | p.inf) ^ 1); // M = 1 (if M = 0)\n\n      m.cinject(this.curve.one, m.czero()); // L = R / M\n\n      var l = r.redMul(m.redFermat()); // X3 = L^2 - X1 - X2\n\n      var nx = l.redSqr().redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n      var ny = l.redMul(this.x.redSub(nx)).redISub(this.y); // Check for infinity.\n\n      var inf = negated | this.inf & p.inf; // Case 1: O + P = P\n\n      nx.cinject(p.x, this.inf);\n      ny.cinject(p.y, this.inf); // Case 2: P + O = P\n\n      nx.cinject(this.x, p.inf);\n      ny.cinject(this.y, p.inf); // Case 3 & 4: P + -P = O, O + O = O\n\n      nx.cinject(this.curve.zero, inf);\n      ny.cinject(this.curve.zero, inf);\n      return this.curve.point(nx, ny, inf);\n    }\n  }, {\n    key: \"udbl\",\n    value: function udbl() {\n      return this.uadd(this);\n    }\n  }, {\n    key: \"recover\",\n    value: function recover(x1, z1, x2, z2) {\n      // Brier-Joye Y-coordinate Recovery.\n      //\n      // [SIDE2] Proposition 3, Page 7, Section 4.\n      //\n      // 14M + 3S + 5A + 2*2 + 1*a + 1*b\n      assert(x1 instanceof BN);\n      assert(z1 instanceof BN);\n      assert(x2 instanceof BN);\n      assert(z2 instanceof BN); // P = O\n\n      if (this.inf) return this.curve.jpoint(); // Z = Z1 * Z2\n\n      var z = z1.redMul(z2); // ZZ = Z^2\n\n      var zz = z.redSqr(); // ZZZ = ZZ * Z\n\n      var zzz = zz.redMul(z); // U0 = X0 * Z\n\n      var u0 = this.x.redMul(z); // U1 = X1 * Z2\n\n      var u1 = x1.redMul(z2); // U2 = X2 * Z1\n\n      var u2 = x2.redMul(z1); // A = 2 * b * ZZZ\n\n      var a = this.curve.b.redMul(zzz).redIMuln(2); // B = a * ZZ + U0 * U1\n\n      var b = u0.redMul(u1).redIAdd(this.curve.a.redMul(zz)); // C = U0 + U1\n\n      var c = u0.redAdd(u1); // D = U0 - U1\n\n      var d = u0.redISub(u1); // E = A + B * C\n\n      var e = a.redIAdd(b.redMul(c)); // F = U2 * D^2\n\n      var f = u2.redMul(d.redSqr()); // G = E - F\n\n      var g = e.redISub(f); // H = 2 * Y0 * ZZZ\n\n      var h = this.y.redMul(zzz).redIMuln(2); // I = X1 * H\n\n      var i = x1.redMul(h); // J = G * Z1\n\n      var j = g.redMul(z1); // K = Z1 * H\n\n      var k = z1.redMul(h); // X3 = I * K\n\n      var nx = i.redMul(k); // Y3 = J * K^2\n\n      var ny = j.redMul(k.redSqr()); // Z3 = K\n\n      var nz = k;\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      if (this.inf) throw new Error('Invalid point.');\n      return this.x.fromRed();\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      if (this.inf) throw new Error('Invalid point.');\n      return this.y.fromRed();\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(p) {\n      assert(p instanceof ShortPoint); // P = Q\n\n      if (this === p) return true; // P = O\n\n      if (this.inf) return p.inf !== 0; // Q = O\n\n      if (p.inf) return false; // X1 = X2, Y1 = Y2\n\n      return this.x.eq(p.x) && this.y.eq(p.y);\n    }\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      // Infinity cannot be represented in\n      // the affine space, except by a flag.\n      return this.inf !== 0;\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      if (this.inf) return false;\n      return this.y.redIsOdd();\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      if (this.inf) return false;\n      return this.y.redIsEven();\n    }\n  }, {\n    key: \"isSquare\",\n    value: function isSquare() {\n      if (this.inf) return false;\n      return this.y.redJacobi() !== -1;\n    }\n  }, {\n    key: \"eqX\",\n    value: function eqX(x) {\n      assert(x instanceof BN);\n      assert(!x.red);\n      if (this.inf) return false;\n      return this.getX().eq(x);\n    }\n  }, {\n    key: \"eqXToP\",\n    value: function eqXToP(x) {\n      assert(x instanceof BN);\n      assert(!x.red);\n      assert(!this.curve.n.isZero());\n      if (this.inf) return false;\n      return this.getX().imod(this.curve.n).eq(x);\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(k) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mul\", this).call(this, k).toP();\n    }\n  }, {\n    key: \"muln\",\n    value: function muln(k) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"muln\", this).call(this, k).toP();\n    }\n  }, {\n    key: \"mulSimple\",\n    value: function mulSimple(k) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mulSimple\", this).call(this, k).toP();\n    }\n  }, {\n    key: \"mulBlind\",\n    value: function mulBlind(k, rng) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mulBlind\", this).call(this, k, rng).toP();\n    }\n  }, {\n    key: \"mulConst\",\n    value: function mulConst(k, rng) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mulConst\", this).call(this, k, rng).toP();\n    }\n  }, {\n    key: \"mulAdd\",\n    value: function mulAdd(k1, p2, k2) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mulAdd\", this).call(this, k1, p2, k2).toP();\n    }\n  }, {\n    key: \"mulAddSimple\",\n    value: function mulAddSimple(k1, p2, k2) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mulAddSimple\", this).call(this, k1, p2, k2).toP();\n    }\n  }, {\n    key: \"mulH\",\n    value: function mulH() {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"mulH\", this).call(this).toP();\n    }\n  }, {\n    key: \"div\",\n    value: function div(k) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"div\", this).call(this, k).toP();\n    }\n  }, {\n    key: \"divn\",\n    value: function divn(k) {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"divn\", this).call(this, k).toP();\n    }\n  }, {\n    key: \"divH\",\n    value: function divH() {\n      return _get(_getPrototypeOf(ShortPoint.prototype), \"divH\", this).call(this).toP();\n    }\n  }, {\n    key: \"toP\",\n    value: function toP() {\n      return this;\n    }\n  }, {\n    key: \"toJ\",\n    value: function toJ() {\n      // (X3, Y3, Z3) = (1, 1, 0)\n      if (this.inf) return this.curve.jpoint(); // (X3, Y3, Z3) = (X1, Y1, 1)\n\n      return this.curve.jpoint(this.x, this.y, this.curve.one);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(compact) {\n      // [SEC1] Page 10, Section 2.3.3.\n      if (compact == null) compact = true;\n      assert(typeof compact === 'boolean');\n      var fieldSize = this.curve.fieldSize; // We do not serialize points at infinity.\n\n      if (this.inf) throw new Error('Invalid point.'); // Compressed form (0x02 = even, 0x03 = odd).\n\n      if (compact) {\n        var _p = Buffer.allocUnsafe(1 + fieldSize);\n\n        var _x3 = this.curve.encodeField(this.getX());\n\n        _p[0] = 0x02 | this.y.redIsOdd();\n\n        _x3.copy(_p, 1);\n\n        return _p;\n      } // Uncompressed form (0x04).\n\n\n      var p = Buffer.allocUnsafe(1 + fieldSize * 2);\n      var x = this.curve.encodeField(this.getX());\n      var y = this.curve.encodeField(this.getY());\n      p[0] = 0x04;\n      x.copy(p, 1);\n      y.copy(p, 1 + fieldSize);\n      return p;\n    }\n  }, {\n    key: \"encodeX\",\n    value: function encodeX() {\n      // [SCHNORR] \"Specification\".\n      // [BIP340] \"Specification\".\n      return this.curve.encodeField(this.getX());\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      if (this.inf) return [];\n      var x = this.getX().toJSON();\n      var y = this.getY().toJSON();\n      if (pre === true && this.pre) return [x, y, this.pre.toJSON()];\n      return [x, y];\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      if (this.inf) return '<ShortPoint: Infinity>';\n      return '<ShortPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(curve, bytes) {\n      // [SEC1] Page 11, Section 2.3.4.\n      assert(curve instanceof ShortCurve);\n      assert(Buffer.isBuffer(bytes));\n      var len = curve.fieldSize;\n      if (bytes.length < 1 + len) throw new Error('Not a point.'); // Point forms:\n      //\n      //   0x00 -> Infinity (openssl, unsupported)\n      //   0x02 -> Compressed Even\n      //   0x03 -> Compressed Odd\n      //   0x04 -> Uncompressed\n      //   0x06 -> Hybrid Even (openssl)\n      //   0x07 -> Hybrid Odd (openssl)\n      //\n      // Note that openssl supports serializing points\n      // at infinity as {0}. We choose not to support it\n      // because it's strange and not terribly useful.\n\n      var form = bytes[0];\n\n      switch (form) {\n        case 0x02:\n        case 0x03:\n          {\n            if (bytes.length !== 1 + len) throw new Error('Invalid point size for compressed.');\n            var x = curve.decodeField(bytes.slice(1, 1 + len));\n            if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n            var p = curve.pointFromX(x, form === 0x03);\n            assert(!p.isInfinity());\n            return p;\n          }\n\n        case 0x04:\n        case 0x06:\n        case 0x07:\n          {\n            if (bytes.length !== 1 + len * 2) throw new Error('Invalid point size for uncompressed.');\n\n            var _x4 = curve.decodeField(bytes.slice(1, 1 + len));\n\n            var y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len)); // [GECC] Algorithm 4.3, Page 180, Section 4.\n\n            if (_x4.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0) throw new Error('Invalid point.'); // OpenSSL hybrid encoding.\n\n            if (form !== 0x04 && form !== (0x06 | y.isOdd())) throw new Error('Invalid hybrid encoding.');\n\n            var _p2 = curve.point(_x4, y);\n\n            if (!_p2.validate()) throw new Error('Invalid point.');\n            assert(!_p2.isInfinity());\n            return _p2;\n          }\n\n        default:\n          {\n            throw new Error('Unknown point format.');\n          }\n      }\n    }\n  }, {\n    key: \"decodeEven\",\n    value: function decodeEven(curve, bytes) {\n      // [BIP340] \"Specification\".\n      assert(curve instanceof ShortCurve);\n      var x = curve.decodeField(bytes);\n      if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n      return curve.pointFromX(x, false);\n    }\n  }, {\n    key: \"decodeSquare\",\n    value: function decodeSquare(curve, bytes) {\n      // [SCHNORR] \"Specification\".\n      // [BIP340] \"Specification\".\n      assert(curve instanceof ShortCurve);\n      var x = curve.decodeField(bytes);\n      if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n      return curve.pointFromX(x);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      assert(curve instanceof ShortCurve);\n      assert(Array.isArray(json));\n      assert(json.length === 0 || json.length === 2 || json.length === 3);\n      if (json.length === 0) return curve.point();\n      var x = BN.fromJSON(json[0]);\n      var y = BN.fromJSON(json[1]);\n      var point = curve.point(x, y);\n      if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);\n      return point;\n    }\n  }]);\n\n  return ShortPoint;\n}(Point);\n/**\n * JPoint\n */\n\n\nvar JPoint = /*#__PURE__*/function (_Point2) {\n  _inherits(JPoint, _Point2);\n\n  var _super3 = _createSuper(JPoint);\n\n  function JPoint(curve, x, y, z) {\n    var _this4;\n\n    _classCallCheck(this, JPoint);\n\n    assert(curve instanceof ShortCurve);\n    _this4 = _super3.call(this, curve, types.JACOBIAN);\n    _this4.x = _this4.curve.one;\n    _this4.y = _this4.curve.one;\n    _this4.z = _this4.curve.zero;\n    _this4.zOne = 0;\n    if (x != null) _this4._init(x, y, z);\n    return _this4;\n  }\n\n  _createClass(JPoint, [{\n    key: \"_init\",\n    value: function _init(x, y, z) {\n      assert(x instanceof BN);\n      assert(y instanceof BN);\n      assert(z == null || z instanceof BN);\n      this.x = x;\n      this.y = y;\n      this.z = z || this.curve.one;\n      if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n      if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n      if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n      this.zOne = this.z.eq(this.curve.one) | 0;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.curve.jpoint(this.x.clone(), this.y.clone(), this.z.clone());\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(point, flag) {\n      assert(point instanceof JPoint);\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var zOne1 = this.zOne;\n      var zOne2 = point.zOne;\n      this.x.cswap(point.x, flag);\n      this.y.cswap(point.y, flag);\n      this.z.cswap(point.z, flag);\n      this.zOne = zOne1 & (cond ^ 1) | zOne2 & cond;\n      point.zOne = zOne2 & (cond ^ 1) | zOne1 & cond;\n      return this;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      // [GECC] Example 3.20, Page 88, Section 3.\n      var _this$curve = this.curve,\n          a = _this$curve.a,\n          b = _this$curve.b; // P = O\n\n      if (this.isInfinity()) return true; // Z1 = 1\n\n      if (this.zOne) return this.curve.validate(this.toP()); // y^2 = x^3 + a * x * z^4 + b * z^6\n\n      var lhs = this.y.redSqr();\n      var x3 = this.x.redSqr().redMul(this.x);\n      var z2 = this.z.redSqr();\n      var z4 = z2.redSqr();\n      var z6 = z4.redMul(z2);\n      var rhs = x3.redIAdd(b.redMul(z6));\n\n      if (!this.curve.zeroA) {\n        // Save some cycles for a = -3.\n        if (this.curve.threeA) rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));else rhs.redIAdd(a.redMul(z4).redMul(this.x));\n      }\n\n      return lhs.eq(rhs);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z\n      // 1I + 3M + 1S\n      // Z = 1\n      if (this.zOne) return this; // P = O\n\n      if (this.isInfinity()) return this; // A = 1 / Z1\n\n      var a = this.z.redInvert(); // AA = A^2\n\n      var aa = a.redSqr(); // X3 = X1 * AA\n\n      this.x = this.x.redMul(aa); // Y3 = Y1 * AA * A\n\n      this.y = this.y.redMul(aa).redMul(a); // Z3 = 1\n\n      this.z = this.curve.one;\n      this.zOne = 1;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a) {\n      assert(a instanceof BN); // P = O\n\n      if (this.isInfinity()) return this.curve.jpoint(); // AA = A^2\n\n      var aa = a.redSqr(); // X3 = X1 * AA\n\n      var nx = this.x.redMul(aa); // Y3 = Y1 * AA * A\n\n      var ny = this.y.redMul(aa).redMul(a); // Z3 = Z1 * A\n\n      var nz = this.z.redMul(a);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      // -(X1, Y1, Z1) = (X1, -Y1, Z1)\n      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n    }\n  }, {\n    key: \"add\",\n    value: function add(p) {\n      assert(p instanceof Point);\n      if (p.type === types.AFFINE) return this._mixedAdd(p);\n      return this._add(p);\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(p) {\n      assert(p instanceof JPoint); // O + P = P\n\n      if (this.isInfinity()) return p; // P + O = P\n\n      if (p.isInfinity()) return this; // Z1 = 1, Z2 = 1\n\n      if (this.zOne && p.zOne) return this._addAA(p); // Z1 = 1\n\n      if (this.zOne) return p._addJA(this); // Z2 = 1\n\n      if (p.zOne) return this._addJA(p);\n      return this._addJJ(p);\n    }\n  }, {\n    key: \"_mixedAdd\",\n    value: function _mixedAdd(p) {\n      assert(p instanceof ShortPoint); // O + P = P\n\n      if (this.isInfinity()) return p.toJ(); // P + O = P\n\n      if (p.isInfinity()) return this; // Z1 = 1, Z2 = 1\n\n      if (this.zOne) return this._addAA(p);\n      return this._addJA(p);\n    }\n  }, {\n    key: \"_addJJ\",\n    value: function _addJJ(p) {\n      // No assumptions.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2\n      // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)\n      // Z1Z1 = Z1^2\n      var z1z1 = this.z.redSqr(); // Z2Z2 = Z2^2\n\n      var z2z2 = p.z.redSqr(); // U1 = X1 * Z2Z2\n\n      var u1 = this.x.redMul(z2z2); // U2 = X2 * Z1Z1\n\n      var u2 = p.x.redMul(z1z1); // S1 = Y1 * Z2 * Z2Z2\n\n      var s1 = this.y.redMul(p.z).redMul(z2z2); // S2 = Y2 * Z1 * Z1Z1\n\n      var s2 = p.y.redMul(this.z).redMul(z1z1); // H = U2 - U1\n\n      var h = u2.redISub(u1); // r = S2 - S1\n\n      var r = s2.redISub(s1); // H = 0\n\n      if (h.isZero()) {\n        if (!r.isZero()) return this.curve.jpoint();\n        return this.dbl();\n      } // HH = H^2\n\n\n      var hh = h.redSqr(); // HHH = H * HH\n\n      var hhh = h.redMul(hh); // V = U1 * HH\n\n      var v = u1.redMul(hh); // X3 = r^2 - HHH - 2 * V\n\n      var nx = r.redSqr().redISub(hhh).redISub(v).redISub(v); // Y3 = r * (V - X3) - S1 * HHH\n\n      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh)); // Z3 = Z1 * Z2 * H\n\n      var nz = this.z.redMul(p.z).redMul(h);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"_addJA\",\n    value: function _addJA(p) {\n      // Assumes Z2 = 1.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd\n      // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)\n      // Z1Z1 = Z1^2\n      var z1z1 = this.z.redSqr(); // U2 = X2 * Z1Z1\n\n      var u2 = p.x.redMul(z1z1); // S2 = Y2 * Z1 * Z1Z1\n\n      var s2 = p.y.redMul(this.z).redMul(z1z1); // H = U2 - X1\n\n      var h = u2.redISub(this.x); // r = 2 * (S2 - Y1)\n\n      var r = s2.redISub(this.y).redIMuln(2); // H = 0\n\n      if (h.isZero()) {\n        if (!r.isZero()) return this.curve.jpoint();\n        return this.dbl();\n      } // I = (2 * H)^2\n\n\n      var i = h.redMuln(2).redSqr(); // J = H * I\n\n      var j = h.redMul(i); // V = X1 * I\n\n      var v = this.x.redMul(i); // X3 = r^2 - J - 2 * V\n\n      var nx = r.redSqr().redISub(j).redISub(v).redISub(v); // Y3 = r * (V - X3) - 2 * Y1 * J\n\n      var ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2)); // Z3 = 2 * Z1 * H\n\n      var nz = this.z.redMul(h).redIMuln(2);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"_addAA\",\n    value: function _addAA(p) {\n      // Assumes Z1 = 1, Z2 = 1.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-mmadd-2007-bl\n      // 4M + 2S + 6A + 4*2 + 1*4 (implemented as: 4M + 2S + 7A + 3*2 + 1*4)\n      // H = X2 - X1\n      var h = p.x.redSub(this.x); // r = 2 * (Y2 - Y1)\n\n      var r = p.y.redSub(this.y).redIMuln(2); // H = 0\n\n      if (h.isZero()) {\n        if (!r.isZero()) return this.curve.jpoint();\n        return this.dbl();\n      } // HH = H^2\n\n\n      var hh = h.redSqr(); // I = 4 * HH\n\n      var i = hh.redIMuln(4); // J = H * I\n\n      var j = h.redMul(i); // V = X1 * I\n\n      var v = this.x.redMul(i); // X3 = r^2 - J - 2 * V\n\n      var nx = r.redSqr().redISub(j).redISub(v).redISub(v); // Y3 = r * (V - X3) - 2 * Y1 * J\n\n      var ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2)); // Z3 = 2 * H\n\n      var nz = h.redIMuln(2);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      // P = O\n      if (this.isInfinity()) return this; // Y1 = 0\n\n      if (this.y.isZero()) return this.curve.jpoint(); // Z1 = 1\n\n      if (this.zOne) return this._dblA(); // a = 0\n\n      if (this.curve.zeroA) return this._dbl0(); // a = -3\n\n      if (this.curve.threeA) return this._dbl3();\n      return this._dblJ();\n    }\n  }, {\n    key: \"_dblJ\",\n    value: function _dblJ() {\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n      // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8\n      // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)\n      // XX = X1^2\n      var xx = this.x.redSqr(); // YY = Y1^2\n\n      var yy = this.y.redSqr(); // ZZ = Z1^2\n\n      var zz = this.z.redSqr(); // S = 4 * X1 * YY\n\n      var s = this.x.redMul(yy).redIMuln(4); // M = 3 * XX + a * ZZ^2\n\n      var m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr())); // T = M^2 - 2 * S\n\n      var t = m.redSqr().redISub(s).redISub(s); // X3 = T\n\n      var nx = t; // Y3 = M * (S - T) - 8 * YY^2\n\n      var ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8)); // Z3 = 2 * Y1 * Z1\n\n      var nz = this.y.redMul(this.z).redIMuln(2);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"_dblA\",\n    value: function _dblA() {\n      // Assumes Z = 1.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-mdbl-2007-bl\n      // 1M + 5S + 7A + 3*2 + 1*3 + 1*8\n      // (implemented as: 1M + 5S + 8A + 2*2 + 1*3 + 1*8)\n      // XX = X1^2\n      var xx = this.x.redSqr(); // YY = Y1^2\n\n      var yy = this.y.redSqr(); // YYYY = YY^2\n\n      var yyyy = yy.redSqr(); // + XYY2 = (X1 + YY)^2\n\n      var xyy2 = yy.redIAdd(this.x).redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\n      var s = xyy2.redISub(xx).redISub(yyyy).redIMuln(2); // M = 3 * XX + a\n\n      var m = xx.redIMuln(3).redIAdd(this.curve.a); // T = M^2 - 2 * S\n\n      var t = m.redSqr().redISub(s).redISub(s); // X3 = T\n\n      var nx = t; // Y3 = M * (S - T) - 8 * YYYY\n\n      var ny = m.redMul(s.redISub(t)).redISub(yyyy.redIMuln(8)); // Z3 = 2 * Y1\n\n      var nz = this.y.redMuln(2);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"_dbl0\",\n    value: function _dbl0() {\n      // Assumes a = 0.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n      // 2M + 5S + 6A + 3*2 + 1*3 + 1*8\n      // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)\n      // A = X1^2\n      var a = this.x.redSqr(); // B = Y1^2\n\n      var b = this.y.redSqr(); // C = B^2\n\n      var c = b.redSqr(); // + XB2 = (X1 + B)^2\n\n      var xb2 = b.redIAdd(this.x).redSqr(); // D = 2 * ((X1 + B)^2 - A - C)\n\n      var d = xb2.redISub(a).redISub(c).redIMuln(2); // E = 3 * A\n\n      var e = a.redIMuln(3); // F = E^2\n\n      var f = e.redSqr(); // X3 = F - 2 * D\n\n      var nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C\n\n      var ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8)); // Z3 = 2 * Y1 * Z1\n\n      var nz = this.y.redMul(this.z).redIMuln(2);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"_dbl3\",\n    value: function _dbl3() {\n      // Assumes a = -3.\n      // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n      // 3M + 5S + 8A + 1*3 + 1*4 + 2*8\n      // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)\n      // delta = Z1^2\n      var delta = this.z.redSqr(); // gamma = Y1^2\n\n      var gamma = this.y.redSqr(); // beta = X1 * gamma\n\n      var beta = this.x.redMul(gamma); // + xmdelta = X1 - delta\n\n      var xmdelta = this.x.redSub(delta); // + xpdelta = X1 + delta\n\n      var xpdelta = this.x.redAdd(delta); // alpha = 3 * (X1 - delta) * (X1 + delta)\n\n      var alpha = xmdelta.redMul(xpdelta).redIMuln(3); // + beta4 = 4 * beta\n\n      var beta4 = beta.redIMuln(4); // + beta8 = 2 * beta4\n\n      var beta8 = beta4.redMuln(2); // + gamma28 = 8 * gamma^2\n\n      var gamma28 = gamma.redSqr().redIMuln(8); // X3 = alpha^2 - 8 * beta\n\n      var nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta\n\n      var nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n\n      var ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"dblp\",\n    value: function dblp(pow) {\n      assert(pow >>> 0 === pow); // a = 0 or a = -3\n\n      if (this.curve.zeroA || this.curve.threeA) return _get(_getPrototypeOf(JPoint.prototype), \"dblp\", this).call(this, pow); // m = 0\n\n      if (pow === 0) return this; // P = O\n\n      if (this.isInfinity()) return this;\n      return this._dblp(pow);\n    }\n  }, {\n    key: \"_dblp\",\n    value: function _dblp(pow) {\n      // Repeated point doubling (Jacobian coordinates).\n      //\n      // [GECC] Algorithm 3.23, Page 93, Section 3.2.\n      //\n      // Modified version of:\n      //   https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n      //\n      // Divergences from the above formula are marked with diff notation.\n      //\n      // Implemented as:\n      //   1M + 2S + 1*2 + N * (4M + 4S + 4A + 1*a + 1*3 + 2*2)\n      //   e.g. N = 1 => 5M + 6S + 4A + 1*a + 1*3 + 3*2\n      //\n      // Repeated doubling also explained here:\n      //   https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates\n      //\n      // Note that the above sources change:\n      //   M = 3 * XX + a * ZZZZ\n      // To:\n      //   M = 3 * (XX - ZZZZ)\n      //\n      // In order to assume a = -3.\n      var _this$curve2 = this.curve,\n          a = _this$curve2.a,\n          i2 = _this$curve2.i2; // Reuse results (y is always y*2).\n\n      var x = this.x;\n      var z = this.z; // + Y1 = Y1 * 2\n\n      var y = this.y.redMuln(2); // + ZZZZ = Z1^4\n\n      var zzzz = z.redPown(4);\n\n      for (var i = 0; i < pow; i++) {\n        // Y1 = 0\n        if (y.isZero()) return this.curve.jpoint(); // XX = X1^2\n\n        var xx = x.redSqr(); // YY = Y1^2\n\n        var yy = y.redSqr(); // + YYYY = YY^2\n\n        var yyyy = yy.redSqr(); // - M = 3 * XX + a * ZZ^2\n        // + M = 3 * XX + a * ZZZZ\n\n        var m = xx.redIMuln(3).redIAdd(a.redMul(zzzz)); // - S = 4 * X1 * YY\n        // + S = X1 * YY\n\n        var s = x.redMul(yy); // T = M^2 - 2 * S\n\n        var t = m.redSqr().redISub(s).redISub(s); // X3 = T\n\n        var nx = t; // - Y3 = M * (S - T) - 8 * YY^2\n        // + Y3 = M * (S - T) * 2 - YYYY\n\n        var ny = m.redMul(s.redISub(t)).redIMuln(2).redISub(yyyy); // Z3 = 2 * Y1 * Z1\n\n        var nz = y.redMul(z); // + ZZZZ = ZZZZ * YYYY\n\n        if (i + 1 < pow) zzzz = zzzz.redMul(yyyy); // + X1 = X3\n\n        x = nx; // + Y1 = Y3\n\n        y = ny; // + Z1 = Z3\n\n        z = nz;\n      }\n\n      return this.curve.jpoint(x, y.redMul(i2), z);\n    }\n  }, {\n    key: \"uadd\",\n    value: function uadd(p) {\n      assert(p instanceof Point);\n      if (p.type === types.AFFINE) return this._uadd(p.toJ());\n      return this._uadd(p);\n    }\n  }, {\n    key: \"_uadd\",\n    value: function _uadd(p) {\n      // Strongly unified Jacobian addition (Brier and Joye).\n      //\n      // [SIDE2] Page 6, Section 3.\n      // [SIDE3] Page 4, Section 3.\n      //\n      // The above documents use projective coordinates[1]\n      // and have been modified for jacobian coordinates. A\n      // further modification, taken from libsecp256k1[2],\n      // handles the degenerate case of: x1 != x2, y1 = -y2.\n      //\n      // [1] https://hyperelliptic.org/EFD/g1p/auto-shortw-projective.html#addition-add-2002-bj\n      // [2] https://github.com/bitcoin-core/secp256k1/blob/ee9e68c/src/group_impl.h#L525\n      //\n      // 11M + 8S + 7A + 1*a + 2*4 + 1*3 + 2*2 (a != 0)\n      // 11M + 6S + 6A + 2*4 + 1*3 + 2*2 (a = 0)\n      assert(p instanceof JPoint);\n      var _this$curve3 = this.curve,\n          zero = _this$curve3.zero,\n          one = _this$curve3.one; // Z1Z1 = Z1^2\n\n      var z1z1 = this.z.redSqr(); // Z2Z2 = Z2^2\n\n      var z2z2 = p.z.redSqr(); // U1 = X1 * Z2Z2\n\n      var u1 = this.x.redMul(z2z2); // U2 = X2 * Z1Z1\n\n      var u2 = p.x.redMul(z1z1); // S1 = Y1 * Z2Z2 * Z2\n\n      var s1 = this.y.redMul(z2z2).redMul(p.z); // S2 = Y2 * Z1Z1 * Z1\n\n      var s2 = p.y.redMul(z1z1).redMul(this.z); // Z = Z1 * Z2\n\n      var z = this.z.redMul(p.z); // T = U1 + U2\n\n      var t = u1.redAdd(u2); // M = S1 + S2\n\n      var m = s1.redAdd(s2); // R = T^2 - U1 * U2\n\n      var r = t.redSqr().redISub(u1.redMul(u2)); // R = R + a * Z^4 (if a != 0)\n\n      if (!this.curve.zeroA) {\n        var zzzz = z.redPown(4); // Save some cycles for a = -3.\n\n        if (this.curve.threeA) r.redIAdd(zzzz.redIMuln(-3));else r.redIAdd(this.curve.a.redMul(zzzz));\n      } // Check for degenerate case (X1 != X2, Y1 = -Y2).\n\n\n      var degenerate = m.czero() & r.czero(); // M = U1 - U2 (if degenerate)\n\n      m.cinject(u1.redSub(u2), degenerate); // R = S1 - S2 (if degenerate)\n\n      r.cinject(s1.redSub(s2), degenerate); // L = M^2\n\n      var l = m.redSqr(); // G = T * L\n\n      var g = t.redMul(l); // LL = L^2\n\n      var ll = l.redSqr(); // LL = 0 (if degenerate)\n\n      ll.cinject(zero, degenerate); // W = R^2\n\n      var w = r.redSqr(); // F = Z * M\n\n      var f = z.redMul(m); // H = 3 * G - 2 * W\n\n      var h = g.redMuln(3).redISub(w).redISub(w); // X3 = 4 * (W - G)\n\n      var nx = w.redISub(g).redIMuln(4); // Y3 = 4 * (R * H - LL)\n\n      var ny = r.redMul(h).redISub(ll).redIMuln(4); // Z3 = 2 * F\n\n      var nz = f.redIMuln(2); // Check for infinity.\n\n      var inf1 = this.z.czero();\n      var inf2 = p.z.czero();\n      var inf3 = nz.czero() & ((inf1 | inf2) ^ 1); // Case 1: O + P = P\n\n      nx.cinject(p.x, inf1);\n      ny.cinject(p.y, inf1);\n      nz.cinject(p.z, inf1); // Case 2: P + O = P\n\n      nx.cinject(this.x, inf2);\n      ny.cinject(this.y, inf2);\n      nz.cinject(this.z, inf2); // Case 3: P + -P = O\n\n      nx.cinject(one, inf3);\n      ny.cinject(one, inf3);\n      nz.cinject(zero, inf3);\n      return this.curve.jpoint(nx, ny, nz);\n    }\n  }, {\n    key: \"udbl\",\n    value: function udbl() {\n      var p = this._udbl();\n\n      var inf = this.z.czero() | this.y.czero(); // Case 1 & 2: 2 * O = O, 2 * (X, 0) = O\n\n      p.x.cinject(this.curve.one, inf);\n      p.y.cinject(this.curve.one, inf);\n      p.z.cinject(this.curve.zero, inf);\n      return p;\n    }\n  }, {\n    key: \"_udbl\",\n    value: function _udbl() {\n      // a = 0\n      if (this.curve.zeroA) return this._dbl0(); // a = -3\n\n      if (this.curve.threeA) return this._dbl3();\n      return this._dblJ();\n    }\n  }, {\n    key: \"zaddu\",\n    value: function zaddu(p) {\n      // Co-Z addition with update (ZADDU).\n      // [COZ] Algorithm 19, Page 15, Appendix C.\n      // 5M + 2S + 7A\n      assert(p instanceof JPoint); // H = X1 - X2\n\n      var h = this.x.redSub(p.x); // R = Y1 - Y2\n\n      var r = this.y.redSub(p.y); // HH = H^2\n\n      var hh = h.redSqr(); // V1 = X1 * HH\n\n      var v1 = this.x.redMul(hh); // V2 = X2 * HH\n\n      var v2 = p.x.redMul(hh); // X4 = V1\n\n      var x4 = v1; // X3 = R^2 - V1 - V2\n\n      var x3 = r.redSqr().redISub(v1).redISub(v2); // Y4 = Y1 * (V1 - V2)\n\n      var y4 = this.y.redMul(v1.redSub(v2)); // Y3 = R * (X4 - X3) - Y4\n\n      var y3 = r.redMul(x4.redSub(x3)).redISub(y4); // Z4 = Z1 * H\n\n      var z4 = this.z.redMul(h); // Z3 = Z4\n\n      var z3 = z4; // R = (X3, Y3, Z3)\n      // P = (X4, Y4, Z4)\n\n      return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];\n    }\n  }, {\n    key: \"zaddc\",\n    value: function zaddc(p) {\n      // Co-Z addition with conjugate (ZADDC).\n      // [COZ] Algorithm 20, Page 15, Appendix C.\n      // 6M + 3S + 14A + 1*2\n      assert(p instanceof JPoint); // H = X1 - X2\n\n      var h = this.x.redSub(p.x); // R = Y1 - Y2\n\n      var r = this.y.redSub(p.y); // M = Y1 + Y2\n\n      var m = this.y.redAdd(p.y); // HH = H^2\n\n      var hh = h.redSqr(); // V1 = X1 * HH\n\n      var v1 = this.x.redMul(hh); // V2 = X2 * HH\n\n      var v2 = p.x.redMul(hh); // X4 = (Y1 + Y2)^2 - V1 - V2\n\n      var x4 = m.redSqr().redISub(v1).redISub(v2); // X3 = R^2 - V1 - V2\n\n      var x3 = r.redSqr().redISub(v1).redISub(v2); // Y = Y1 * (V2 - V1)\n\n      var y = this.y.redMul(v2.redISub(v1)); // Z = R + 2 * Y2\n\n      var z = p.y.redMuln(2).redIAdd(r); // I = V1 - X4\n\n      var i = v1.redISub(x4); // J = X4 + I - X3\n\n      var j = x4.redAdd(i).redISub(x3); // Y4 = Z * I + Y\n\n      var y4 = z.redMul(i).redIAdd(y); // Y3 = R * J + Y\n\n      var y3 = r.redMul(j).redIAdd(y); // Z4 = Z1 * H\n\n      var z4 = this.z.redMul(h); // Z3 = Z4\n\n      var z3 = z4; // R = (X3, Y3, Z3)\n      // S = (X4, Y4, Z4)\n\n      return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];\n    }\n  }, {\n    key: \"zdblu\",\n    value: function zdblu() {\n      // Co-Z doubling with update (DBLU).\n      // [COZ] Algorithm 21, Page 15, Appendix C.\n      //\n      // 1M + 5S + 8A + 4*2 + 1*8\n      //\n      // Note that the original formula assumed Z1=1.\n      // We have modified it to allow for scaled points.\n      //\n      // New Cost: 2M + 5S + 8A + 1*a + 1*3 + 2*2 + 1*8\n      // XX = X1^2\n      var xx = this.x.redSqr(); // YY = Y1^2\n\n      var yy = this.y.redSqr(); // YYYY = YY^2\n\n      var yyyy = yy.redSqr(); // S = (X1 + YY)^2\n\n      var s = this.x.redAdd(yy).redSqr(); // M = 3 * XX\n\n      var m = xx.redMuln(3); // M = M + a * Z1^4 (if a != 0)\n\n      if (!this.curve.zeroA) {\n        var zzzz = this.z.redPown(4); // Save some cycles for a = -3.\n\n        if (this.curve.threeA) m.redIAdd(zzzz.redIMuln(-3));else m.redIAdd(this.curve.a.redMul(zzzz));\n      } // X4 = 2 * (S - XX - YYYY)\n\n\n      var x4 = s.redISub(xx).redISub(yyyy).redIMuln(2); // X3 = M^2 - X4 - X4\n\n      var x3 = m.redSqr().redISub(x4).redISub(x4); // Y4 = 8 * YYYY\n\n      var y4 = yyyy.redIMuln(8); // Y3 = (X4 - X3) * M - Y4\n\n      var y3 = x4.redSub(x3).redMul(m).redISub(y4); // Z4 = 2 * (Y1 * Z1)\n\n      var z4 = this.y.redMul(this.z).redIMuln(2); // Z3 = Z4\n\n      var z3 = z4; // R = (X3, Y3, Z3)\n      // P = (X4, Y4, Z4)\n\n      return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];\n    }\n  }, {\n    key: \"recover\",\n    value: function recover(x1, z1, x2, z2) {\n      return this.toP().recover(x1, z1, x2, z2);\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      if (this.isInfinity()) throw new Error('Invalid point.');\n      this.normalize();\n      return this.x.fromRed();\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      if (this.isInfinity()) throw new Error('Invalid point.');\n      this.normalize();\n      return this.y.fromRed();\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(p) {\n      assert(p instanceof JPoint); // P = Q\n\n      if (this === p) return true; // P = O\n\n      if (this.isInfinity()) return p.isInfinity(); // Q = O\n\n      if (p.isInfinity()) return false; // Z1 = Z2\n\n      if (this.z.eq(p.z)) {\n        return this.x.eq(p.x) && this.y.eq(p.y);\n      } // X1 * Z2^2 == X2 * Z1^2\n\n\n      var zz1 = this.z.redSqr();\n      var zz2 = p.z.redSqr();\n      var x1 = this.x.redMul(zz2);\n      var x2 = p.x.redMul(zz1);\n      if (!x1.eq(x2)) return false; // Y1 * Z2^3 == Y2 * Z1^3\n\n      var zzz1 = zz1.redMul(this.z);\n      var zzz2 = zz2.redMul(p.z);\n      var y1 = this.y.redMul(zzz2);\n      var y2 = p.y.redMul(zzz1);\n      return y1.eq(y2);\n    }\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      // Z1 = 0\n      return this.z.isZero();\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      if (this.isInfinity()) return false;\n      this.normalize();\n      return this.y.redIsOdd();\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      if (this.isInfinity()) return false;\n      this.normalize();\n      return this.y.redIsEven();\n    }\n  }, {\n    key: \"isSquare\",\n    value: function isSquare() {\n      if (this.isInfinity()) return false;\n      return this.y.redMul(this.z).redJacobi() !== -1;\n    }\n  }, {\n    key: \"eqX\",\n    value: function eqX(x) {\n      // Verify that integer `x` is equal to field\n      // element `x` by scaling it by our z coordinate.\n      // This optimization is mentioned in and used for\n      // bip-schnorr[1]. This avoids having to affinize\n      // the resulting point during verification.\n      //\n      // [1] [SCHNORR] \"Optimizations\".\n      assert(x instanceof BN);\n      assert(!x.red);\n      if (this.isInfinity()) return false;\n      var zz = this.z.redSqr();\n      var rx = x.toRed(this.curve.red).redMul(zz);\n      return this.x.eq(rx);\n    }\n  }, {\n    key: \"eqXToP\",\n    value: function eqXToP(x) {\n      // Similar to the optimization above, this\n      // optimization, suggested by Maxwell[1],\n      // compares an integer to an X coordinate\n      // by scaling it.\n      //\n      // Since a signature's R value is modulo N\n      // in ECDSA, we may be dealing with an R\n      // value greater than N in actuality.\n      //\n      // If the equality check fails, we can\n      // scale N itself by Z and add it to the\n      // X field element (up until a certain\n      // limit) and repeat the check.\n      //\n      // If P is more than 100 times larger than\n      // N, we don't gain much here, so we just\n      // affinize and do the comparison.\n      //\n      // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f\n      assert(x instanceof BN);\n      assert(!x.red);\n      if (!this.curve.smallGap) return this.toP().eqXToP(x);\n      if (this.isInfinity()) return false;\n      if (x.cmp(this.curve.p) >= 0) return false;\n      var zz = this.z.redSqr();\n      var rx = x.toRed(this.curve.red).redMul(zz);\n      if (this.x.eq(rx)) return true;\n      if (this.curve.highOrder) return false;\n      if (x.cmp(this.curve.pmodn) >= 0) return false;\n      var rn = this.curve.redN.redMul(zz);\n      rx.redIAdd(rn);\n      return this.x.eq(rx);\n    }\n  }, {\n    key: \"toP\",\n    value: function toP() {\n      // P = O\n      if (this.isInfinity()) return this.curve.point();\n      this.normalize(); // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)\n\n      return this.curve.point(this.x, this.y);\n    }\n  }, {\n    key: \"toJ\",\n    value: function toJ() {\n      return this;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(compact) {\n      return this.toP().encode(compact);\n    }\n  }, {\n    key: \"encodeX\",\n    value: function encodeX() {\n      return this.toP().encodeX();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      return this.toP().toJSON(pre);\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      if (this.isInfinity()) return '<JPoint: Infinity>';\n      return '<JPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(curve, bytes) {\n      return ShortPoint.decode(curve, bytes).toJ();\n    }\n  }, {\n    key: \"decodeEven\",\n    value: function decodeEven(curve, bytes) {\n      return ShortPoint.decodeEven(curve, bytes).toJ();\n    }\n  }, {\n    key: \"decodeSquare\",\n    value: function decodeSquare(curve, bytes) {\n      return ShortPoint.decodeSquare(curve, bytes).toJ();\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      return ShortPoint.fromJSON(curve, json).toJ();\n    }\n  }]);\n\n  return JPoint;\n}(Point);\n/**\n * MontCurve\n */\n\n\nvar MontCurve = /*#__PURE__*/function (_Curve2) {\n  _inherits(MontCurve, _Curve2);\n\n  var _super4 = _createSuper(MontCurve);\n\n  function MontCurve(conf) {\n    var _this5;\n\n    _classCallCheck(this, MontCurve);\n\n    _this5 = _super4.call(this, MontPoint, 'mont', conf);\n    _this5.a = BN.fromJSON(conf.a).toRed(_this5.red);\n    _this5.b = BN.fromJSON(conf.b).toRed(_this5.red);\n    _this5.bi = _this5.b.redInvert();\n    _this5.a2 = _this5.a.redAdd(_this5.two);\n    _this5.a24 = _this5.a2.redMul(_this5.i4);\n    _this5.a3 = _this5.a.redMul(_this5.i3);\n    _this5.a0 = _this5.a.redMul(_this5.bi);\n    _this5.b0 = _this5.bi.redSqr();\n\n    _this5._finalize(conf);\n\n    return _this5;\n  }\n\n  _createClass(MontCurve, [{\n    key: \"_short\",\n    value: function _short(a0, odd) {\n      // Montgomery->Short Weierstrass Equivalence.\n      //\n      // [MONT2] \"Equivalence with Weierstrass curves\".\n      //\n      // Transformation:\n      //\n      //   a = (3 - A^2) / (3 * B^2)\n      //   b = (2 * A^3 - 9 * A) / (27 * B^3)\n      var a = this.a,\n          b = this.b,\n          three = this.three;\n      var a2 = a.redSqr();\n      var a3 = a2.redMul(a);\n      var b2 = b.redSqr();\n      var b3 = b2.redMul(b);\n      var n0 = three.redSub(a2);\n      var d0 = b2.redMuln(3);\n      var n1 = a3.redMuln(2).redISub(a.redMuln(9));\n      var d1 = b3.redMuln(27);\n      var wa = n0.redDiv(d0);\n      var wb = n1.redDiv(d1);\n      if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);\n      return [wa, wb];\n    }\n  }, {\n    key: \"_mont\",\n    value: function _mont(b0) {\n      return MontCurve._isomorphism(this.a, this.b, b0);\n    }\n  }, {\n    key: \"_edwards\",\n    value: function _edwards(a0) {\n      var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Montgomery->Twisted Edwards Transformation.\n      //\n      // [MONT1] Page 11, Section 4.3.5.\n      // [TWISTED] Theorem 3.2, Page 4, Section 3.\n      //\n      // Equivalence:\n      //\n      //   a = (A + 2) / B\n      //   d = (A - 2) / B\n      //\n      // Isomorphism:\n      //\n      //   a = a'\n      //   d = a' * (A - 2) / (A + 2)\n      //\n      // Where ((A + 2) / (B * a')) is square.\n      //\n      // If `d` is square, we can usually find\n      // a complete curve by using the `invert`\n      // option. This will create an isomorphism\n      // chain of: M(A,B)->E(a,d)->E(d,a).\n      //\n      // The equivalence between E(a,d) and\n      // E(d,a) is:\n      //\n      //   (x, y) = (x, 1 / y)\n      //\n      // Meaning our map to E(d,a) is:\n      //\n      //   x = u / v\n      //   y = 1 / ((u - 1) / (u + 1))\n      //     = (u + 1) / (u - 1)\n      assert(typeof invert === 'boolean');\n      var two = this.two,\n          bi = this.bi;\n      var a = this.a.redAdd(two).redMul(bi);\n      var d = this.a.redSub(two).redMul(bi);\n      if (invert) a.swap(d);\n      if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);\n      return [a, d];\n    }\n  }, {\n    key: \"_scaleShort\",\n    value: function _scaleShort(curve) {\n      assert(curve instanceof ShortCurve);\n\n      var _curve$_scale3 = curve._scale(this),\n          _curve$_scale4 = _slicedToArray(_curve$_scale3, 2),\n          u2 = _curve$_scale4[0],\n          u3 = _curve$_scale4[1];\n\n      return [this.field(u2.redInvert()), this.field(u3.redInvert())];\n    }\n  }, {\n    key: \"_scaleMont\",\n    value: function _scaleMont(curve) {\n      // We can extract the isomorphism factor with:\n      //\n      //   c = +-sqrt(B / B')\n      //\n      // If base points are available, we can do:\n      //\n      //   c = v' / v\n      assert(curve instanceof MontCurve);\n      if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.b).redDivSqrt(this.b);\n      return this.g.y.redDiv(this.field(curve.g.y));\n    }\n  }, {\n    key: \"_scaleEdwards\",\n    value: function _scaleEdwards(curve, invert) {\n      // We _could_ do something like:\n      //\n      //   B = 4 / (a - d)\n      //   c = +-sqrt(B / B')\n      //\n      // Which can be reduced to:\n      //\n      //   c = +-sqrt(4 / ((a - d) * B'))\n      //\n      // If base points are available:\n      //\n      //   v = u' / x\n      //   c = v' / v\n      //\n      // Which can be reduced to:\n      //\n      //   c = v' * x / u'\n      //\n      // However, the way our maps are\n      // written, we can re-use the Edwards\n      // isomorphism factor when going the\n      // other direction.\n      assert(curve instanceof EdwardsCurve);\n\n      var c = curve._scale(this, invert);\n\n      return this.field(c);\n    }\n  }, {\n    key: \"_solveY0\",\n    value: function _solveY0(x) {\n      assert(x instanceof BN); // y^2 = x^3 + A * x^2 + B * x\n\n      var a = this.a0;\n      var b = this.b0;\n      var x2 = x.redSqr();\n      var x3 = x2.redMul(x);\n      var y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));\n      return y2;\n    }\n  }, {\n    key: \"_elligator2\",\n    value: function _elligator2(u) {\n      // Elligator 2.\n      //\n      // Distribution: 1/2.\n      //\n      // [ELL2] Page 11, Section 5.2.\n      // [H2EC] \"Elligator 2 Method\".\n      //        \"Mappings for Montgomery curves\".\n      // [SAFE] \"Indistinguishability from uniform random strings\".\n      //\n      // Assumptions:\n      //\n      //   - y^2 = x^3 + A * x^2 + B * x.\n      //   - A != 0, B != 0.\n      //   - A^2 - 4 * B is non-zero and non-square in F(p).\n      //   - Let z be a non-square in F(p).\n      //   - u != +-sqrt(-1 / z).\n      //\n      // Note that Elligator 2 is defined over the form:\n      //\n      //   y'^2 = x'^3 + A' * x'^2 + B' * x'\n      //\n      // Instead of:\n      //\n      //   B * y^2 = x^3 + A * x^2 + x\n      //\n      // Where:\n      //\n      //   A' = A / B\n      //   B' = 1 / B^2\n      //   x' = x / B\n      //   y' = y / B\n      //\n      // And:\n      //\n      //   x = B * x'\n      //   y = B * y'\n      //\n      // This is presumably the result of Elligator 2\n      // being designed in long Weierstrass form. If\n      // we want to support B != 1, we need to do the\n      // conversion.\n      //\n      // Map:\n      //\n      //   g(x) = x^3 + A * x^2 + B * x\n      //   x1 = -A / (1 + z * u^2)\n      //   x1 = -A, if x1 = 0\n      //   x2 = -x1 - A\n      //   x = x1, if g(x1) is square\n      //     = x2, otherwise\n      //   y = sign(u) * abs(sqrt(g(x)))\n      var lhs = this.a0.redNeg();\n      var rhs = this.one.redAdd(this.z.redMul(u.redSqr()));\n      rhs.cinject(this.one, rhs.czero());\n      var x1 = lhs.redMul(rhs.redFermat());\n      var x2 = x1.redNeg().redISub(this.a0);\n\n      var y1 = this._solveY0(x1);\n\n      var y2 = this._solveY0(x2);\n\n      var alpha = y1.redIsSquare() | 0;\n      var x0 = x1.cinject(x2, alpha ^ 1);\n      var y0 = y1.cinject(y2, alpha ^ 1).redSqrt();\n      y0.cinject(y0.redNeg(), y0.redIsOdd() ^ u.redIsOdd());\n      var x = this.b.redMul(x0);\n      var y = this.b.redMul(y0);\n      return this.point(x, y);\n    }\n  }, {\n    key: \"_invert2\",\n    value: function _invert2(p, hint) {\n      // Inverting the Map (Elligator 2).\n      //\n      // [ELL2] Page 12, Section 5.3.\n      //\n      // Assumptions:\n      //\n      //   - -z * x * (x + A) is square in F(p).\n      //   - If r = 1 then x != 0.\n      //   - If r = 2 then x != -A.\n      //\n      // Map:\n      //\n      //   u1 = -(x + A) / (x * z)\n      //   u2 = -x / ((x + A) * z)\n      //   r = random integer in [1,2]\n      //   u = sign(y) * abs(sqrt(ur))\n      //\n      // Note that `0 / 0` can only occur if `A == 0`\n      // (this violates the assumptions of Elligator 2).\n      var x = p.x,\n          y = p.y;\n      var r = hint & 1;\n      var x0 = x.redMul(this.bi);\n      var y0 = y.redMul(this.bi);\n      var n = x0.redAdd(this.a0);\n      var d = x0;\n      n.cswap(d, r);\n      var lhs = n.redINeg();\n      var rhs = d.redMul(this.z);\n\n      var _divSqrt5 = divSqrt(lhs, rhs),\n          _divSqrt6 = _slicedToArray(_divSqrt5, 2),\n          sqr = _divSqrt6[0],\n          u = _divSqrt6[1];\n\n      u.cinject(u.redNeg(), u.redIsOdd() ^ y0.redIsOdd());\n      if (!sqr) throw new Error('Invalid point.');\n      return u;\n    }\n  }, {\n    key: \"_constMul\",\n    value: function _constMul(p, k, rng) {\n      // Use the single-coordinate ladder in\n      // combination with y-coordinate recovery\n      // to compute an affine point.\n      //\n      // There are a few edge cases here, some\n      // of them documented by Mike Hamburg[1].\n      //\n      // There are two primary edge cases here:\n      //\n      //   1. P * k = O where k = n - 1.\n      //   2. P * k = O where P is small order.\n      //\n      // The first occurs due to the fact that\n      // the Okeya-Sakurai formula requires\n      // one to compute both Q and Q+P. In the\n      // case of k=n-1, Q+P becomes infinity.\n      //\n      // In other words:\n      //\n      //   Q2 = P * (n - 1) + P = O\n      //\n      // The second edge case is a side effect\n      // of the differential addition used in\n      // the ladder. This covers the first two\n      // cases mentioned by Hamburg.\n      //\n      // [1] https://tinyurl.com/y4q2dey9\n      assert(p instanceof MontPoint);\n      var x = p.toX();\n\n      var _x$ladderConst = x.ladderConst(k, rng),\n          _x$ladderConst2 = _slicedToArray(_x$ladderConst, 2),\n          a = _x$ladderConst2[0],\n          b = _x$ladderConst2[1];\n\n      var q = p.recover(b, a);\n      return k.isNeg() ? q.neg() : q;\n    }\n  }, {\n    key: \"isElliptic\",\n    value: function isElliptic() {\n      var a2 = this.a.redSqr();\n      var d = this.b.redMul(a2.redSub(this.four)); // B * (A^2 - 4) != 0\n\n      return !d.isZero();\n    }\n  }, {\n    key: \"jinv\",\n    value: function jinv() {\n      // [MONT3] Page 3, Section 2.\n      var a = this.a,\n          three = this.three,\n          four = this.four;\n      var a2 = a.redSqr();\n      var t0 = a2.redSub(three);\n      var lhs = t0.redPown(3).redIMuln(256);\n      var rhs = a2.redSub(four);\n      if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // (256 * (A^2 - 3)^3) / (A^2 - 4)\n\n      return lhs.redDiv(rhs).fromRed();\n    }\n  }, {\n    key: \"point\",\n    value: function point(x, y) {\n      var inf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return new MontPoint(this, x, y, inf);\n    }\n  }, {\n    key: \"jpoint\",\n    value: function jpoint(x, y, z) {\n      assert(x == null && y == null && z == null);\n      return this.point();\n    }\n  }, {\n    key: \"xpoint\",\n    value: function xpoint(x, z) {\n      return new XPoint(this, x, z);\n    }\n  }, {\n    key: \"solveY2\",\n    value: function solveY2(x) {\n      // [MONT3] Page 3, Section 2.\n      // https://hyperelliptic.org/EFD/g1p/auto-montgom.html\n      assert(x instanceof BN); // B * y^2 = x^3 + A * x^2 + x\n\n      var x2 = x.redSqr();\n      var x3 = x2.redMul(x);\n      var by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);\n      var y2 = by2.redMul(this.bi);\n      return y2;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(point) {\n      assert(point instanceof MontPoint);\n      if (point.isInfinity()) return true;\n      var x = point.x,\n          y = point.y;\n      var y2 = this.solveY2(x);\n      return y.redSqr().eq(y2);\n    }\n  }, {\n    key: \"pointFromX\",\n    value: function pointFromX(x) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      assert(x instanceof BN);\n      assert(sign == null || typeof sign === 'boolean');\n      if (!x.red) x = x.toRed(this.red);\n      var y = this.solveY(x);\n\n      if (sign != null) {\n        if (y.redIsOdd() !== sign) y.redINeg();\n      }\n\n      return this.point(x, y);\n    }\n  }, {\n    key: \"isIsomorphic\",\n    value: function isIsomorphic(curve, invert) {\n      // [MONT3] Page 3, Section 2.1.\n      assert(curve instanceof Curve);\n      if (!curve.p.eq(this.p)) return false; // M(A,B) <-> M(A,B')\n\n      if (curve.type === 'mont') {\n        var a = this.field(curve.a);\n        var b = this.field(curve.b); // A' = A\n\n        if (!this.a.eq(a)) return false; // B' != 0\n\n        if (this.b.isZero()) return false; // jacobi(B / B') = 1\n\n        var c = b.redDiv(this.b);\n        return c.redJacobi() === 1;\n      }\n\n      return curve.isIsomorphic(this, invert);\n    }\n  }, {\n    key: \"isIsogenous\",\n    value: function isIsogenous(curve) {\n      assert(curve instanceof Curve);\n      if (curve.type === 'mont') return false;\n      return curve.isIsogenous(this);\n    }\n  }, {\n    key: \"pointFromShort\",\n    value: function pointFromShort(point) {\n      // [ALT] Appendix E.2 (Switching between Alternative Representations).\n      // [MONT2] \"Equivalence with Weierstrass curves\"\n      assert(point instanceof ShortPoint);\n\n      if (this.isIsomorphic(point.curve)) {\n        // Equivalence for E(a,b)->M(A,B):\n        //\n        //   u = B * x - A / 3\n        //   v = B * y\n        //\n        // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n        if (point.isInfinity()) return this.point();\n        var a3 = this.a3,\n            b = this.b;\n\n        var _this$_scale13 = this._scale(point.curve),\n            _this$_scale14 = _slicedToArray(_this$_scale13, 2),\n            u2 = _this$_scale14[0],\n            u3 = _this$_scale14[1];\n\n        var x = this.field(point.x).redMul(u2);\n        var y = this.field(point.y).redMul(u3);\n        var u = b.redMul(x).redISub(a3);\n        var v = b.redMul(y);\n        return this.point(u, v);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromMont\",\n    value: function pointFromMont(point) {\n      // [MONT3] Page 3, Section 2.1.\n      assert(point instanceof MontPoint);\n\n      if (this.isIsomorphic(point.curve)) {\n        // Isomorphic maps for M(A,B)<->M(A,B'):\n        //\n        //   u' = u\n        //   v' = +-sqrt(B / B') * v\n        //\n        // Undefined if (B / B') is not square.\n        if (point.isInfinity()) return this.point();\n\n        var c = this._scale(point.curve);\n\n        var u = this.field(point.x);\n        var v = this.field(point.y);\n        var nu = u;\n        var nv = c.redMul(v);\n        return this.point(nu, nv);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromEdwards\",\n    value: function pointFromEdwards(point) {\n      // [RFC7748] Section 4.1 & 4.2.\n      // [MONT3] Page 6, Section 2.5.\n      // [TWISTED] Theorem 3.2, Page 4, Section 3.\n      assert(point instanceof EdwardsPoint);\n      assert(point.curve.p.eq(this.p)); // Edwards `x`, `y`, `z`.\n\n      var x = this.field(point.x);\n      var y = this.field(point.y);\n      var z = this.field(point.z);\n\n      if (this.isIsogenous(point.curve)) {\n        // 4-isogeny maps for E(1,d)->M(2-4d,1):\n        //\n        //   u = y^2 / x^2\n        //   v = (2 - x^2 - y^2) * y / x^3\n        //\n        // Undefined for x = 0.\n        //\n        // Exceptional Cases:\n        //   - (0, 1) -> O\n        //   - (0, -1) -> (0, 0)\n        //\n        // Unexceptional Cases:\n        //   - (+-1, 0) -> (0, 0)\n        if (point.isInfinity()) return this.point();\n        if (point.x.isZero()) return this.point(this.zero, this.zero);\n        var c = z.redSqr().redIMuln(2);\n        var uu = y.redSqr();\n        var uz = x.redSqr();\n        var vv = c.redISub(uz).redISub(uu).redMul(y);\n        var vz = uz.redMul(x);\n        return this.cpoint(uu, uz, vv, vz);\n      }\n\n      if (this.isIsomorphic(point.curve, true)) {\n        // Isomorphic maps for E(d,a)->M(A,B):\n        //\n        //   u = (y + 1) / (y - 1)\n        //   v = +-sqrt((A - 2) / (B * a)) * u / x\n        //\n        // Undefined for x = 0 or y = 1.\n        //\n        // Exceptional Cases:\n        //   - (0, 1) -> O\n        //   - (0, -1) -> (0, 0)\n        //\n        // Unexceptional Cases:\n        //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))\n        if (point.isInfinity()) return this.point();\n        if (point.x.isZero()) return this.point(this.zero, this.zero);\n\n        var _c = this._scale(point.curve, true);\n\n        var _uu = y.redAdd(z);\n\n        var _uz = y.redSub(z);\n\n        var _vv = _c.redMul(z).redMul(_uu);\n\n        var _vz = x.redMul(_uz);\n\n        return this.cpoint(_uu, _uz, _vv, _vz);\n      }\n\n      if (this.isIsomorphic(point.curve, false)) {\n        // Isomorphic maps for E(a,d)->M(A,B):\n        //\n        //   u = (1 + y) / (1 - y)\n        //   v = +-sqrt((A + 2) / (B * a)) * u / x\n        //\n        // Undefined for x = 0 or y = 1.\n        //\n        // Exceptional Cases:\n        //   - (0, 1) -> O\n        //   - (0, -1) -> (0, 0)\n        //\n        // Unexceptional Cases:\n        //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))\n        if (point.isInfinity()) return this.point();\n        if (point.x.isZero()) return this.point(this.zero, this.zero);\n\n        var _c2 = this._scale(point.curve, false);\n\n        var _uu2 = z.redAdd(y);\n\n        var _uz2 = z.redSub(y);\n\n        var _vv2 = _c2.redMul(z).redMul(_uu2);\n\n        var _vz2 = x.redMul(_uz2);\n\n        return this.cpoint(_uu2, _uz2, _vv2, _vz2);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromUniform\",\n    value: function pointFromUniform(u) {\n      assert(u instanceof BN); // z = 0 or A = 0\n\n      if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.');\n      return this._elligator2(u);\n    }\n  }, {\n    key: \"pointToUniform\",\n    value: function pointToUniform(p, hint) {\n      assert(p instanceof MontPoint);\n      assert(hint >>> 0 === hint); // z = 0 or A = 0\n\n      if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.'); // P = O\n\n      if (p.isInfinity()) throw new Error('Invalid point.'); // Add a random torsion component.\n\n      var i = (hint >>> 4 & 15) % this.torsion.length;\n      var q = p.add(this.torsion[i]);\n      return this._invert2(q, hint);\n    }\n  }, {\n    key: \"decodePoint\",\n    value: function decodePoint(bytes, sign) {\n      return MontPoint.decode(this, bytes, sign);\n    }\n  }, {\n    key: \"encodeX\",\n    value: function encodeX(point) {\n      assert(point instanceof XPoint);\n      return point.encode();\n    }\n  }, {\n    key: \"decodeX\",\n    value: function decodeX(bytes) {\n      return XPoint.decode(this, bytes);\n    }\n  }, {\n    key: \"toShort\",\n    value: function toShort(a0, odd) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_short3 = this._short(a0, odd),\n          _this$_short4 = _slicedToArray(_this$_short3, 2),\n          a = _this$_short4[0],\n          b = _this$_short4[1];\n\n      var curve = new ShortCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        b: b,\n        n: this.n,\n        h: this.h\n      });\n\n      if (sign != null) {\n        var _curve$_scale5 = curve._scale(this),\n            _curve$_scale6 = _slicedToArray(_curve$_scale5, 2),\n            u3 = _curve$_scale6[1];\n\n        if (u3.redIsOdd() !== sign) u3.redINeg();\n      }\n\n      if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);\n\n      for (var i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"toMont\",\n    value: function toMont(b0) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var _this$_mont3 = this._mont(b0),\n          _this$_mont4 = _slicedToArray(_this$_mont3, 2),\n          a = _this$_mont4[0],\n          b = _this$_mont4[1];\n\n      var curve = new MontCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        b: b,\n        n: this.n,\n        h: this.h,\n        z: this.z\n      });\n\n      if (sign != null) {\n        var c = curve._scale(this);\n\n        if (c.redIsOdd() !== sign) c.redINeg();\n      }\n\n      if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);\n\n      for (var i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"toEdwards\",\n    value: function toEdwards(a0, invert) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_edwards3 = this._edwards(a0, invert),\n          _this$_edwards4 = _slicedToArray(_this$_edwards3, 2),\n          a = _this$_edwards4[0],\n          d = _this$_edwards4[1];\n\n      var curve = new EdwardsCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        d: d,\n        n: this.n,\n        h: this.h,\n        z: this.z\n      });\n\n      if (sign != null) {\n        var c = curve._scale(this, invert);\n\n        if (c.redIsOdd() !== sign) c.redINeg();\n      }\n\n      if (!this.g.isInfinity()) {\n        curve.g = curve.pointFromMont(this.g);\n        curve.g.normalize();\n      }\n\n      if (curve.isComplete()) {\n        for (var i = 0; i < this.h; i++) {\n          curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n          curve.torsion[i].normalize();\n        }\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"pointFromJSON\",\n    value: function pointFromJSON(json) {\n      return MontPoint.fromJSON(this, json);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      var json = _get(_getPrototypeOf(MontCurve.prototype), \"toJSON\", this).call(this, pre);\n\n      json.a = this.a.fromRed().toJSON();\n      json.b = this.b.fromRed().toJSON();\n      return json;\n    }\n  }], [{\n    key: \"_isomorphism\",\n    value: function _isomorphism(curveA, curveB, customB) {\n      // Montgomery Isomorphism.\n      //\n      // [MONT3] Page 3, Section 2.1.\n      //\n      // Transformation:\n      //\n      //   A' = A\n      //   B' = B'\n      //\n      // Where (B / B') is square.\n      assert(curveA instanceof BN);\n      assert(curveB instanceof BN);\n      assert(customB instanceof BN);\n      var a = curveA.clone();\n      var b = customB.clone();\n      var c = curveB.redDiv(customB);\n      if (c.redJacobi() !== 1) throw new Error('Invalid `b` coefficient.');\n      return [a, b];\n    }\n  }]);\n\n  return MontCurve;\n}(Curve);\n/**\n * MontPoint\n */\n\n\nvar MontPoint = /*#__PURE__*/function (_Point3) {\n  _inherits(MontPoint, _Point3);\n\n  var _super5 = _createSuper(MontPoint);\n\n  function MontPoint(curve, x, y, inf) {\n    var _this6;\n\n    _classCallCheck(this, MontPoint);\n\n    assert(curve instanceof MontCurve);\n    _this6 = _super5.call(this, curve, types.AFFINE);\n    _this6.x = _this6.curve.zero;\n    _this6.y = _this6.curve.zero;\n    _this6.inf = 1;\n    if (x != null) _this6._init(x, y, inf);\n    return _this6;\n  }\n\n  _createClass(MontPoint, [{\n    key: \"_init\",\n    value: function _init(x, y, inf) {\n      assert(x instanceof BN);\n      assert(y instanceof BN);\n      this.x = x;\n      this.y = y;\n      if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n      if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n      this.inf = inf | 0;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.curve.point(this.x.clone(), this.y.clone(), this.inf);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(point, flag) {\n      assert(point instanceof MontPoint);\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var inf1 = this.inf;\n      var inf2 = point.inf;\n      this.x.cswap(point.x, flag);\n      this.y.cswap(point.y, flag);\n      this.inf = inf1 & (cond ^ 1) | inf2 & cond;\n      point.inf = inf2 & (cond ^ 1) | inf1 & cond;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a) {\n      return this.clone();\n    }\n  }, {\n    key: \"randomize\",\n    value: function randomize(rng) {\n      return this.clone();\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      // P = O\n      if (this.inf) return this; // -(X1, Y1) = (X1, -Y1)\n\n      return this.curve.point(this.x, this.y.redNeg());\n    }\n  }, {\n    key: \"add\",\n    value: function add(p) {\n      // [MONT1] Page 8, Section 4.3.2.\n      //\n      // Addition Law:\n      //\n      //   l = (y2 - y1) / (x2 - x1)\n      //   x3 = b * l^2 - a - x1 - x2\n      //   y3 = l * (x1 - x3) - y1\n      //\n      // 1I + 2M + 1S + 7A + 1*b\n      assert(p instanceof MontPoint); // O + P = P\n\n      if (this.inf) return p; // P + O = P\n\n      if (p.inf) return this; // P + P, P + -P\n\n      if (this.x.eq(p.x)) {\n        // P + -P = O\n        if (!this.y.eq(p.y)) return this.curve.point(); // P + P = 2P\n\n        return this.dbl();\n      } // H = X2 - X1\n\n\n      var h = p.x.redSub(this.x); // R = Y2 - Y1\n\n      var r = p.y.redSub(this.y); // L = R / H\n\n      var l = r.redDiv(h); // K = b * L^2\n\n      var k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - X1 - X2\n\n      var nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n      var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      // [MONT1] Page 8, Section 4.3.2.\n      //\n      // Addition Law (doubling):\n      //\n      //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)\n      //   x3 = b * l^2 - a - 2 * x1\n      //   y3 = l * (x1 - x3) - y1\n      //\n      // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3\n      // P = O\n      if (this.inf) return this; // Y1 = 0\n\n      if (this.y.isZero()) return this.curve.point(); // M1 = 3 * X1^2\n\n      var m1 = this.x.redSqr().redIMuln(3); // M2 = 2 * a * X1\n\n      var m2 = this.curve.a.redMul(this.x).redIMuln(2); // M = M1 + M2 + 1\n\n      var m = m1.redIAdd(m2).redIAdd(this.curve.one); // Z = 2 * b * Y1\n\n      var z = this.curve.b.redMul(this.y).redIMuln(2); // L = M / Z\n\n      var l = m.redDiv(z); // K = b * L^2\n\n      var k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - 2 * X1\n\n      var nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x); // Y3 = L * (X1 - X3) - Y1\n\n      var ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n      return this.curve.point(nx, ny);\n    }\n  }, {\n    key: \"uadd\",\n    value: function uadd(p) {\n      // [MONT1] Page 8, Section 4.3.2.\n      // 1I + 3M + 2S + 9A + 1*a + 2*b + 2*2 + 1*3\n      assert(p instanceof MontPoint); // H = X2 - X1\n\n      var h = p.x.redSub(this.x); // R = Y2 - Y1\n\n      var r = p.y.redSub(this.y); // M1 = 3 * X1^2\n\n      var m1 = this.x.redSqr().redIMuln(3); // M2 = 2 * a * X1\n\n      var m2 = this.curve.a.redMul(this.x).redIMuln(2); // M = M1 + M2 + 1\n\n      var m = m1.redIAdd(m2).redIAdd(this.curve.one); // Z = 2 * b * Y1\n\n      var z = this.curve.b.redMul(this.y).redIMuln(2); // Check for doubling (X1 = X2, Y1 = Y2).\n\n      var double = h.czero() & r.czero(); // R = M (if double)\n\n      r.cinject(m, double); // H = Z (if double)\n\n      h.cinject(z, double); // Check for negation (X1 = X2, Y1 = -Y2).\n\n      var negated = h.czero() & ((this.inf | p.inf) ^ 1); // H = 1 (if H = 0)\n\n      h.cinject(this.curve.one, h.czero()); // L = R / H\n\n      var l = r.redMul(h.redFermat()); // K = b * L^2\n\n      var k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - X1 - X2\n\n      var nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n      var ny = l.redMul(this.x.redSub(nx)).redISub(this.y); // Check for infinity.\n\n      var inf = negated | this.inf & p.inf; // Case 1: O + P = P\n\n      nx.cinject(p.x, this.inf);\n      ny.cinject(p.y, this.inf); // Case 2: P + O = P\n\n      nx.cinject(this.x, p.inf);\n      ny.cinject(this.y, p.inf); // Case 3 & 4: P + -P = O, O + O = O\n\n      nx.cinject(this.curve.zero, inf);\n      ny.cinject(this.curve.zero, inf);\n      return this.curve.point(nx, ny, inf);\n    }\n  }, {\n    key: \"udbl\",\n    value: function udbl() {\n      return this.uadd(this);\n    }\n  }, {\n    key: \"recover\",\n    value: function recover(p1, p2) {\n      // Okeya-Sakurai Y-coordinate Recovery.\n      //\n      // [MONT3] Algorithm 5, Page 13, Section 4.3.\n      //         Algorithm 6, Page 14, Section 4.3.\n      //\n      // 1I + 12M + 1S + 6A + 1*a + 1*b + 2*2\n      assert(p1 instanceof XPoint);\n      assert(p2 instanceof XPoint); // P = O\n\n      if (this.inf) return this.curve.point(); // A = X0 * Z1\n\n      var a = this.x.redMul(p1.z); // B = X1 + A\n\n      var b = p1.x.redAdd(a); // C = (X1 - A)^2 * X2\n\n      var c = p1.x.redSub(a).redSqr().redMul(p2.x); // D = 2 * a * Z1\n\n      var d = this.curve.a.redMul(p1.z).redIMuln(2); // E = B + D\n\n      var e = b.redIAdd(d); // F = X0 * X1 + Z1\n\n      var f = this.x.redMul(p1.x).redIAdd(p1.z); // G = E * F\n\n      var g = e.redMul(f); // H = D * Z1\n\n      var h = d.redMul(p1.z); // I = (G - H) * Z2\n\n      var i = g.redISub(h).redMul(p2.z); // J = 2 * b * Y0\n\n      var j = this.curve.b.redMul(this.y).redIMuln(2); // K = J * Z1 * Z2\n\n      var k = j.redMul(p1.z).redMul(p2.z); // X = K * X1\n\n      var x = k.redMul(p1.x); // Y = I - C\n\n      var y = i.redISub(c); // Z = K * Z1\n\n      var z = k.redMul(p1.z); // Z = 0\n\n      if (z.isZero()) return this.curve.point(); // L = 1 / Z\n\n      var l = z.redInvert(); // X3 = X * L\n\n      var nx = x.redMul(l); // Y3 = Y * L\n\n      var ny = y.redMul(l);\n      return this.curve.point(nx, ny);\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      if (this.inf) throw new Error('Invalid point.');\n      return this.x.fromRed();\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      if (this.inf) throw new Error('Invalid point.');\n      return this.y.fromRed();\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(p) {\n      assert(p instanceof MontPoint); // P = Q\n\n      if (this === p) return true; // P = O\n\n      if (this.inf) return p.inf !== 0; // Q = O\n\n      if (p.inf) return false; // X1 = X2, Y1 = Y2\n\n      return this.x.eq(p.x) && this.y.eq(p.y);\n    }\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      // Infinity cannot be represented in\n      // the affine space, except by a flag.\n      return this.inf !== 0;\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      if (this.inf) return false;\n      return this.y.redIsOdd();\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      if (this.inf) return false;\n      return this.y.redIsEven();\n    }\n  }, {\n    key: \"toP\",\n    value: function toP() {\n      return this;\n    }\n  }, {\n    key: \"toJ\",\n    value: function toJ() {\n      return this;\n    }\n  }, {\n    key: \"toX\",\n    value: function toX() {\n      // (X3, Z3) = (1, 0)\n      if (this.inf) return this.curve.xpoint(); // (X3, Z3) = (X1, 1)\n\n      return this.curve.xpoint(this.x, this.curve.one);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      return this.toX().encode();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      if (this.inf) return [];\n      var x = this.getX().toJSON();\n      var y = this.getY().toJSON();\n      return [x, y];\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      if (this.inf) return '<MontPoint: Infinity>';\n      return '<MontPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(curve, bytes, sign) {\n      assert(curve instanceof MontCurve);\n      return curve.decodeX(bytes).toP(sign);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      assert(curve instanceof MontCurve);\n      assert(Array.isArray(json));\n      assert(json.length === 0 || json.length === 2 || json.length === 3);\n      if (json.length === 0) return curve.point();\n      var x = BN.fromJSON(json[0]);\n      var y = BN.fromJSON(json[1]);\n      return curve.point(x, y);\n    }\n  }]);\n\n  return MontPoint;\n}(Point);\n/**\n * XPoint\n */\n\n\nvar XPoint = /*#__PURE__*/function (_Point4) {\n  _inherits(XPoint, _Point4);\n\n  var _super6 = _createSuper(XPoint);\n\n  function XPoint(curve, x, z) {\n    var _this7;\n\n    _classCallCheck(this, XPoint);\n\n    assert(curve instanceof MontCurve);\n    _this7 = _super6.call(this, curve, types.PROJECTIVE);\n    _this7.x = _this7.curve.one;\n    _this7.z = _this7.curve.zero;\n    if (x != null) _this7._init(x, z);\n    return _this7;\n  }\n\n  _createClass(XPoint, [{\n    key: \"_init\",\n    value: function _init(x, z) {\n      assert(x instanceof BN);\n      assert(z == null || z instanceof BN);\n      this.x = x;\n      this.z = z || this.curve.one;\n      if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n      if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.curve.xpoint(this.x.clone(), this.z.clone());\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(point, flag) {\n      assert(point instanceof XPoint);\n      this.x.cswap(point.x, flag);\n      this.z.cswap(point.z, flag);\n      return this;\n    }\n  }, {\n    key: \"precompute\",\n    value: function precompute(power, rng) {\n      // No-op.\n      return this;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      if (this.isInfinity()) return true; // B * y^2 * z = x^3 + A * x^2 * z + x * z^2\n\n      var x = this.x,\n          z = this.z;\n      var x2 = x.redSqr();\n      var x3 = x2.redMul(x);\n      var z2 = z.redSqr();\n      var ax2 = this.curve.a.redMul(x2).redMul(z);\n      var by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));\n      var y2 = by2.redMul(this.curve.bi); // sqrt(y^2 * z^4) = y * z^2\n\n      return y2.redMul(z).redJacobi() !== -1;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale\n      // 1I + 1M\n      // P = O\n      if (this.isInfinity()) return this; // Z1 = 1\n\n      if (this.z.eq(this.curve.one)) return this; // X3 = X1 / Z1\n\n      this.x = this.x.redDiv(this.z); // Z3 = 1\n\n      this.z = this.curve.one;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a) {\n      assert(a instanceof BN); // P = O\n\n      if (this.isInfinity()) return this.curve.xpoint(); // X3 = X1 * A\n\n      var nx = this.x.redMul(a); // Y3 = Y1 * A\n\n      var nz = this.z.redMul(a);\n      return this.curve.xpoint(nx, nz);\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      // -(X1, Z1) = (X1, Z1)\n      return this;\n    }\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n      // 2M + 2S + 4A + 1*a24\n      // A = X1 + Z1\n      var a = this.x.redAdd(this.z); // AA = A^2\n\n      var aa = a.redSqr(); // B = X1 - Z1\n\n      var b = this.x.redSub(this.z); // BB = B^2\n\n      var bb = b.redSqr(); // C = AA - BB\n\n      var c = aa.redSub(bb); // X3 = AA * BB\n\n      var nx = aa.redMul(bb); // Z3 = C * (BB + a24 * C)\n\n      var nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));\n      return this.curve.xpoint(nx, nz);\n    }\n  }, {\n    key: \"diffAdd\",\n    value: function diffAdd(p, q) {\n      // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n      // 4M + 2S + 6A\n      assert(p instanceof XPoint);\n      assert(q instanceof XPoint); // A = X2 + Z2\n\n      var a = p.x.redAdd(p.z); // B = X2 - Z2\n\n      var b = p.x.redSub(p.z); // C = X3 + Z3\n\n      var c = q.x.redAdd(q.z); // D = X3 - Z3\n\n      var d = q.x.redSub(q.z); // DA = D * A\n\n      var da = d.redMul(a); // CB = C * B\n\n      var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2\n\n      var nx = this.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2\n\n      var nz = this.x.redMul(da.redISub(cb).redSqr());\n      return this.curve.xpoint(nx, nz);\n    }\n  }, {\n    key: \"diffAddDbl\",\n    value: function diffAddDbl(p, q) {\n      // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3\n      // Note that we swap P2 and P3 here (for consistency).\n      // 6M + 4S + 8A + 1*a24\n      assert(p instanceof XPoint);\n      assert(q instanceof XPoint); // A = X2 + Z2\n\n      var a = q.x.redAdd(q.z); // AA = A^2\n\n      var aa = a.redSqr(); // B = X2 - Z2\n\n      var b = q.x.redSub(q.z); // BB = B^2\n\n      var bb = b.redSqr(); // E = AA - BB\n\n      var e = aa.redSub(bb); // C = X3 + Z3\n\n      var c = p.x.redAdd(p.z); // D = X3 - Z3\n\n      var d = p.x.redSub(p.z); // DA = D * A\n\n      var da = d.redMul(a); // CB = C * B\n\n      var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2\n\n      var nx = this.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2\n\n      var nz = this.x.redMul(da.redISub(cb).redSqr()); // X4 = AA * BB\n\n      var dx = aa.redMul(bb); // Z4 = E * (BB + a24 * E)\n\n      var dz = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));\n      return [this.curve.xpoint(nx, nz), this.curve.xpoint(dx, dz)];\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      if (this.isInfinity()) throw new Error('Invalid point.');\n      this.normalize();\n      return this.x.fromRed();\n    }\n  }, {\n    key: \"getY\",\n    value: function getY(sign) {\n      return this.toP(sign).getY();\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(p) {\n      assert(p instanceof XPoint); // P = Q\n\n      if (this === p) return true; // P = O\n\n      if (this.isInfinity()) return p.isInfinity(); // Q = O\n\n      if (p.isInfinity()) return false; // Z1 = Z2\n\n      if (this.z.eq(p.z)) return this.x.eq(p.x); // X1 * Z2 == X2 * Z1\n\n      var x1 = this.x.redMul(p.z);\n      var x2 = p.x.redMul(this.z);\n      return x1.eq(x2);\n    }\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      // Z1 = 0\n      return this.z.isZero();\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      return false;\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      return false;\n    }\n  }, {\n    key: \"hasTorsion\",\n    value: function hasTorsion() {\n      if (this.isInfinity()) return false; // X1 = 0, Z1 != 0 (edge case)\n\n      if (this.x.isZero()) return true;\n      return _get(_getPrototypeOf(XPoint.prototype), \"hasTorsion\", this).call(this);\n    }\n  }, {\n    key: \"jmul\",\n    value: function jmul(k) {\n      return this.ladder(k)[1];\n    }\n  }, {\n    key: \"jmulSimple\",\n    value: function jmulSimple(k) {\n      return this.ladderSimple(k)[1];\n    }\n  }, {\n    key: \"jmulBlind\",\n    value: function jmulBlind(k, rng) {\n      return this.ladderBlind(k, rng)[1];\n    }\n  }, {\n    key: \"jmulConst\",\n    value: function jmulConst(k, rng) {\n      return this.ladderConst(k, rng)[1];\n    }\n  }, {\n    key: \"jmulAdd\",\n    value: function jmulAdd(k1, p2, k2) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"jmulAddSimple\",\n    value: function jmulAddSimple(k1, p2, k2) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"ladder\",\n    value: function ladder(k) {\n      // Multiply with the Montgomery Ladder.\n      //\n      // [MONT3] Algorithm 4, Page 12, Section 4.2.\n      //\n      // Note that any clamping is meant to\n      // be done _outside_ of this function.\n      assert(k instanceof BN);\n      assert(!k.red);\n      var bits = k.bitLength();\n      var a = this;\n      var b = this.curve.xpoint();\n\n      for (var i = bits - 1; i >= 0; i--) {\n        var bit = k.bit(i);\n\n        if (bit === 0) {\n          var _this$diffAddDbl = this.diffAddDbl(a, b);\n\n          var _this$diffAddDbl2 = _slicedToArray(_this$diffAddDbl, 2);\n\n          a = _this$diffAddDbl2[0];\n          b = _this$diffAddDbl2[1];\n        } else {\n          var _this$diffAddDbl3 = this.diffAddDbl(b, a);\n\n          var _this$diffAddDbl4 = _slicedToArray(_this$diffAddDbl3, 2);\n\n          b = _this$diffAddDbl4[0];\n          a = _this$diffAddDbl4[1];\n        }\n      }\n\n      return [a, b];\n    }\n  }, {\n    key: \"ladderSimple\",\n    value: function ladderSimple(k) {\n      // Montgomery Ladder with explicit\n      // additions and doubling (testing).\n      assert(k instanceof BN);\n      assert(!k.red);\n      var bits = k.bitLength();\n      var a = this;\n      var b = this.curve.xpoint(); // Climb the ladder.\n\n      for (var i = bits - 1; i >= 0; i--) {\n        var bit = k.bit(i);\n\n        if (bit === 0) {\n          a = this.diffAdd(a, b);\n          b = b.dbl();\n        } else {\n          b = this.diffAdd(b, a);\n          a = a.dbl();\n        }\n      }\n\n      return [a, b];\n    }\n  }, {\n    key: \"ladderBlind\",\n    value: function ladderBlind(k, rng) {\n      if (!rng) return this.ladder(k); // Randomize if available.\n\n      return this.randomize(rng).ladder(k);\n    }\n  }, {\n    key: \"ladderConst\",\n    value: function ladderConst(k, rng) {\n      // Multiply with the Montgomery Ladder.\n      //\n      // [MONT3] Algorithm 7, Page 16, Section 5.3.\n      //         Algorithm 8, Page 16, Section 5.3.\n      //\n      // [RFC7748] Page 7, Section 5.\n      //\n      // Note that any clamping is meant to\n      // be done _outside_ of this function.\n      assert(k instanceof BN);\n      assert(!k.red);\n      var bits = Math.max(k.bitLength(), this.curve.fieldBits);\n      var bytes = bits + 7 >>> 3; // Recode scalar to base256.\n\n      var exp = k.toArray('le', bytes); // Randomize if available.\n\n      var point = rng ? this.randomize(rng) : this; // Clone points (for safe swapping).\n\n      var a = point.clone();\n      var b = this.curve.xpoint().clone();\n      var swap = 0; // Climb the ladder.\n\n      for (var i = bits - 1; i >= 0; i--) {\n        var bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.\n\n        a.swap(b, swap ^ bit); // Single coordinate add+double.\n\n        var _point$diffAddDbl = point.diffAddDbl(a, b);\n\n        var _point$diffAddDbl2 = _slicedToArray(_point$diffAddDbl, 2);\n\n        a = _point$diffAddDbl2[0];\n        b = _point$diffAddDbl2[1];\n        swap = bit;\n      } // Finalize loop.\n\n\n      a.swap(b, swap);\n      return [a, b];\n    }\n  }, {\n    key: \"toP\",\n    value: function toP() {\n      var sign = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      assert(sign == null || typeof sign === 'boolean');\n      if (this.isInfinity()) return this.curve.point();\n      this.normalize();\n      return this.curve.pointFromX(this.x, sign);\n    }\n  }, {\n    key: \"toJ\",\n    value: function toJ() {\n      return this;\n    }\n  }, {\n    key: \"toX\",\n    value: function toX() {\n      return this;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      // [RFC7748] Section 5.\n      return this.curve.encodeField(this.getX());\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      return this.toP().toJSON(pre);\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      if (this.isInfinity()) return '<XPoint: Infinity>';\n      return '<XPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(curve, bytes) {\n      assert(curve instanceof MontCurve); // [RFC7748] Section 5.\n\n      var x = curve.decodeField(bytes); // We're supposed to ignore the hi bit\n      // on montgomery points... I think. If\n      // we don't, the X25519 test vectors\n      // break, which is pretty convincing\n      // evidence. This is a no-op for X448.\n\n      x.iumaskn(curve.fieldBits); // Note: montgomery points are meant to be\n      // reduced by the prime and do not have to\n      // be explicitly validated in order to do\n      // the montgomery ladder.\n\n      var p = curve.xpoint(x, curve.one);\n      assert(!p.isInfinity());\n      return p;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      return MontPoint.fromJSON(curve, json).toX();\n    }\n  }]);\n\n  return XPoint;\n}(Point);\n/**\n * EdwardsCurve\n */\n\n\nvar EdwardsCurve = /*#__PURE__*/function (_Curve3) {\n  _inherits(EdwardsCurve, _Curve3);\n\n  var _super7 = _createSuper(EdwardsCurve);\n\n  function EdwardsCurve(conf) {\n    var _this8;\n\n    _classCallCheck(this, EdwardsCurve);\n\n    _this8 = _super7.call(this, EdwardsPoint, 'edwards', conf);\n    _this8.a = BN.fromJSON(conf.a).toRed(_this8.red);\n    _this8.d = BN.fromJSON(conf.d).toRed(_this8.red);\n    _this8.s = BN.fromJSON(conf.s || '0').toRed(_this8.red);\n    _this8.si = _this8.s.isZero() ? _this8.zero : _this8.s.redInvert();\n    _this8.k = _this8.d.redMuln(2);\n    _this8.smi = -_this8.d.redNeg().word(0);\n    _this8.ad6 = _this8.a.redAdd(_this8.d).redMul(_this8.i6);\n    _this8.twisted = !_this8.a.eq(_this8.one);\n    _this8.oneA = _this8.a.eq(_this8.one);\n    _this8.mOneA = _this8.a.eq(_this8.one.redNeg());\n    _this8.smallD = _this8.prime != null && _this8.d.redNeg().length === 1;\n    _this8.alt = null;\n\n    _this8._finalize(conf);\n\n    return _this8;\n  }\n\n  _createClass(EdwardsCurve, [{\n    key: \"_short\",\n    value: function _short(a0, odd) {\n      // Twisted Edwards->Short Weierstrass Equivalence.\n      //\n      // [TWISTEQ] Section 2.\n      //\n      // Transformation:\n      //\n      //   a' = -(a^2 + 14 * a * d + d^2) / 48\n      //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864\n      var a = this.a,\n          d = this.d;\n      var a2 = a.redSqr();\n      var a3 = a2.redMul(a);\n      var d2 = d.redSqr();\n      var d3 = d2.redMul(d);\n      var ad14 = a.redMul(d).redIMuln(14);\n      var a2d = a2.redMul(d);\n      var ad2 = a.redMul(d2);\n      var t0 = a2d.redIAdd(ad2).redIMuln(33);\n      var wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);\n      var wb = t0.redISub(a3).redISub(d3).redDivn(864);\n      if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);\n      return [wa, wb];\n    }\n  }, {\n    key: \"_mont\",\n    value: function _mont(b0) {\n      var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Twisted Edwards->Montgomery Transformation.\n      //\n      // [TWISTED] Theorem 3.2, Page 4, Section 3.\n      //\n      // Equivalence:\n      //\n      //   A = 2 * (a + d) / (a - d)\n      //   B = 4 / (a - d)\n      //\n      // Isomorphism:\n      //\n      //   A = 2 * (a + d) / (a - d)\n      //   B = B'\n      //\n      // Where ((4 / (a - d)) / B') is square.\n      //\n      // If `4 / (a - d)` is non-square, we can\n      // usually force B=1 by using the `invert`\n      // option. This will create an isomorphism\n      // chain of: E(a,d)->E(d,a)->M(-A,-B).\n      //\n      // The equivalence between E(a,d) and E(d,a)\n      // is:\n      //\n      //   (x, y) = (x, 1 / y)\n      //\n      // Meaning our map to M(-A,-B) is:\n      //\n      //   u = (1 + 1 / y) / (1 - 1 / y)\n      //     = (y + 1) / (y - 1)\n      //   v = u / x\n      assert(typeof invert === 'boolean');\n      var apd, amd;\n\n      if (invert) {\n        apd = this.d.redAdd(this.a);\n        amd = this.d.redSub(this.a);\n      } else {\n        apd = this.a.redAdd(this.d);\n        amd = this.a.redSub(this.d);\n      }\n\n      var z = amd.redInvert();\n      var a = apd.redMuln(2).redMul(z);\n      var b = z.redMuln(4);\n      if (b0 != null) return MontCurve._isomorphism(a, b, b0);\n      return [a, b];\n    }\n  }, {\n    key: \"_edwards\",\n    value: function _edwards(a0) {\n      return EdwardsCurve._isomorphism(this.a, this.d, a0);\n    }\n  }, {\n    key: \"_scaleShort\",\n    value: function _scaleShort(curve) {\n      assert(curve instanceof ShortCurve);\n\n      var _curve$_scale7 = curve._scale(this),\n          _curve$_scale8 = _slicedToArray(_curve$_scale7, 2),\n          u2 = _curve$_scale8[0],\n          u3 = _curve$_scale8[1];\n\n      return [this.field(u2.redInvert()), this.field(u3.redInvert())];\n    }\n  }, {\n    key: \"_scaleMont\",\n    value: function _scaleMont(curve) {\n      var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Calculate isomorphism factor between\n      // Twisted Edwards and Montgomery with:\n      //\n      //   a = (A + 2) / B\n      //   c = +-sqrt(a / a')\n      //\n      // Which can be reduced to:\n      //\n      //   c = +-sqrt((A + 2) / (B * a'))\n      //\n      // If base points are available, we can do:\n      //\n      //   x = u / v\n      //   c = x' / x\n      //\n      // Which can be reduced to:\n      //\n      //   c = v * x' / u\n      //\n      // We can now calculate the Edwards `x` with:\n      //\n      //   x' = c * u / v\n      //\n      // And likewise, the Montgomery `v`:\n      //\n      //   v = c * u / x'\n      assert(curve instanceof MontCurve);\n      assert(typeof invert === 'boolean');\n\n      if (this.g.isInfinity() || curve.g.isInfinity()) {\n        var _curve$_edwards = curve._edwards(null, invert),\n            _curve$_edwards2 = _slicedToArray(_curve$_edwards, 1),\n            a = _curve$_edwards2[0];\n\n        return this.field(a).redDivSqrt(this.a);\n      }\n\n      var x = curve.g.x.redDiv(curve.g.y);\n      return this.g.x.redDiv(this.field(x));\n    }\n  }, {\n    key: \"_scaleEdwards\",\n    value: function _scaleEdwards(curve) {\n      // We can extract the isomorphism factor with:\n      //\n      //   c = +-sqrt(a / a')\n      //\n      // If base points are available, we can do:\n      //\n      //   c = x' / x\n      assert(curve instanceof EdwardsCurve);\n      if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.a).redDivSqrt(this.a);\n      return this.g.x.redDiv(this.field(curve.g.x));\n    }\n  }, {\n    key: \"_mulA\",\n    value: function _mulA(num) {\n      assert(num instanceof BN); // n * a = n\n\n      if (this.oneA) return num.clone(); // n * a = -n\n\n      if (this.mOneA) return num.redNeg();\n      return this.a.redMul(num);\n    }\n  }, {\n    key: \"_mulD\",\n    value: function _mulD(num) {\n      assert(num instanceof BN); // -d < 0x4000000\n\n      if (this.smallD) return num.redMuln(this.smi);\n      return this.d.redMul(num);\n    }\n  }, {\n    key: \"_elligator1\",\n    value: function _elligator1(t) {\n      // Elligator 1.\n      //\n      // Distribution: 1/2.\n      //\n      // [ELL1] Page 6, Section 3.\n      //        Page 15, Appendix A.\n      // [ELL2] Page 7, Section 3.2.\n      //\n      // Assumptions:\n      //\n      //   - Let p be a prime power congruent to 3 mod 4.\n      //   - Let s be a nonzero element of F(p).\n      //   - Let c = 2 / s^2.\n      //   - Let r = c + 1 / c.\n      //   - Let d = -(c + 1)^2 / (c - 1)^2.\n      //   - (s^2 - 2) * (s^2 + 2) != 0.\n      //   - c * (c - 1) * (c + 1) != 0.\n      //   - r != 0.\n      //   - d is not square.\n      //   - x^2 + y^2 = 1 + d * x^2 * y^2.\n      //   - u * v * X * Y * x * (Y + 1) != 0.\n      //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.\n      //\n      // Elligator 1, as devised by Fouque et al,\n      // takes place on the hyperelliptic curve of:\n      //\n      //   y^2 = x^5 + (r^2 - 2) * x^3 + x\n      //\n      // Not only must our Edwards curve be complete,\n      // with a prime congruent to 3 mod 4, and a = 1,\n      // our curve must be isomorphic to a hyperelliptic\n      // curve of the above form. Roughly one half of\n      // all Edwards curves are isomorphic to a curve\n      // of said form.\n      //\n      // We can derive the isomorphism with:\n      //\n      //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)\n      //   s = +-sqrt(2 / c)\n      //   r = c + 1 / c\n      //\n      // Note that even if your curve is an Elligator 1\n      // curve, Elligator 2 is probably still preferable,\n      // as it has nearly the same properties (i.e. the\n      // same distribution), and is much less complex.\n      //\n      // Map:\n      //\n      //   f(a) = a^((p - 1) / 2)\n      //   u = (1 - t) / (1 + t)\n      //   v = u^5 + (r^2 - 2) * u^3 + u\n      //   X = f(v) * u\n      //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)\n      //   Y = 1, if u = 0\n      //   x = (c - 1) * s * X * (1 + X) / Y\n      //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)\n      //\n      // When t = +-1, we create the hyperelliptic\n      // 2-torsion point of (0, 0). This needs to be\n      // mapped to (0, -1) in Edwards form, but the x\n      // denominator becomes zero. As far as I can\n      // tell, this is the only exceptional case.\n      //\n      // The only other exceptional case initially\n      // appears to be when the y denominator sums to\n      // zero (when t = sqrt(4 / r + 1)), however, the\n      // hyperelliptic `X` is negated by the sign of\n      // `v`, making this impossible.\n      var s = this.s,\n          si = this.si,\n          i2 = this.i2,\n          one = this.one,\n          two = this.two;\n      var c = si.redSqr().redIMuln(2);\n      var ci = s.redSqr().redMul(i2);\n      var ci2 = ci.redSqr();\n      var r = c.redAdd(ci);\n      var r2 = r.redSqr().redISub(two);\n      var cm1 = c.redSub(one);\n      var e0 = this.p.subn(2);\n      var e1 = this.p.subn(1).iushrn(1);\n      var e2 = this.p.addn(1).iushrn(2);\n      var uu = one.redSub(t);\n      var uz = one.redAdd(t);\n      var u = uu.redMul(uz.redPow(e0));\n      var u2 = u.redSqr();\n      var u3 = u2.redMul(u);\n      var u5 = u3.redMul(u2);\n      var v = u5.redAdd(r2.redMul(u3)).redIAdd(u);\n      var f0 = v.redPow(e1);\n      var f1 = u2.redAdd(ci2).redPow(e1);\n      var f2 = f0.redMul(f1);\n      var X = f0.redMul(u);\n      var Y = f0.redMul(v).redPow(e2).redMul(f2);\n      var X1 = one.redAdd(X);\n      var rX = r.redMul(X);\n      var X12 = X1.redSqr();\n      var xx = cm1.redMul(s).redMul(X).redMul(X1);\n      var xz = Y.cinject(this.one, u.czero());\n      var yy = rX.redSub(X12);\n      var yz = rX.redAdd(X12);\n      return this.cpoint(xx, xz, yy, yz);\n    }\n  }, {\n    key: \"_invert1\",\n    value: function _invert1(p, hint) {\n      // Inverting the Map (Elligator 1).\n      //\n      // [ELL1] Page 6, Section 3.\n      //        Page 15, Appendix A.\n      // [ELL2] Page 7, Section 3.3.\n      //\n      // Assumptions:\n      //\n      //   - y + 1 != 0.\n      //   - (1 + n * r)^2 - 1 is square in F(p).\n      //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.\n      //   - Y = (c - 1) * s * X * (1 + X) / x.\n      //\n      // Map:\n      //\n      //   f(a) = a^((p - 1) / 2)\n      //   n = (y - 1) / (2 * (y + 1))\n      //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)\n      //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))\n      //   u = z * X\n      //   t = (1 - u) / (1 + u)\n      var s = this.s,\n          si = this.si,\n          i2 = this.i2,\n          one = this.one;\n      var x = p.x,\n          y = p.y,\n          z = p.z;\n      var sign = hint & 1;\n      var c = si.redSqr().redIMuln(2);\n      var ci = s.redSqr().redMul(i2);\n      var ci2 = ci.redSqr();\n      var r = c.redAdd(ci);\n      var cm1 = c.redSub(one);\n      var e0 = this.p.subn(2);\n      var e1 = this.p.subn(1).iushrn(1);\n      var e2 = this.p.addn(1).iushrn(2);\n      var nn = y.redSub(z);\n      var nz = y.redAdd(z).redIMuln(2);\n      var n = nn.redMul(nz.redPow(e0));\n      var nr1 = one.redAdd(n.redMul(r));\n      var w2 = nr1.redSqr().redISub(one);\n      var w = w2.redPow(e2);\n      var sqr = w.redSqr().ceq(w2);\n      var X = w.redSub(nr1);\n      var X1 = one.redAdd(X);\n      var YY = cm1.redMul(s).redMul(X).redMul(X1);\n      var Y = YY.redMul(x.redMul(z));\n      var X2 = X.redSqr().redIAdd(ci2);\n      var Z = Y.redMul(X2).redPow(e1);\n      var u = Z.redMul(X);\n      var tt = one.redSub(u);\n      var tz = one.redAdd(u);\n      var t = tt.redMul(tz.redPow(e0));\n      t.cinject(t.redNeg(), t.redIsOdd() ^ sign);\n      if (!sqr) throw new Error('Invalid point.');\n      return t;\n    }\n  }, {\n    key: \"_alt\",\n    value: function _alt() {\n      if (!this.alt) this.alt = this.toMont();\n      return this.alt;\n    }\n  }, {\n    key: \"isElliptic\",\n    value: function isElliptic() {\n      var ad = this.a.redMul(this.d);\n      var amd = this.a.redSub(this.d); // a * d * (a - d) != 0\n\n      return !ad.redMul(amd).isZero();\n    }\n  }, {\n    key: \"jinv\",\n    value: function jinv() {\n      // [TWISTED] Definition 2.1, Page 3, Section 2.\n      var a = this.a,\n          d = this.d;\n      var ad = a.redMul(d);\n      var amd4 = a.redSub(d).redPown(4);\n      var a2 = a.redSqr();\n      var d2 = d.redSqr();\n      var t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);\n      var lhs = t0.redPown(3).redIMuln(16);\n      var rhs = ad.redMul(amd4);\n      if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)\n\n      return lhs.redDiv(rhs).fromRed();\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;\n    }\n  }, {\n    key: \"point\",\n    value: function point(x, y, z, t) {\n      return new EdwardsPoint(this, x, y, z, t);\n    }\n  }, {\n    key: \"jpoint\",\n    value: function jpoint(x, y, z) {\n      assert(x == null && y == null && z == null);\n      return this.point();\n    }\n  }, {\n    key: \"cpoint\",\n    value: function cpoint(xx, xz, yy, yz) {\n      assert(xx instanceof BN);\n      assert(xz instanceof BN);\n      assert(yy instanceof BN);\n      assert(yz instanceof BN);\n      var x = xx.redMul(yz);\n      var y = yy.redMul(xz);\n      var z = xz.redMul(yz);\n      var t = xx.redMul(yy);\n      return this.point(x, y, z, t);\n    }\n  }, {\n    key: \"solveX2\",\n    value: function solveX2(y) {\n      // [RFC8032] Section 5.1.3 & 5.2.3.\n      assert(y instanceof BN); // x^2 = (y^2 - 1) / (d * y^2 - a)\n\n      var y2 = y.redSqr();\n\n      var rhs = this._mulD(y2).redISub(this.a);\n\n      var lhs = y2.redISub(this.one);\n      var x2 = lhs.redDiv(rhs);\n      return x2;\n    }\n  }, {\n    key: \"solveX\",\n    value: function solveX(y) {\n      // Optimize with inverse square root trick.\n      //\n      // Note that `0 / 0` can only occur if\n      // `a == d` (i.e. the curve is singular).\n      var y2 = y.redSqr();\n\n      var rhs = this._mulD(y2).redISub(this.a);\n\n      var lhs = y2.redISub(this.one);\n      return lhs.redDivSqrt(rhs);\n    }\n  }, {\n    key: \"solveY2\",\n    value: function solveY2(x) {\n      assert(x instanceof BN); // y^2 = (a * x^2 - 1) / (d * x^2 - 1)\n\n      var x2 = x.redSqr();\n\n      var lhs = this._mulA(x2).redISub(this.one);\n\n      var rhs = this._mulD(x2).redISub(this.one);\n\n      var y2 = lhs.redDiv(rhs);\n      return y2;\n    }\n  }, {\n    key: \"solveY\",\n    value: function solveY(x) {\n      // Optimize with inverse square root trick.\n      //\n      // Note that `0 / 0` can only occur if\n      // `a == d` (i.e. the curve is singular).\n      var x2 = x.redSqr();\n\n      var lhs = this._mulA(x2).redISub(this.one);\n\n      var rhs = this._mulD(x2).redISub(this.one);\n\n      return lhs.redDivSqrt(rhs);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(point) {\n      // [TWISTED] Definition 2.1, Page 3, Section 2.\n      //           Page 11, Section 6.\n      assert(point instanceof EdwardsPoint); // Z1 = 1\n\n      if (point.zOne) {\n        // a * x^2 + y^2 = 1 + d * x^2 * y^2\n        var _x5 = point.x.redSqr();\n\n        var _y2 = point.y.redSqr();\n\n        var _dxy = this._mulD(_x5).redMul(_y2);\n\n        var _lhs = this._mulA(_x5).redIAdd(_y2);\n\n        var _rhs = this.one.redAdd(_dxy);\n\n        var _tz = point.t;\n\n        var _xy = point.x.redMul(point.y);\n\n        return _lhs.eq(_rhs) && _tz.eq(_xy);\n      } // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2\n\n\n      var x2 = point.x.redSqr();\n      var y2 = point.y.redSqr();\n      var z2 = point.z.redSqr();\n      var z4 = z2.redSqr();\n\n      var dxy = this._mulD(x2).redMul(y2);\n\n      var lhs = this._mulA(x2).redIAdd(y2).redMul(z2);\n\n      var rhs = z4.redIAdd(dxy);\n      var tz = point.t.redMul(point.z);\n      var xy = point.x.redMul(point.y);\n      return lhs.eq(rhs) && tz.eq(xy);\n    }\n  }, {\n    key: \"pointFromX\",\n    value: function pointFromX(x) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      assert(x instanceof BN);\n      assert(sign == null || typeof sign === 'boolean');\n      if (!x.red) x = x.toRed(this.red);\n      var y = this.solveY(x);\n\n      if (sign != null) {\n        if (y.isZero() && sign) throw new Error('Invalid point.');\n        if (y.redIsOdd() !== sign) y.redINeg();\n      }\n\n      return this.point(x, y);\n    }\n  }, {\n    key: \"pointFromY\",\n    value: function pointFromY(y) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      assert(y instanceof BN);\n      assert(sign == null || typeof sign === 'boolean');\n      if (!y.red) y = y.toRed(this.red);\n      var x = this.solveX(y);\n\n      if (sign != null) {\n        if (x.isZero() && sign) throw new Error('Invalid point.');\n        if (x.redIsOdd() !== sign) x.redINeg();\n      }\n\n      return this.point(x, y);\n    }\n  }, {\n    key: \"isIsomorphic\",\n    value: function isIsomorphic(curve) {\n      var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // [TWISTED] Theorem 3.2, Page 4, Section 3.\n      //           Definition 2.1, Page 3, Section 2.\n      assert(curve instanceof Curve);\n      assert(typeof invert === 'boolean');\n      if (!curve.p.eq(this.p)) return false; // E(a,d) <-> E(a,b)\n\n      if (curve.type === 'short') return curve.isIsomorphic(this); // E(a,d) <-> M(A,B)\n      // E(a,d) <-> M(-A,-B)\n\n      if (curve.type === 'mont') {\n        // A * (a - d) = 2 * (a + d)\n        var a = this.field(curve.a);\n        var apd, amd;\n\n        if (invert) {\n          apd = this.d.redAdd(this.a);\n          amd = this.d.redSub(this.a);\n        } else {\n          apd = this.a.redAdd(this.d);\n          amd = this.a.redSub(this.d);\n        }\n\n        return a.redMul(amd).eq(apd.redIMuln(2));\n      } // E(a,d) <-> E(a',a'd/a)\n\n\n      if (curve.type === 'edwards') {\n        // a' * d = a * d'\n        var _a = this.field(curve.a);\n\n        var d = this.field(curve.d);\n        return this.a.redMul(d).eq(_a.redMul(this.d));\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isIsogenous\",\n    value: function isIsogenous(curve) {\n      // Check for the 4-isogenies described by Hamburg:\n      // https://moderncrypto.org/mail-archive/curves/2016/000806.html\n      assert(curve instanceof Curve);\n      if (!curve.p.eq(this.p)) return false; // E(1,d) <-> M(2-4d,1)\n\n      if (curve.type === 'mont') {\n        if (!this.a.eq(this.one)) return false;\n        var a = this.field(curve.a);\n        var b = this.field(curve.b);\n        var d24 = this.two.redSub(this.d.redMuln(4));\n        return a.eq(d24) && b.eq(this.one);\n      } // E(a,d) <-> E(-a,d-a)\n\n\n      if (curve.type === 'edwards') {\n        var _a2 = this.field(curve.a);\n\n        var d = this.field(curve.d);\n        return _a2.eq(this.a.redNeg()) && d.eq(this.d.redSub(this.a));\n      }\n\n      return false;\n    }\n  }, {\n    key: \"pointFromShort\",\n    value: function pointFromShort(point) {\n      // [TWISTEQ] Section 1.\n      assert(point instanceof ShortPoint);\n\n      if (this.isIsomorphic(point.curve)) {\n        // Equivalence for E(a,b)->E(a',d'):\n        //\n        //   x' = (6 * x - a' - d') / (6 * y)\n        //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')\n        //\n        // Undefined for x = (5 * d' - a') / 12 or y = 0.\n        //\n        // Exceptional Cases:\n        //   - O -> (0, 1)\n        //   - ((a' + d') / 6, 0) -> (0, -1)\n        //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)\n        //\n        // Unexceptional Cases:\n        //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)\n        if (point.isInfinity()) return this.point();\n        if (point.y.isZero()) return this.point(this.zero, this.one.redNeg());\n        var a = this.a,\n            d = this.d;\n\n        var _this$_scale15 = this._scale(point.curve),\n            _this$_scale16 = _slicedToArray(_this$_scale15, 2),\n            u2 = _this$_scale16[0],\n            u3 = _this$_scale16[1];\n\n        var a5 = a.redMuln(5);\n        var d5 = d.redMuln(5);\n        var x = this.field(point.x).redMul(u2);\n        var y = this.field(point.y).redMul(u3);\n        var x6 = x.redMuln(6);\n        var x12 = x.redMuln(12);\n        var xx = x6.redSub(a).redISub(d);\n        var xz = y.redMuln(6);\n        var yy = x12.redSub(a5).redIAdd(d);\n        var yz = x12.redAdd(a).redISub(d5);\n        return this.cpoint(xx, xz, yy, yz);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromMont\",\n    value: function pointFromMont(point) {\n      // [RFC7748] Section 4.1 & 4.2.\n      // [MONT3] Page 6, Section 2.5.\n      // [TWISTED] Theorem 3.2, Page 4, Section 3.\n      assert(point instanceof MontPoint);\n      assert(point.curve.p.eq(this.p)); // Montgomery `u`, `v`.\n\n      var u = this.field(point.x);\n      var v = this.field(point.y);\n\n      if (this.isIsogenous(point.curve)) {\n        // 4-isogeny maps for M(2-4d,1)->E(1,d):\n        //\n        //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)\n        //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /\n        //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)\n        //\n        // Undefined for u = 0 and v = 0.\n        //\n        // Exceptional Cases:\n        //   - O -> (0, 1)\n        //   - (0, 0) -> (0, 1)\n        //\n        // Unexceptional Cases:\n        //   - (-1, +-sqrt(A - 2)) -> (0, 1)\n        //   - (1, +-sqrt(A + 2)) -> (0, -1)\n        //\n        // The point (1, v) is invalid on Curve448.\n        if (point.isInfinity()) return this.point();\n        if (point.x.isZero()) return this.point();\n        var u2 = u.redSqr();\n        var u3 = u2.redMul(u);\n        var u4 = u3.redMul(u);\n        var u5 = u4.redMul(u);\n        var v2 = v.redSqr();\n        var a = v.redMuln(4);\n        var b = u2.redSub(this.one);\n        var c = u2.redMuln(2);\n        var d = v2.redMuln(4);\n        var e = u3.redIMuln(2);\n        var f = u.redMul(v2).redIMuln(4);\n        var g = u2.redMul(v2).redIMuln(2);\n        var h = v2.redIMuln(2);\n        var xx = a.redMul(b);\n        var xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);\n        var yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();\n        var yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);\n        return this.cpoint(xx, xz, yy, yz).divn(4);\n      }\n\n      if (this.isIsomorphic(point.curve, true)) {\n        // Isomorphic maps for M(-A,-B)->E(a,d):\n        //\n        //   x = +-sqrt((A - 2) / (B * a)) * u / v\n        //   y = (u + 1) / (u - 1)\n        //\n        // Undefined for u = 1 or v = 0.\n        //\n        // Exceptional Cases:\n        //   - O -> (0, 1)\n        //   - (0, 0) -> (0, -1)\n        //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)\n        //\n        // Unexceptional Cases:\n        //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)\n        //\n        // The point (1, v) is invalid on Curve448.\n        if (point.isInfinity()) return this.point();\n        if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());\n\n        var _c3 = this._scale(point.curve, true);\n\n        var _xx = _c3.redMul(u);\n\n        var _xz = v;\n\n        var _yy = u.redAdd(this.one);\n\n        var _yz = u.redSub(this.one);\n\n        return this.cpoint(_xx, _xz, _yy, _yz);\n      }\n\n      if (this.isIsomorphic(point.curve, false)) {\n        // Isomorphic maps for M(A,B)->E(a,d):\n        //\n        //   x = +-sqrt((A + 2) / (B * a)) * u / v\n        //   y = (u - 1) / (u + 1)\n        //\n        // Undefined for u = -1 or v = 0.\n        //\n        // Exceptional Cases:\n        //   - O -> (0, 1)\n        //   - (0, 0) -> (0, -1)\n        //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)\n        //\n        // Unexceptional Cases:\n        //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)\n        //\n        // The point (-1, v) is invalid on Curve25519.\n        if (point.isInfinity()) return this.point();\n        if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());\n\n        var _c4 = this._scale(point.curve, false);\n\n        var _xx2 = _c4.redMul(u);\n\n        var _xz2 = v;\n\n        var _yy2 = u.redSub(this.one);\n\n        var _yz2 = u.redAdd(this.one);\n\n        return this.cpoint(_xx2, _xz2, _yy2, _yz2);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromEdwards\",\n    value: function pointFromEdwards(point) {\n      // [TWISTED] Definition 2.1, Page 3, Section 2.\n      // [ISOGENY] Page 2, Section 2.\n      assert(point instanceof EdwardsPoint);\n      assert(point.curve.p.eq(this.p)); // Edwards `x`, `y`, `z`, `t`.\n\n      var a = this.field(point.curve.a);\n      var x = this.field(point.x);\n      var y = this.field(point.y);\n      var z = this.field(point.z);\n      var t = this.field(point.t);\n\n      if (this.isIsogenous(point.curve)) {\n        // 4-isogeny maps for E(a,d)<->E(-a,d-a):\n        //\n        //   x' = (2 * x * y) / (y^2 - a * x^2)\n        //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)\n        //\n        // Undefined for y^2 - a * x^2 = 0\n        //            or y^2 + a * x^2 = 2.\n        var xy = x.redMul(y);\n        var x2 = x.redSqr();\n        var y2 = y.redSqr();\n        var z2 = z.redSqr();\n        var ax2 = a.redMul(x2);\n        var xx = xy.redIMuln(2);\n        var xz = y2.redSub(ax2);\n        var yy = y2.redAdd(ax2);\n        var yz = z2.redIMuln(2).redISub(yy);\n        var p = this.cpoint(xx, xz, yy, yz);\n        return !this.twisted ? p.divn(4) : p;\n      }\n\n      if (this.isIsomorphic(point.curve)) {\n        // Isomorphic maps for E(a,d)<->E(a',a'd/a):\n        //\n        //   x' = +-sqrt(a / a') * x\n        //   y' = y\n        //\n        // Undefined when (a / a') is not square.\n        var c = this._scale(point.curve);\n\n        var nx = c.redMul(x);\n        var ny = y;\n        var nz = z;\n        var nt = c.redMul(t);\n        return this.point(nx, ny, nz, nt);\n      }\n\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"pointFromUniform\",\n    value: function pointFromUniform(u) {\n      var curve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      assert(u instanceof BN);\n      assert(u.red === this.red);\n      assert(curve == null || curve instanceof MontCurve);\n      if (!curve) curve = this._alt();\n      var u0 = curve.field(u);\n      var p0 = curve.pointFromUniform(u0);\n      return this.pointFromMont(p0);\n    }\n  }, {\n    key: \"pointToUniform\",\n    value: function pointToUniform(p, hint) {\n      var curve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      assert(p instanceof EdwardsPoint);\n      assert(hint >>> 0 === hint);\n      assert(curve == null || curve instanceof MontCurve);\n      if (!curve) curve = this._alt(); // Add a random torsion component.\n\n      var i = (hint >> 4 & 15) % this.torsion.length;\n      var q = p.add(this.torsion[i]); // Convert and invert.\n\n      var p0 = curve.pointFromEdwards(q);\n      var u0 = curve.pointToUniform(p0, hint & 15);\n      return this.field(u0);\n    }\n  }, {\n    key: \"pointFromHash\",\n    value: function pointFromHash(bytes, pake) {\n      var curve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      assert(curve == null || curve instanceof MontCurve);\n      if (!curve) curve = this._alt();\n      var p0 = curve.pointFromHash(bytes, pake);\n      return this.pointFromMont(p0);\n    }\n  }, {\n    key: \"pointToHash\",\n    value: function pointToHash(p, subgroup, rng) {\n      var curve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      assert(p instanceof EdwardsPoint);\n      assert(subgroup >>> 0 === subgroup);\n      assert(curve == null || curve instanceof MontCurve);\n      if (!curve) curve = this._alt(); // Add a random torsion component.\n\n      var i = subgroup % this.torsion.length;\n      var q = p.add(this.torsion[i]); // Convert and invert.\n\n      var p0 = curve.pointFromEdwards(q);\n      return curve.pointToHash(p0, 0, rng);\n    }\n  }, {\n    key: \"decodePoint\",\n    value: function decodePoint(bytes) {\n      return EdwardsPoint.decode(this, bytes);\n    }\n  }, {\n    key: \"toShort\",\n    value: function toShort(a0, odd) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_short5 = this._short(a0, odd),\n          _this$_short6 = _slicedToArray(_this$_short5, 2),\n          a = _this$_short6[0],\n          b = _this$_short6[1];\n\n      var curve = new ShortCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        b: b,\n        n: this.n,\n        h: this.h\n      });\n\n      if (sign != null) {\n        var _curve$_scale9 = curve._scale(this),\n            _curve$_scale10 = _slicedToArray(_curve$_scale9, 2),\n            u3 = _curve$_scale10[1];\n\n        if (u3.redIsOdd() !== sign) u3.redINeg();\n      }\n\n      if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);\n\n      for (var i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"toMont\",\n    value: function toMont(b0, invert) {\n      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      var _this$_mont5 = this._mont(b0, invert),\n          _this$_mont6 = _slicedToArray(_this$_mont5, 2),\n          a = _this$_mont6[0],\n          b = _this$_mont6[1];\n\n      var curve = new MontCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        b: b,\n        n: this.n,\n        h: this.h,\n        z: this.z\n      });\n\n      if (sign != null) {\n        var c = this._scale(curve, invert);\n\n        if (c.redIsOdd() !== sign) c.redINeg();\n      }\n\n      if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);\n\n      for (var i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"toEdwards\",\n    value: function toEdwards(a0) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var _this$_edwards5 = this._edwards(a0),\n          _this$_edwards6 = _slicedToArray(_this$_edwards5, 2),\n          a = _this$_edwards6[0],\n          d = _this$_edwards6[1];\n\n      var curve = new EdwardsCurve({\n        red: this.red,\n        prime: this.prime,\n        p: this.p,\n        a: a,\n        d: d,\n        n: this.n,\n        h: this.h,\n        z: this.z\n      });\n\n      if (sign != null) {\n        var c = curve._scale(this);\n\n        if (c.redIsOdd() !== sign) c.redINeg();\n      }\n\n      if (!this.g.isInfinity()) {\n        curve.g = curve.pointFromEdwards(this.g);\n        curve.g.normalize();\n      }\n\n      if (curve.isComplete()) {\n        for (var i = 0; i < this.h; i++) {\n          curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n          curve.torsion[i].normalize();\n        }\n      }\n\n      return curve;\n    }\n  }, {\n    key: \"pointFromJSON\",\n    value: function pointFromJSON(json) {\n      return EdwardsPoint.fromJSON(this, json);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      var json = _get(_getPrototypeOf(EdwardsCurve.prototype), \"toJSON\", this).call(this, pre);\n\n      json.a = this.a.fromRed().toJSON();\n      json.d = this.d.fromRed().toJSON();\n      if (!this.s.isZero()) json.s = this.s.fromRed().toJSON();\n      return json;\n    }\n  }], [{\n    key: \"_isomorphism\",\n    value: function _isomorphism(curveA, curveD, customA) {\n      // Twisted Edwards Isomorphism.\n      //\n      // [TWISTED] Definition 2.1, Page 3, Section 2.\n      //\n      // Transformation:\n      //\n      //   a' = a'\n      //   d' = a' * d / a\n      //\n      // Where (a / a') is square.\n      assert(curveA instanceof BN);\n      assert(curveD instanceof BN);\n      assert(customA instanceof BN);\n      var a = customA.clone();\n      var d = customA.redMul(curveD).redDiv(curveA);\n      var c = curveA.redDiv(customA);\n      if (c.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');\n      return [a, d];\n    }\n  }]);\n\n  return EdwardsCurve;\n}(Curve);\n/**\n * EdwardsPoint\n */\n\n\nvar EdwardsPoint = /*#__PURE__*/function (_Point5) {\n  _inherits(EdwardsPoint, _Point5);\n\n  var _super8 = _createSuper(EdwardsPoint);\n\n  function EdwardsPoint(curve, x, y, z, t) {\n    var _this9;\n\n    _classCallCheck(this, EdwardsPoint);\n\n    assert(curve instanceof EdwardsCurve);\n    _this9 = _super8.call(this, curve, types.EXTENDED);\n    _this9.x = _this9.curve.zero;\n    _this9.y = _this9.curve.one;\n    _this9.z = _this9.curve.one;\n    _this9.t = _this9.curve.zero;\n    _this9.zOne = 1;\n    if (x != null) _this9._init(x, y, z, t);\n    return _this9;\n  }\n\n  _createClass(EdwardsPoint, [{\n    key: \"_init\",\n    value: function _init(x, y, z, t) {\n      assert(x instanceof BN);\n      assert(y instanceof BN);\n      assert(z == null || z instanceof BN);\n      assert(t == null || t instanceof BN);\n      this.x = x;\n      this.y = y;\n      this.z = z || this.curve.one;\n      this.t = t || null;\n      if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n      if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n      if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n      if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);\n      this.zOne = this.z.eq(this.curve.one) | 0;\n\n      this._check();\n\n      if (!this.t) {\n        this.t = this.x.redMul(this.y);\n        if (!this.zOne) this.t = this.t.redDiv(this.z);\n      }\n    }\n  }, {\n    key: \"_check\",\n    value: function _check() {\n      // In order to achieve complete\n      // addition formulas, `a` must\n      // be a square (always the case\n      // for a=1), and `d` must be a\n      // non-square.\n      //\n      // If this is not the case, the\n      // addition formulas may have\n      // exceptional cases where Z3=0.\n      //\n      // In particular, this can occur\n      // when: Q*h = -P*h and Q != -P.\n      //\n      // This is assuming 4-torsion is\n      // involved (the 4-torsion point\n      // is _not_ representable when\n      // `d` is square).\n      if (this.z.isZero()) throw new Error('Invalid point.');\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.curve.point(this.x.clone(), this.y.clone(), this.z.clone(), this.t.clone());\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(point, flag) {\n      assert(point instanceof EdwardsPoint);\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var zOne1 = this.zOne;\n      var zOne2 = point.zOne;\n      this.x.cswap(point.x, flag);\n      this.y.cswap(point.y, flag);\n      this.z.cswap(point.z, flag);\n      this.t.cswap(point.t, flag);\n      this.zOne = zOne1 & (cond ^ 1) | zOne2 & cond;\n      point.zOne = zOne2 & (cond ^ 1) | zOne1 & cond;\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z\n      // 1I + 2M (+ 1M if extended)\n      // Z1 = 1\n      if (this.zOne) return this; // A = 1 / Z1\n\n      var a = this.z.redInvert(); // X3 = X1 * A\n\n      this.x = this.x.redMul(a); // Y3 = Y1 * A\n\n      this.y = this.y.redMul(a); // T3 = T1 * A\n\n      this.t = this.t.redMul(a); // Z3 = 1\n\n      this.z = this.curve.one;\n      this.zOne = 1;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(a) {\n      assert(a instanceof BN); // X3 = X1 * A\n\n      var nx = this.x.redMul(a); // Y3 = Y1 * A\n\n      var ny = this.y.redMul(a); // Z3 = Z1 * A\n\n      var nz = this.z.redMul(a); // T3 = T1 * A\n\n      var nt = this.t.redMul(a);\n      return this.curve.point(nx, ny, nz, nt);\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)\n      var nx = this.x.redNeg();\n      var ny = this.y;\n      var nz = this.z;\n      var nt = this.t.redNeg();\n      return this.curve.point(nx, ny, nz, nt);\n    }\n  }, {\n    key: \"add\",\n    value: function add(p) {\n      assert(p instanceof EdwardsPoint); // P = O\n\n      if (this.isInfinity()) return p; // Q = O\n\n      if (p.isInfinity()) return this; // Z1 = 1\n\n      if (this.zOne) return p._add(this, 0);\n      return this._add(p, 0);\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(p, flag) {\n      // a = -1\n      if (this.curve.mOneA) return this._addM1(p, flag);\n      return this._addA(p, flag);\n    }\n  }, {\n    key: \"_addM1\",\n    value: function _addM1(p, flag) {\n      // Assumes a = -1.\n      //\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n      // 8M + 8A + 1*k + 1*2\n      //\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3\n      // 7M + 8A + 1*k + 1*2\n      var zOne = p.zOne & (flag ^ 1); // A = (Y1 - X1) * (Y2 - X2)\n\n      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)\n\n      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2\n\n      var c = this.t.redMul(this.curve.k).redMul(p.t); // D = Z1 * 2 * Z2\n\n      var d = zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2); // E = B - A\n\n      var e = b.redSub(a); // F = D - C\n\n      var f = d.redSub(c); // G = D + C\n\n      var g = d.redIAdd(c); // H = B + A\n\n      var h = b.redIAdd(a); // X3 = E * F\n\n      var nx = e.redMul(f); // Y3 = G * H\n\n      var ny = g.redMul(h); // T3 = E * H\n\n      var nt = e.redMul(h); // Z3 = F * G\n\n      var nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }\n  }, {\n    key: \"_addA\",\n    value: function _addA(p, flag) {\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n      // 9M + 7A + 1*a + 1*d\n      //\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd\n      // 8M + 7A + 1*a + 1*d\n      var zOne = p.zOne & (flag ^ 1); // A = X1 * X2\n\n      var a = this.x.redMul(p.x); // B = Y1 * Y2\n\n      var b = this.y.redMul(p.y); // C = T1 * d * T2\n\n      var c = this.curve._mulD(this.t).redMul(p.t); // D = Z1 * Z2\n\n\n      var d = zOne ? this.z.clone() : this.z.redMul(p.z); // + XYXY = (X1 + Y1) * (X2 + Y2)\n\n      var xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)); // E = (X1 + Y1) * (X2 + Y2) - A - B\n\n      var e = xyxy.redISub(a).redISub(b); // F = D - C\n\n      var f = d.redSub(c); // G = D + C\n\n      var g = d.redIAdd(c); // H = B - a * A\n\n      var h = b.redISub(this.curve._mulA(a)); // X3 = E * F\n\n      var nx = e.redMul(f); // Y3 = G * H\n\n      var ny = g.redMul(h); // T3 = E * H\n\n      var nt = e.redMul(h); // Z3 = F * G\n\n      var nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      // P = O\n      if (this.isInfinity()) return this;\n      return this._dbl(0);\n    }\n  }, {\n    key: \"_dbl\",\n    value: function _dbl(flag) {\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n      // 4M + 4S + 6A + 1*a + 1*2\n      //\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd\n      // 3M + 4S + 7A + 1*a + 1*2\n      var zOne = this.zOne & (flag ^ 1); // A = X1^2\n\n      var a = this.x.redSqr(); // B = Y1^2\n\n      var b = this.y.redSqr(); // C = 2 * Z1^2\n\n      var c = zOne ? this.curve.two : this.z.redSqr().redIMuln(2); // D = a * A\n\n      var d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B\n\n\n      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B\n\n      var g = d.redAdd(b); // F = G - C\n\n      var f = g.redSub(c); // H = D - B\n\n      var h = d.redISub(b); // X3 = E * F\n\n      var nx = e.redMul(f); // Y3 = G * H\n\n      var ny = g.redMul(h); // T3 = E * H\n\n      var nt = e.redMul(h); // Z3 = F * G\n\n      var nz = f.redMul(g);\n      return this.curve.point(nx, ny, nz, nt);\n    }\n  }, {\n    key: \"uadd\",\n    value: function uadd(p) {\n      assert(p instanceof EdwardsPoint);\n      return this._add(p, 1);\n    }\n  }, {\n    key: \"udbl\",\n    value: function udbl() {\n      return this._dbl(1);\n    }\n  }, {\n    key: \"getX\",\n    value: function getX() {\n      this.normalize();\n      return this.x.fromRed();\n    }\n  }, {\n    key: \"getY\",\n    value: function getY() {\n      this.normalize();\n      return this.y.fromRed();\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(p) {\n      assert(p instanceof EdwardsPoint);\n      assert(!this.z.isZero());\n      assert(!p.z.isZero()); // P = Q\n\n      if (this === p) return true; // Z1 = Z2\n\n      if (this.z.eq(p.z)) {\n        return this.x.eq(p.x) && this.y.eq(p.y);\n      } // X1 * Z2 == X2 * Z1\n\n\n      var x1 = this.x.redMul(p.z);\n      var x2 = p.x.redMul(this.z);\n      if (!x1.eq(x2)) return false;\n      var y1 = this.y.redMul(p.z);\n      var y2 = p.y.redMul(this.z);\n      return y1.eq(y2);\n    }\n  }, {\n    key: \"isInfinity\",\n    value: function isInfinity() {\n      assert(!this.z.isZero()); // X1 = 0\n\n      if (!this.x.isZero()) return false; // Y1 = Z1\n\n      return this.y.eq(this.z);\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      this.normalize();\n      return this.x.redIsOdd();\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      this.normalize();\n      return this.x.redIsEven();\n    }\n  }, {\n    key: \"toP\",\n    value: function toP() {\n      return this.normalize();\n    }\n  }, {\n    key: \"toJ\",\n    value: function toJ() {\n      return this;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      // [RFC8032] Section 5.1.2.\n      var y = this.getY(); // Note: `x` normalized from `getY()` call.\n\n      y.setn(this.curve.signBit, this.x.redIsOdd());\n      return this.curve.encodeAdjusted(y);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pre) {\n      if (this.isInfinity()) return [];\n      var x = this.getX().toJSON();\n      var y = this.getY().toJSON();\n      if (pre === true && this.pre) return [x, y, this.pre.toJSON()];\n      return [x, y];\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      if (this.isInfinity()) return '<EdwardsPoint: Infinity>';\n      return '<EdwardsPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(curve, bytes) {\n      // [RFC8032] Section 5.1.3.\n      assert(curve instanceof EdwardsCurve);\n      var y = curve.decodeAdjusted(bytes);\n      var sign = y.testn(curve.signBit) !== 0;\n      y.setn(curve.signBit, 0);\n      if (y.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n      return curve.pointFromY(y, sign);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      assert(curve instanceof EdwardsCurve);\n      assert(Array.isArray(json));\n      assert(json.length === 0 || json.length === 2 || json.length === 3);\n      if (json.length === 0) return curve.point();\n      var x = BN.fromJSON(json[0]);\n      var y = BN.fromJSON(json[1]);\n      var point = curve.point(x, y);\n      if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);\n      return point;\n    }\n  }]);\n\n  return EdwardsPoint;\n}(Point);\n/**\n * Mask\n */\n\n\nvar Mask = /*#__PURE__*/function () {\n  function Mask(curve) {\n    _classCallCheck(this, Mask);\n\n    assert(curve instanceof Curve); // Get prime bit length.\n\n    var bits = curve.fieldBits;\n    var top = bits & 7;\n    if (top === 0) top = 8; // Adjust for low order.\n\n    if (curve.scalarSize < curve.fieldSize) {\n      bits = curve.scalarSize * 8;\n      top = 8;\n    } // Our curve.\n\n\n    this.curve = curve; // Cofactor mask (p25519=-8, p448=-4).\n\n    this.h = -curve.h.word(0) & 0xff; // Prime top byte (p25519=0x7f, p448=0xff).\n\n    this.n = (1 << top) - 1; // High bit (p25519=0x40, p448=0x80).\n\n    this.b = 1 << top - 1; // AND mask (p25519=0x7fff...f8, p448=0xffff...fc).\n\n    this.and = BN.mask(bits).iuxorn(this.h ^ 0xff); // OR mask (p25519=0x4000..., p448=0x8000...).\n\n    this.or = BN.shift(1, bits - 1);\n  }\n\n  _createClass(Mask, [{\n    key: \"reduce\",\n    value: function reduce(k) {\n      assert(k instanceof BN);\n      assert(!k.red);\n      k.iuand(this.and);\n      k.iuor(this.or);\n      return k;\n    }\n  }, {\n    key: \"clamp\",\n    value: function clamp(bytes) {\n      assert(Buffer.isBuffer(bytes));\n      assert(bytes.length === this.curve.scalarSize);\n      var i = 0;\n      var j = this.curve.scalarSize - 1;\n\n      if (this.curve.endian === 'be') {\n        var _ref = [j, i];\n        i = _ref[0];\n        j = _ref[1];\n      } // Adjust for high order.\n\n\n      if (this.curve.scalarSize > this.curve.fieldSize) {\n        if (this.curve.endian === 'be') bytes[j++] = 0;else bytes[j--] = 0;\n      } // Ensure a multiple of the cofactor.\n\n\n      bytes[i] &= this.h; // Clamp to the prime.\n\n      bytes[j] &= this.n; // Set the high bit.\n\n      bytes[j] |= this.b;\n      return bytes;\n    }\n  }, {\n    key: \"splitHash\",\n    value: function splitHash(bytes) {\n      assert(Buffer.isBuffer(bytes));\n      assert(bytes.length === this.curve.adjustedSize * 2);\n      var off = 0;\n      if (this.curve.endian === 'be') off = this.curve.adjustedSize - this.curve.scalarSize;\n      var scalar = bytes.slice(off, off + this.curve.scalarSize);\n      var prefix = bytes.slice(this.curve.adjustedSize);\n      this.clamp(scalar);\n      return [scalar, prefix];\n    }\n  }]);\n\n  return Mask;\n}();\n/**\n * Precomp\n */\n\n\nvar Precomp = /*#__PURE__*/function () {\n  function Precomp() {\n    _classCallCheck(this, Precomp);\n\n    this.naf = null;\n    this.windows = null;\n    this.doubles = null;\n    this.blinding = null;\n    this.beta = null;\n  }\n\n  _createClass(Precomp, [{\n    key: \"map\",\n    value: function map(func) {\n      assert(typeof func === 'function');\n      var out = new this.constructor();\n      if (this.naf) out.naf = this.naf.map(func);\n      if (this.doubles) out.doubles = this.doubles.map(func);\n      return out;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        naf: this.naf ? this.naf.toJSON() : null,\n        windows: this.windows ? this.windows.toJSON() : null,\n        doubles: this.doubles ? this.doubles.toJSON() : null,\n        blinding: this.blinding ? this.blinding.toJSON() : undefined\n      };\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(point, json) {\n      assert(point instanceof Point);\n      assert(json && typeof json === 'object');\n      if (json.naf != null) this.naf = NAF.fromJSON(point, json.naf);\n      if (json.windows != null) this.windows = Windows.fromJSON(point, json.windows);\n      if (json.doubles != null) this.doubles = Doubles.fromJSON(point, json.doubles);\n      if (json.blinding != null) this.blinding = Blinding.fromJSON(point, json.blinding);\n      return this;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(point, json) {\n      return new this().fromJSON(point, json);\n    }\n  }]);\n\n  return Precomp;\n}();\n/**\n * NAF\n */\n\n\nvar NAF = /*#__PURE__*/function () {\n  function NAF(width, points) {\n    _classCallCheck(this, NAF);\n\n    this.width = width;\n    this.points = points;\n  }\n\n  _createClass(NAF, [{\n    key: \"map\",\n    value: function map(func) {\n      assert(typeof func === 'function');\n      var width = this.width;\n      var points = [];\n\n      var _iterator = _createForOfIteratorHelper(this.points),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var point = _step.value;\n          points.push(func(point));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return new this.constructor(width, points);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        width: this.width,\n        points: this.points.slice(1).map(function (point) {\n          return point.toJSON();\n        })\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(point, json) {\n      assert(point instanceof Point);\n      assert(json && typeof json === 'object');\n      assert(json.width >>> 0 === json.width);\n      assert(Array.isArray(json.points));\n      var curve = point.curve;\n      var width = json.width;\n      var points = [point];\n\n      var _iterator2 = _createForOfIteratorHelper(json.points),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          points.push(curve.pointFromJSON(item));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return new this(width, points);\n    }\n  }]);\n\n  return NAF;\n}();\n/**\n * Windows\n */\n\n\nvar Windows = /*#__PURE__*/function () {\n  function Windows(width, bits, points) {\n    _classCallCheck(this, Windows);\n\n    this.width = width;\n    this.bits = bits;\n    this.points = points;\n  }\n\n  _createClass(Windows, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        width: this.width,\n        bits: this.bits,\n        points: this.points.slice(1).map(function (point) {\n          return point.toJSON();\n        })\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(point, json) {\n      assert(point instanceof Point);\n      assert(json && typeof json === 'object');\n      assert(json.width >>> 0 === json.width);\n      assert(json.bits >>> 0 === json.bits);\n      assert(Array.isArray(json.points));\n      var curve = point.curve;\n      var width = json.width,\n          bits = json.bits;\n      var points = [point];\n\n      var _iterator3 = _createForOfIteratorHelper(json.points),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          points.push(curve.pointFromJSON(item));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return new this(width, bits, points);\n    }\n  }]);\n\n  return Windows;\n}();\n/**\n * Doubles\n */\n\n\nvar Doubles = /*#__PURE__*/function () {\n  function Doubles(step, points) {\n    _classCallCheck(this, Doubles);\n\n    this.step = step;\n    this.points = points;\n  }\n\n  _createClass(Doubles, [{\n    key: \"map\",\n    value: function map(func) {\n      assert(typeof func === 'function');\n      var step = this.step;\n      var points = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.points),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var point = _step4.value;\n          points.push(func(point));\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return new this.constructor(step, points);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        step: this.step,\n        points: this.points.slice(1).map(function (point) {\n          return point.toJSON();\n        })\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(point, json) {\n      assert(point instanceof Point);\n      assert(json && typeof json === 'object');\n      assert(json.step >>> 0 === json.step);\n      assert(Array.isArray(json.points));\n      var curve = point.curve;\n      var step = json.step;\n      var points = [point];\n\n      var _iterator5 = _createForOfIteratorHelper(json.points),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n          points.push(curve.pointFromJSON(item));\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return new this(step, points);\n    }\n  }]);\n\n  return Doubles;\n}();\n/**\n * Blinding\n */\n\n\nvar Blinding = /*#__PURE__*/function () {\n  function Blinding(blind, unblind) {\n    _classCallCheck(this, Blinding);\n\n    this.blind = blind;\n    this.unblind = unblind;\n  }\n\n  _createClass(Blinding, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        blind: this.blind.toJSON(),\n        unblind: this.unblind.toJSON()\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(point, json) {\n      assert(point instanceof Point);\n      assert(json && typeof json === 'object');\n      var curve = point.curve;\n      var blind = BN.fromJSON(json.blind);\n      var unblind = curve.pointFromJSON(json.unblind);\n      return new this(blind, unblind);\n    }\n  }]);\n\n  return Blinding;\n}();\n/**\n * Endo\n */\n\n\nvar Endo = /*#__PURE__*/function () {\n  function Endo(beta, lambda, basis, pre) {\n    _classCallCheck(this, Endo);\n\n    this.beta = beta;\n    this.lambda = lambda;\n    this.basis = basis;\n    this.pre = pre;\n  }\n\n  _createClass(Endo, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        beta: this.beta.fromRed().toJSON(),\n        lambda: this.lambda.toJSON(),\n        basis: [this.basis[0].toJSON(), this.basis[1].toJSON()],\n        pre: [this.pre[0].toJSON(), this.pre[1].toJSON()]\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(curve, json) {\n      assert(curve instanceof Curve);\n      assert(json && typeof json === 'object');\n      assert(Array.isArray(json.basis));\n      assert(Array.isArray(json.pre));\n      assert(json.basis.length === 2);\n      assert(json.pre.length === 2);\n      var beta = BN.fromJSON(json.beta).toRed(curve.red);\n      var lambda = BN.fromJSON(json.lambda);\n      var basis = [Vector.fromJSON(json.basis[0]), Vector.fromJSON(json.basis[1])];\n      var pre = [BN.fromJSON(json.pre[0]), BN.fromJSON(json.pre[1])];\n      return new this(beta, lambda, basis, pre);\n    }\n  }]);\n\n  return Endo;\n}();\n/**\n * Vector\n */\n\n\nvar Vector = /*#__PURE__*/function () {\n  function Vector(a, b) {\n    _classCallCheck(this, Vector);\n\n    this.a = a;\n    this.b = b;\n  }\n\n  _createClass(Vector, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        a: this.a.toJSON(),\n        b: this.b.toJSON()\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      assert(json && typeof json === 'object');\n      var a = BN.fromJSON(json.a);\n      var b = BN.fromJSON(json.b);\n      return new this(a, b);\n    }\n  }]);\n\n  return Vector;\n}();\n/**\n * P192\n * https://tinyurl.com/fips-186-2 (page 29)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\n\nvar P192 = /*#__PURE__*/function (_ShortCurve) {\n  _inherits(P192, _ShortCurve);\n\n  var _super9 = _createSuper(P192);\n\n  function P192(pre) {\n    _classCallCheck(this, P192);\n\n    return _super9.call(this, {\n      id: 'P192',\n      ossl: 'prime192v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p192',\n      // 2^192 - 2^64 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff fffffffc'],\n      b: ['64210519 e59c80e7 0fa7e9ab 72243049', 'feb8deec c146b9b1'],\n      n: ['ffffffff ffffffff ffffffff 99def836', '146bc9b1 b4d22831'],\n      h: '1',\n      // Icart\n      z: '-5',\n      g: [['188da80e b03090f6 7cbf20eb 43a18800', 'f4ff0afd 82ff1012'], ['07192b95 ffc8da78 631011ed 6b24cdd5', '73f977a1 1e794811'], pre]\n    });\n  }\n\n  return P192;\n}(ShortCurve);\n/**\n * P224\n * https://tinyurl.com/fips-186-2 (page 30)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\n\nvar P224 = /*#__PURE__*/function (_ShortCurve2) {\n  _inherits(P224, _ShortCurve2);\n\n  var _super10 = _createSuper(P224);\n\n  function P224(pre) {\n    _classCallCheck(this, P224);\n\n    return _super10.call(this, {\n      id: 'P224',\n      ossl: 'secp224r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p224',\n      // 2^224 - 2^96 + 1 (no congruence)\n      p: ['ffffffff ffffffff ffffffff ffffffff', '00000000 00000000 00000001'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff fffffffe'],\n      b: ['b4050a85 0c04b3ab f5413256 5044b0b7', 'd7bfd8ba 270b3943 2355ffb4'],\n      n: ['ffffffff ffffffff ffffffff ffff16a2', 'e0b8f03e 13dd2945 5c5c2a3d'],\n      h: '1',\n      // SSWU\n      z: '1f',\n      g: [['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3', '56c21122 343280d6 115c1d21'], ['bd376388 b5f723fb 4c22dfe6 cd4375a0', '5a074764 44d58199 85007e34'], pre]\n    });\n  }\n\n  return P224;\n}(ShortCurve);\n/**\n * P256\n * https://tinyurl.com/fips-186-2 (page 31)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\n\nvar P256 = /*#__PURE__*/function (_ShortCurve3) {\n  _inherits(P256, _ShortCurve3);\n\n  var _super11 = _createSuper(P256);\n\n  function P256(pre) {\n    _classCallCheck(this, P256);\n\n    return _super11.call(this, {\n      id: 'P256',\n      ossl: 'prime256v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)\n      p: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff fffffffc'],\n      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc', '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],\n      n: ['ffffffff 00000000 ffffffff ffffffff', 'bce6faad a7179e84 f3b9cac2 fc632551'],\n      h: '1',\n      // SSWU\n      z: '-a',\n      g: [['6b17d1f2 e12c4247 f8bce6e5 63a440f2', '77037d81 2deb33a0 f4a13945 d898c296'], ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16', '2bce3357 6b315ece cbb64068 37bf51f5'], pre]\n    });\n  }\n\n  return P256;\n}(ShortCurve);\n/**\n * P384\n * https://tinyurl.com/fips-186-2 (page 32)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\n\nvar P384 = /*#__PURE__*/function (_ShortCurve4) {\n  _inherits(P384, _ShortCurve4);\n\n  var _super12 = _createSuper(P384);\n\n  function P384(pre) {\n    _classCallCheck(this, P384);\n\n    return _super12.call(this, {\n      id: 'P384',\n      ossl: 'secp384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 fffffffc'],\n      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19', '181d9c6e fe814112 0314088f 5013875a', 'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],\n      n: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff c7634d81 f4372ddf', '581a0db2 48b0a77a ecec196a ccc52973'],\n      h: '1',\n      // Icart\n      z: '-c',\n      g: [['aa87ca22 be8b0537 8eb1c71e f320ad74', '6e1d3b62 8ba79b98 59f741e0 82542a38', '5502f25d bf55296c 3a545e38 72760ab7'], ['3617de4a 96262c6f 5d9e98bf 9292dc29', 'f8f41dbd 289a147c e9da3113 b5f0b8c0', '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'], pre]\n    });\n  }\n\n  return P384;\n}(ShortCurve);\n/**\n * P521\n * https://tinyurl.com/fips-186-2 (page 33)\n * https://tinyurl.com/fips-186-3 (page 90)\n */\n\n\nvar P521 = /*#__PURE__*/function (_ShortCurve5) {\n  _inherits(P521, _ShortCurve5);\n\n  var _super13 = _createSuper(P521);\n\n  function P521(pre) {\n    _classCallCheck(this, P521);\n\n    return _super13.call(this, {\n      id: 'P521',\n      ossl: 'secp521r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: 'p521',\n      // 2^521 - 1 (= 3 mod 4)\n      p: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff'],\n      // -3 mod p\n      a: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffc'],\n      b: ['00000051 953eb961 8e1c9a1f 929a21a0', 'b68540ee a2da725b 99b315f3 b8b48991', '8ef109e1 56193951 ec7e937b 1652c0bd', '3bb1bf07 3573df88 3d2c34f1 ef451fd4', '6b503f00'],\n      n: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffa 51868783 bf2f966b 7fcc0148', 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e', '91386409'],\n      h: '1',\n      // SSWU\n      z: '-4',\n      g: [['000000c6 858e06b7 0404e9cd 9e3ecb66', '2395b442 9c648139 053fb521 f828af60', '6b4d3dba a14b5e77 efe75928 fe1dc127', 'a2ffa8de 3348b3c1 856a429b f97e7e31', 'c2e5bd66'], ['00000118 39296a78 9a3bc004 5c8a5fb4', '2c7d1bd9 98f54449 579b4468 17afbd17', '273e662c 97ee7299 5ef42640 c550b901', '3fad0761 353c7086 a272c240 88be9476', '9fd16650'], pre]\n    });\n  }\n\n  return P521;\n}(ShortCurve);\n/**\n * SECP256K1\n * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)\n * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)\n */\n\n\nvar SECP256K1 = /*#__PURE__*/function (_ShortCurve6) {\n  _inherits(SECP256K1, _ShortCurve6);\n\n  var _super14 = _createSuper(SECP256K1);\n\n  function SECP256K1(pre) {\n    _classCallCheck(this, SECP256K1);\n\n    return _super14.call(this, {\n      id: 'SECP256K1',\n      ossl: 'secp256k1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'k256',\n      // 2^256 - 2^32 - 977 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe fffffc2f'],\n      a: '0',\n      b: '7',\n      n: ['ffffffff ffffffff ffffffff fffffffe', 'baaedce6 af48a03b bfd25e8c d0364141'],\n      h: '1',\n      // SVDW\n      z: '1',\n      // sqrt(-3)\n      c: ['0a2d2ba9 3507f1df 233770c2 a797962c', 'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],\n      g: [['79be667e f9dcbbac 55a06295 ce870b07', '029bfcdb 2dce28d9 59f2815b 16f81798'], ['483ada77 26a3c465 5da4fbfc 0e1108a8', 'fd17b448 a6855419 9c47d08f fb10d4b8'], pre],\n      // Precomputed endomorphism.\n      endo: {\n        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9', '9cf04975 12f58995 c1396c28 719501ee'],\n        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a', '122e22ea 20816678 df02967c 1b23bd72'],\n        basis: [{\n          a: '3086d221a7d46bcde86c90e49284eb15',\n          b: '-e4437ed6010e88286f547fa90abfe4c3'\n        }, {\n          a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n          b: '3086d221a7d46bcde86c90e49284eb15'\n        }],\n        pre: ['3086d221a7d46bcde86c90e49284eb153dab', '-e4437ed6010e88286f547fa90abfe4c42212']\n      }\n    });\n  }\n\n  return SECP256K1;\n}(ShortCurve);\n/**\n * BRAINPOOLP256\n * https://tools.ietf.org/html/rfc5639#section-3.4\n */\n\n\nvar BRAINPOOLP256 = /*#__PURE__*/function (_ShortCurve7) {\n  _inherits(BRAINPOOLP256, _ShortCurve7);\n\n  var _super15 = _createSuper(BRAINPOOLP256);\n\n  function BRAINPOOLP256(pre) {\n    _classCallCheck(this, BRAINPOOLP256);\n\n    return _super15.call(this, {\n      id: 'BRAINPOOLP256',\n      ossl: 'brainpoolP256r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72', '6e3bf623 d5262028 2013481d 1f6e5377'],\n      a: ['7d5a0975 fc2c3057 eef67530 417affe7', 'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],\n      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf', '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],\n      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71', '8c397aa3 b561a6f7 901e0e82 974856a7'],\n      h: '1',\n      // Icart\n      z: '-2',\n      g: [['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af', 'b9de27e1 e3bd23c2 3a4453bd 9ace3262'], ['547ef835 c3dac4fd 97f8461a 14611dc9', 'c2774513 2ded8e54 5c1d54c7 2f046997'], pre]\n    });\n  }\n\n  return BRAINPOOLP256;\n}(ShortCurve);\n/**\n * BRAINPOOLP384\n * https://tools.ietf.org/html/rfc5639#section-3.6\n */\n\n\nvar BRAINPOOLP384 = /*#__PURE__*/function (_ShortCurve8) {\n  _inherits(BRAINPOOLP384, _ShortCurve8);\n\n  var _super16 = _createSuper(BRAINPOOLP384);\n\n  function BRAINPOOLP384(pre) {\n    _classCallCheck(this, BRAINPOOLP384);\n\n    return _super16.call(this, {\n      id: 'BRAINPOOLP384',\n      ossl: 'brainpoolP384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b4 12b1da19 7fb71123', 'acd3a729 901d1a71 87470013 3107ec53'],\n      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0', 'c2bea28e 4fb22787 139165ef ba91f90f', '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],\n      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c', '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5', '7cb43902 95dbc994 3ab78696 fa504c11'],\n      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b3 1f166e6c ac0425a7', 'cf3ab6af 6b7fc310 3b883202 e9046565'],\n      h: '1',\n      // SSWU\n      z: '-5',\n      g: [['1d1c64f0 68cf45ff a2a63a81 b7c13f6b', '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8', 'e826e034 36d646aa ef87b2e2 47d4af1e'], ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552', '62b70b29 feec5864 e19c054f f9912928', '0e464621 77918111 42820341 263c5315'], pre]\n    });\n  }\n\n  return BRAINPOOLP384;\n}(ShortCurve);\n/**\n * BRAINPOOLP512\n * https://tools.ietf.org/html/rfc5639#section-3.7\n */\n\n\nvar BRAINPOOLP512 = /*#__PURE__*/function (_ShortCurve9) {\n  _inherits(BRAINPOOLP512, _ShortCurve9);\n\n  var _super17 = _createSuper(BRAINPOOLP512);\n\n  function BRAINPOOLP512(pre) {\n    _classCallCheck(this, BRAINPOOLP512);\n\n    return _super17.call(this, {\n      id: 'BRAINPOOLP512',\n      ossl: 'brainpoolP512r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330871', '7d4d9b00 9bc66842 aecda12a e6a380e6', '2881ff2f 2d82c685 28aa6056 583a48f3'],\n      a: ['7830a331 8b603b89 e2327145 ac234cc5', '94cbdd8d 3df91610 a83441ca ea9863bc', '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5', '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],\n      b: ['3df91610 a83441ca ea9863bc 2ded5d5a', 'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7', '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67', '984050b7 5ebae5dd 2809bd63 8016f723'],\n      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330870', '553e5c41 4ca92619 41866119 7fac1047', '1db1d381 085ddadd b5879682 9ca90069'],\n      h: '1',\n      // Icart\n      z: '7',\n      g: [['81aee4bd d82ed964 5a21322e 9c4c6a93', '85ed9f70 b5d916c1 b43b62ee f4d0098e', 'ff3b1f78 e2d0d48d 50d1687b 93b97d5f', '7c6d5047 406a5e68 8b352209 bcb9f822'], ['7dde385d 566332ec c0eabfa9 cf7822fd', 'f209f700 24a57b1a a000c55b 881f8111', 'b2dcde49 4a5f485e 5bca4bd8 8a2763ae', 'd1ca2b2f a8f05406 78cd1e0f 3ad80892'], pre]\n    });\n  }\n\n  return BRAINPOOLP512;\n}(ShortCurve);\n/**\n * X25519\n * https://tools.ietf.org/html/rfc7748#section-4.1\n */\n\n\nvar X25519 = /*#__PURE__*/function (_MontCurve) {\n  _inherits(X25519, _MontCurve);\n\n  var _super18 = _createSuper(X25519);\n\n  function X25519() {\n    _classCallCheck(this, X25519);\n\n    return _super18.call(this, {\n      id: 'X25519',\n      ossl: 'X25519',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHA512',\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],\n      // 486662\n      a: '76d06',\n      b: '1',\n      n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000009'], // See: https://www.rfc-editor.org/errata/eid4730\n      ['5f51e65e 475f794b 1fe122d3 88b72eb3', '6dc2b281 92839e4d d6163a5d 81312c14']],\n      torsion: [// (1)\n      [], // (2)\n      ['0000000000000000000000000000000000000000000000000000000000000000', '0000000000000000000000000000000000000000000000000000000000000000'], // (4)\n      ['0000000000000000000000000000000000000000000000000000000000000001', '141b0b6806563d503de05885280b59109ca5ee38d7b56c9c165db7106377bbd8'], // (4)\n      ['0000000000000000000000000000000000000000000000000000000000000001', '6be4f497f9a9c2afc21fa77ad7f4a6ef635a11c7284a9363e9a248ef9c884415'], // (8)\n      ['00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0', '46ce3ed6a9617c5ad6b7d3eb19d74ba86cc403d6127fe4b29778eb7c6daf84d3'], // (8)\n      ['00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0', '3931c129569e83a529482c14e628b457933bfc29ed801b4d6887148392507b1a'], // (8)\n      ['57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f', '173a6c76c2ba719bce3935ffba04afeadf5bbcb971559722f0efc7bdfb7f9a36'], // (8)\n      ['57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f', '68c593893d458e6431c6ca0045fb501520a443468eaa68dd0f103842048065b7']]\n    });\n  }\n\n  return X25519;\n}(MontCurve);\n/**\n * X448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n */\n\n\nvar X448 = /*#__PURE__*/function (_MontCurve2) {\n  _inherits(X448, _MontCurve2);\n\n  var _super19 = _createSuper(X448);\n\n  function X448() {\n    _classCallCheck(this, X448);\n\n    return _super19.call(this, {\n      id: 'X448',\n      ossl: 'X448',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      // 156326\n      a: '262a6',\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000005'], ['7d235d12 95f5b1f6 6c98ab6e 58326fce', 'cbae5d34 f55545d0 60f75dc2 8df3f6ed', 'b8027e23 46430d21 1312c4b1 50677af7', '6fd7223d 457b5b1a']],\n      torsion: [// (1)\n      [], // (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['ba4d3a0829b6112f8812e51ba0bb2abebc1cb08eb48e556936ba50fd', 'd2e7d68af8cb32160522425b3f990812abbe635ad37a21e17551b193']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['45b2c5f7d649eed077ed1ae45f44d54143e34f714b71aa96c945af01', '2d1829750734cde9faddbda4c066f7ed54419ca52c85de1e8aae4e6c']]]\n    });\n  }\n\n  return X448;\n}(MontCurve);\n/**\n * MONT448\n * Isomorphic to Ed448-Goldilocks.\n */\n\n\nvar MONT448 = /*#__PURE__*/function (_MontCurve3) {\n  _inherits(MONT448, _MontCurve3);\n\n  var _super20 = _createSuper(MONT448);\n\n  function MONT448() {\n    _classCallCheck(this, MONT448);\n\n    return _super20.call(this, {\n      id: 'MONT448',\n      ossl: null,\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      // -78160 / -39082 mod p\n      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5', '5d93f8d2 22746997 60ccffc6 49961ed6', 'c5b05fca c24864ed 6fb59697 931b78da', '84ddecd8 ca2b5cfb'],\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['ac0d24cc c6c75cb0 eb71f81e 7a6edf51', '48e88aee 009a2a24 e795687e c28e125a', '3e6730a6 0d46367b aa7fe99d 152128dc', '41321bc7 7817f059'], ['5a4437f6 80c0d0db 9b061276 d5d0ffcc', 'e786ff33 b6a53d30 98746425 82e66f09', '4433dae7 7244a6e2 6b11e905 7228f483', '556c41a5 913f55fe']],\n      torsion: [// (1)\n      [], // (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['bec92fd06da2acf2b4e261e87cef0d3422e75c183c589857b71924e5', '73c2f9cee18da5f2466e2f393c2eedf0f105a60ab40c717d4f1e1fd7']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['4136d02f925d530d4b1d9e178310f2cbdd18a3e7c3a767a848e6db19', '8c3d06311e725a0db991d0c6c3d1120f0efa59f54bf38e82b0e1e028']]]\n    });\n  }\n\n  return MONT448;\n}(MontCurve);\n/**\n * ED25519\n * https://tools.ietf.org/html/rfc8032#section-5.1\n */\n\n\nvar ED25519 = /*#__PURE__*/function (_EdwardsCurve) {\n  _inherits(ED25519, _EdwardsCurve);\n\n  var _super21 = _createSuper(ED25519);\n\n  function ED25519(pre) {\n    _classCallCheck(this, ED25519);\n\n    return _super21.call(this, {\n      id: 'ED25519',\n      ossl: 'ED25519',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHA512',\n      prefix: 'SigEd25519 no Ed25519 collisions',\n      context: false,\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],\n      a: '-1',\n      // -121665 / 121666 mod p\n      d: ['52036cee 2b6ffe73 8cc74079 7779e898', '00700a4d 4141d8ab 75eb4dca 135978a3'],\n      n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [['216936d3 cd6e53fe c0a4e231 fdd6dc5c', '692cc760 9525a7b2 c9562d60 8f25d51a'], // 4/5\n      ['66666666 66666666 66666666 66666666', '66666666 66666666 66666666 66666658'], pre],\n      torsion: [// (0, 1) (1)\n      ['0000000000000000000000000000000000000000000000000000000000000000', '0000000000000000000000000000000000000000000000000000000000000001'], // (0, -1) (2)\n      ['0000000000000000000000000000000000000000000000000000000000000000', '7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'], // (-sqrt(1 / a), 0) (4)\n      ['547cdb7fb03e20f4d4b2ff66c2042858d0bce7f952d01b873b11e4d8b5f15f3d', '0000000000000000000000000000000000000000000000000000000000000000'], // (sqrt(1 / a), 0) (4)\n      ['2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0', '0000000000000000000000000000000000000000000000000000000000000000'], // (-sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), sqrt(a) * x) (8)\n      ['602a465ff9c6b5d716cc66cdc721b544a3e6c38fec1a1dc7215eb9b93aba2ea3', '7a03ac9277fdc74ec6cc392cfa53202a0f67100d760b3cba4fd84d3d706a17c7'], // (sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), sqrt(a) * x) (8)\n      ['1fd5b9a006394a28e933993238de4abb5c193c7013e5e238dea14646c545d14a', '7a03ac9277fdc74ec6cc392cfa53202a0f67100d760b3cba4fd84d3d706a17c7'], // (-sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), -sqrt(a) * x) (8)\n      ['602a465ff9c6b5d716cc66cdc721b544a3e6c38fec1a1dc7215eb9b93aba2ea3', '05fc536d880238b13933c6d305acdfd5f098eff289f4c345b027b2c28f95e826'], // (sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), -sqrt(a) * x) (8)\n      ['1fd5b9a006394a28e933993238de4abb5c193c7013e5e238dea14646c545d14a', '05fc536d880238b13933c6d305acdfd5f098eff289f4c345b027b2c28f95e826']]\n    });\n  }\n\n  return ED25519;\n}(EdwardsCurve);\n/**\n * ISO448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658\n */\n\n\nvar ISO448 = /*#__PURE__*/function (_EdwardsCurve2) {\n  _inherits(ISO448, _EdwardsCurve2);\n\n  var _super22 = _createSuper(ISO448);\n\n  function ISO448(pre) {\n    _classCallCheck(this, ISO448);\n\n    return _super22.call(this, {\n      id: 'ISO448',\n      ossl: null,\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      a: '1',\n      // 39082 / 39081 mod p\n      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc', 'ad461572 42a50f37 809b1da3 412a12e7', '9ccc9c81 264cfe9a d0809970 58fb61c4', '243cc32d baa156b9'],\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['79a70b2b 70400553 ae7c9df4 16c792c6', '1128751a c9296924 0c25a07d 728bdc93', 'e21f7787 ed697224 9de732f3 8496cd11', '69871309 3e9c04fc'], // Note: the RFC has this wrong.\n      ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 80000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], pre],\n      torsion: [// (0, c) (1)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001']], // (0, -c) (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe']], // (c, 0) (4)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (-c, 0) (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']]]\n    });\n  }\n\n  return ISO448;\n}(EdwardsCurve);\n/**\n * ED448\n * https://tools.ietf.org/html/rfc8032#section-5.2\n */\n\n\nvar ED448 = /*#__PURE__*/function (_EdwardsCurve3) {\n  _inherits(ED448, _EdwardsCurve3);\n\n  var _super23 = _createSuper(ED448);\n\n  function ED448(pre) {\n    _classCallCheck(this, ED448);\n\n    return _super23.call(this, {\n      id: 'ED448',\n      ossl: 'ED448',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      a: '1',\n      // -39081 mod p\n      d: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffff6756'],\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['4f1970c6 6bed0ded 221d15a6 22bf36da', '9e146570 470f1767 ea6de324 a3d3a464', '12ae1af7 2ab66511 433b80e1 8b00938e', '2626a82b c70cc05e'], ['693f4671 6eb6bc24 88762037 56c9c762', '4bea7373 6ca39840 87789c1e 05a0c2d7', '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad', '9808795b f230fa14'], pre],\n      torsion: [// (0, c) (1)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001']], // (0, -c) (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe']], // (c, 0) (4)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (-c, 0) (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']]]\n    });\n  }\n\n  return ED448;\n}(EdwardsCurve);\n/*\n * Curve Registry\n */\n\n\nvar curves = {\n  __proto__: null,\n  P192: P192,\n  P224: P224,\n  P256: P256,\n  P384: P384,\n  P521: P521,\n  SECP256K1: SECP256K1,\n  BRAINPOOLP256: BRAINPOOLP256,\n  BRAINPOOLP384: BRAINPOOLP384,\n  BRAINPOOLP512: BRAINPOOLP512,\n  X25519: X25519,\n  X448: X448,\n  MONT448: MONT448,\n  ED25519: ED25519,\n  ISO448: ISO448,\n  ED448: ED448\n};\nvar cache = {\n  __proto__: null,\n  P192: null,\n  P224: null,\n  P256: null,\n  P384: null,\n  P521: null,\n  SECP256K1: null,\n  BRAINPOOLP256: null,\n  BRAINPOOLP384: null,\n  BRAINPOOLP512: null,\n  X25519: null,\n  X448: null,\n  MONT448: null,\n  ED25519: null,\n  ISO448: null,\n  ED448: null\n};\n\nfunction curve(name) {\n  assert(typeof name === 'string');\n  var key = name.toUpperCase();\n  var curve = cache[key];\n\n  if (!curve) {\n    var _Curve4 = curves[key];\n    if (!_Curve4) throw new Error(\"Curve not found: \\\"\".concat(name, \"\\\".\"));\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    curve = _construct(_Curve4, args);\n    cache[key] = curve;\n  }\n\n  return curve;\n}\n\nfunction register(name, Curve) {\n  assert(typeof name === 'string');\n  assert(typeof Curve === 'function');\n  var key = name.toUpperCase();\n  if (curves[key]) throw new Error(\"Curve already registered: \\\"\".concat(name, \"\\\".\"));\n  curves[key] = Curve;\n  cache[key] = null;\n}\n/*\n * Scalar Recoding\n */\n\n\nfunction getNAF(c, width, max) {\n  // Computing the width-w NAF of a positive integer.\n  //\n  // [GECC] Algorithm 3.35, Page 100, Section 3.3.\n  assert(c instanceof BN);\n  assert(!c.red);\n  assert(width >>> 0 === width);\n  assert(max >>> 0 === max);\n  var naf = new Array(max);\n  var pow = 1 << width + 1;\n  var k = c.abs();\n  var s = c.sign() | 1;\n  var i = 0;\n\n  while (!k.isZero()) {\n    var z = 0;\n\n    if (k.isOdd()) {\n      z = k.andln(pow - 1);\n      if (z & pow >>> 1) z -= pow;\n      k.isubn(z);\n    }\n\n    naf[i++] = z * s; // Optimization: shift by word if possible.\n\n    var shift = 1;\n    if (!k.isZero() && k.andln(pow - 1) === 0) shift = width + 1;\n\n    for (var j = 1; j < shift; j++) {\n      naf[i++] = 0;\n    }\n\n    k.iushrn(shift);\n  }\n\n  assert(i <= max);\n\n  for (; i < max; i++) {\n    naf[i] = 0;\n  }\n\n  return naf;\n}\n\nfunction getFixedNAF(k, width, max, step) {\n  assert(step >>> 0 === step); // Recode to NAF.\n\n  var naf = getNAF(k, width, max); // Translate into more windowed form.\n\n  var len = Math.ceil(naf.length / step);\n  var repr = new Array(len);\n  var i = 0;\n\n  for (var j = 0; j < naf.length; j += step) {\n    var nafW = 0;\n\n    for (var _k = j + step - 1; _k >= j; _k--) {\n      nafW = (nafW << 1) + naf[_k];\n    }\n\n    repr[i++] = nafW;\n  }\n\n  assert(i === len);\n  return repr;\n}\n\nfunction getJSF(c1, c2, max) {\n  // Joint sparse form.\n  //\n  // [GECC] Algorithm 3.50, Page 111, Section 3.3.\n  assert(c1 instanceof BN);\n  assert(c2 instanceof BN);\n  assert(!c1.red);\n  assert(!c2.red);\n  assert(max >>> 0 === max);\n  var jsf = [new Array(max), new Array(max)];\n  var k1 = c1.abs();\n  var k2 = c2.abs();\n  var s1 = c1.sign() | 1;\n  var s2 = c2.sign() | 1;\n  var i = 0;\n  var d1 = 0;\n  var d2 = 0;\n\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase.\n    var m14 = k1.andln(3) + d1 & 3;\n    var m24 = k2.andln(3) + d2 & 3;\n    var u1 = 0;\n    var u2 = 0;\n    if (m14 === 3) m14 = -1;\n    if (m24 === 3) m24 = -1;\n\n    if (m14 & 1) {\n      var m8 = k1.andln(7) + d1 & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;\n    }\n\n    if (m24 & 1) {\n      var _m = k2.andln(7) + d2 & 7;\n\n      if ((_m === 3 || _m === 5) && m14 === 2) u2 = -m24;else u2 = m24;\n    }\n\n    jsf[0][i] = u1 * s1;\n    jsf[1][i] = u2 * s2; // Second phase.\n\n    if (2 * d1 === u1 + 1) d1 = 1 - d1;\n    if (2 * d2 === u2 + 1) d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n    i += 1;\n  }\n\n  assert(i <= max);\n\n  for (; i < max; i++) {\n    jsf[0][i] = 0;\n    jsf[1][i] = 0;\n  }\n\n  return jsf;\n}\n\nfunction getJNAF(c1, c2, max) {\n  var jsf = getJSF(c1, c2, max);\n  var naf = new Array(max); // JSF -> NAF conversion.\n\n  for (var i = 0; i < max; i++) {\n    var ja = jsf[0][i];\n    var jb = jsf[1][i];\n    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];\n  }\n\n  return naf;\n}\n\nfunction getLadderBits(k, n) {\n  // [TIMING] Page 16, Section 6.\n  assert(k instanceof BN);\n  assert(n instanceof BN); // Ensure positive.\n\n  var k0 = k.abs(); // Inflate scalar.\n\n  var k1 = k0.add(n);\n  var k2 = k1.add(n); // Get bit lengths.\n\n  var kb = k1.bitLength();\n  var nb = n.bitLength(); // k' = k + 2 * n, if ceil(log2(k + n)) <= ceil(log2(n)),\n  //    = k + n, otherwise\n\n  k1.cinject(k2, kb - nb - 1 >>> 31); // Track sign.\n\n  var sign = k.isNeg() & 1; // Calculate the new scalar's length.\n\n  var bits = k1.bitLength(); // Recode scalar to base256.\n\n  var exp = k1.toArray('le');\n  return [sign, bits, exp];\n}\n\nfunction getCOZBits(k, n) {\n  assert(k instanceof BN);\n  assert(n instanceof BN); // Reduce.\n\n  var u = k.mod(n); // Negate scalar.\n\n  var v = n.sub(u); // Get bit lengths.\n\n  var ub = u.bitLength();\n  var vb = v.bitLength(); // Negate if ceil(log2(k)) < ceil(log2(-k)).\n\n  var sign = ub - vb >>> 31; // Possibly negate.\n\n  u.cinject(v, sign); // Calculate the new scalar's length.\n\n  var bits = u.bitLength(); // Recode scalar to base256.\n\n  var exp = u.toArray('le'); // Final edge case.\n\n  var m1 = u.ceq(n.subn(1));\n  return [sign, bits, exp, m1];\n}\n/*\n * Helpers\n */\n\n\nfunction assert(val, msg) {\n  if (!val) {\n    var _err = new Error(msg || 'Assertion failed');\n\n    if (Error.captureStackTrace) Error.captureStackTrace(_err, assert);\n    throw _err;\n  }\n}\n\nfunction sqrt(a) {\n  assert(a instanceof BN);\n\n  try {\n    return [1, a.redSqrt()];\n  } catch (e) {\n    if (e.message === 'X is not a square mod P.') return [0, a.clone()];\n    throw e;\n  }\n}\n\nfunction divSqrt(u, v) {\n  assert(u instanceof BN);\n  assert(v instanceof BN);\n\n  try {\n    return [1, u.redDivSqrt(v)];\n  } catch (e) {\n    if (e.message === 'Not invertible.' || e.message === 'X is not a square mod P.') {\n      return [0, u.clone()];\n    }\n\n    throw e;\n  }\n}\n\nfunction randomInt(rng) {\n  return BN.randomBits(rng, 32).toNumber();\n}\n\nfunction memoize(method, self) {\n  var cache = new WeakMap();\n  return function memoized(curve, invert) {\n    var i = invert & 1;\n    var item = cache.get(curve);\n    if (item && item[i] !== null) return item[i];\n    var result = method.call(self, curve, invert);\n    if (!cache.has(curve)) cache.set(curve, [null, null]);\n    cache.get(curve)[i] = result;\n    return result;\n  };\n}\n/*\n * Expose\n */\n\n\nexports.Curve = Curve;\nexports.Point = Point;\nexports.ShortCurve = ShortCurve;\nexports.ShortPoint = ShortPoint;\nexports.JPoint = JPoint;\nexports.MontCurve = MontCurve;\nexports.MontPoint = MontPoint;\nexports.XPoint = XPoint;\nexports.EdwardsCurve = EdwardsCurve;\nexports.EdwardsPoint = EdwardsPoint;\nexports.curves = curves;\nexports.curve = curve;\nexports.register = register;","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/bcrypto/lib/js/elliptic.js"],"names":["require","custom","BN","types","AFFINE","JACOBIAN","PROJECTIVE","EXTENDED","jsfIndex","USE_FIXED","Curve","Point","type","conf","id","ossl","endian","hash","prefix","context","prime","p","red","fieldSize","fieldBits","adjustedSize","signBit","n","h","q","z","g","nh","scalarSize","scalarBits","mask","zero","one","two","three","four","i2","i3","i4","i6","torsion","endo","hi","_init","assert","Red","Array","isArray","Buffer","from","fromJSON","mont","precompute","byteLength","bitLength","mul","toRed","ushrn","redInvert","redSqr","redMul","word","i","length","point","_scale","memoize","isIsomorphic","isIsogenous","sign","isOdd","cmpn","Mask","pointFromJSON","k","bits","isNeg","neg","acc","jpoint","bit","dbl","add","points","coeffs","len","npoints","ncoeffs","max","coeff","Error","Math","j","rng","isZero","_simpleMul","_coZLadderMul","_ladderMul","getLadderBits","exp","a","toJ","clone","b","swap","uadd","udbl","c","getCOZBits","m1","zdblu","zaddc","zaddu","pre","windows","_getWindows","width","size","steps","doubles","_getDoubles","step","naf","getFixedNAF","I","nafW","sub","wnd","dblp","r","pos","w","_safeNAF","getNAF","ppoint","pcoeff","_getNAF","_getJNAF","getJNAF","nafw","curve","invert","eq","_scaleShort","_scaleMont","_scaleEdwards","isInfinity","num","base","imod","x","cast","forceRed","y","xx","xz","yy","yz","solveX2","redSqrt","solveY2","u","bytes","pake","isBuffer","s1","slice","s2","u1","decodeUniform","u2","p1","pointFromUniform","p2","p3","mulH","subgroup","p0","randomField","usub","hint","randomInt","pointToUniform","e","message","encodeUniform","concat","random","pointFromX","validate","jmulAll","jmulAllSimple","_endoWnafMulAdd","_wnafMulAdd","_simpleMulAdd","imulH","iushln","imuln","reduce","splitHash","clamp","encode","decode","fromRed","out","iumaskn","compact","b0","a0","toJSON","json","toString","redIsHigh","isub","undefined","d","s","NAF","toP","Windows","power","ceil","Doubles","blinding","blind","randomScalar","unblind","Blinding","t","iadd","randomize","flag","Precomp","beta","_getBeta","_getBlinding","scale","pow","jmulH","jmul","jmuln","jmulSimple","jmulBlind","jmulConst","k1","k2","jmulAdd","jmulAddSimple","jdiv","jdivn","jdivH","_hasWindows","_fixedMul","_hasDoubles","_fixedNafMul","_wnafMul","_blind","_constMul","normalize","ShortCurve","ShortPoint","ai","zi","zeroA","threeA","redNeg","redN","pmodn","highOrder","cmp","smallGap","_finalize","Endo","_getEndomorphism","mod","div","odd","_isomorphism","_findRS","redMuln","MontCurve","r3","redAdd","redSub","EdwardsCurve","redIAdd","r2","redIsOdd","redINeg","u4","redDiv","field","u6","u3","_scale0","_scale1","_short","nx","a3","bi","ny","a5","d5","dma","d5a","da5","ypz","ymz","redIMuln","index","modrn","_getEndoRoots","b1","b2","l1","l2","lambda","basis","_getEndoBasis","_getEndoPrecomp","r1","sort","_egcdSqrt","rl","tl","rl1","tl1","rl2","tl2","a1","lhs","sqr","rhs","a2","Vector","sqrtn","v","x1","y1","x2","y2","quo","v1","v2","shift","g1","divRound","g2","c1","c2","q1","ineg","q2","_endoBeta","_endoSplit","u0","i27","ushln","isubn","idivn","cinject","czero","u6i","redFermat","redISub","u6d27","u2d3","redPow","subn","z2","ba","bza","t1","alpha","redIsSquare","a2x2","abx2","b23","axb","sqrt","s0","n0","n1","d0","d1","divSqrt","gz","z3","t2","t3","t4","x3","y3","_svdwf","z4","gz2","x2z","xz2","c0","t0","t5","n2","n3","x0","s3","ceq","inf","JPoint","solveY","ad6","MontPoint","EdwardsPoint","cpoint","_sswu","_svdw","_sswui","_svdwi","encodeX","decodeEven","decodeSquare","pointFromShort","_mont","_edwards","isComplete","curveA","curveB","customA","redJacobi","xb","map","comb","cond","inf1","inf2","cswap","l","m","degenerate","negated","z1","zz","zzz","f","nz","redIsEven","getX","allocUnsafe","encodeField","copy","getY","form","decodeField","zOne","zOne1","zOne2","z6","aa","_mixedAdd","_add","_addAA","_addJA","_addJJ","z1z1","z2z2","hh","hhh","_dblA","_dbl0","_dbl3","_dblJ","yyyy","xyy2","xb2","delta","gamma","xmdelta","xpdelta","beta4","beta8","gamma28","_dblp","zzzz","redPown","_uadd","ll","inf3","_udbl","x4","y4","recover","zz1","zz2","zzz1","zzz2","rx","eqXToP","rn","a24","b3","wa","wb","redDivSqrt","_solveY0","y0","toX","ladderConst","XPoint","by2","nu","nv","uu","uz","vv","vz","_elligator2","_invert2","pointFromMont","customB","m2","double","xpoint","decodeX","ax2","bb","da","cb","dx","dz","ladder","ladderSimple","ladderBlind","diffAddDbl","diffAdd","toArray","si","smi","twisted","oneA","mOneA","smallD","alt","d2","d3","ad14","a2d","ad2","redDivn","apd","amd","ci","ci2","cm1","e0","e1","iushrn","e2","addn","u5","f0","f1","f2","X","Y","X1","rX","X12","nn","nr1","w2","YY","X2","Z","tt","tz","toMont","ad","amd4","_mulD","_mulA","dxy","xy","solveX","d24","x6","x12","divn","nt","_alt","pointFromEdwards","pointFromHash","pointToHash","curveD","_check","_addM1","_addA","xyxy","_dbl","setn","encodeAdjusted","decodeAdjusted","testn","pointFromY","top","and","iuxorn","or","iuand","iuor","off","scalar","func","constructor","push","item","P192","P224","P256","P384","P521","SECP256K1","BRAINPOOLP256","BRAINPOOLP384","BRAINPOOLP512","X25519","X448","MONT448","ED25519","ISO448","ED448","curves","__proto__","cache","name","key","toUpperCase","args","register","abs","andln","repr","getJSF","jsf","m14","m24","m8","ja","jb","k0","kb","nb","ub","vb","val","msg","err","captureStackTrace","randomBits","toNumber","method","self","WeakMap","memoized","get","result","call","has","set","exports"],"mappings":"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","sourcesContent":["/*!\n * elliptic.js - elliptic curves for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/elliptic:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/elliptic\n *\n * Formulas from DJB and Tanja Lange [EFD].\n *\n * References:\n *\n *   [GECC] Guide to Elliptic Curve Cryptography\n *     D. Hankerson, A. Menezes, and S. Vanstone\n *     https://tinyurl.com/guide-to-ecc\n *\n *   [GLV] Faster Point Multiplication on Elliptic Curves\n *     R. Gallant, R. Lambert, and S. Vanstone\n *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf\n *\n *   [MONT1] Montgomery curves and the Montgomery ladder\n *     Daniel J. Bernstein, Tanja Lange\n *     https://eprint.iacr.org/2017/293.pdf\n *\n *   [COZ] Scalar Multiplication on Elliptic Curves from Co-Z Arithmetic\n *     R. Goundar, M. Joye, A. Miyaji, M. Rivain, A. Venelli\n *     https://www.matthieurivain.com/files/jcen11b.pdf\n *\n *   [SQUARED] Elligator Squared\n *     Mehdi Tibouchi\n *     https://eprint.iacr.org/2014/043.pdf\n *\n *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group\n *     Certicom Research\n *     https://www.secg.org/sec1-v2.pdf\n *\n *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters\n *     Certicom Research\n *     https://www.secg.org/sec2-v2.pdf\n *\n *   [SIDE1] Elliptic Curves and Side-Channel Attacks\n *     Marc Joye\n *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf\n *\n *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications\n *     B. Feix, M. Roussellet, A. Venelli\n *     https://eprint.iacr.org/2014/191.pdf\n *\n *   [ALT] Alternative Elliptic Curve Representations\n *     R. Struik\n *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html\n *\n *   [ARITH1] Arithmetic of Elliptic Curves\n *     Christophe Doche, Tanja Lange\n *     Handbook of Elliptic and Hyperelliptic Curve Cryptography\n *     Page 267, Section 13 (978-1-58488-518-4)\n *     https://hyperelliptic.org/HEHCC/index.html\n *\n *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition\n *     Joseph H. Silverman\n *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf\n *\n *   [EFD] Explicit-Formulas Database\n *     Daniel J. Bernstein, Tanja Lange\n *     https://hyperelliptic.org/EFD/index.html\n *\n *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography\n *     Daniel J. Bernstein\n *     https://safecurves.cr.yp.to/\n *\n *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves\n *     Hairong Yi, Yuqing Zhu, and Dongdai Lin\n *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf\n *\n *   [ICART] How to Hash into Elliptic Curves\n *     Thomas Icart\n *     https://eprint.iacr.org/2009/226.pdf\n *\n *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\n *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi\n *     https://eprint.iacr.org/2009/340.pdf\n *\n *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields\n *     Maciej Ulas\n *     https://arxiv.org/abs/0706.1448\n *\n *   [H2EC] Hashing to Elliptic Curves\n *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood\n *     https://git.io/JeWz6\n *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve\n *\n *   [SVDW1] Construction of Rational Points on Elliptic Curves\n *     A. Shallue, C. E. van de Woestijne\n *     https://works.bepress.com/andrew_shallue/1/download/\n *\n *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves\n *     Pierre-Alain Fouque, Mehdi Tibouchi\n *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf\n *\n *   [SVDW3] Covert ECDH over secp256k1\n *     Pieter Wuille\n *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039\n *\n *   [MONT2] Montgomery Curve (wikipedia)\n *     https://en.wikipedia.org/wiki/Montgomery_curve\n *\n *   [SIDE2] Weierstrass Elliptic Curves and Side-Channel Attacks\n *     Eric Brier, Marc Joye\n *     http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.2.273&rep=rep1&type=pdf\n *\n *   [SIDE3] Unified Point Addition Formulae and Side-Channel Attacks\n *     Douglas Stebila, Nicolas Theriault\n *     https://eprint.iacr.org/2005/419.pdf\n *\n *   [MONT3] Montgomery Curves and their arithmetic\n *     C. Costello, B. Smith\n *     https://eprint.iacr.org/2017/212.pdf\n *\n *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings\n *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange\n *     https://elligator.cr.yp.to/elligator-20130828.pdf\n *\n *   [RFC7748] Elliptic Curves for Security\n *     A. Langley, M. Hamburg, S. Turner\n *     https://tools.ietf.org/html/rfc7748\n *\n *   [TWISTED] Twisted Edwards Curves\n *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters\n *     https://eprint.iacr.org/2008/013.pdf\n *\n *   [ELL1] Injective Encodings to Elliptic Curves\n *     P. Fouque, A. Joux, M. Tibouchi\n *     https://eprint.iacr.org/2013/373.pdf\n *\n *   [ISOGENY] Twisting Edwards curves with isogenies\n *     Mike Hamburg\n *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf\n *\n *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)\n *     S. Josefsson, SJD AB, I. Liusvaara\n *     https://tools.ietf.org/html/rfc8032\n *\n *   [TIMING] Remote Timing Attacks are Still Practical\n *     B. Brumley, N. Tuveri\n *     https://eprint.iacr.org/2011/232.pdf\n *\n *   [SCHNORR] Schnorr Signatures for secp256k1\n *     Pieter Wuille\n *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki\n *\n *   [BIP340] Schnorr Signatures for secp256k1\n *     Pieter Wuille, Jonas Nick, Tim Ruffing\n *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography\n *            on Sensor Networks Using the MSP430X Microcontroller\n *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez\n *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf\n *\n *   [FIPS186] Federal Information Processing Standards Publication\n *     National Institute of Standards and Technology\n *     https://tinyurl.com/fips-186-3\n *\n *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool\n *             Standard Curves and Curve Generation\n *     M. Lochter, BSI, J. Merkle\n *     https://tools.ietf.org/html/rfc5639\n *\n *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence\n *     Christopher Jeffrey\n *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc\n *\n *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)\n *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication\n */\n\n'use strict';\n\nconst {custom} = require('../internal/custom');\nconst BN = require('../bn');\n\n/*\n * Constants\n */\n\nconst types = {\n  AFFINE: 0,\n  JACOBIAN: 1,\n  PROJECTIVE: 2,\n  EXTENDED: 3\n};\n\nconst jsfIndex = [\n  -3, // -1 -1\n  -1, // -1 0\n  -5, // -1 1\n  -7, // 0 -1\n  0, // 0 0\n  7, // 0 1\n  5, // 1 -1\n  1, // 1 0\n  3  // 1 1\n];\n\nconst USE_FIXED = false;\n\n/**\n * Curve\n */\n\nclass Curve {\n  constructor(Point, type, conf) {\n    this.Point = null;\n    this.id = null;\n    this.ossl = null;\n    this.type = 'base';\n    this.endian = 'be';\n    this.hash = null;\n    this.prefix = null;\n    this.context = false;\n    this.prime = null;\n    this.p = null;\n    this.red = null;\n    this.fieldSize = 0;\n    this.fieldBits = 0;\n    this.adjustedSize = 0;\n    this.signBit = 0;\n    this.n = null;\n    this.h = null;\n    this.q = null;\n    this.z = null;\n    this.g = null;\n    this.nh = null;\n    this.scalarSize = 0;\n    this.scalarBits = 0;\n    this.mask = null;\n    this.zero = null;\n    this.one = null;\n    this.two = null;\n    this.three = null;\n    this.four = null;\n    this.i2 = null;\n    this.i3 = null;\n    this.i4 = null;\n    this.i6 = null;\n    this.torsion = null;\n    this.endo = null;\n    this.hi = null;\n    this._init(Point, type, conf);\n  }\n\n  _init(Point, type, conf) {\n    assert(typeof Point === 'function');\n    assert(typeof type === 'string');\n    assert(conf && typeof conf === 'object');\n    assert(conf.red == null || (conf.red instanceof BN.Red));\n    assert(conf.p != null, 'Must pass a prime.');\n    assert(conf.id == null || typeof conf.id === 'string');\n    assert(conf.ossl == null || typeof conf.ossl === 'string');\n    assert(conf.endian == null || typeof conf.endian === 'string');\n    assert(conf.hash == null || typeof conf.hash === 'string');\n    assert(conf.prefix == null || typeof conf.prefix === 'string');\n    assert(conf.context == null || typeof conf.context === 'boolean');\n    assert(conf.prime == null || typeof conf.prime === 'string');\n    assert(conf.torsion == null || Array.isArray(conf.torsion));\n\n    // Point class.\n    this.Point = Point;\n\n    // Meta.\n    this.id = conf.id || null;\n    this.ossl = conf.ossl || null;\n    this.type = type;\n    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');\n    this.hash = conf.hash || null;\n    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;\n    this.context = conf.context || false;\n    this.prime = conf.prime || null;\n\n    // Prime.\n    this.p = BN.fromJSON(conf.p);\n\n    // Reduction.\n    if (conf.red) {\n      this.red = conf.red;\n    } else {\n      // Use Montgomery when there is no fast reduction for the prime.\n      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n      this.red.precompute();\n    }\n\n    // Precalculate encoding length.\n    this.fieldSize = this.p.byteLength();\n    this.fieldBits = this.p.bitLength();\n    this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);\n    this.signBit = this.adjustedSize * 8 - 1;\n\n    // Curve configuration, optional.\n    this.n = BN.fromJSON(conf.n || '0');\n    this.h = BN.fromJSON(conf.h || '1');\n    this.q = this.n.mul(this.h);\n    this.z = BN.fromJSON(conf.z || '0').toRed(this.red);\n    this.g = null;\n    this.nh = this.n.ushrn(1);\n    this.scalarSize = this.n.byteLength();\n    this.scalarBits = this.n.bitLength();\n    this.mask = null;\n\n    // Useful for many curves.\n    this.zero = new BN(0).toRed(this.red);\n    this.one = new BN(1).toRed(this.red);\n    this.two = new BN(2).toRed(this.red);\n    this.three = new BN(3).toRed(this.red);\n    this.four = new BN(4).toRed(this.red);\n\n    // Inverses.\n    this.i2 = this.two.redInvert();\n    this.i3 = this.three.redInvert();\n    this.i4 = this.i2.redSqr();\n    this.i6 = this.i2.redMul(this.i3);\n\n    // Torsion.\n    this.torsion = new Array(this.h.word(0));\n\n    for (let i = 0; i < this.torsion.length; i++)\n      this.torsion[i] = this.point();\n\n    // Endomorphism.\n    this.endo = null;\n\n    // Cache.\n    this.hi = null;\n\n    // Memoize.\n    this._scale = memoize(this._scale, this);\n    this.isIsomorphic = memoize(this.isIsomorphic, this);\n    this.isIsogenous = memoize(this.isIsogenous, this);\n\n    // Sanity checks.\n    assert(this.p.sign() > 0 && this.p.isOdd());\n    assert(this.n.sign() >= 0);\n    assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);\n    assert(this.endian === 'be' || this.endian === 'le');\n\n    return this;\n  }\n\n  _finalize(conf) {\n    assert(conf && typeof conf === 'object');\n\n    // Create mask.\n    this.mask = new Mask(this);\n\n    // Create base point.\n    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();\n\n    // Parse small order points.\n    if (conf.torsion) {\n      assert(conf.torsion.length === this.torsion.length);\n\n      for (let i = 0; i < this.torsion.length; i++)\n        this.torsion[i] = this.pointFromJSON(conf.torsion[i]);\n    }\n\n    return this;\n  }\n\n  _simpleMul(p, k) {\n    // Left-to-right point multiplication.\n    //\n    // [GECC] Algorithm 3.27, Page 97, Section 3.3.\n    //        Algorithm 3.26, Page 96, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    // We prefer left-to-right since it\n    // allows us to repeatedly add an\n    // affine point to the accumulator.\n    const bits = k.bitLength();\n\n    // Flip sign if necessary.\n    if (k.isNeg())\n      p = p.neg();\n\n    // Multiply.\n    let acc = this.jpoint();\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n\n      acc = acc.dbl();\n\n      if (bit === 1)\n        acc = acc.add(p);\n    }\n\n    return acc;\n  }\n\n  _simpleMulAdd(points, coeffs) {\n    // Multiple point multiplication, also known\n    // as \"Shamir's trick\".\n    //\n    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n\n    const len = points.length;\n    const npoints = new Array(len);\n    const ncoeffs = coeffs;\n\n    // Check arrays and calculate size.\n    let max = 0;\n\n    for (let i = 0; i < len; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n\n      assert(point instanceof Point);\n      assert(coeff instanceof BN);\n      assert(!coeff.red);\n\n      if (i > 0 && point.type !== points[i - 1].type)\n        throw new Error('Cannot mix points.');\n\n      // Flip signs if necessary.\n      npoints[i] = coeff.isNeg() ? point.neg() : point;\n\n      // Compute max scalar size.\n      max = Math.max(max, coeff.bitLength());\n    }\n\n    // Multiply and add.\n    let acc = this.jpoint();\n\n    for (let i = max - 1; i >= 0; i--) {\n      acc = acc.dbl();\n\n      for (let j = 0; j < len; j++) {\n        const point = npoints[j];\n        const coeff = ncoeffs[j];\n        const bit = coeff.bit(i);\n\n        if (bit === 1)\n          acc = acc.add(point);\n      }\n    }\n\n    return acc;\n  }\n\n  _constMul(p, k, rng) {\n    assert(p instanceof Point);\n\n    // Must have order.\n    if (this.n.isZero())\n      return this._simpleMul(p, k);\n\n    // Use Co-Z arithmetic for Weierstrass (h=1).\n    if (this.type === 'short' && this.h.cmpn(1) === 0)\n      return this._coZLadderMul(p, k);\n\n    // Otherwise, a regular ladder.\n    return this._ladderMul(p, k);\n  }\n\n  _ladderMul(p, k) {\n    // Generalized Montgomery Ladder.\n    //\n    // [MONT1] Page 24, Section 4.6.2.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    // Curve must expose some form of unified\n    // addition (this is easier said than done\n    // for Weierstrass curves). This ensures\n    // both branches of the ladder consume\n    // the same power and number of cycles.\n    //\n    // We implement the ladder as a branchless\n    // function with a constant time swap.\n    //\n    // Current cost:\n    //\n    //   N * (14M + 14S + 11A + 2*a + 1*8 + 3*4 + 2*3 + 4*2)\n    //\n    //   N=256 => 3584M + 3584S + 2816A + 512*a\n    //          + 256*8 + 768*4 + 512*3 + 1024*2\n    const [sign, bits, exp] = getLadderBits(k, this.q);\n\n    // Clone points (for safe swapping).\n    let a = p.toJ().clone();\n    let b = this.jpoint().clone();\n    let swap = 0;\n\n    // Climb the ladder.\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = (exp[i >> 3] >> (i & 7)) & 1;\n\n      // Maybe swap.\n      a.swap(b, swap ^ bit);\n\n      // Unified addition.\n      a = a.uadd(b);\n      b = b.udbl();\n\n      swap = bit;\n    }\n\n    // Finalize loop.\n    a.swap(b, swap);\n\n    // Flip sign retroactively.\n    b.swap(b.neg(), sign);\n\n    return b;\n  }\n\n  _coZLadderMul(p, k) {\n    // Co-Z Montgomery Ladder.\n    //\n    // [COZ] Algorithm 9, Page 6, Section 4.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    // Multiply with Co-Z arithmetic. This method is\n    // 2x faster than our regular unified addition\n    // ladder. However, there are some problems with\n    // leakage of the scalar length.\n    //\n    // There are three issues with this algorithm:\n    //\n    //   1. The amount of steps in the ladder is not\n    //      constant, since we must assume k[n-1]=1\n    //      (it follows that k[n]=0). A side effect\n    //      of this is that we cannot handle a point\n    //      at infinity (k[n-1]=0).\n    //\n    //   2. On the off chance we pass in a \"low\"\n    //      scalar (lacking several hi bits), there\n    //      will be a noticeable difference in cycles.\n    //\n    //   3. The algorithm cannot handle k = -1 mod n.\n    //      It will overflow to infinity.\n    //\n    // To avoid two of these issues, we _negate_ the\n    // scalar in the event that bits(k) < bits(-k). If\n    // we do end up negating a scalar, we negate the\n    // resulting point in constant time at the end.\n    //\n    // Doing this not only solves the point at infinity\n    // issue (i.e. N-0=N=0), but it also ensures a scalar\n    // is within at least 1 bit of the order (usually).\n    //\n    // The final edge case can be solved with a\n    // comparison and subsequent constant-time swap at\n    // the end.\n    //\n    // Note that our scalar recoding here disallows\n    // the possibility of curves with a cofactor > 1.\n    //\n    // A possibility for a perf improvement involves\n    // using the ZACAU method. This is faster assuming\n    // a cost of 1S < 1M, but our squaring impl. is\n    // identical to our multiplication impl., so we\n    // wouldn't get any real benefit.\n    //\n    // Current cost:\n    //\n    //   1M + 5S + 8A + 4*2 + 1*8\n    //   N * (11M + 3S + 21A + 1*2)\n    //\n    //   N=256 => 2817M + 773S + 5384A + 256*2 + 4*2 + 1*8\n    const c = p.toJ().clone();\n    const [sign, bits, exp, m1] = getCOZBits(k, this.n);\n\n    // Initial double (we assume k[n-1] == 1).\n    let [a, b] = c.zdblu();\n    let swap = 0;\n\n    // Climb the ladder.\n    for (let i = bits - 2; i >= 0; i--) {\n      const bit = (exp[i >> 3] >> (i & 7)) & 1;\n\n      // Maybe swap.\n      a.swap(b, swap ^ bit);\n\n      // Co-Z addition.\n      [a, b] = b.zaddc(a);\n      [b, a] = a.zaddu(b);\n\n      swap = bit;\n    }\n\n    // Finalize loop.\n    a.swap(b, swap);\n\n    // Final edge case.\n    b.swap(c.neg(), m1);\n\n    // Adjust sign.\n    b.swap(b.neg(), sign);\n\n    return b;\n  }\n\n  _fixedMul(p, k) {\n    // Fixed-base method for point multiplication.\n    //\n    // [ECPM] \"Windowed method\".\n    // [GECC] Page 95, Section 3.3.\n    //\n    // Windows are appropriately shifted to avoid any\n    // doublings. This reduces a 256 bit multiplication\n    // down to 64 additions with a window size of 4.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(p.pre && p.pre.windows);\n\n    // Get precomputed windows.\n    const {width, bits, points} = p._getWindows(0, 0);\n\n    // Recompute window size.\n    const size = 1 << width;\n\n    // Recompute steps.\n    const steps = ((bits + width - 1) / width) >>> 0;\n\n    // Multiply.\n    let acc = this.jpoint();\n\n    for (let i = 0; i < steps; i++) {\n      const bits = k.bits(i * width, width);\n\n      acc = acc.add(points[i * size + bits]);\n    }\n\n    // Adjust sign.\n    if (k.isNeg())\n      acc = acc.neg();\n\n    return acc;\n  }\n\n  _fixedNafMul(p, k) {\n    // Fixed-base NAF windowing method for point multiplication.\n    //\n    // [GECC] Algorithm 3.42, Page 105, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(p.pre && p.pre.doubles);\n\n    // Get precomputed doubles.\n    const {step, points} = p._getDoubles(0, 0);\n\n    // Get fixed NAF (in a more windowed form).\n    const naf = getFixedNAF(k, 1, k.bitLength() + 1, step);\n\n    // Compute steps.\n    const I = ((1 << (step + 1)) - (step % 2 === 0 ? 2 : 1)) / 3;\n\n    // Multiply.\n    let a = this.jpoint();\n    let b = this.jpoint();\n\n    for (let i = I; i > 0; i--) {\n      for (let j = 0; j < naf.length; j++) {\n        const nafW = naf[j];\n\n        if (nafW === i)\n          b = b.add(points[j]);\n        else if (nafW === -i)\n          b = b.sub(points[j]);\n      }\n\n      a = a.add(b);\n    }\n\n    return a;\n  }\n\n  _windowMul(width, p, k) {\n    // Windowed method for point multiplication.\n    //\n    // [ECPM] \"Windowed method\".\n    // [GECC] Page 95, Section 3.3.\n    assert((width >>> 0) === width);\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n\n    const size = 1 << width;\n    const bits = Math.max(k.bitLength(), this.n.bitLength());\n    const steps = ((bits + width - 1) / width) >>> 0;\n    const wnd = new Array(size);\n    const point = p.toJ();\n\n    // Precompute.\n    wnd[0] = this.jpoint();\n    wnd[1] = point;\n\n    for (let i = 2; i < size; i += 2) {\n      wnd[i + 0] = wnd[i >> 1].dbl();\n      wnd[i + 1] = wnd[i].add(point);\n    }\n\n    // Multiply.\n    let acc = this.jpoint();\n\n    for (let i = steps - 1; i >= 0; i--) {\n      const bits = k.bits(i * width, width);\n\n      if (i === steps - 1) {\n        acc = wnd[bits];\n      } else {\n        acc = acc.dblp(width);\n        acc = acc.add(wnd[bits]);\n      }\n    }\n\n    // Adjust sign.\n    if (k.isNeg())\n      acc = acc.neg();\n\n    return acc;\n  }\n\n  _slideMul(width, p, k) {\n    // Sliding window method for point multiplication.\n    //\n    // [ECPM] \"Sliding-window method\".\n    // [GECC] Algorithm 3.38, Page 101, Section 3.3.\n    assert((width >>> 0) === width);\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n\n    const size = 1 << (width - 1);\n    const wnd = new Array(size);\n    const point = p.toJ();\n\n    // Precompute.\n    wnd[0] = point.dblp(width - 1);\n    wnd[1] = wnd[0].add(point);\n\n    for (let i = 2; i < size; i++)\n      wnd[i] = wnd[i - 1].add(point);\n\n    // Multiply.\n    let i = k.bitLength();\n    let r = this.jpoint();\n\n    while (i >= width) {\n      const pos = i - width;\n      const bits = k.bits(pos, width);\n\n      if (bits < size) {\n        r = r.dbl();\n        i -= 1;\n        continue;\n      }\n\n      r = r.dblp(width);\n      r = r.add(wnd[bits & ~size]);\n      i = pos;\n    }\n\n    // Finish.\n    if (i > 0) {\n      const bits = k.bits(0, i);\n\n      while (i--) {\n        r = r.dbl();\n\n        if ((bits >> i) & 1)\n          r = r.add(p);\n      }\n    }\n\n    // Adjust sign.\n    if (k.isNeg())\n      r = r.neg();\n\n    return r;\n  }\n\n  _wnafMul(w, p, k) {\n    // Window NAF method for point multiplication.\n    //\n    // [GECC] Algorithm 3.36, Page 100, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n\n    // Precompute window.\n    const {width, points} = p._safeNAF(w);\n\n    // Get NAF form.\n    const naf = getNAF(k, width, k.bitLength() + 1);\n\n    // Add `this`*(N+1) for every w-NAF index.\n    let acc = this.jpoint();\n\n    for (let i = naf.length - 1; i >= 0; i--) {\n      const z = naf[i];\n\n      if (i !== naf.length - 1)\n        acc = acc.dbl();\n\n      if (z > 0)\n        acc = acc.add(points[(z - 1) >> 1]);\n      else if (z < 0)\n        acc = acc.sub(points[(-z - 1) >> 1]);\n    }\n\n    return acc;\n  }\n\n  _wnafMulAdd(w, points, coeffs) {\n    // Multiple point multiplication, also known\n    // as \"Shamir's trick\" (with interleaved NAFs).\n    //\n    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n    //        Algorithm 3.51, Page 112, Section 3.3.\n    //\n    // This is particularly useful for signature\n    // verifications and mutiplications after an\n    // endomorphism split.\n    assert((w >>> 0) === w);\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n\n    const length = points.length;\n    const wnd = new Array(length);\n    const naf = new Array(length);\n\n    // Check arrays and calculate size.\n    let max = 0;\n\n    for (let i = 0; i < length; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n\n      assert(point instanceof Point);\n      assert(coeff instanceof BN);\n\n      if (i > 0 && point.type !== points[i - 1].type)\n        throw new Error('Cannot mix points.');\n\n      // Avoid sparse arrays.\n      wnd[i] = null;\n      naf[i] = null;\n\n      // Compute max scalar size.\n      max = Math.max(max, coeff.bitLength() + 1);\n    }\n\n    // Compute NAFs.\n    let ppoint = null;\n    let pcoeff = null;\n    let len = 0;\n\n    for (let i = 0; i < length; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n      const pre = point._getNAF(0);\n\n      // Use precomputation if available.\n      if (pre) {\n        wnd[len] = pre.points;\n        naf[len] = getNAF(coeff, pre.width, max);\n        len += 1;\n        continue;\n      }\n\n      // Save last non-precomputed point.\n      if (!ppoint) {\n        ppoint = point;\n        pcoeff = coeff;\n        continue;\n      }\n\n      // Compute JSF in NAF form.\n      wnd[len] = ppoint._getJNAF(point);\n      naf[len] = getJNAF(pcoeff, coeff, max);\n\n      ppoint = null;\n      pcoeff = null;\n\n      len += 1;\n    }\n\n    // Regular NAF for odd points.\n    if (ppoint) {\n      const nafw = ppoint._safeNAF(w);\n\n      wnd[len] = nafw.points;\n      naf[len] = getNAF(pcoeff, nafw.width, max);\n\n      len += 1;\n    }\n\n    // Multiply and add.\n    let acc = this.jpoint();\n\n    for (let i = max - 1; i >= 0; i--) {\n      if (i !== max - 1)\n        acc = acc.dbl();\n\n      for (let j = 0; j < len; j++) {\n        const z = naf[j][i];\n\n        if (z > 0)\n          acc = acc.add(wnd[j][(z - 1) >> 1]);\n        else if (z < 0)\n          acc = acc.sub(wnd[j][(-z - 1) >> 1]);\n      }\n    }\n\n    return acc;\n  }\n\n  _endoWnafMulAdd(points, coeffs) {\n    throw new Error('Not implemented.');\n  }\n\n  _scale(curve, invert) {\n    assert(curve instanceof Curve);\n    assert(curve.p.eq(this.p));\n\n    switch (curve.type) {\n      case 'short':\n        return this._scaleShort(curve, invert);\n      case 'mont':\n        return this._scaleMont(curve, invert);\n      case 'edwards':\n        return this._scaleEdwards(curve, invert);\n      default:\n        throw new Error('Not implemented.');\n    }\n  }\n\n  _scaleShort(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  _scaleMont(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  _scaleEdwards(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  isElliptic() {\n    throw new Error('Not implemented.');\n  }\n\n  jinv() {\n    throw new Error('Not implemented.');\n  }\n\n  isComplete() {\n    return false;\n  }\n\n  precompute(rng) {\n    assert(!this.g.isInfinity(), 'Must have base point.');\n    assert(!this.n.isZero(), 'Must have order.');\n\n    this.g.precompute(this.n.bitLength(), rng);\n\n    return this;\n  }\n\n  scalar(num, base, endian) {\n    const k = new BN(num, base, endian);\n\n    assert(!k.red);\n\n    if (this.n.isZero())\n      return k;\n\n    return k.imod(this.n);\n  }\n\n  field(num, base, endian) {\n    const x = BN.cast(num, base, endian);\n\n    if (x.red)\n      return x.forceRed(this.red);\n\n    return x.toRed(this.red);\n  }\n\n  point(x, y) {\n    throw new Error('Not implemented.');\n  }\n\n  jpoint(x, y, z) {\n    throw new Error('Not implemented.');\n  }\n\n  xpoint(x, z) {\n    throw new Error('Not implemented.');\n  }\n\n  cpoint(xx, xz, yy, yz) {\n    assert(xx instanceof BN);\n    assert(xz instanceof BN);\n    assert(yy instanceof BN);\n    assert(yz instanceof BN);\n\n    if (xz.isZero() || yz.isZero())\n      return this.point();\n\n    const z = xz.redMul(yz).redInvert();\n    const x = xx.redMul(yz).redMul(z);\n    const y = yy.redMul(xz).redMul(z);\n\n    return this.point(x, y);\n  }\n\n  solveX2(y) {\n    throw new Error('Not implemented.');\n  }\n\n  solveX(y) {\n    return this.solveX2(y).redSqrt();\n  }\n\n  solveY2(x) {\n    throw new Error('Not implemented.');\n  }\n\n  solveY(x) {\n    return this.solveY2(x).redSqrt();\n  }\n\n  validate(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromX(x, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromY(y, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  isIsomorphic(curve) {\n    throw new Error('Not implemented.');\n  }\n\n  isIsogenous(curve) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromShort(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    throw new Error('Not implemented.');\n  }\n\n  pointToUniform(p) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromHash(bytes, pake = false) {\n    // [H2EC] \"Roadmap\".\n    assert(Buffer.isBuffer(bytes));\n    assert(typeof pake === 'boolean');\n\n    if (bytes.length !== this.fieldSize * 2)\n      throw new Error('Invalid hash size.');\n\n    // Random oracle encoding.\n    // Ensure a proper distribution.\n    const s1 = bytes.slice(0, this.fieldSize);\n    const s2 = bytes.slice(this.fieldSize);\n    const u1 = this.decodeUniform(s1);\n    const u2 = this.decodeUniform(s2);\n    const p1 = this.pointFromUniform(u1);\n    const p2 = this.pointFromUniform(u2);\n    const p3 = p1.uadd(p2);\n\n    return pake ? p3.mulH() : p3;\n  }\n\n  pointToHash(p, subgroup, rng) {\n    // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n    assert(p instanceof this.Point);\n    assert((subgroup >>> 0) === subgroup);\n\n    // Add a random torsion component.\n    const i = subgroup % this.torsion.length;\n    const p0 = p.add(this.torsion[i]);\n\n    // Average Cost (R = sqrt):\n    //\n    //   SSWU (~4 iterations) => 8I + 16R\n    //   SVDW (~4 iterations) => 12I + 28R\n    //   Elligator 1 (~2 iterations) => 6I + 10R\n    //   Elligator 2 (~2 iterations) => 4I + 6R\n    //   Ristretto (~1 iteration) => 1I + 2R + h*1R\n    for (;;) {\n      const u1 = this.randomField(rng);\n      const p1 = this.pointFromUniform(u1);\n\n      // Avoid 2-torsion points:\n      //   Short Weierstrass: ((A / 3) / B, 0)\n      //   Montgomery: (0, 0)\n      //   Twisted Edwards: (0, -1)\n      if (p1.neg().eq(p1))\n        continue;\n\n      const p2 = p0.usub(p1);\n      const hint = randomInt(rng);\n\n      let u2;\n      try {\n        u2 = this.pointToUniform(p2, hint & 15);\n      } catch (e) {\n        if (e.message === 'Invalid point.')\n          continue;\n        throw e;\n      }\n\n      const s1 = this.encodeUniform(u1, hint >>> 8);\n      const s2 = this.encodeUniform(u2, hint >>> 16);\n\n      return Buffer.concat([s1, s2]);\n    }\n  }\n\n  randomScalar(rng) {\n    const max = this.n.isZero() ? this.p : this.n;\n    return BN.random(rng, 1, max);\n  }\n\n  randomField(rng) {\n    return BN.random(rng, 1, this.p).toRed(this.red);\n  }\n\n  randomPoint(rng) {\n    let p;\n\n    for (;;) {\n      const x = this.randomField(rng);\n      const sign = (randomInt(rng) & 1) !== 0;\n\n      try {\n        p = this.pointFromX(x, sign);\n      } catch (e) {\n        continue;\n      }\n\n      assert(p.validate());\n\n      return p.mulH();\n    }\n  }\n\n  mulAll(points, coeffs) {\n    return this.jmulAll(points, coeffs);\n  }\n\n  mulAllSimple(points, coeffs) {\n    return this.jmulAllSimple(points, coeffs);\n  }\n\n  jmulAll(points, coeffs) {\n    assert(Array.isArray(points));\n    assert(points.length === 0 || (points[0] instanceof Point));\n\n    // Multiply with endomorphism if we're using affine points.\n    if (this.endo && points.length > 0 && points[0].type === types.AFFINE)\n      return this._endoWnafMulAdd(points, coeffs);\n\n    // Otherwise, a regular Shamir's trick.\n    return this._wnafMulAdd(4, points, coeffs);\n  }\n\n  jmulAllSimple(points, coeffs) {\n    return this._simpleMulAdd(points, coeffs);\n  }\n\n  mulH(k) {\n    assert(k instanceof BN);\n    return this.imulH(k.clone());\n  }\n\n  imulH(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    const word = this.h.word(0);\n\n    // Optimize for powers of two.\n    if ((word & (word - 1)) === 0) {\n      const bits = this.h.bitLength();\n      return k.iushln(bits - 1).imod(this.n);\n    }\n\n    return k.imuln(word).imod(this.n);\n  }\n\n  reduce(k) {\n    return this.mask.reduce(k);\n  }\n\n  splitHash(bytes) {\n    return this.mask.splitHash(bytes);\n  }\n\n  clamp(bytes) {\n    return this.mask.clamp(bytes);\n  }\n\n  encodeField(x) {\n    // [SEC1] Page 12, Section 2.3.5.\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    return x.encode(this.endian, this.fieldSize);\n  }\n\n  decodeField(bytes) {\n    // [SEC1] Page 13, Section 2.3.6.\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.fieldSize)\n      throw new Error('Invalid field element size.');\n\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeAdjusted(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    return x.encode(this.endian, this.adjustedSize);\n  }\n\n  decodeAdjusted(bytes) {\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.adjustedSize)\n      throw new Error('Invalid field element size.');\n\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeScalar(k) {\n    // [SEC1] Page 13, Section 2.3.7.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    return k.encode(this.endian, this.scalarSize);\n  }\n\n  decodeScalar(bytes) {\n    // [SEC1] Page 14, Section 2.3.8.\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.scalarSize)\n      throw new Error('Invalid scalar size.');\n\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeUniform(r, bits) {\n    assert(r instanceof BN);\n    assert((bits >>> 0) === bits);\n\n    let mask = 0xff;\n\n    if ((this.fieldBits & 7) !== 0)\n      mask = (1 << (this.fieldBits & 7)) - 1;\n\n    const x = r.fromRed();\n    const i = this.endian === 'le' ? this.fieldSize - 1 : 0;\n    const out = x.encode(this.endian, this.fieldSize);\n\n    out[i] |= (bits & ~mask) & 0xff;\n\n    return out;\n  }\n\n  decodeUniform(bytes) {\n    assert(Buffer.isBuffer(bytes));\n\n    if (bytes.length !== this.fieldSize)\n      throw new Error('Invalid field size.');\n\n    const x = BN.decode(bytes, this.endian);\n\n    x.iumaskn(this.fieldBits);\n\n    return x.toRed(this.red);\n  }\n\n  encodePoint(point, compact) {\n    assert(point instanceof Point);\n    return point.encode(compact);\n  }\n\n  decodePoint(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  encodeX(point) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeX(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeEven(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeSquare(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  toShort() {\n    throw new Error('Not implemented.');\n  }\n\n  toMont(b0) {\n    throw new Error('Not implemented.');\n  }\n\n  toEdwards(a0) {\n    throw new Error('Not implemented.');\n  }\n\n  pointToJSON(point, pre) {\n    assert(point instanceof Point);\n    return point.toJSON(pre);\n  }\n\n  pointFromJSON(json) {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON(pre) {\n    let prefix, context;\n    let n, z, endo;\n\n    if (this.type === 'edwards') {\n      prefix = this.prefix ? this.prefix.toString() : null;\n      context = this.context;\n    }\n\n    if (!this.n.isZero())\n      n = this.n.toJSON();\n\n    if (!this.z.isZero()) {\n      z = this.z.fromRed();\n\n      if (this.z.redIsHigh())\n        z.isub(this.p);\n\n      z = z.toString(16);\n    }\n\n    if (this.endo)\n      endo = this.endo.toJSON();\n\n    return {\n      id: this.id,\n      ossl: this.ossl,\n      type: this.type,\n      endian: this.endian,\n      hash: this.hash,\n      prefix,\n      context,\n      prime: this.prime,\n      p: this.p.toJSON(),\n      a: undefined,\n      b: undefined,\n      d: undefined,\n      n,\n      h: this.h.toString(16),\n      s: undefined,\n      z,\n      c: undefined,\n      g: this.g.toJSON(pre),\n      endo\n    };\n  }\n\n  static fromJSON(json) {\n    return new this(json);\n  }\n}\n\n/**\n * Point\n */\n\nclass Point {\n  constructor(curve, type) {\n    assert(curve instanceof Curve);\n    assert((type >>> 0) === type);\n\n    this.curve = curve;\n    this.type = type;\n    this.pre = null;\n  }\n\n  _init() {\n    throw new Error('Not implemented.');\n  }\n\n  _getNAF(width) {\n    assert((width >>> 0) === width);\n\n    if (this.pre && this.pre.naf)\n      return this.pre.naf;\n\n    if (width === 0)\n      return null;\n\n    const size = 1 << (width - 1);\n    const points = new Array(size);\n    const dbl = size === 1 ? null : this.dbl();\n\n    points[0] = this;\n\n    for (let i = 1; i < size; i++)\n      points[i] = points[i - 1].add(dbl);\n\n    return new NAF(width, points);\n  }\n\n  _safeNAF(width) {\n    return this._getNAF(width);\n  }\n\n  _getWindows(width, bits) {\n    assert((width >>> 0) === width);\n    assert((bits >>> 0) === bits);\n\n    if (this.pre && this.pre.windows)\n      return this.pre.windows;\n\n    if (width === 0)\n      return null;\n\n    const size = 1 << width;\n    const steps = ((bits + width - 1) / width) >>> 0;\n    const points = new Array(steps * size);\n\n    let g = this.toP();\n\n    for (let i = 0; i < steps; i++) {\n      points[i * size] = this.curve.point();\n\n      for (let j = 1; j < size; j++)\n        points[i * size + j] = points[i * size + j - 1].add(g);\n\n      g = g.dblp(width);\n    }\n\n    return new Windows(width, bits, points);\n  }\n\n  _getDoubles(step, power) {\n    assert((step >>> 0) === step);\n    assert((power >>> 0) === power);\n\n    if (this.pre && this.pre.doubles)\n      return this.pre.doubles;\n\n    if (step === 0)\n      return null;\n\n    const len = Math.ceil(power / step) + 1;\n    const points = new Array(len);\n\n    let acc = this;\n    let k = 0;\n\n    points[k++] = acc;\n\n    for (let i = 0; i < power; i += step) {\n      for (let j = 0; j < step; j++)\n        acc = acc.dbl();\n\n      points[k++] = acc;\n    }\n\n    assert(k === len);\n\n    return new Doubles(step, points);\n  }\n\n  _getBeta() {\n    return null;\n  }\n\n  _getBlinding(rng) {\n    if (this.pre && this.pre.blinding)\n      return this.pre.blinding;\n\n    if (!rng)\n      return null;\n\n    if (this.curve.n.isZero())\n      return null;\n\n    // Pregenerate a random blinding value:\n    //\n    //   blind = random integer in [1,n-1]\n    //   unblind = G * blind\n    //\n    // We intend to subtract the blinding value\n    // from scalars before multiplication. We\n    // can add the unblinding point once the\n    // multiplication is complete.\n    const blind = this.curve.randomScalar(rng);\n    const unblind = this.mul(blind);\n\n    return new Blinding(blind, unblind);\n  }\n\n  _hasWindows(k) {\n    assert(k instanceof BN);\n\n    if (!this.pre || !this.pre.windows)\n      return false;\n\n    const {bits} = this.pre.windows;\n\n    return bits >= k.bitLength();\n  }\n\n  _hasDoubles(k) {\n    assert(k instanceof BN);\n\n    if (!this.pre || !this.pre.doubles)\n      return false;\n\n    const {step, points} = this.pre.doubles;\n    const power = k.bitLength() + 1;\n\n    return points.length >= Math.ceil(power / step) + 1;\n  }\n\n  _getJNAF(point) {\n    assert(point instanceof Point);\n    assert(point.type === this.type);\n\n    // Create comb for JSF.\n    return [\n      this, // 1\n      this.add(point), // 3\n      this.sub(point), // 5\n      point // 7\n    ];\n  }\n\n  _blind(k, rng) {\n    // [SIDE1] Page 5, Section 4.\n    // [BLIND] Page 20, Section 7.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    // Scalar splitting (requires precomputation).\n    //\n    // Blind a multiplication by first subtracting\n    // a blinding value from the scalar. Example:\n    //\n    //   b = random integer in [1,n-1]\n    //   B = P * b (precomputed)\n    //   Q = P * (k - b) + B\n    //\n    // Note that Joye describes a different method\n    // (multiplier randomization) which computes:\n    //\n    //   B = random point in E\n    //   Q = (P + B) * k - B * k\n    //\n    // Our method is more similar to the \"scalar\n    // splitting\" technique described in the\n    // second source above.\n    //\n    // The blinding value and its corresponding\n    // point are randomly generated and computed\n    // on boot. As long as an attacker is not\n    // able to observe the boot, this should give\n    // a decent bit of protection against various\n    // channel attacks.\n    if (this.pre && this.pre.blinding) {\n      const {blind, unblind} = this.pre.blinding;\n      const t = k.sub(blind);\n\n      return [this, t, unblind];\n    }\n\n    // Randomization is not possible without\n    // an RNG. Do a normal multiplication.\n    if (!rng)\n      return [this, k, null];\n\n    // If we have no precomputed blinding\n    // factor, there are two possibilities\n    // for randomization:\n    //\n    // 1. Randomize the multiplier by adding\n    //    a random multiple of `n`.\n    //\n    // 2. Re-scale the point itself by a\n    //    random factor.\n    //\n    // The first option can be accomplished\n    // with some like:\n    //\n    //   a = random integer in [1,n-1]\n    //   r = a * n\n    //   Q = P * (k + r)\n    //\n    // The second is accomplished with:\n    //\n    //   a = random element in F(p)\n    //   R = (x * a^2, y * a^3, z * a)\n    //   Q = R * k\n    //\n    // If we have precomputed doubles / naf\n    // points, we opt for the first method\n    // to avoid randomizing everything.\n    if (this.pre) {\n      if (this.curve.n.isZero())\n        return [this, k, null];\n\n      const a = this.curve.randomScalar(rng);\n      const r = a.mul(this.curve.n);\n      const t = r.iadd(k);\n\n      return [this, t, null];\n    }\n\n    // If there is no precomputation _at all_,\n    // we opt for the second method.\n    const p = this.randomize(rng);\n\n    return [p, k, null];\n  }\n\n  clone() {\n    throw new Error('Not implemented.');\n  }\n\n  swap(point, flag) {\n    throw new Error('Not implemented.');\n  }\n\n  precompute(bits, rng) {\n    assert((bits >>> 0) === bits);\n\n    if (!this.pre)\n      this.pre = new Precomp();\n\n    if (!this.pre.naf)\n      this.pre.naf = this._getNAF(8);\n\n    if (USE_FIXED && !this.pre.windows)\n      this.pre.windows = this._getWindows(4, bits);\n\n    if (!this.pre.doubles)\n      this.pre.doubles = this._getDoubles(4, bits + 1);\n\n    if (!this.pre.beta)\n      this.pre.beta = this._getBeta();\n\n    if (!this.pre.blinding)\n      this.pre.blinding = this._getBlinding(rng);\n\n    return this;\n  }\n\n  validate() {\n    return this.curve.validate(this);\n  }\n\n  normalize() {\n    return this;\n  }\n\n  scale(a) {\n    throw new Error('Not implemented.');\n  }\n\n  randomize(rng) {\n    const z = this.curve.randomField(rng);\n    return this.scale(z);\n  }\n\n  neg() {\n    throw new Error('Not implemented.');\n  }\n\n  add(point) {\n    throw new Error('Not implemented.');\n  }\n\n  sub(point) {\n    assert(point instanceof Point);\n    return this.add(point.neg());\n  }\n\n  dbl() {\n    throw new Error('Not implemented.');\n  }\n\n  dblp(pow) {\n    // Repeated doubling. This can\n    // be optimized by child classes.\n    assert((pow >>> 0) === pow);\n\n    let r = this;\n\n    for (let i = 0; i < pow; i++)\n      r = r.dbl();\n\n    return r;\n  }\n\n  uadd(point) {\n    throw new Error('Not implemented.');\n  }\n\n  usub(point) {\n    assert(point instanceof Point);\n    return this.uadd(point.neg());\n  }\n\n  udbl() {\n    throw new Error('Not implemented.');\n  }\n\n  zaddu(point) {\n    throw new Error('Not implemented.');\n  }\n\n  zaddc(point) {\n    throw new Error('Not implemented.');\n  }\n\n  zdblu() {\n    throw new Error('Not implemented.');\n  }\n\n  diffAdd(p, q) {\n    throw new Error('Not implemented.');\n  }\n\n  diffAddDbl(p, q) {\n    throw new Error('Not implemented.');\n  }\n\n  recover() {\n    throw new Error('Not implemented.');\n  }\n\n  getX() {\n    throw new Error('Not implemented.');\n  }\n\n  getY() {\n    throw new Error('Not implemented.');\n  }\n\n  eq(point) {\n    throw new Error('Not implemented.');\n  }\n\n  isInfinity() {\n    throw new Error('Not implemented.');\n  }\n\n  isOdd() {\n    throw new Error('Not implemented.');\n  }\n\n  isEven() {\n    throw new Error('Not implemented.');\n  }\n\n  isSquare() {\n    throw new Error('Not implemented.');\n  }\n\n  eqX(x) {\n    throw new Error('Not implemented.');\n  }\n\n  eqXToP(x) {\n    throw new Error('Not implemented.');\n  }\n\n  isSmall() {\n    // Test whether the point is of small order.\n    if (this.isInfinity())\n      return false;\n\n    // P * h = O\n    return this.jmulH().isInfinity();\n  }\n\n  hasTorsion() {\n    // Test whether the point is in another subgroup.\n    if (this.isInfinity())\n      return false;\n\n    // P * n != O\n    return !this.jmul(this.curve.n).isInfinity();\n  }\n\n  mul(k) {\n    return this.jmul(k);\n  }\n\n  muln(k) {\n    return this.jmuln(k);\n  }\n\n  mulSimple(k) {\n    return this.jmulSimple(k);\n  }\n\n  mulBlind(k, rng) {\n    return this.jmulBlind(k, rng);\n  }\n\n  mulConst(k, rng) {\n    return this.jmulConst(k, rng);\n  }\n\n  mulAdd(k1, p2, k2) {\n    return this.jmulAdd(k1, p2, k2);\n  }\n\n  mulAddSimple(k1, p2, k2) {\n    return this.jmulAddSimple(k1, p2, k2);\n  }\n\n  mulH() {\n    return this.jmulH();\n  }\n\n  div(k) {\n    return this.jdiv(k);\n  }\n\n  divn(k) {\n    return this.jdivn(k);\n  }\n\n  divH() {\n    return this.jdivH();\n  }\n\n  jmul(k) {\n    if (USE_FIXED && this._hasWindows(k))\n      return this.curve._fixedMul(this, k);\n\n    if (this._hasDoubles(k))\n      return this.curve._fixedNafMul(this, k);\n\n    if (this.curve.endo && this.type === types.AFFINE)\n      return this.curve._endoWnafMulAdd([this], [k]);\n\n    return this.curve._wnafMul(4, this, k);\n  }\n\n  jmuln(k) {\n    assert((k | 0) === k);\n    return this.jmulSimple(new BN(k));\n  }\n\n  jmulSimple(k) {\n    return this.curve._simpleMul(this, k);\n  }\n\n  jmulBlind(k, rng = null) {\n    const [p, t, unblind] = this._blind(k, rng);\n    const q = p.jmul(t);\n\n    if (unblind)\n      return q.add(unblind);\n\n    return q;\n  }\n\n  jmulConst(k, rng = null) {\n    const [p, t, unblind] = this._blind(k, rng);\n    const q = this.curve._constMul(p, t, rng);\n\n    if (unblind)\n      return q.uadd(unblind);\n\n    return q;\n  }\n\n  jmulAdd(k1, p2, k2) {\n    if (this.curve.endo && this.type === types.AFFINE)\n      return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);\n\n    return this.curve._wnafMulAdd(4, [this, p2], [k1, k2]);\n  }\n\n  jmulAddSimple(k1, p2, k2) {\n    return this.curve._simpleMulAdd([this, p2], [k1, k2]);\n  }\n\n  jmulH() {\n    const word = this.curve.h.word(0);\n\n    // Optimize for powers of two.\n    if ((word & (word - 1)) === 0) {\n      const bits = this.curve.h.bitLength();\n      return this.toJ().dblp(bits - 1);\n    }\n\n    return this.jmulSimple(this.curve.h);\n  }\n\n  jdiv(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    return this.jmul(k.invert(this.curve.n));\n  }\n\n  jdivn(k) {\n    assert(!this.curve.n.isZero());\n\n    if (this.curve.h.cmpn(k) === 0)\n      return this.jdivH();\n\n    return this.jdiv(new BN(k));\n  }\n\n  jdivH() {\n    if (this.curve.n.isZero())\n      return this.toJ();\n\n    if (this.curve.h.cmpn(1) === 0)\n      return this.toJ();\n\n    if (this.curve.hi === null)\n      this.curve.hi = this.curve.h.invert(this.curve.n);\n\n    return this.jmul(this.curve.hi);\n  }\n\n  ladder(k) {\n    throw new Error('Not implemented.');\n  }\n\n  ladderSimple(k) {\n    throw new Error('Not implemented.');\n  }\n\n  ladderBlind(k, rng) {\n    throw new Error('Not implemented.');\n  }\n\n  ladderConst(k, rng) {\n    throw new Error('Not implemented.');\n  }\n\n  toP() {\n    return this.normalize();\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    return this;\n  }\n\n  encode(compact) {\n    throw new Error('Not implemented.');\n  }\n\n  static decode(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  encodeX() {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeX(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeEven(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeSquare(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON(pre) {\n    throw new Error('Not implemented.');\n  }\n\n  static fromJSON(curve, json) {\n    throw new Error('Not implemented.');\n  }\n\n  [custom]() {\n    return '<Point>';\n  }\n}\n\n/**\n * ShortCurve\n */\n\nclass ShortCurve extends Curve {\n  constructor(conf) {\n    super(ShortPoint, 'short', conf);\n\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.b = BN.fromJSON(conf.b).toRed(this.red);\n    this.c = BN.fromJSON(conf.c || '0').toRed(this.red);\n    this.ai = this.a.isZero() ? this.zero : this.a.redInvert();\n    this.zi = this.z.isZero() ? this.zero : this.z.redInvert();\n\n    this.zeroA = this.a.isZero();\n    this.threeA = this.a.eq(this.three.redNeg());\n    this.redN = this.n.toRed(this.red);\n    this.pmodn = this.p.clone();\n    this.highOrder = this.n.cmp(this.p) >= 0;\n    this.smallGap = false;\n\n    this._finalize(conf);\n  }\n\n  _finalize(conf) {\n    super._finalize(conf);\n\n    // Precalculate endomorphism.\n    if (conf.endo != null)\n      this.endo = Endo.fromJSON(this, conf.endo);\n    else\n      this.endo = this._getEndomorphism();\n\n    if (!this.n.isZero()) {\n      this.pmodn = this.p.mod(this.n);\n\n      // Check for Maxwell's trick (see eqXToP).\n      this.smallGap = this.p.div(this.n).cmpn(1) <= 0;\n    }\n\n    return this;\n  }\n\n  static _isomorphism(curveA, curveB, customA, odd) {\n    // Short Weierstrass Isomorphism.\n    //\n    // [GECC] Page 84, Section 3.1.5.\n    // [ARITH1] Page 274, Section 13.1.5.\n    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n    //\n    // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.\n    //\n    // Transformation:\n    //\n    //   u4 = a' / a\n    //   u2 = +-sqrt(u4)\n    //   u6 = u4 * u2\n    //   a' = a * u4\n    //   b' = b * u6\n    //\n    // Where `u2` is any root that is square.\n    assert(curveA instanceof BN);\n    assert(curveB instanceof BN);\n    assert(customA instanceof BN);\n    assert(odd == null || typeof odd === 'boolean');\n    assert(!curveA.isZero() && !curveB.isZero());\n\n    const u4 = customA.redDiv(curveA);\n    const u2 = u4.redSqrt();\n\n    if (odd != null) {\n      if (u2.redIsOdd() !== odd)\n        u2.redINeg();\n    } else {\n      if (u2.redJacobi() !== 1)\n        u2.redINeg();\n    }\n\n    if (u2.redJacobi() !== 1)\n      throw new Error('Invalid `a` coefficient.');\n\n    const u6 = u4.redMul(u2);\n    const a = curveA.redMul(u4);\n    const b = curveB.redMul(u6);\n\n    assert(a.eq(customA));\n\n    return [a, b];\n  }\n\n  _short(a0, odd) {\n    return ShortCurve._isomorphism(this.a, this.b, a0, odd);\n  }\n\n  _mont(b0, odd) {\n    // Short Weierstrass->Montgomery Equivalence.\n    //\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    // [SAFE] \"Ladders\".\n    //\n    // Transformation:\n    //\n    //   r = A / (3 * B)\n    //   s = +-sqrt(3 * r^2 + a)\n    //   A = 3 * r / s\n    //   B = 1 / s\n    const [r, s] = this._findRS(odd);\n    const b = s.redInvert();\n    const a = r.redMuln(3).redMul(b);\n\n    if (b0 != null)\n      return MontCurve._isomorphism(a, b, b0);\n\n    return [a, b];\n  }\n\n  _edwards(a0, odd) {\n    // Short Weierstrass->Twisted Edwards Equivalence.\n    //\n    // [TWISTEQ] Section 1.\n    //\n    // Transformation:\n    //\n    //   r = (a' + d') / 6\n    //   s = +-sqrt(3 * r^2 + a)\n    //   a' = 3 * r + 2 * s\n    //   d' = 3 * r - 2 * s\n    const [r, s] = this._findRS(odd);\n    const r3 = r.redMuln(3);\n    const s2 = s.redMuln(2);\n    const a = r3.redAdd(s2);\n    const d = r3.redSub(s2);\n\n    if (a0 != null)\n      return EdwardsCurve._isomorphism(a, d, a0);\n\n    return [a, d];\n  }\n\n  _findRS(sign) {\n    // Find `r` and `s` for equivalence.\n    //\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    // [SAFE] \"Ladders\".\n    //\n    // Computation:\n    //\n    //   r = solve(r^3 + a * r + b == 0, r)\n    //   s = +-sqrt(3 * r^2 + a)\n    //\n    // Computing `r` is non-trivial. We need\n    // to solve `r^3 + a * r + b = 0`, but we\n    // don't have a polynomial solver, so we\n    // loop over random points until we find\n    // one with 2-torsion. Multiplying by the\n    // subgroup order should yield a point of\n    // ((A / 3) / B, 0) which is a solution.\n    assert(sign == null || typeof sign === 'boolean');\n    assert(this.h.word(0) >= 4);\n    assert(!this.n.isZero());\n\n    const x = this.one.redNeg();\n\n    let p;\n\n    for (;;) {\n      x.redIAdd(this.one);\n\n      try {\n        p = this.pointFromX(x);\n      } catch (e) {\n        continue;\n      }\n\n      p = p.mul(this.n);\n\n      if (p.isInfinity())\n        continue;\n\n      if (!p.y.isZero())\n        continue;\n\n      break;\n    }\n\n    const r = p.x;\n    const r2 = r.redSqr();\n    const s = r2.redMuln(3).redIAdd(this.a).redSqrt();\n\n    if (sign != null) {\n      if (s.redIsOdd() !== sign)\n        s.redINeg();\n    }\n\n    return [r, s];\n  }\n\n  _scale0(a, b) {\n    // We can extract the isomorphism factors with:\n    //\n    //   u4 = a' / a\n    //   u6 = b' / b\n    //   u2 = +-sqrt(u4)\n    //   u = +-sqrt(u2)\n    //   u3 = u2 * u\n    //\n    // `u2` should be picked such that `u4 * u2 = u6`.\n    const u4 = this.a.redDiv(this.field(a));\n    const u6 = this.b.redDiv(this.field(b));\n    const u2 = u4.redSqrt();\n\n    if (!u4.redMul(u2).eq(u6))\n      u2.redINeg();\n\n    assert(u4.redMul(u2).eq(u6));\n\n    const u = u2.redSqrt();\n    const u3 = u2.redMul(u);\n\n    assert(!u.isZero());\n\n    return [u2, u3];\n  }\n\n  _scale1(x, y) {\n    // If base points are available, it is much\n    // easier, with:\n    //\n    //   u2 = x' / x\n    //   u3 = y' / y\n    //   u = +-sqrt(u2)\n    //\n    // `u` should be picked such that `u2 * u = u3`.\n    const u2 = this.g.x.redDiv(this.field(x));\n    const u3 = this.g.y.redDiv(this.field(y));\n    const u = u2.redSqrt();\n\n    if (!u2.redMul(u).eq(u3))\n      u.redINeg();\n\n    assert(u2.redMul(u).eq(u3));\n    assert(!u.isZero());\n\n    return [u2, u3];\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity())\n      return this._scale0(curve.a, curve.b);\n\n    return this._scale1(curve.g.x, curve.g.y);\n  }\n\n  _scaleMont(curve) {\n    assert(curve instanceof MontCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a, b] = curve._short();\n      return this._scale0(a, b);\n    }\n\n    const {x, y} = curve.g;\n    const nx = x.redAdd(curve.a3).redMul(curve.bi);\n    const ny = y.redMul(curve.bi);\n\n    return this._scale1(nx, ny);\n  }\n\n  _scaleEdwards(curve) {\n    assert(curve instanceof EdwardsCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a, b] = curve._short();\n      return this._scale0(a, b);\n    }\n\n    const {x, y, z} = curve.g;\n    const a5 = curve.a.redMuln(5);\n    const d5 = curve.d.redMuln(5);\n    const dma = curve.d.redSub(curve.a);\n    const d5a = d5.redSub(curve.a);\n    const da5 = curve.d.redSub(a5);\n    const ypz = y.redAdd(z);\n    const ymz = y.redSub(z);\n    const xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n    const xz = ymz.redMuln(12);\n    const yy = dma.redMul(ypz).redMul(z);\n    const yz = ymz.redMul(x).redIMuln(4);\n    const zi = xz.redMul(yz).redInvert();\n    const nx = xx.redMul(yz).redMul(zi);\n    const ny = yy.redMul(xz).redMul(zi);\n\n    return this._scale1(nx, ny);\n  }\n\n  _getEndomorphism(index = 0) {\n    // Compute endomorphism.\n    //\n    // [GECC] Example 3.76, Page 128, Section 3.5.\n\n    // No curve params.\n    if (this.n.isZero() || this.g.isInfinity())\n      return null;\n\n    // No efficient endomorphism.\n    if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)\n      return null;\n\n    // Solve beta^3 mod p = 1.\n    const [b1, b2] = this._getEndoRoots(this.p);\n\n    // Choose the smallest beta by default.\n    const beta = [b1, b2][index & 1].toRed(this.red);\n\n    // Solve lambda^3 mod n = 1.\n    const [l1, l2] = this._getEndoRoots(this.n);\n\n    // Choose the lambda matching selected beta.\n    // Note that P * lambda = (x * beta, y).\n    const p = this.point(this.g.x.redMul(beta), this.g.y);\n\n    let lambda;\n\n    if (this.g.mul(l1).eq(p)) {\n      lambda = l1;\n    } else {\n      assert(this.g.mul(l2).eq(p));\n      lambda = l2;\n    }\n\n    // Get basis vectors.\n    const basis = this._getEndoBasis(lambda);\n\n    // Precompute `g1` and `g2`.\n    const pre = this._getEndoPrecomp(basis);\n\n    return new Endo(beta, lambda, basis, pre);\n  }\n\n  _getEndoRoots(num) {\n    // Find roots for x^2 + x + 1 in F.\n    //\n    // [GECC] Example 3.76, Page 128, Section 3.5.\n    // [GLV] Page 192, Section 2 (Endomorphisms).\n    //\n    // The above document doesn't fully explain how\n    // to derive these and only \"hints\" at it, as\n    // mentioned by Hal Finney[1], but we're basically\n    // computing two possible cube roots of 1 here.\n    //\n    // Note that we could also compute[2]:\n    //\n    //   beta = 2^((p - 1) / 3) mod p\n    //   lambda = 3^((n - 1) / 3) mod n\n    //\n    // As an extension of Fermat's little theorem:\n    //\n    //   g^(p - 1) mod p == 1\n    //\n    // It is suspected[3] this is how Hal Finney[4]\n    // computed his original endomorphism roots.\n    //\n    // @indutny's method for computing cube roots\n    // of unity[5] appears to be the method described\n    // on wikipedia[6][7].\n    //\n    // Sage produces the same solution:\n    //\n    //   sage: solve(x^2 + x + 1 == 0, x)\n    //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]\n    //\n    // This can be reduced to:\n    //\n    //   x = (+-sqrt(-3) - 1) / 2\n    //\n    // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565\n    // [2] https://crypto.stackexchange.com/a/22739\n    // [3] https://bitcoin.stackexchange.com/a/35872\n    // [4] https://github.com/halfinney/bitcoin/commit/dc411b5\n    // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity\n    // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example\n    // [7] http://mathworld.wolfram.com/SplittingField.html\n    const red = num === this.p ? this.red : BN.mont(num);\n    const two = new BN(2).toRed(red);\n    const three = new BN(3).toRed(red);\n    const i2 = two.redInvert();\n\n    // S1 = sqrt(-3) / 2\n    const s1 = three.redNeg().redSqrt().redMul(i2);\n\n    // S2 = -S1\n    const s2 = s1.redNeg();\n\n    // R1 = S1 - 1 / 2\n    const r1 = s1.redSub(i2).fromRed();\n\n    // R2 = S2 - 1 / 2\n    const r2 = s2.redSub(i2).fromRed();\n\n    return [r1, r2].sort(BN.cmp);\n  }\n\n  _getEndoBasis(lambda) {\n    // Compute endomorphic basis.\n    //\n    // This essentially computes Cornacchia's algorithm\n    // for solving x^2 + d * y^2 = m (d = lambda, m = order).\n    //\n    // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm\n    //\n    // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n    // [GLV] Page 196, Section 4 (Decomposing K).\n    //\n    // Balanced length-two representation of a multiplier.\n    //\n    // 1. Run the extended euclidean algorithm with inputs n\n    //    and lambda. The algorithm produces a sequence of\n    //    equations si*n + ti*lam = ri where s0=1, t0=0,\n    //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri\n    //    and are non-negative and strictly decreasing. Let\n    //    l be the greatest index for which rl >= sqrt(n).\n    const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda);\n\n    // 2. Set (a1, b1) <- (rl+1, -tl+1).\n    const a1 = rl1;\n    const b1 = tl1.neg();\n\n    // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)\n    //    then set (a2, b2) <- (rl, -tl).\n    //    else set (a2, b2) <- (rl+2, -tl+2).\n    const lhs = rl.sqr().iadd(tl.sqr());\n    const rhs = rl2.sqr().iadd(tl2.sqr());\n\n    let a2, b2;\n\n    if (lhs.cmp(rhs) <= 0) {\n      a2 = rl;\n      b2 = tl.neg();\n    } else {\n      a2 = rl2;\n      b2 = tl2.neg();\n    }\n\n    return [\n      new Vector(a1, b1),\n      new Vector(a2, b2)\n    ];\n  }\n\n  _egcdSqrt(lambda) {\n    // Extended Euclidean algorithm for integers.\n    //\n    // [GECC] Algorithm 2.19, Page 40, Section 2.2.\n    // [GLV] Page 196, Section 4 (Decomposing K).\n    assert(lambda instanceof BN);\n    assert(!lambda.red);\n    assert(lambda.sign() > 0);\n    assert(this.n.sign() > 0);\n\n    // Note that we insert the approximate square\n    // root checks as described in algorithm 3.74.\n    //\n    // Algorithm 2.19 is defined as:\n    //\n    // 1. u <- a\n    //    v <- b\n    //\n    // 2. x1 <- 1\n    //    y1 <- 0\n    //    x2 <- 0\n    //    y2 <- 1\n    //\n    // 3. while u != 0 do\n    //\n    // 3.1. q <- floor(v / u)\n    //      r <- v - q * u\n    //      x <- x2 - q * x1\n    //      y <- y2 - q * y1\n    //\n    // 3.2. v <- u\n    //      u <- r\n    //      x2 <- x1\n    //      x1 <- x\n    //      y2 <- y1\n    //      y1 <- y\n    //\n    // 4. d <- v\n    //    x <- x2\n    //    y <- y2\n    //\n    // 5. Return (d, x, y).\n\n    // Start with an approximate square root of n.\n    const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);\n\n    let u = lambda; // r1\n    let v = this.n.clone(); // r0\n    let x1 = new BN(1); // t1\n    let y1 = new BN(0); // t0\n    let x2 = new BN(0); // s1\n    let y2 = new BN(1); // s0\n\n    // All vectors are roots of: a + b * lambda = 0 (mod n).\n    let rl, tl;\n\n    // First vector.\n    let rl1, tl1;\n\n    // Inner.\n    let i = 0;\n    let j = 0;\n    let p;\n\n    // Compute EGCD.\n    while (!u.isZero() && i < 2) {\n      const q = v.quo(u);\n      const r = v.sub(q.mul(u));\n      const x = x2.sub(q.mul(x1));\n      const y = y2.sub(q.mul(y1));\n\n      // Check for r < sqrt(n).\n      if (j === 0 && r.cmp(sqrtn) < 0) {\n        rl = p;\n        tl = x1;\n        rl1 = r;\n        tl1 = x;\n        j = 1; // 1 more round.\n      }\n\n      p = r;\n      v = u;\n      u = r;\n      x2 = x1;\n      x1 = x;\n      y2 = y1;\n      y1 = y;\n\n      i += j;\n    }\n\n    // Should never happen.\n    assert(j !== 0, 'Could not find r < sqrt(n).');\n\n    // Second vector.\n    const rl2 = x2;\n    const tl2 = x1;\n\n    return [\n      rl,\n      tl,\n      rl1,\n      tl1,\n      rl2,\n      tl2\n    ];\n  }\n\n  _getEndoPrecomp(basis) {\n    // Precompute `g1` and `g2` to avoid round division.\n    //\n    // [JCEN12] Page 5, Section 4.3.\n    //\n    // Computation:\n    //\n    //   d = a1 * b2 - b1 * a2\n    //   t = ceil(log2(d+1)) + 16\n    //   g1 = round((2^t * b2) / d)\n    //   g2 = round((2^t * b1) / d)\n    //\n    // Where `d` is equal to `n`.\n    //\n    // As far as `t` goes, the paper above adds 2,\n    // whereas libsecp256k1 adds 16 (a total of 272).\n    assert(Array.isArray(basis));\n    assert(basis.length === 2);\n    assert(basis[0] instanceof Vector);\n    assert(basis[1] instanceof Vector);\n\n    const [v1, v2] = basis;\n    const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));\n    const shift = d.bitLength() + 16;\n    const pow = BN.shift(1, shift);\n    const g1 = pow.mul(v2.b).divRound(d);\n    const g2 = pow.mul(v1.b).divRound(d);\n\n    assert(d.eq(this.n));\n\n    return [g1, g2];\n  }\n\n  _endoSplit(k) {\n    // Balanced length-two representation of a multiplier.\n    //\n    // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n    //\n    // Also note that it is possible to precompute[1]\n    // values in order to avoid the division[2][3][4].\n    //\n    // This involves precomputing `g1` and `g2 (see\n    // above). `c1` and `c2` can then be computed as\n    // follows:\n    //\n    //   t = ceil(log2(n+1)) + 16\n    //   c1 = (k * g1) >> t\n    //   c2 = -((k * g2) >> t)\n    //\n    // Where `>>` is an _unsigned_ right shift. Also\n    // note that the last bit discarded in the shift\n    // must be stored. If it is 1, then add 1 to the\n    // scalar (absolute addition).\n    //\n    // It's worth noting that libsecp256k1 uses a\n    // different calculation along the lines of:\n    //\n    //   t = ceil(log2(n+1)) + 16\n    //   c1 = ((k * g1) >> t) * -b1\n    //   c2 = ((k * -g2) >> t) * -b2\n    //   k2 = c1 + c2\n    //   k1 = k2 * -lambda + k\n    //\n    // So, in the future, we can consider changing\n    // step 4 to:\n    //\n    //   4. Compute c1 = (k * g1) >> t\n    //          and c2 = -((k * g2) >> t).\n    //\n    //   const shift = this.scalarBits + 16;\n    //   const [g1, g2] = this.endo.pre;\n    //   const c1 = k.mulShift(g1, shift);\n    //   const c2 = k.mulShift(g2, shift).ineg();\n    //\n    // Once we're brave enough, that is.\n    //\n    // [1] [JCEN12] Page 5, Section 4.3.\n    // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259\n    // [3] https://github.com/bitcoin-core/secp256k1/pull/21\n    // [4] https://github.com/bitcoin-core/secp256k1/pull/127\n    assert(k instanceof BN);\n    assert(!k.red);\n    assert(!this.n.isZero());\n\n    const [v1, v2] = this.endo.basis;\n\n    // 4. Compute c1 = round(b2 * k / n)\n    //        and c2 = round(-b1 * k / n).\n    const c1 = v2.b.mul(k).divRound(this.n);\n    const c2 = v1.b.neg().mul(k).divRound(this.n);\n\n    // 5. Compute k1 = k - c1 * a1 - c2 * a2\n    //        and k2 = -c1 * b1 - c2 * b2.\n    const p1 = c1.mul(v1.a);\n    const p2 = c2.mul(v2.a);\n    const q1 = c1.ineg().mul(v1.b);\n    const q2 = c2.mul(v2.b);\n\n    // Calculate answer.\n    const k1 = k.sub(p1).isub(p2);\n    const k2 = q1.isub(q2);\n\n    // 6. Return (k1, k2).\n    return [k1, k2];\n  }\n\n  _endoBeta(point) {\n    assert(point instanceof ShortPoint);\n    return [point, point._getBeta()];\n  }\n\n  _endoWnafMulAdd(points, coeffs) {\n    // Point multiplication with efficiently computable endomorphisms.\n    //\n    // [GECC] Algorithm 3.77, Page 129, Section 3.5.\n    // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).\n    //\n    // Note it may be possible to do this 4-dimensionally [4GLV].\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n    assert(this.endo != null);\n\n    const len = points.length;\n    const npoints = new Array(len * 2);\n    const ncoeffs = new Array(len * 2);\n\n    for (let i = 0; i < len; i++) {\n      const [p1, p2] = this._endoBeta(points[i]);\n      const [k1, k2] = this._endoSplit(coeffs[i]);\n\n      npoints[i * 2 + 0] = p1;\n      ncoeffs[i * 2 + 0] = k1;\n      npoints[i * 2 + 1] = p2;\n      ncoeffs[i * 2 + 1] = k2;\n    }\n\n    return this._wnafMulAdd(4, npoints, ncoeffs);\n  }\n\n  _icart(u0) {\n    // Icart's Method.\n    //\n    // Distribution: 5/8.\n    //\n    // [ICART] Page 4, Section 2.\n    // [H2EC] \"Icart Method\".\n    //\n    // Assumptions:\n    //\n    //   - p = 2 (mod 3).\n    //   - u != 0.\n    //\n    // Map:\n    //\n    //   u = 1, if u = 0\n    //   v = (3 * a - u^4) / (6 * u)\n    //   w = (2 * p - 1) / 3\n    //   x = (v^2 - b - u^6 / 27)^w + u^2 / 3\n    //   y = u * x + v\n    const {a, b, i3, one} = this;\n    const i27 = i3.redSqr().redMul(i3);\n    const w = this.p.ushln(1).isubn(1).idivn(3);\n    const u = u0.clone();\n\n    u.cinject(one, u.czero());\n\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const u6 = u4.redMul(u2);\n    const u6i = u.redMuln(6).redFermat();\n    const v = a.redMuln(3).redISub(u4).redMul(u6i);\n    const v2 = v.redSqr();\n    const u6d27 = u6.redMul(i27);\n    const u2d3 = u2.redMul(i3);\n    const x = v2.redISub(b).redISub(u6d27).redPow(w).redIAdd(u2d3);\n    const y = u.redMul(x).redIAdd(v);\n\n    return this.point(x, y);\n  }\n\n  _sswu(u) {\n    // Simplified Shallue-Woestijne-Ulas Method.\n    //\n    // Distribution: 3/8.\n    //\n    // [SSWU1] Page 15-16, Section 7. Appendix G.\n    // [SSWU2] Page 5, Theorem 2.3.\n    // [H2EC] \"Simplified Shallue-van de Woestijne-Ulas Method\".\n    //\n    // Assumptions:\n    //\n    //   - a != 0, b != 0.\n    //   - Let z be a non-square in F(p).\n    //   - z != -1.\n    //   - The polynomial g(x) - z is irreducible over F(p).\n    //   - g(b / (z * a)) is square in F(p).\n    //   - u != 0, u != +-sqrt(-1 / z).\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + a * x + b\n    //   t1 = 1 / (z^2 * u^4 + z * u^2)\n    //   x1 = (-b / a) * (1 + t1)\n    //   x1 = b / (z * a), if t1 = 0\n    //   x2 = z * u^2 * x1\n    //   x = x1, if g(x1) is square\n    //     = x2, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const {b, z, ai, zi, one} = this;\n    const e = this.p.subn(2);\n    const z2 = z.redSqr();\n    const ba = b.redNeg().redMul(ai);\n    const bza = b.redMul(zi).redMul(ai);\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const t1 = z2.redMul(u4).redIAdd(z.redMul(u2)).redPow(e);\n    const x1 = ba.redMul(one.redAdd(t1));\n\n    x1.cinject(bza, t1.czero());\n\n    const x2 = z.redMul(u2).redMul(x1);\n    const y1 = this.solveY2(x1);\n    const y2 = this.solveY2(x2);\n    const alpha = y1.redIsSquare() | 0;\n    const x = x1.cinject(x2, alpha ^ 1);\n    const y = y1.cinject(y2, alpha ^ 1).redSqrt();\n\n    y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());\n\n    return this.point(x, y);\n  }\n\n  _sswui(p, hint) {\n    // Inverting the Map (Simplified Shallue-Woestijne-Ulas).\n    //\n    // Assumptions:\n    //\n    //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).\n    //   - If r < 3 then x != -b / a.\n    //\n    // Unlike SVDW, the preimages here are evenly\n    // distributed (more or less). SSWU covers ~3/8\n    // of the curve points. Each preimage has a 1/2\n    // chance of mapping to either x1 or x2.\n    //\n    // Assuming the point is within that set, each\n    // point has a 1/4 chance of inverting to any\n    // of the preimages. This means we can simply\n    // randomly select a preimage if one exists.\n    //\n    // However, the [SVDW2] sampling method seems\n    // slighly faster in practice for [SQUARED].\n    //\n    // Map:\n    //\n    //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)\n    //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)\n    //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)\n    //   u3 = -(a * x + b - c) / (2 * b * z)\n    //   u4 = -(a * x + b + c) / (2 * b * z)\n    //   r = random integer in [1,4]\n    //   u = sign(y) * abs(sqrt(ur))\n    const {a, b, z} = this;\n    const {x, y} = p;\n    const r = hint & 3;\n    const a2x2 = a.redSqr().redMul(x.redSqr());\n    const abx2 = a.redMul(b).redMul(x).redIMuln(2);\n    const b23 = b.redSqr().redMuln(3);\n    const axb = a.redMul(x).redIAdd(b);\n    const [s0, c] = sqrt(a2x2.redISub(abx2).redISub(b23));\n    const n0 = axb.redSub(c).redINeg();\n    const n1 = axb.redAdd(c).redINeg();\n    const d0 = axb.redMul(z).redIMuln(2);\n    const d1 = b.redMul(z).redIMuln(2);\n\n    n0.cinject(n1, r & 1); // r = 1 or 3\n    d0.cinject(d1, r >>> 1); // r = 2 or 3\n\n    const [s1, u] = divSqrt(n0, d0);\n\n    u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());\n\n    if (!(s0 & s1))\n      throw new Error('Invalid point.');\n\n    return u;\n  }\n\n  _svdwf(u) {\n    // Shallue-van de Woestijne Method.\n    //\n    // Distribution: 9/16.\n    //\n    // [SVDW1] Section 5.\n    // [SVDW2] Page 8, Section 3.\n    //         Page 15, Section 6, Algorithm 1.\n    // [H2EC] \"Shallue-van de Woestijne Method\".\n    //\n    // Assumptions:\n    //\n    //   - p = 1 (mod 3).\n    //   - a = 0, b != 0.\n    //   - Let z be a unique element in F(p).\n    //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).\n    //   - u != 0, u != +-sqrt(-g(z)).\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + b\n    //   c = sqrt(-3 * z^2)\n    //   t1 = u^2 + g(z)\n    //   t2 = 1 / (u^2 * t1)\n    //   t3 = u^4 * t2 * c\n    //   x1 = (c - z) / 2 - t3\n    //   x2 = t3 - (c + z) / 2\n    //   x3 = z - t1^3 * t2 / (3 * z^2)\n    //   x = x1, if g(x1) is square\n    //     = x2, if g(x2) is square\n    //     = x3, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const {c, z, zi, i2, i3} = this;\n    const e = this.p.subn(2);\n    const gz = this.solveY2(z);\n    const z3 = i3.redMul(zi.redSqr());\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const t1 = u2.redAdd(gz);\n    const t2 = u2.redMul(t1).redPow(e);\n    const t3 = u4.redMul(t2).redMul(c);\n    const t4 = t1.redSqr().redMul(t1);\n    const x1 = c.redSub(z).redMul(i2).redISub(t3);\n    const x2 = t3.redSub(c.redAdd(z).redMul(i2));\n    const x3 = z.redSub(t4.redMul(t2).redMul(z3));\n    const y1 = this.solveY2(x1);\n    const y2 = this.solveY2(x2);\n    const y3 = this.solveY2(x3);\n    const alpha = y1.redIsSquare() | 0;\n    const beta = y2.redIsSquare() | 0;\n\n    x1.cinject(x2, (alpha ^ 1) & beta);\n    y1.cinject(y2, (alpha ^ 1) & beta);\n    x1.cinject(x3, (alpha ^ 1) & (beta ^ 1));\n    y1.cinject(y3, (alpha ^ 1) & (beta ^ 1));\n\n    return [x1, y1];\n  }\n\n  _svdw(u) {\n    const [x, yy] = this._svdwf(u);\n    const y = yy.redSqrt();\n\n    y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());\n\n    return this.point(x, y);\n  }\n\n  _svdwi(p, hint) {\n    // Inverting the Map (Shallue-van de Woestijne).\n    //\n    // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n    // [SVDW2] Page 12, Section 5.\n    // [SVDW3] \"Inverting the map\".\n    //\n    // Assumptions:\n    //\n    //   - If r = 1 then x != -(c + z) / 2.\n    //   - If r = 2 then x != (c - z) / 2.\n    //   - If r > 2 then (t0 - t1 + t2) is square in F(p).\n    //   - f(f^-1(x)) = x where f is the map function.\n    //\n    // We use the sampling method from [SVDW2],\n    // _not_ [SQUARED]. This seems to have a\n    // better distribution in practice.\n    //\n    // Note that [SVDW3] also appears to be\n    // incorrect in terms of distribution.\n    //\n    // The distribution of f(u), assuming u is\n    // random, is (1/2, 1/4, 1/4).\n    //\n    // To mirror this, f^-1(x) should simply\n    // pick (1/2, 1/4, 1/8, 1/8).\n    //\n    // To anyone running the forward map, our\n    // strings will appear to be random.\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + b\n    //   c = sqrt(-3 * z^2)\n    //   t0 = 9 * (x^2 * z^2 + z^4)\n    //   t1 = 18 * x * z^3\n    //   t2 = 12 * g(z) * (x - z)\n    //   t3 = sqrt(t0 - t1 + t2)\n    //   t4 = t3 * z\n    //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)\n    //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)\n    //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2\n    //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2\n    //   r = random integer in [1,4]\n    //   u = sign(y) * abs(sqrt(ur))\n    const {b, c, z, two} = this;\n    const {x, y} = p;\n    const r = hint & 3;\n    const z2 = z.redSqr();\n    const z3 = z2.redMul(z);\n    const z4 = z2.redSqr();\n    const gz = z3.redAdd(b);\n    const gz2 = gz.redMuln(2);\n    const xx = x.redSqr();\n    const x2z = x.redMuln(2).redIAdd(z);\n    const xz2 = x.redMul(z2);\n    const c0 = c.redSub(x2z);\n    const c1 = c.redAdd(x2z);\n    const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);\n    const t1 = x.redMul(z3).redIMuln(18);\n    const t2 = gz.redMul(x.redSub(z)).redIMuln(12);\n    const [s0, t3] = sqrt(t0.redISub(t1).redIAdd(t2));\n    const s1 = ((r - 2) >>> 31) | s0;\n    const t4 = t3.redMul(z);\n    const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);\n    const n0 = gz.redMul(c0);\n    const n1 = gz.redMul(c1);\n    const n2 = t5.redAdd(t4);\n    const n3 = t5.redSub(t4);\n    const d0 = two.clone();\n\n    n0.cinject(n1, ((r ^ 1) - 1) >>> 31); // r = 1\n    n0.cinject(n2, ((r ^ 2) - 1) >>> 31); // r = 2\n    n0.cinject(n3, ((r ^ 3) - 1) >>> 31); // r = 3\n    d0.cinject(c1, ((r ^ 0) - 1) >>> 31); // r = 0\n    d0.cinject(c0, ((r ^ 1) - 1) >>> 31); // r = 1\n\n    const [s2, u] = divSqrt(n0, d0);\n    const [x0] = this._svdwf(u);\n    const s3 = x0.ceq(x);\n\n    u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());\n\n    if (!(s1 & s2 & s3))\n      throw new Error('Invalid point.');\n\n    return u;\n  }\n\n  isElliptic() {\n    const {a, b} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const d = b2.redMuln(27).redIAdd(a3.redMuln(4));\n\n    // 4 * a^3 + 27 * b^2 != 0\n    return !d.isZero();\n  }\n\n  jinv() {\n    // [ARITH1] Page 71, Section 4.4.\n    // http://mathworld.wolfram.com/j-Invariant.html\n    const {a, b} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const t0 = a3.redMuln(4);\n    const lhs = t0.redMuln(1728);\n    const rhs = b2.redMuln(27).redIAdd(t0);\n\n    if (rhs.isZero())\n      throw new Error('Curve is not elliptic.');\n\n    // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  point(x, y, inf = 0) {\n    return new ShortPoint(this, x, y, inf);\n  }\n\n  jpoint(x, y, z) {\n    return new JPoint(this, x, y, z);\n  }\n\n  solveY2(x) {\n    // [GECC] Page 89, Section 3.2.2.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw.html\n    assert(x instanceof BN);\n\n    // y^2 = x^3 + a * x + b\n    const x3 = x.redSqr().redMul(x);\n    const y2 = x3.redIAdd(this.b);\n\n    if (!this.zeroA) {\n      // Save some cycles for a = -3.\n      if (this.threeA)\n        y2.redIAdd(x.redMuln(-3));\n      else\n        y2.redIAdd(this.a.redMul(x));\n    }\n\n    return y2;\n  }\n\n  validate(point) {\n    assert(point instanceof ShortPoint);\n\n    if (point.inf)\n      return true;\n\n    const {x, y} = point;\n    const y2 = this.solveY2(x);\n\n    return y.redSqr().eq(y2);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!x.red)\n      x = x.toRed(this.red);\n\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.redIsOdd() !== sign)\n        y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve) {\n    // [GECC] Page 84, Section 3.1.5.\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    assert(curve instanceof Curve);\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    let u2, u3;\n    try {\n      [u2, u3] = this._scale(curve);\n    } catch (e) {\n      return false;\n    }\n\n    // E(a,b) <-> E(au^4,bu^6)\n    if (curve.type === 'short') {\n      // a' = a * u^4, b' = b * u^6\n      const a = this.field(curve.a).redMul(u2.redSqr());\n      const b = this.field(curve.b).redMul(u3.redSqr());\n\n      return this.a.eq(a) && this.b.eq(b);\n    }\n\n    // E(a,b) <-> M(A,B)\n    if (curve.type === 'mont') {\n      // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0\n      const {a3, bi} = curve;\n      const x = this.field(a3.redMul(bi)).redMul(u2);\n      const y2 = this.solveY2(x);\n\n      return y2.isZero();\n    }\n\n    // E(a,b) <-> E(a,d)\n    if (curve.type === 'edwards') {\n      // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0\n      const x = this.field(curve.ad6).redMul(u2);\n      const y2 = this.solveY2(x);\n\n      return y2.isZero();\n    }\n\n    return false;\n  }\n\n  isIsogenous(curve) {\n    assert(curve instanceof Curve);\n    return false;\n  }\n\n  pointFromShort(point) {\n    // [GECC] Page 84, Section 3.1.5.\n    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for E(a,b)<->E(au^4,bu^6):\n      //\n      //   x' = x * u^2\n      //   y' = y * u^3\n      //\n      // Where a * u^4 = a' and b * u^6 = b'.\n      if (point.isInfinity())\n        return this.point();\n\n      const [u2, u3] = this._scale(point.curve);\n      const x = this.field(point.x);\n      const y = this.field(point.y);\n      const nx = x.redMul(u2);\n      const ny = y.redMul(u3);\n\n      return this.point(nx, ny);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [ALT] Appendix E.2 (Switching between Alternative Representations).\n    // [MONT2] \"Equivalence with Weierstrass curves\"\n    assert(point instanceof MontPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for M(A,B)->E(a,b):\n      //\n      //   x = (u + A / 3) / B\n      //   y = v / B\n      //\n      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n      if (point.isInfinity())\n        return this.point();\n\n      const {a3, bi} = point.curve;\n      const [u2, u3] = this._scale(point.curve);\n      const nx = point.x.redAdd(a3).redMul(bi);\n      const ny = point.y.redMul(bi);\n\n      return this.point(this.field(nx).redMul(u2),\n                        this.field(ny).redMul(u3));\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [TWISTEQ] Section 2.\n    assert(point instanceof EdwardsPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,d)->E(a',b'):\n      //\n      //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))\n      //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> ((a + d) / 6, 0)\n      //\n      // Unexceptional Cases:\n      //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))\n      const {a, d, ad6} = point.curve;\n      const [u2, u3] = this._scale(point.curve);\n\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero()) {\n        const x = this.field(ad6).redMul(u2);\n        return this.point(x, this.zero);\n      }\n\n      const {x, y, z} = point;\n      const a5 = a.redMuln(5);\n      const d5 = d.redMuln(5);\n      const dma = d.redSub(a);\n      const d5a = d5.redSub(a);\n      const da5 = d.redSub(a5);\n      const ypz = y.redAdd(z);\n      const ymz = y.redSub(z);\n      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n      const xz = ymz.redMuln(12);\n      const yy = dma.redMul(ypz).redMul(z);\n      const yz = ymz.redMul(x).redIMuln(4);\n\n      return this.cpoint(this.field(xx).redMul(u2),\n                         this.field(xz),\n                         this.field(yy).redMul(u3),\n                         this.field(yz));\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    assert(u instanceof BN);\n\n    // z = 0 or b = 0\n    if (this.z.isZero() || this.b.isZero())\n      throw new Error('Not implemented.');\n\n    // a != 0, b != 0\n    if (!this.a.isZero())\n      return this._sswu(u);\n\n    // p = 1 mod 3, a = 0, b != 0\n    if (!this.c.isZero())\n      return this._svdw(u);\n\n    throw new Error('Not implemented.');\n  }\n\n  pointToUniform(p, hint) {\n    assert(p instanceof ShortPoint);\n    assert((hint >>> 0) === hint);\n\n    // z = 0 or b = 0\n    if (this.z.isZero() || this.b.isZero())\n      throw new Error('Not implemented.');\n\n    // P = O\n    if (p.isInfinity())\n      throw new Error('Invalid point.');\n\n    // Add a random torsion component.\n    const i = ((hint >>> 4) & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    // a != 0, b != 0\n    if (!this.a.isZero())\n      return this._sswui(q, hint);\n\n    // p = 1 mod 3, a = 0, b != 0\n    if (!this.c.isZero())\n      return this._svdwi(q, hint);\n\n    throw new Error('Not implemented.');\n  }\n\n  mulAll(points, coeffs) {\n    return super.mulAll(points, coeffs).toP();\n  }\n\n  mulAllSimple(points, coeffs) {\n    return super.mulAllSimple(points, coeffs).toP();\n  }\n\n  decodePoint(bytes) {\n    return ShortPoint.decode(this, bytes);\n  }\n\n  encodeX(point) {\n    assert(point instanceof Point);\n    return point.encodeX();\n  }\n\n  decodeEven(bytes) {\n    return ShortPoint.decodeEven(this, bytes);\n  }\n\n  decodeSquare(bytes) {\n    return ShortPoint.decodeSquare(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromShort(this.g);\n\n    for (let i = 0; i < this.h; i++)\n      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, odd, sign = null) {\n    const [a, b] = this._mont(b0, odd);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = this._scale(curve);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromShort(this.g);\n\n    for (let i = 0; i < this.h; i++)\n      curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, odd, sign = null) {\n    const [a, d] = this._edwards(a0, odd);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = this._scale(curve);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromShort(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return ShortPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n\n    json.a = this.a.fromRed().toJSON();\n    json.b = this.b.fromRed().toJSON();\n\n    if (!this.c.isZero())\n      json.c = this.c.fromRed().toJSON();\n\n    return json;\n  }\n}\n\n/**\n * ShortPoint\n */\n\nclass ShortPoint extends Point {\n  constructor(curve, x, y, inf) {\n    assert(curve instanceof ShortCurve);\n\n    super(curve, types.AFFINE);\n\n    this.x = this.curve.zero;\n    this.y = this.curve.zero;\n    this.inf = 1;\n\n    if (x != null)\n      this._init(x, y, inf);\n  }\n\n  _init(x, y, inf) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n\n    this.x = x;\n    this.y = y;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    this.inf = inf | 0;\n  }\n\n  _safeNAF(width) {\n    assert((width >>> 0) === width);\n\n    if (this.pre && this.pre.naf)\n      return this.pre.naf;\n\n    // Avoid inversions.\n    if (width > 1)\n      return this.toJ()._getNAF(width);\n\n    return this._getNAF(width);\n  }\n\n  _getBeta() {\n    if (!this.curve.endo)\n      return null;\n\n    if (this.pre && this.pre.beta)\n      return this.pre.beta;\n\n    // Augment the point with our beta value.\n    // This is the counterpart to `k2` after\n    // the endomorphism split of `k`.\n    //\n    // Note that if we have precomputation,\n    // we have to clone and update all of the\n    // precomputed points below.\n    const xb = this.x.redMul(this.curve.endo.beta);\n    const beta = this.curve.point(xb, this.y);\n\n    if (this.pre) {\n      beta.pre = this.pre.map((point) => {\n        const xb = point.x.redMul(this.curve.endo.beta);\n        return this.curve.point(xb, point.y);\n      });\n\n      this.pre.beta = beta;\n    }\n\n    return beta;\n  }\n\n  _getJNAF(point) {\n    assert(point instanceof ShortPoint);\n\n    if (this.inf | point.inf)\n      return super._getJNAF(point);\n\n    // Create comb for JSF.\n    const comb = [\n      this, // 1\n      null, // 3\n      null, // 5\n      point // 7\n    ];\n\n    // Try to avoid Jacobian points, if possible.\n    if (this.y.eq(point.y)) {\n      comb[1] = this.add(point);\n      comb[2] = this.toJ().sub(point);\n    } else if (this.y.eq(point.y.redNeg())) {\n      comb[1] = this.toJ().add(point);\n      comb[2] = this.sub(point);\n    } else {\n      comb[1] = this.toJ().add(point);\n      comb[2] = this.toJ().sub(point);\n    }\n\n    return comb;\n  }\n\n  clone() {\n    return this.curve.point(this.x.clone(),\n                            this.y.clone(),\n                            this.inf);\n  }\n\n  swap(point, flag) {\n    assert(point instanceof ShortPoint);\n\n    const cond = ((flag >> 31) | (-flag >> 31)) & 1;\n    const inf1 = this.inf;\n    const inf2 = point.inf;\n\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n\n    this.inf = (inf1 & (cond ^ 1)) | (inf2 & cond);\n    point.inf = (inf2 & (cond ^ 1)) | (inf1 & cond);\n\n    return this;\n  }\n\n  scale(a) {\n    return this.toJ().scale(a);\n  }\n\n  neg() {\n    // P = O\n    if (this.inf)\n      return this;\n\n    // -(X1, Y1) = (X1, -Y1)\n    return this.curve.point(this.x, this.y.redNeg());\n  }\n\n  add(p) {\n    // [GECC] Page 80, Section 3.1.2.\n    //\n    // Addition Law:\n    //\n    //   l = (y1 - y2) / (x1 - x2)\n    //   x3 = l^2 - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 1S + 6A\n    assert(p instanceof ShortPoint);\n\n    // O + P = P\n    if (this.inf)\n      return p;\n\n    // P + O = P\n    if (p.inf)\n      return this;\n\n    // P + P, P + -P\n    if (this.x.eq(p.x)) {\n      // P + -P = O\n      if (!this.y.eq(p.y))\n        return this.curve.point();\n\n      // P + P = 2P\n      return this.dbl();\n    }\n\n    // X1 != X2, Y1 = Y2\n    if (this.y.eq(p.y)) {\n      // X3 = -X1 - X2\n      const nx = this.x.redNeg().redISub(p.x);\n\n      // Y3 = -Y1\n      const ny = this.y.redNeg();\n\n      // Skip the inverse.\n      return this.curve.point(nx, ny);\n    }\n\n    // H = X1 - X2\n    const h = this.x.redSub(p.x);\n\n    // R = Y1 - Y2\n    const r = this.y.redSub(p.y);\n\n    // L = R / H\n    const l = r.redDiv(h);\n\n    // X3 = L^2 - X1 - X2\n    const nx = l.redSqr().redISub(this.x).redISub(p.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  dbl() {\n    // [GECC] Page 80, Section 3.1.2.\n    //\n    // Addition Law (doubling):\n    //\n    //   l = (3 * x1^2 + a) / (2 * y1)\n    //   x3 = l^2 - 2 * x1\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 2S + 3A + 2*2 + 1*3\n\n    // P = O\n    if (this.inf)\n      return this;\n\n    // Y1 = 0\n    if (this.y.isZero())\n      return this.curve.point();\n\n    // XX = X1^2\n    const xx = this.x.redSqr();\n\n    // M = 3 * XX + a\n    const m = xx.redIMuln(3).redIAdd(this.curve.a);\n\n    // Z = 2 * Y1\n    const z = this.y.redMuln(2);\n\n    // L = M / Z\n    const l = m.redDiv(z);\n\n    // X3 = L^2 - 2 * X1\n    const nx = l.redSqr().redISub(this.x).redISub(this.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  dblp(pow) {\n    return this.toJ().dblp(pow).toP();\n  }\n\n  uadd(p) {\n    // [SIDE2] Page 5, Section 3.\n    // [SIDE3] Page 4, Section 3.\n    //\n    // Addition Law (unified):\n    //\n    //   l = ((x1 + x2)^2 - (x1 * x2) + a) / (y1 + y2)\n    //   x3 = l^2 - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // If x1 != x2 and y1 = -y2, we switch\n    // back to the regular addition lambda:\n    //\n    //   l = (y1 - y2) / (x1 - x2)\n    //\n    // 1I + 3M + 2S + 10A\n    assert(p instanceof ShortPoint);\n\n    // M = Y1 + Y2\n    const m = this.y.redAdd(p.y);\n\n    // A = (X1 + X2)^2\n    const a = this.x.redAdd(p.x).redSqr();\n\n    // B = X1 * X2\n    const b = this.x.redMul(p.x);\n\n    // R = A - B + a\n    const r = a.redISub(b).redIAdd(this.curve.a);\n\n    // Check for degenerate case (X1 != X2, Y1 = -Y2).\n    const degenerate = m.czero() & r.czero();\n\n    // M = X1 - X2 (if degenerate)\n    m.cinject(this.x.redSub(p.x), degenerate);\n\n    // R = Y1 - Y2 (if degenerate)\n    r.cinject(this.y.redSub(p.y), degenerate);\n\n    // Check for negation (X1 = X2, Y1 = -Y2).\n    const negated = m.czero() & ((this.inf | p.inf) ^ 1);\n\n    // M = 1 (if M = 0)\n    m.cinject(this.curve.one, m.czero());\n\n    // L = R / M\n    const l = r.redMul(m.redFermat());\n\n    // X3 = L^2 - X1 - X2\n    const nx = l.redSqr().redISub(this.x).redISub(p.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    // Check for infinity.\n    const inf = negated | (this.inf & p.inf);\n\n    // Case 1: O + P = P\n    nx.cinject(p.x, this.inf);\n    ny.cinject(p.y, this.inf);\n\n    // Case 2: P + O = P\n    nx.cinject(this.x, p.inf);\n    ny.cinject(this.y, p.inf);\n\n    // Case 3 & 4: P + -P = O, O + O = O\n    nx.cinject(this.curve.zero, inf);\n    ny.cinject(this.curve.zero, inf);\n\n    return this.curve.point(nx, ny, inf);\n  }\n\n  udbl() {\n    return this.uadd(this);\n  }\n\n  recover(x1, z1, x2, z2) {\n    // Brier-Joye Y-coordinate Recovery.\n    //\n    // [SIDE2] Proposition 3, Page 7, Section 4.\n    //\n    // 14M + 3S + 5A + 2*2 + 1*a + 1*b\n    assert(x1 instanceof BN);\n    assert(z1 instanceof BN);\n    assert(x2 instanceof BN);\n    assert(z2 instanceof BN);\n\n    // P = O\n    if (this.inf)\n      return this.curve.jpoint();\n\n    // Z = Z1 * Z2\n    const z = z1.redMul(z2);\n\n    // ZZ = Z^2\n    const zz = z.redSqr();\n\n    // ZZZ = ZZ * Z\n    const zzz = zz.redMul(z);\n\n    // U0 = X0 * Z\n    const u0 = this.x.redMul(z);\n\n    // U1 = X1 * Z2\n    const u1 = x1.redMul(z2);\n\n    // U2 = X2 * Z1\n    const u2 = x2.redMul(z1);\n\n    // A = 2 * b * ZZZ\n    const a = this.curve.b.redMul(zzz).redIMuln(2);\n\n    // B = a * ZZ + U0 * U1\n    const b = u0.redMul(u1).redIAdd(this.curve.a.redMul(zz));\n\n    // C = U0 + U1\n    const c = u0.redAdd(u1);\n\n    // D = U0 - U1\n    const d = u0.redISub(u1);\n\n    // E = A + B * C\n    const e = a.redIAdd(b.redMul(c));\n\n    // F = U2 * D^2\n    const f = u2.redMul(d.redSqr());\n\n    // G = E - F\n    const g = e.redISub(f);\n\n    // H = 2 * Y0 * ZZZ\n    const h = this.y.redMul(zzz).redIMuln(2);\n\n    // I = X1 * H\n    const i = x1.redMul(h);\n\n    // J = G * Z1\n    const j = g.redMul(z1);\n\n    // K = Z1 * H\n    const k = z1.redMul(h);\n\n    // X3 = I * K\n    const nx = i.redMul(k);\n\n    // Y3 = J * K^2\n    const ny = j.redMul(k.redSqr());\n\n    // Z3 = K\n    const nz = k;\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  getX() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof ShortPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.inf)\n      return p.inf !== 0;\n\n    // Q = O\n    if (p.inf)\n      return false;\n\n    // X1 = X2, Y1 = Y2\n    return this.x.eq(p.x)\n        && this.y.eq(p.y);\n  }\n\n  isInfinity() {\n    // Infinity cannot be represented in\n    // the affine space, except by a flag.\n    return this.inf !== 0;\n  }\n\n  isOdd() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsEven();\n  }\n\n  isSquare() {\n    if (this.inf)\n      return false;\n\n    return this.y.redJacobi() !== -1;\n  }\n\n  eqX(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    if (this.inf)\n      return false;\n\n    return this.getX().eq(x);\n  }\n\n  eqXToP(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n    assert(!this.curve.n.isZero());\n\n    if (this.inf)\n      return false;\n\n    return this.getX().imod(this.curve.n).eq(x);\n  }\n\n  mul(k) {\n    return super.mul(k).toP();\n  }\n\n  muln(k) {\n    return super.muln(k).toP();\n  }\n\n  mulSimple(k) {\n    return super.mulSimple(k).toP();\n  }\n\n  mulBlind(k, rng) {\n    return super.mulBlind(k, rng).toP();\n  }\n\n  mulConst(k, rng) {\n    return super.mulConst(k, rng).toP();\n  }\n\n  mulAdd(k1, p2, k2) {\n    return super.mulAdd(k1, p2, k2).toP();\n  }\n\n  mulAddSimple(k1, p2, k2) {\n    return super.mulAddSimple(k1, p2, k2).toP();\n  }\n\n  mulH() {\n    return super.mulH().toP();\n  }\n\n  div(k) {\n    return super.div(k).toP();\n  }\n\n  divn(k) {\n    return super.divn(k).toP();\n  }\n\n  divH() {\n    return super.divH().toP();\n  }\n\n  toP() {\n    return this;\n  }\n\n  toJ() {\n    // (X3, Y3, Z3) = (1, 1, 0)\n    if (this.inf)\n      return this.curve.jpoint();\n\n    // (X3, Y3, Z3) = (X1, Y1, 1)\n    return this.curve.jpoint(this.x, this.y, this.curve.one);\n  }\n\n  encode(compact) {\n    // [SEC1] Page 10, Section 2.3.3.\n    if (compact == null)\n      compact = true;\n\n    assert(typeof compact === 'boolean');\n\n    const {fieldSize} = this.curve;\n\n    // We do not serialize points at infinity.\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    // Compressed form (0x02 = even, 0x03 = odd).\n    if (compact) {\n      const p = Buffer.allocUnsafe(1 + fieldSize);\n      const x = this.curve.encodeField(this.getX());\n\n      p[0] = 0x02 | this.y.redIsOdd();\n      x.copy(p, 1);\n\n      return p;\n    }\n\n    // Uncompressed form (0x04).\n    const p = Buffer.allocUnsafe(1 + fieldSize * 2);\n    const x = this.curve.encodeField(this.getX());\n    const y = this.curve.encodeField(this.getY());\n\n    p[0] = 0x04;\n    x.copy(p, 1);\n    y.copy(p, 1 + fieldSize);\n\n    return p;\n  }\n\n  static decode(curve, bytes) {\n    // [SEC1] Page 11, Section 2.3.4.\n    assert(curve instanceof ShortCurve);\n    assert(Buffer.isBuffer(bytes));\n\n    const len = curve.fieldSize;\n\n    if (bytes.length < 1 + len)\n      throw new Error('Not a point.');\n\n    // Point forms:\n    //\n    //   0x00 -> Infinity (openssl, unsupported)\n    //   0x02 -> Compressed Even\n    //   0x03 -> Compressed Odd\n    //   0x04 -> Uncompressed\n    //   0x06 -> Hybrid Even (openssl)\n    //   0x07 -> Hybrid Odd (openssl)\n    //\n    // Note that openssl supports serializing points\n    // at infinity as {0}. We choose not to support it\n    // because it's strange and not terribly useful.\n    const form = bytes[0];\n\n    switch (form) {\n      case 0x02:\n      case 0x03: {\n        if (bytes.length !== 1 + len)\n          throw new Error('Invalid point size for compressed.');\n\n        const x = curve.decodeField(bytes.slice(1, 1 + len));\n\n        if (x.cmp(curve.p) >= 0)\n          throw new Error('Invalid point.');\n\n        const p = curve.pointFromX(x, form === 0x03);\n\n        assert(!p.isInfinity());\n\n        return p;\n      }\n\n      case 0x04:\n      case 0x06:\n      case 0x07: {\n        if (bytes.length !== 1 + len * 2)\n          throw new Error('Invalid point size for uncompressed.');\n\n        const x = curve.decodeField(bytes.slice(1, 1 + len));\n        const y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len));\n\n        // [GECC] Algorithm 4.3, Page 180, Section 4.\n        if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0)\n          throw new Error('Invalid point.');\n\n        // OpenSSL hybrid encoding.\n        if (form !== 0x04 && form !== (0x06 | y.isOdd()))\n          throw new Error('Invalid hybrid encoding.');\n\n        const p = curve.point(x, y);\n\n        if (!p.validate())\n          throw new Error('Invalid point.');\n\n        assert(!p.isInfinity());\n\n        return p;\n      }\n\n      default: {\n        throw new Error('Unknown point format.');\n      }\n    }\n  }\n\n  encodeX() {\n    // [SCHNORR] \"Specification\".\n    // [BIP340] \"Specification\".\n    return this.curve.encodeField(this.getX());\n  }\n\n  static decodeEven(curve, bytes) {\n    // [BIP340] \"Specification\".\n    assert(curve instanceof ShortCurve);\n\n    const x = curve.decodeField(bytes);\n\n    if (x.cmp(curve.p) >= 0)\n      throw new Error('Invalid point.');\n\n    return curve.pointFromX(x, false);\n  }\n\n  static decodeSquare(curve, bytes) {\n    // [SCHNORR] \"Specification\".\n    // [BIP340] \"Specification\".\n    assert(curve instanceof ShortCurve);\n\n    const x = curve.decodeField(bytes);\n\n    if (x.cmp(curve.p) >= 0)\n      throw new Error('Invalid point.');\n\n    return curve.pointFromX(x);\n  }\n\n  toJSON(pre) {\n    if (this.inf)\n      return [];\n\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n\n    if (pre === true && this.pre)\n      return [x, y, this.pre.toJSON()];\n\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof ShortCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0\n        || json.length === 2\n        || json.length === 3);\n\n    if (json.length === 0)\n      return curve.point();\n\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    const point = curve.point(x, y);\n\n    if (json.length > 2 && json[2] != null)\n      point.pre = Precomp.fromJSON(point, json[2]);\n\n    return point;\n  }\n\n  [custom]() {\n    if (this.inf)\n      return '<ShortPoint: Infinity>';\n\n    return '<ShortPoint:'\n         + ' x=' + this.x.fromRed().toString(16, 2)\n         + ' y=' + this.y.fromRed().toString(16, 2)\n         + '>';\n  }\n}\n\n/**\n * JPoint\n */\n\nclass JPoint extends Point {\n  constructor(curve, x, y, z) {\n    assert(curve instanceof ShortCurve);\n\n    super(curve, types.JACOBIAN);\n\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = this.curve.zero;\n    this.zOne = 0;\n\n    if (x != null)\n      this._init(x, y, z);\n  }\n\n  _init(x, y, z) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    assert(z == null || (z instanceof BN));\n\n    this.x = x;\n    this.y = y;\n    this.z = z || this.curve.one;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n\n    this.zOne = this.z.eq(this.curve.one) | 0;\n  }\n\n  clone() {\n    return this.curve.jpoint(this.x.clone(),\n                             this.y.clone(),\n                             this.z.clone());\n  }\n\n  swap(point, flag) {\n    assert(point instanceof JPoint);\n\n    const cond = ((flag >> 31) | (-flag >> 31)) & 1;\n    const zOne1 = this.zOne;\n    const zOne2 = point.zOne;\n\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n    this.z.cswap(point.z, flag);\n\n    this.zOne = (zOne1 & (cond ^ 1)) | (zOne2 & cond);\n    point.zOne = (zOne2 & (cond ^ 1)) | (zOne1 & cond);\n\n    return this;\n  }\n\n  validate() {\n    // [GECC] Example 3.20, Page 88, Section 3.\n    const {a, b} = this.curve;\n\n    // P = O\n    if (this.isInfinity())\n      return true;\n\n    // Z1 = 1\n    if (this.zOne)\n      return this.curve.validate(this.toP());\n\n    // y^2 = x^3 + a * x * z^4 + b * z^6\n    const lhs = this.y.redSqr();\n    const x3 = this.x.redSqr().redMul(this.x);\n    const z2 = this.z.redSqr();\n    const z4 = z2.redSqr();\n    const z6 = z4.redMul(z2);\n    const rhs = x3.redIAdd(b.redMul(z6));\n\n    if (!this.curve.zeroA) {\n      // Save some cycles for a = -3.\n      if (this.curve.threeA)\n        rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));\n      else\n        rhs.redIAdd(a.redMul(z4).redMul(this.x));\n    }\n\n    return lhs.eq(rhs);\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z\n    // 1I + 3M + 1S\n\n    // Z = 1\n    if (this.zOne)\n      return this;\n\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    // A = 1 / Z1\n    const a = this.z.redInvert();\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // X3 = X1 * AA\n    this.x = this.x.redMul(aa);\n\n    // Y3 = Y1 * AA * A\n    this.y = this.y.redMul(aa).redMul(a);\n\n    // Z3 = 1\n    this.z = this.curve.one;\n    this.zOne = 1;\n\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN);\n\n    // P = O\n    if (this.isInfinity())\n      return this.curve.jpoint();\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // X3 = X1 * AA\n    const nx = this.x.redMul(aa);\n\n    // Y3 = Y1 * AA * A\n    const ny = this.y.redMul(aa).redMul(a);\n\n    // Z3 = Z1 * A\n    const nz = this.z.redMul(a);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  neg() {\n    // -(X1, Y1, Z1) = (X1, -Y1, Z1)\n    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n  }\n\n  add(p) {\n    assert(p instanceof Point);\n\n    if (p.type === types.AFFINE)\n      return this._mixedAdd(p);\n\n    return this._add(p);\n  }\n\n  _add(p) {\n    assert(p instanceof JPoint);\n\n    // O + P = P\n    if (this.isInfinity())\n      return p;\n\n    // P + O = P\n    if (p.isInfinity())\n      return this;\n\n    // Z1 = 1, Z2 = 1\n    if (this.zOne && p.zOne)\n      return this._addAA(p);\n\n    // Z1 = 1\n    if (this.zOne)\n      return p._addJA(this);\n\n    // Z2 = 1\n    if (p.zOne)\n      return this._addJA(p);\n\n    return this._addJJ(p);\n  }\n\n  _mixedAdd(p) {\n    assert(p instanceof ShortPoint);\n\n    // O + P = P\n    if (this.isInfinity())\n      return p.toJ();\n\n    // P + O = P\n    if (p.isInfinity())\n      return this;\n\n    // Z1 = 1, Z2 = 1\n    if (this.zOne)\n      return this._addAA(p);\n\n    return this._addJA(p);\n  }\n\n  _addJJ(p) {\n    // No assumptions.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2\n    // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)\n\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr();\n\n    // Z2Z2 = Z2^2\n    const z2z2 = p.z.redSqr();\n\n    // U1 = X1 * Z2Z2\n    const u1 = this.x.redMul(z2z2);\n\n    // U2 = X2 * Z1Z1\n    const u2 = p.x.redMul(z1z1);\n\n    // S1 = Y1 * Z2 * Z2Z2\n    const s1 = this.y.redMul(p.z).redMul(z2z2);\n\n    // S2 = Y2 * Z1 * Z1Z1\n    const s2 = p.y.redMul(this.z).redMul(z1z1);\n\n    // H = U2 - U1\n    const h = u2.redISub(u1);\n\n    // r = S2 - S1\n    const r = s2.redISub(s1);\n\n    // H = 0\n    if (h.isZero()) {\n      if (!r.isZero())\n        return this.curve.jpoint();\n\n      return this.dbl();\n    }\n\n    // HH = H^2\n    const hh = h.redSqr();\n\n    // HHH = H * HH\n    const hhh = h.redMul(hh);\n\n    // V = U1 * HH\n    const v = u1.redMul(hh);\n\n    // X3 = r^2 - HHH - 2 * V\n    const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v);\n\n    // Y3 = r * (V - X3) - S1 * HHH\n    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh));\n\n    // Z3 = Z1 * Z2 * H\n    const nz = this.z.redMul(p.z).redMul(h);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _addJA(p) {\n    // Assumes Z2 = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd\n    // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)\n\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr();\n\n    // U2 = X2 * Z1Z1\n    const u2 = p.x.redMul(z1z1);\n\n    // S2 = Y2 * Z1 * Z1Z1\n    const s2 = p.y.redMul(this.z).redMul(z1z1);\n\n    // H = U2 - X1\n    const h = u2.redISub(this.x);\n\n    // r = 2 * (S2 - Y1)\n    const r = s2.redISub(this.y).redIMuln(2);\n\n    // H = 0\n    if (h.isZero()) {\n      if (!r.isZero())\n        return this.curve.jpoint();\n\n      return this.dbl();\n    }\n\n    // I = (2 * H)^2\n    const i = h.redMuln(2).redSqr();\n\n    // J = H * I\n    const j = h.redMul(i);\n\n    // V = X1 * I\n    const v = this.x.redMul(i);\n\n    // X3 = r^2 - J - 2 * V\n    const nx = r.redSqr().redISub(j).redISub(v).redISub(v);\n\n    // Y3 = r * (V - X3) - 2 * Y1 * J\n    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));\n\n    // Z3 = 2 * Z1 * H\n    const nz = this.z.redMul(h).redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _addAA(p) {\n    // Assumes Z1 = 1, Z2 = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-mmadd-2007-bl\n    // 4M + 2S + 6A + 4*2 + 1*4 (implemented as: 4M + 2S + 7A + 3*2 + 1*4)\n\n    // H = X2 - X1\n    const h = p.x.redSub(this.x);\n\n    // r = 2 * (Y2 - Y1)\n    const r = p.y.redSub(this.y).redIMuln(2);\n\n    // H = 0\n    if (h.isZero()) {\n      if (!r.isZero())\n        return this.curve.jpoint();\n\n      return this.dbl();\n    }\n\n    // HH = H^2\n    const hh = h.redSqr();\n\n    // I = 4 * HH\n    const i = hh.redIMuln(4);\n\n    // J = H * I\n    const j = h.redMul(i);\n\n    // V = X1 * I\n    const v = this.x.redMul(i);\n\n    // X3 = r^2 - J - 2 * V\n    const nx = r.redSqr().redISub(j).redISub(v).redISub(v);\n\n    // Y3 = r * (V - X3) - 2 * Y1 * J\n    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));\n\n    // Z3 = 2 * H\n    const nz = h.redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  dbl() {\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    // Y1 = 0\n    if (this.y.isZero())\n      return this.curve.jpoint();\n\n    // Z1 = 1\n    if (this.zOne)\n      return this._dblA();\n\n    // a = 0\n    if (this.curve.zeroA)\n      return this._dbl0();\n\n    // a = -3\n    if (this.curve.threeA)\n      return this._dbl3();\n\n    return this._dblJ();\n  }\n\n  _dblJ() {\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n    // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8\n    // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)\n\n    // XX = X1^2\n    const xx = this.x.redSqr();\n\n    // YY = Y1^2\n    const yy = this.y.redSqr();\n\n    // ZZ = Z1^2\n    const zz = this.z.redSqr();\n\n    // S = 4 * X1 * YY\n    const s = this.x.redMul(yy).redIMuln(4);\n\n    // M = 3 * XX + a * ZZ^2\n    const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr()));\n\n    // T = M^2 - 2 * S\n    const t = m.redSqr().redISub(s).redISub(s);\n\n    // X3 = T\n    const nx = t;\n\n    // Y3 = M * (S - T) - 8 * YY^2\n    const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8));\n\n    // Z3 = 2 * Y1 * Z1\n    const nz = this.y.redMul(this.z).redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dblA() {\n    // Assumes Z = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-mdbl-2007-bl\n    // 1M + 5S + 7A + 3*2 + 1*3 + 1*8\n    // (implemented as: 1M + 5S + 8A + 2*2 + 1*3 + 1*8)\n\n    // XX = X1^2\n    const xx = this.x.redSqr();\n\n    // YY = Y1^2\n    const yy = this.y.redSqr();\n\n    // YYYY = YY^2\n    const yyyy = yy.redSqr();\n\n    // + XYY2 = (X1 + YY)^2\n    const xyy2 = yy.redIAdd(this.x).redSqr();\n\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    const s = xyy2.redISub(xx).redISub(yyyy).redIMuln(2);\n\n    // M = 3 * XX + a\n    const m = xx.redIMuln(3).redIAdd(this.curve.a);\n\n    // T = M^2 - 2 * S\n    const t = m.redSqr().redISub(s).redISub(s);\n\n    // X3 = T\n    const nx = t;\n\n    // Y3 = M * (S - T) - 8 * YYYY\n    const ny = m.redMul(s.redISub(t)).redISub(yyyy.redIMuln(8));\n\n    // Z3 = 2 * Y1\n    const nz = this.y.redMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dbl0() {\n    // Assumes a = 0.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8\n    // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)\n\n    // A = X1^2\n    const a = this.x.redSqr();\n\n    // B = Y1^2\n    const b = this.y.redSqr();\n\n    // C = B^2\n    const c = b.redSqr();\n\n    // + XB2 = (X1 + B)^2\n    const xb2 = b.redIAdd(this.x).redSqr();\n\n    // D = 2 * ((X1 + B)^2 - A - C)\n    const d = xb2.redISub(a).redISub(c).redIMuln(2);\n\n    // E = 3 * A\n    const e = a.redIMuln(3);\n\n    // F = E^2\n    const f = e.redSqr();\n\n    // X3 = F - 2 * D\n    const nx = f.redISub(d).redISub(d);\n\n    // Y3 = E * (D - X3) - 8 * C\n    const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8));\n\n    // Z3 = 2 * Y1 * Z1\n    const nz = this.y.redMul(this.z).redIMuln(2);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dbl3() {\n    // Assumes a = -3.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S + 8A + 1*3 + 1*4 + 2*8\n    // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)\n\n    // delta = Z1^2\n    const delta = this.z.redSqr();\n\n    // gamma = Y1^2\n    const gamma = this.y.redSqr();\n\n    // beta = X1 * gamma\n    const beta = this.x.redMul(gamma);\n\n    // + xmdelta = X1 - delta\n    const xmdelta = this.x.redSub(delta);\n\n    // + xpdelta = X1 + delta\n    const xpdelta = this.x.redAdd(delta);\n\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    const alpha = xmdelta.redMul(xpdelta).redIMuln(3);\n\n    // + beta4 = 4 * beta\n    const beta4 = beta.redIMuln(4);\n\n    // + beta8 = 2 * beta4\n    const beta8 = beta4.redMuln(2);\n\n    // + gamma28 = 8 * gamma^2\n    const gamma28 = gamma.redSqr().redIMuln(8);\n\n    // X3 = alpha^2 - 8 * beta\n    const nx = alpha.redSqr().redISub(beta8);\n\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  dblp(pow) {\n    assert((pow >>> 0) === pow);\n\n    // a = 0 or a = -3\n    if (this.curve.zeroA || this.curve.threeA)\n      return super.dblp(pow);\n\n    // m = 0\n    if (pow === 0)\n      return this;\n\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    return this._dblp(pow);\n  }\n\n  _dblp(pow) {\n    // Repeated point doubling (Jacobian coordinates).\n    //\n    // [GECC] Algorithm 3.23, Page 93, Section 3.2.\n    //\n    // Modified version of:\n    //   https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n    //\n    // Divergences from the above formula are marked with diff notation.\n    //\n    // Implemented as:\n    //   1M + 2S + 1*2 + N * (4M + 4S + 4A + 1*a + 1*3 + 2*2)\n    //   e.g. N = 1 => 5M + 6S + 4A + 1*a + 1*3 + 3*2\n    //\n    // Repeated doubling also explained here:\n    //   https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates\n    //\n    // Note that the above sources change:\n    //   M = 3 * XX + a * ZZZZ\n    // To:\n    //   M = 3 * (XX - ZZZZ)\n    //\n    // In order to assume a = -3.\n    const {a, i2} = this.curve;\n\n    // Reuse results (y is always y*2).\n    let x = this.x;\n    let z = this.z;\n\n    // + Y1 = Y1 * 2\n    let y = this.y.redMuln(2);\n\n    // + ZZZZ = Z1^4\n    let zzzz = z.redPown(4);\n\n    for (let i = 0; i < pow; i++) {\n      // Y1 = 0\n      if (y.isZero())\n        return this.curve.jpoint();\n\n      // XX = X1^2\n      const xx = x.redSqr();\n\n      // YY = Y1^2\n      const yy = y.redSqr();\n\n      // + YYYY = YY^2\n      const yyyy = yy.redSqr();\n\n      // - M = 3 * XX + a * ZZ^2\n      // + M = 3 * XX + a * ZZZZ\n      const m = xx.redIMuln(3).redIAdd(a.redMul(zzzz));\n\n      // - S = 4 * X1 * YY\n      // + S = X1 * YY\n      const s = x.redMul(yy);\n\n      // T = M^2 - 2 * S\n      const t = m.redSqr().redISub(s).redISub(s);\n\n      // X3 = T\n      const nx = t;\n\n      // - Y3 = M * (S - T) - 8 * YY^2\n      // + Y3 = M * (S - T) * 2 - YYYY\n      const ny = m.redMul(s.redISub(t)).redIMuln(2).redISub(yyyy);\n\n      // Z3 = 2 * Y1 * Z1\n      const nz = y.redMul(z);\n\n      // + ZZZZ = ZZZZ * YYYY\n      if (i + 1 < pow)\n        zzzz = zzzz.redMul(yyyy);\n\n      // + X1 = X3\n      x = nx;\n\n      // + Y1 = Y3\n      y = ny;\n\n      // + Z1 = Z3\n      z = nz;\n    }\n\n    return this.curve.jpoint(x, y.redMul(i2), z);\n  }\n\n  uadd(p) {\n    assert(p instanceof Point);\n\n    if (p.type === types.AFFINE)\n      return this._uadd(p.toJ());\n\n    return this._uadd(p);\n  }\n\n  _uadd(p) {\n    // Strongly unified Jacobian addition (Brier and Joye).\n    //\n    // [SIDE2] Page 6, Section 3.\n    // [SIDE3] Page 4, Section 3.\n    //\n    // The above documents use projective coordinates[1]\n    // and have been modified for jacobian coordinates. A\n    // further modification, taken from libsecp256k1[2],\n    // handles the degenerate case of: x1 != x2, y1 = -y2.\n    //\n    // [1] https://hyperelliptic.org/EFD/g1p/auto-shortw-projective.html#addition-add-2002-bj\n    // [2] https://github.com/bitcoin-core/secp256k1/blob/ee9e68c/src/group_impl.h#L525\n    //\n    // 11M + 8S + 7A + 1*a + 2*4 + 1*3 + 2*2 (a != 0)\n    // 11M + 6S + 6A + 2*4 + 1*3 + 2*2 (a = 0)\n    assert(p instanceof JPoint);\n\n    const {zero, one} = this.curve;\n\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr();\n\n    // Z2Z2 = Z2^2\n    const z2z2 = p.z.redSqr();\n\n    // U1 = X1 * Z2Z2\n    const u1 = this.x.redMul(z2z2);\n\n    // U2 = X2 * Z1Z1\n    const u2 = p.x.redMul(z1z1);\n\n    // S1 = Y1 * Z2Z2 * Z2\n    const s1 = this.y.redMul(z2z2).redMul(p.z);\n\n    // S2 = Y2 * Z1Z1 * Z1\n    const s2 = p.y.redMul(z1z1).redMul(this.z);\n\n    // Z = Z1 * Z2\n    const z = this.z.redMul(p.z);\n\n    // T = U1 + U2\n    const t = u1.redAdd(u2);\n\n    // M = S1 + S2\n    const m = s1.redAdd(s2);\n\n    // R = T^2 - U1 * U2\n    const r = t.redSqr().redISub(u1.redMul(u2));\n\n    // R = R + a * Z^4 (if a != 0)\n    if (!this.curve.zeroA) {\n      const zzzz = z.redPown(4);\n\n      // Save some cycles for a = -3.\n      if (this.curve.threeA)\n        r.redIAdd(zzzz.redIMuln(-3));\n      else\n        r.redIAdd(this.curve.a.redMul(zzzz));\n    }\n\n    // Check for degenerate case (X1 != X2, Y1 = -Y2).\n    const degenerate = m.czero() & r.czero();\n\n    // M = U1 - U2 (if degenerate)\n    m.cinject(u1.redSub(u2), degenerate);\n\n    // R = S1 - S2 (if degenerate)\n    r.cinject(s1.redSub(s2), degenerate);\n\n    // L = M^2\n    const l = m.redSqr();\n\n    // G = T * L\n    const g = t.redMul(l);\n\n    // LL = L^2\n    const ll = l.redSqr();\n\n    // LL = 0 (if degenerate)\n    ll.cinject(zero, degenerate);\n\n    // W = R^2\n    const w = r.redSqr();\n\n    // F = Z * M\n    const f = z.redMul(m);\n\n    // H = 3 * G - 2 * W\n    const h = g.redMuln(3).redISub(w).redISub(w);\n\n    // X3 = 4 * (W - G)\n    const nx = w.redISub(g).redIMuln(4);\n\n    // Y3 = 4 * (R * H - LL)\n    const ny = r.redMul(h).redISub(ll).redIMuln(4);\n\n    // Z3 = 2 * F\n    const nz = f.redIMuln(2);\n\n    // Check for infinity.\n    const inf1 = this.z.czero();\n    const inf2 = p.z.czero();\n    const inf3 = nz.czero() & ((inf1 | inf2) ^ 1);\n\n    // Case 1: O + P = P\n    nx.cinject(p.x, inf1);\n    ny.cinject(p.y, inf1);\n    nz.cinject(p.z, inf1);\n\n    // Case 2: P + O = P\n    nx.cinject(this.x, inf2);\n    ny.cinject(this.y, inf2);\n    nz.cinject(this.z, inf2);\n\n    // Case 3: P + -P = O\n    nx.cinject(one, inf3);\n    ny.cinject(one, inf3);\n    nz.cinject(zero, inf3);\n\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  udbl() {\n    const p = this._udbl();\n    const inf = this.z.czero() | this.y.czero();\n\n    // Case 1 & 2: 2 * O = O, 2 * (X, 0) = O\n    p.x.cinject(this.curve.one, inf);\n    p.y.cinject(this.curve.one, inf);\n    p.z.cinject(this.curve.zero, inf);\n\n    return p;\n  }\n\n  _udbl() {\n    // a = 0\n    if (this.curve.zeroA)\n      return this._dbl0();\n\n    // a = -3\n    if (this.curve.threeA)\n      return this._dbl3();\n\n    return this._dblJ();\n  }\n\n  zaddu(p) {\n    // Co-Z addition with update (ZADDU).\n    // [COZ] Algorithm 19, Page 15, Appendix C.\n    // 5M + 2S + 7A\n    assert(p instanceof JPoint);\n\n    // H = X1 - X2\n    const h = this.x.redSub(p.x);\n\n    // R = Y1 - Y2\n    const r = this.y.redSub(p.y);\n\n    // HH = H^2\n    const hh = h.redSqr();\n\n    // V1 = X1 * HH\n    const v1 = this.x.redMul(hh);\n\n    // V2 = X2 * HH\n    const v2 = p.x.redMul(hh);\n\n    // X4 = V1\n    const x4 = v1;\n\n    // X3 = R^2 - V1 - V2\n    const x3 = r.redSqr().redISub(v1).redISub(v2);\n\n    // Y4 = Y1 * (V1 - V2)\n    const y4 = this.y.redMul(v1.redSub(v2));\n\n    // Y3 = R * (X4 - X3) - Y4\n    const y3 = r.redMul(x4.redSub(x3)).redISub(y4);\n\n    // Z4 = Z1 * H\n    const z4 = this.z.redMul(h);\n\n    // Z3 = Z4\n    const z3 = z4;\n\n    // R = (X3, Y3, Z3)\n    // P = (X4, Y4, Z4)\n    return [\n      this.curve.jpoint(x3, y3, z3),\n      this.curve.jpoint(x4, y4, z4)\n    ];\n  }\n\n  zaddc(p) {\n    // Co-Z addition with conjugate (ZADDC).\n    // [COZ] Algorithm 20, Page 15, Appendix C.\n    // 6M + 3S + 14A + 1*2\n    assert(p instanceof JPoint);\n\n    // H = X1 - X2\n    const h = this.x.redSub(p.x);\n\n    // R = Y1 - Y2\n    const r = this.y.redSub(p.y);\n\n    // M = Y1 + Y2\n    const m = this.y.redAdd(p.y);\n\n    // HH = H^2\n    const hh = h.redSqr();\n\n    // V1 = X1 * HH\n    const v1 = this.x.redMul(hh);\n\n    // V2 = X2 * HH\n    const v2 = p.x.redMul(hh);\n\n    // X4 = (Y1 + Y2)^2 - V1 - V2\n    const x4 = m.redSqr().redISub(v1).redISub(v2);\n\n    // X3 = R^2 - V1 - V2\n    const x3 = r.redSqr().redISub(v1).redISub(v2);\n\n    // Y = Y1 * (V2 - V1)\n    const y = this.y.redMul(v2.redISub(v1));\n\n    // Z = R + 2 * Y2\n    const z = p.y.redMuln(2).redIAdd(r);\n\n    // I = V1 - X4\n    const i = v1.redISub(x4);\n\n    // J = X4 + I - X3\n    const j = x4.redAdd(i).redISub(x3);\n\n    // Y4 = Z * I + Y\n    const y4 = z.redMul(i).redIAdd(y);\n\n    // Y3 = R * J + Y\n    const y3 = r.redMul(j).redIAdd(y);\n\n    // Z4 = Z1 * H\n    const z4 = this.z.redMul(h);\n\n    // Z3 = Z4\n    const z3 = z4;\n\n    // R = (X3, Y3, Z3)\n    // S = (X4, Y4, Z4)\n    return [\n      this.curve.jpoint(x3, y3, z3),\n      this.curve.jpoint(x4, y4, z4)\n    ];\n  }\n\n  zdblu() {\n    // Co-Z doubling with update (DBLU).\n    // [COZ] Algorithm 21, Page 15, Appendix C.\n    //\n    // 1M + 5S + 8A + 4*2 + 1*8\n    //\n    // Note that the original formula assumed Z1=1.\n    // We have modified it to allow for scaled points.\n    //\n    // New Cost: 2M + 5S + 8A + 1*a + 1*3 + 2*2 + 1*8\n\n    // XX = X1^2\n    const xx = this.x.redSqr();\n\n    // YY = Y1^2\n    const yy = this.y.redSqr();\n\n    // YYYY = YY^2\n    const yyyy = yy.redSqr();\n\n    // S = (X1 + YY)^2\n    const s = this.x.redAdd(yy).redSqr();\n\n    // M = 3 * XX\n    const m = xx.redMuln(3);\n\n    // M = M + a * Z1^4 (if a != 0)\n    if (!this.curve.zeroA) {\n      const zzzz = this.z.redPown(4);\n\n      // Save some cycles for a = -3.\n      if (this.curve.threeA)\n        m.redIAdd(zzzz.redIMuln(-3));\n      else\n        m.redIAdd(this.curve.a.redMul(zzzz));\n    }\n\n    // X4 = 2 * (S - XX - YYYY)\n    const x4 = s.redISub(xx).redISub(yyyy).redIMuln(2);\n\n    // X3 = M^2 - X4 - X4\n    const x3 = m.redSqr().redISub(x4).redISub(x4);\n\n    // Y4 = 8 * YYYY\n    const y4 = yyyy.redIMuln(8);\n\n    // Y3 = (X4 - X3) * M - Y4\n    const y3 = x4.redSub(x3).redMul(m).redISub(y4);\n\n    // Z4 = 2 * (Y1 * Z1)\n    const z4 = this.y.redMul(this.z).redIMuln(2);\n\n    // Z3 = Z4\n    const z3 = z4;\n\n    // R = (X3, Y3, Z3)\n    // P = (X4, Y4, Z4)\n    return [\n      this.curve.jpoint(x3, y3, z3),\n      this.curve.jpoint(x4, y4, z4)\n    ];\n  }\n\n  recover(x1, z1, x2, z2) {\n    return this.toP().recover(x1, z1, x2, z2);\n  }\n\n  getX() {\n    if (this.isInfinity())\n      throw new Error('Invalid point.');\n\n    this.normalize();\n\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.isInfinity())\n      throw new Error('Invalid point.');\n\n    this.normalize();\n\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof JPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.isInfinity())\n      return p.isInfinity();\n\n    // Q = O\n    if (p.isInfinity())\n      return false;\n\n    // Z1 = Z2\n    if (this.z.eq(p.z)) {\n      return this.x.eq(p.x)\n          && this.y.eq(p.y);\n    }\n\n    // X1 * Z2^2 == X2 * Z1^2\n    const zz1 = this.z.redSqr();\n    const zz2 = p.z.redSqr();\n    const x1 = this.x.redMul(zz2);\n    const x2 = p.x.redMul(zz1);\n\n    if (!x1.eq(x2))\n      return false;\n\n    // Y1 * Z2^3 == Y2 * Z1^3\n    const zzz1 = zz1.redMul(this.z);\n    const zzz2 = zz2.redMul(p.z);\n    const y1 = this.y.redMul(zzz2);\n    const y2 = p.y.redMul(zzz1);\n\n    return y1.eq(y2);\n  }\n\n  isInfinity() {\n    // Z1 = 0\n    return this.z.isZero();\n  }\n\n  isOdd() {\n    if (this.isInfinity())\n      return false;\n\n    this.normalize();\n\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.isInfinity())\n      return false;\n\n    this.normalize();\n\n    return this.y.redIsEven();\n  }\n\n  isSquare() {\n    if (this.isInfinity())\n      return false;\n\n    return this.y.redMul(this.z).redJacobi() !== -1;\n  }\n\n  eqX(x) {\n    // Verify that integer `x` is equal to field\n    // element `x` by scaling it by our z coordinate.\n    // This optimization is mentioned in and used for\n    // bip-schnorr[1]. This avoids having to affinize\n    // the resulting point during verification.\n    //\n    // [1] [SCHNORR] \"Optimizations\".\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    if (this.isInfinity())\n      return false;\n\n    const zz = this.z.redSqr();\n    const rx = x.toRed(this.curve.red).redMul(zz);\n\n    return this.x.eq(rx);\n  }\n\n  eqXToP(x) {\n    // Similar to the optimization above, this\n    // optimization, suggested by Maxwell[1],\n    // compares an integer to an X coordinate\n    // by scaling it.\n    //\n    // Since a signature's R value is modulo N\n    // in ECDSA, we may be dealing with an R\n    // value greater than N in actuality.\n    //\n    // If the equality check fails, we can\n    // scale N itself by Z and add it to the\n    // X field element (up until a certain\n    // limit) and repeat the check.\n    //\n    // If P is more than 100 times larger than\n    // N, we don't gain much here, so we just\n    // affinize and do the comparison.\n    //\n    // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f\n    assert(x instanceof BN);\n    assert(!x.red);\n\n    if (!this.curve.smallGap)\n      return this.toP().eqXToP(x);\n\n    if (this.isInfinity())\n      return false;\n\n    if (x.cmp(this.curve.p) >= 0)\n      return false;\n\n    const zz = this.z.redSqr();\n    const rx = x.toRed(this.curve.red).redMul(zz);\n\n    if (this.x.eq(rx))\n      return true;\n\n    if (this.curve.highOrder)\n      return false;\n\n    if (x.cmp(this.curve.pmodn) >= 0)\n      return false;\n\n    const rn = this.curve.redN.redMul(zz);\n\n    rx.redIAdd(rn);\n\n    return this.x.eq(rx);\n  }\n\n  toP() {\n    // P = O\n    if (this.isInfinity())\n      return this.curve.point();\n\n    this.normalize();\n\n    // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)\n    return this.curve.point(this.x, this.y);\n  }\n\n  toJ() {\n    return this;\n  }\n\n  encode(compact) {\n    return this.toP().encode(compact);\n  }\n\n  static decode(curve, bytes) {\n    return ShortPoint.decode(curve, bytes).toJ();\n  }\n\n  encodeX() {\n    return this.toP().encodeX();\n  }\n\n  static decodeEven(curve, bytes) {\n    return ShortPoint.decodeEven(curve, bytes).toJ();\n  }\n\n  static decodeSquare(curve, bytes) {\n    return ShortPoint.decodeSquare(curve, bytes).toJ();\n  }\n\n  toJSON(pre) {\n    return this.toP().toJSON(pre);\n  }\n\n  static fromJSON(curve, json) {\n    return ShortPoint.fromJSON(curve, json).toJ();\n  }\n\n  [custom]() {\n    if (this.isInfinity())\n      return '<JPoint: Infinity>';\n\n    return '<JPoint:'\n         + ' x=' + this.x.fromRed().toString(16, 2)\n         + ' y=' + this.y.fromRed().toString(16, 2)\n         + ' z=' + this.z.fromRed().toString(16, 2)\n         + '>';\n  }\n}\n\n/**\n * MontCurve\n */\n\nclass MontCurve extends Curve {\n  constructor(conf) {\n    super(MontPoint, 'mont', conf);\n\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.b = BN.fromJSON(conf.b).toRed(this.red);\n\n    this.bi = this.b.redInvert();\n    this.a2 = this.a.redAdd(this.two);\n    this.a24 = this.a2.redMul(this.i4);\n    this.a3 = this.a.redMul(this.i3);\n    this.a0 = this.a.redMul(this.bi);\n    this.b0 = this.bi.redSqr();\n\n    this._finalize(conf);\n  }\n\n  static _isomorphism(curveA, curveB, customB) {\n    // Montgomery Isomorphism.\n    //\n    // [MONT3] Page 3, Section 2.1.\n    //\n    // Transformation:\n    //\n    //   A' = A\n    //   B' = B'\n    //\n    // Where (B / B') is square.\n    assert(curveA instanceof BN);\n    assert(curveB instanceof BN);\n    assert(customB instanceof BN);\n\n    const a = curveA.clone();\n    const b = customB.clone();\n    const c = curveB.redDiv(customB);\n\n    if (c.redJacobi() !== 1)\n      throw new Error('Invalid `b` coefficient.');\n\n    return [a, b];\n  }\n\n  _short(a0, odd) {\n    // Montgomery->Short Weierstrass Equivalence.\n    //\n    // [MONT2] \"Equivalence with Weierstrass curves\".\n    //\n    // Transformation:\n    //\n    //   a = (3 - A^2) / (3 * B^2)\n    //   b = (2 * A^3 - 9 * A) / (27 * B^3)\n    const {a, b, three} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const b3 = b2.redMul(b);\n    const n0 = three.redSub(a2);\n    const d0 = b2.redMuln(3);\n    const n1 = a3.redMuln(2).redISub(a.redMuln(9));\n    const d1 = b3.redMuln(27);\n    const wa = n0.redDiv(d0);\n    const wb = n1.redDiv(d1);\n\n    if (a0 != null)\n      return ShortCurve._isomorphism(wa, wb, a0, odd);\n\n    return [wa, wb];\n  }\n\n  _mont(b0) {\n    return MontCurve._isomorphism(this.a, this.b, b0);\n  }\n\n  _edwards(a0, invert = false) {\n    // Montgomery->Twisted Edwards Transformation.\n    //\n    // [MONT1] Page 11, Section 4.3.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //\n    // Equivalence:\n    //\n    //   a = (A + 2) / B\n    //   d = (A - 2) / B\n    //\n    // Isomorphism:\n    //\n    //   a = a'\n    //   d = a' * (A - 2) / (A + 2)\n    //\n    // Where ((A + 2) / (B * a')) is square.\n    //\n    // If `d` is square, we can usually find\n    // a complete curve by using the `invert`\n    // option. This will create an isomorphism\n    // chain of: M(A,B)->E(a,d)->E(d,a).\n    //\n    // The equivalence between E(a,d) and\n    // E(d,a) is:\n    //\n    //   (x, y) = (x, 1 / y)\n    //\n    // Meaning our map to E(d,a) is:\n    //\n    //   x = u / v\n    //   y = 1 / ((u - 1) / (u + 1))\n    //     = (u + 1) / (u - 1)\n    assert(typeof invert === 'boolean');\n\n    const {two, bi} = this;\n    const a = this.a.redAdd(two).redMul(bi);\n    const d = this.a.redSub(two).redMul(bi);\n\n    if (invert)\n      a.swap(d);\n\n    if (a0 != null)\n      return EdwardsCurve._isomorphism(a, d, a0);\n\n    return [a, d];\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    const [u2, u3] = curve._scale(this);\n\n    return [this.field(u2.redInvert()),\n            this.field(u3.redInvert())];\n  }\n\n  _scaleMont(curve) {\n    // We can extract the isomorphism factor with:\n    //\n    //   c = +-sqrt(B / B')\n    //\n    // If base points are available, we can do:\n    //\n    //   c = v' / v\n    assert(curve instanceof MontCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity())\n      return this.field(curve.b).redDivSqrt(this.b);\n\n    return this.g.y.redDiv(this.field(curve.g.y));\n  }\n\n  _scaleEdwards(curve, invert) {\n    // We _could_ do something like:\n    //\n    //   B = 4 / (a - d)\n    //   c = +-sqrt(B / B')\n    //\n    // Which can be reduced to:\n    //\n    //   c = +-sqrt(4 / ((a - d) * B'))\n    //\n    // If base points are available:\n    //\n    //   v = u' / x\n    //   c = v' / v\n    //\n    // Which can be reduced to:\n    //\n    //   c = v' * x / u'\n    //\n    // However, the way our maps are\n    // written, we can re-use the Edwards\n    // isomorphism factor when going the\n    // other direction.\n    assert(curve instanceof EdwardsCurve);\n\n    const c = curve._scale(this, invert);\n\n    return this.field(c);\n  }\n\n  _solveY0(x) {\n    assert(x instanceof BN);\n\n    // y^2 = x^3 + A * x^2 + B * x\n    const a = this.a0;\n    const b = this.b0;\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));\n\n    return y2;\n  }\n\n  _elligator2(u) {\n    // Elligator 2.\n    //\n    // Distribution: 1/2.\n    //\n    // [ELL2] Page 11, Section 5.2.\n    // [H2EC] \"Elligator 2 Method\".\n    //        \"Mappings for Montgomery curves\".\n    // [SAFE] \"Indistinguishability from uniform random strings\".\n    //\n    // Assumptions:\n    //\n    //   - y^2 = x^3 + A * x^2 + B * x.\n    //   - A != 0, B != 0.\n    //   - A^2 - 4 * B is non-zero and non-square in F(p).\n    //   - Let z be a non-square in F(p).\n    //   - u != +-sqrt(-1 / z).\n    //\n    // Note that Elligator 2 is defined over the form:\n    //\n    //   y'^2 = x'^3 + A' * x'^2 + B' * x'\n    //\n    // Instead of:\n    //\n    //   B * y^2 = x^3 + A * x^2 + x\n    //\n    // Where:\n    //\n    //   A' = A / B\n    //   B' = 1 / B^2\n    //   x' = x / B\n    //   y' = y / B\n    //\n    // And:\n    //\n    //   x = B * x'\n    //   y = B * y'\n    //\n    // This is presumably the result of Elligator 2\n    // being designed in long Weierstrass form. If\n    // we want to support B != 1, we need to do the\n    // conversion.\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + A * x^2 + B * x\n    //   x1 = -A / (1 + z * u^2)\n    //   x1 = -A, if x1 = 0\n    //   x2 = -x1 - A\n    //   x = x1, if g(x1) is square\n    //     = x2, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const lhs = this.a0.redNeg();\n    const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));\n\n    rhs.cinject(this.one, rhs.czero());\n\n    const x1 = lhs.redMul(rhs.redFermat());\n    const x2 = x1.redNeg().redISub(this.a0);\n    const y1 = this._solveY0(x1);\n    const y2 = this._solveY0(x2);\n    const alpha = y1.redIsSquare() | 0;\n    const x0 = x1.cinject(x2, alpha ^ 1);\n    const y0 = y1.cinject(y2, alpha ^ 1).redSqrt();\n\n    y0.cinject(y0.redNeg(), y0.redIsOdd() ^ u.redIsOdd());\n\n    const x = this.b.redMul(x0);\n    const y = this.b.redMul(y0);\n\n    return this.point(x, y);\n  }\n\n  _invert2(p, hint) {\n    // Inverting the Map (Elligator 2).\n    //\n    // [ELL2] Page 12, Section 5.3.\n    //\n    // Assumptions:\n    //\n    //   - -z * x * (x + A) is square in F(p).\n    //   - If r = 1 then x != 0.\n    //   - If r = 2 then x != -A.\n    //\n    // Map:\n    //\n    //   u1 = -(x + A) / (x * z)\n    //   u2 = -x / ((x + A) * z)\n    //   r = random integer in [1,2]\n    //   u = sign(y) * abs(sqrt(ur))\n    //\n    // Note that `0 / 0` can only occur if `A == 0`\n    // (this violates the assumptions of Elligator 2).\n    const {x, y} = p;\n    const r = hint & 1;\n    const x0 = x.redMul(this.bi);\n    const y0 = y.redMul(this.bi);\n    const n = x0.redAdd(this.a0);\n    const d = x0;\n\n    n.cswap(d, r);\n\n    const lhs = n.redINeg();\n    const rhs = d.redMul(this.z);\n    const [sqr, u] = divSqrt(lhs, rhs);\n\n    u.cinject(u.redNeg(), u.redIsOdd() ^ y0.redIsOdd());\n\n    if (!sqr)\n      throw new Error('Invalid point.');\n\n    return u;\n  }\n\n  _constMul(p, k, rng) {\n    // Use the single-coordinate ladder in\n    // combination with y-coordinate recovery\n    // to compute an affine point.\n    //\n    // There are a few edge cases here, some\n    // of them documented by Mike Hamburg[1].\n    //\n    // There are two primary edge cases here:\n    //\n    //   1. P * k = O where k = n - 1.\n    //   2. P * k = O where P is small order.\n    //\n    // The first occurs due to the fact that\n    // the Okeya-Sakurai formula requires\n    // one to compute both Q and Q+P. In the\n    // case of k=n-1, Q+P becomes infinity.\n    //\n    // In other words:\n    //\n    //   Q2 = P * (n - 1) + P = O\n    //\n    // The second edge case is a side effect\n    // of the differential addition used in\n    // the ladder. This covers the first two\n    // cases mentioned by Hamburg.\n    //\n    // [1] https://tinyurl.com/y4q2dey9\n    assert(p instanceof MontPoint);\n\n    const x = p.toX();\n    const [a, b] = x.ladderConst(k, rng);\n    const q = p.recover(b, a);\n\n    return k.isNeg() ? q.neg() : q;\n  }\n\n  isElliptic() {\n    const a2 = this.a.redSqr();\n    const d = this.b.redMul(a2.redSub(this.four));\n\n    // B * (A^2 - 4) != 0\n    return !d.isZero();\n  }\n\n  jinv() {\n    // [MONT3] Page 3, Section 2.\n    const {a, three, four} = this;\n    const a2 = a.redSqr();\n    const t0 = a2.redSub(three);\n    const lhs = t0.redPown(3).redIMuln(256);\n    const rhs = a2.redSub(four);\n\n    if (rhs.isZero())\n      throw new Error('Curve is not elliptic.');\n\n    // (256 * (A^2 - 3)^3) / (A^2 - 4)\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  point(x, y, inf = 0) {\n    return new MontPoint(this, x, y, inf);\n  }\n\n  jpoint(x, y, z) {\n    assert(x == null && y == null && z == null);\n    return this.point();\n  }\n\n  xpoint(x, z) {\n    return new XPoint(this, x, z);\n  }\n\n  solveY2(x) {\n    // [MONT3] Page 3, Section 2.\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom.html\n    assert(x instanceof BN);\n\n    // B * y^2 = x^3 + A * x^2 + x\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);\n    const y2 = by2.redMul(this.bi);\n\n    return y2;\n  }\n\n  validate(point) {\n    assert(point instanceof MontPoint);\n\n    if (point.isInfinity())\n      return true;\n\n    const {x, y} = point;\n    const y2 = this.solveY2(x);\n\n    return y.redSqr().eq(y2);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!x.red)\n      x = x.toRed(this.red);\n\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.redIsOdd() !== sign)\n        y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve, invert) {\n    // [MONT3] Page 3, Section 2.1.\n    assert(curve instanceof Curve);\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    // M(A,B) <-> M(A,B')\n    if (curve.type === 'mont') {\n      const a = this.field(curve.a);\n      const b = this.field(curve.b);\n\n      // A' = A\n      if (!this.a.eq(a))\n        return false;\n\n      // B' != 0\n      if (this.b.isZero())\n        return false;\n\n      // jacobi(B / B') = 1\n      const c = b.redDiv(this.b);\n\n      return c.redJacobi() === 1;\n    }\n\n    return curve.isIsomorphic(this, invert);\n  }\n\n  isIsogenous(curve) {\n    assert(curve instanceof Curve);\n\n    if (curve.type === 'mont')\n      return false;\n\n    return curve.isIsogenous(this);\n  }\n\n  pointFromShort(point) {\n    // [ALT] Appendix E.2 (Switching between Alternative Representations).\n    // [MONT2] \"Equivalence with Weierstrass curves\"\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,b)->M(A,B):\n      //\n      //   u = B * x - A / 3\n      //   v = B * y\n      //\n      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n      if (point.isInfinity())\n        return this.point();\n\n      const {a3, b} = this;\n      const [u2, u3] = this._scale(point.curve);\n      const x = this.field(point.x).redMul(u2);\n      const y = this.field(point.y).redMul(u3);\n      const u = b.redMul(x).redISub(a3);\n      const v = b.redMul(y);\n\n      return this.point(u, v);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [MONT3] Page 3, Section 2.1.\n    assert(point instanceof MontPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for M(A,B)<->M(A,B'):\n      //\n      //   u' = u\n      //   v' = +-sqrt(B / B') * v\n      //\n      // Undefined if (B / B') is not square.\n      if (point.isInfinity())\n        return this.point();\n\n      const c = this._scale(point.curve);\n      const u = this.field(point.x);\n      const v = this.field(point.y);\n      const nu = u;\n      const nv = c.redMul(v);\n\n      return this.point(nu, nv);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [RFC7748] Section 4.1 & 4.2.\n    // [MONT3] Page 6, Section 2.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    assert(point instanceof EdwardsPoint);\n    assert(point.curve.p.eq(this.p));\n\n    // Edwards `x`, `y`, `z`.\n    const x = this.field(point.x);\n    const y = this.field(point.y);\n    const z = this.field(point.z);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for E(1,d)->M(2-4d,1):\n      //\n      //   u = y^2 / x^2\n      //   v = (2 - x^2 - y^2) * y / x^3\n      //\n      // Undefined for x = 0.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-1, 0) -> (0, 0)\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.zero);\n\n      const c = z.redSqr().redIMuln(2);\n      const uu = y.redSqr();\n      const uz = x.redSqr();\n      const vv = c.redISub(uz).redISub(uu).redMul(y);\n      const vz = uz.redMul(x);\n\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    if (this.isIsomorphic(point.curve, true)) {\n      // Isomorphic maps for E(d,a)->M(A,B):\n      //\n      //   u = (y + 1) / (y - 1)\n      //   v = +-sqrt((A - 2) / (B * a)) * u / x\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.zero);\n\n      const c = this._scale(point.curve, true);\n      const uu = y.redAdd(z);\n      const uz = y.redSub(z);\n      const vv = c.redMul(z).redMul(uu);\n      const vz = x.redMul(uz);\n\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    if (this.isIsomorphic(point.curve, false)) {\n      // Isomorphic maps for E(a,d)->M(A,B):\n      //\n      //   u = (1 + y) / (1 - y)\n      //   v = +-sqrt((A + 2) / (B * a)) * u / x\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.zero);\n\n      const c = this._scale(point.curve, false);\n      const uu = z.redAdd(y);\n      const uz = z.redSub(y);\n      const vv = c.redMul(z).redMul(uu);\n      const vz = x.redMul(uz);\n\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    assert(u instanceof BN);\n\n    // z = 0 or A = 0\n    if (this.z.isZero() || this.a.isZero())\n      throw new Error('Not implemented.');\n\n    return this._elligator2(u);\n  }\n\n  pointToUniform(p, hint) {\n    assert(p instanceof MontPoint);\n    assert((hint >>> 0) === hint);\n\n    // z = 0 or A = 0\n    if (this.z.isZero() || this.a.isZero())\n      throw new Error('Not implemented.');\n\n    // P = O\n    if (p.isInfinity())\n      throw new Error('Invalid point.');\n\n    // Add a random torsion component.\n    const i = ((hint >>> 4) & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    return this._invert2(q, hint);\n  }\n\n  decodePoint(bytes, sign) {\n    return MontPoint.decode(this, bytes, sign);\n  }\n\n  encodeX(point) {\n    assert(point instanceof XPoint);\n    return point.encode();\n  }\n\n  decodeX(bytes) {\n    return XPoint.decode(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromMont(this.g);\n\n    for (let i = 0; i < this.h; i++)\n      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, sign = null) {\n    const [a, b] = this._mont(b0);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromMont(this.g);\n\n    for (let i = 0; i < this.h; i++)\n      curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, invert, sign = null) {\n    const [a, d] = this._edwards(a0, invert);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this, invert);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromMont(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return MontPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n    json.a = this.a.fromRed().toJSON();\n    json.b = this.b.fromRed().toJSON();\n    return json;\n  }\n}\n\n/**\n * MontPoint\n */\n\nclass MontPoint extends Point {\n  constructor(curve, x, y, inf) {\n    assert(curve instanceof MontCurve);\n\n    super(curve, types.AFFINE);\n\n    this.x = this.curve.zero;\n    this.y = this.curve.zero;\n    this.inf = 1;\n\n    if (x != null)\n      this._init(x, y, inf);\n  }\n\n  _init(x, y, inf) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n\n    this.x = x;\n    this.y = y;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    this.inf = inf | 0;\n  }\n\n  clone() {\n    return this.curve.point(this.x.clone(),\n                            this.y.clone(),\n                            this.inf);\n  }\n\n  swap(point, flag) {\n    assert(point instanceof MontPoint);\n\n    const cond = ((flag >> 31) | (-flag >> 31)) & 1;\n    const inf1 = this.inf;\n    const inf2 = point.inf;\n\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n\n    this.inf = (inf1 & (cond ^ 1)) | (inf2 & cond);\n    point.inf = (inf2 & (cond ^ 1)) | (inf1 & cond);\n\n    return this;\n  }\n\n  scale(a) {\n    return this.clone();\n  }\n\n  randomize(rng) {\n    return this.clone();\n  }\n\n  neg() {\n    // P = O\n    if (this.inf)\n      return this;\n\n    // -(X1, Y1) = (X1, -Y1)\n    return this.curve.point(this.x, this.y.redNeg());\n  }\n\n  add(p) {\n    // [MONT1] Page 8, Section 4.3.2.\n    //\n    // Addition Law:\n    //\n    //   l = (y2 - y1) / (x2 - x1)\n    //   x3 = b * l^2 - a - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 1S + 7A + 1*b\n    assert(p instanceof MontPoint);\n\n    // O + P = P\n    if (this.inf)\n      return p;\n\n    // P + O = P\n    if (p.inf)\n      return this;\n\n    // P + P, P + -P\n    if (this.x.eq(p.x)) {\n      // P + -P = O\n      if (!this.y.eq(p.y))\n        return this.curve.point();\n\n      // P + P = 2P\n      return this.dbl();\n    }\n\n    // H = X2 - X1\n    const h = p.x.redSub(this.x);\n\n    // R = Y2 - Y1\n    const r = p.y.redSub(this.y);\n\n    // L = R / H\n    const l = r.redDiv(h);\n\n    // K = b * L^2\n    const k = this.curve.b.redMul(l.redSqr());\n\n    // X3 = K - a - X1 - X2\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  dbl() {\n    // [MONT1] Page 8, Section 4.3.2.\n    //\n    // Addition Law (doubling):\n    //\n    //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)\n    //   x3 = b * l^2 - a - 2 * x1\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3\n\n    // P = O\n    if (this.inf)\n      return this;\n\n    // Y1 = 0\n    if (this.y.isZero())\n      return this.curve.point();\n\n    // M1 = 3 * X1^2\n    const m1 = this.x.redSqr().redIMuln(3);\n\n    // M2 = 2 * a * X1\n    const m2 = this.curve.a.redMul(this.x).redIMuln(2);\n\n    // M = M1 + M2 + 1\n    const m = m1.redIAdd(m2).redIAdd(this.curve.one);\n\n    // Z = 2 * b * Y1\n    const z = this.curve.b.redMul(this.y).redIMuln(2);\n\n    // L = M / Z\n    const l = m.redDiv(z);\n\n    // K = b * L^2\n    const k = this.curve.b.redMul(l.redSqr());\n\n    // X3 = K - a - 2 * X1\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    return this.curve.point(nx, ny);\n  }\n\n  uadd(p) {\n    // [MONT1] Page 8, Section 4.3.2.\n    // 1I + 3M + 2S + 9A + 1*a + 2*b + 2*2 + 1*3\n    assert(p instanceof MontPoint);\n\n    // H = X2 - X1\n    const h = p.x.redSub(this.x);\n\n    // R = Y2 - Y1\n    const r = p.y.redSub(this.y);\n\n    // M1 = 3 * X1^2\n    const m1 = this.x.redSqr().redIMuln(3);\n\n    // M2 = 2 * a * X1\n    const m2 = this.curve.a.redMul(this.x).redIMuln(2);\n\n    // M = M1 + M2 + 1\n    const m = m1.redIAdd(m2).redIAdd(this.curve.one);\n\n    // Z = 2 * b * Y1\n    const z = this.curve.b.redMul(this.y).redIMuln(2);\n\n    // Check for doubling (X1 = X2, Y1 = Y2).\n    const double = h.czero() & r.czero();\n\n    // R = M (if double)\n    r.cinject(m, double);\n\n    // H = Z (if double)\n    h.cinject(z, double);\n\n    // Check for negation (X1 = X2, Y1 = -Y2).\n    const negated = h.czero() & ((this.inf | p.inf) ^ 1);\n\n    // H = 1 (if H = 0)\n    h.cinject(this.curve.one, h.czero());\n\n    // L = R / H\n    const l = r.redMul(h.redFermat());\n\n    // K = b * L^2\n    const k = this.curve.b.redMul(l.redSqr());\n\n    // X3 = K - a - X1 - X2\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);\n\n    // Y3 = L * (X1 - X3) - Y1\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n\n    // Check for infinity.\n    const inf = negated | (this.inf & p.inf);\n\n    // Case 1: O + P = P\n    nx.cinject(p.x, this.inf);\n    ny.cinject(p.y, this.inf);\n\n    // Case 2: P + O = P\n    nx.cinject(this.x, p.inf);\n    ny.cinject(this.y, p.inf);\n\n    // Case 3 & 4: P + -P = O, O + O = O\n    nx.cinject(this.curve.zero, inf);\n    ny.cinject(this.curve.zero, inf);\n\n    return this.curve.point(nx, ny, inf);\n  }\n\n  udbl() {\n    return this.uadd(this);\n  }\n\n  recover(p1, p2) {\n    // Okeya-Sakurai Y-coordinate Recovery.\n    //\n    // [MONT3] Algorithm 5, Page 13, Section 4.3.\n    //         Algorithm 6, Page 14, Section 4.3.\n    //\n    // 1I + 12M + 1S + 6A + 1*a + 1*b + 2*2\n    assert(p1 instanceof XPoint);\n    assert(p2 instanceof XPoint);\n\n    // P = O\n    if (this.inf)\n      return this.curve.point();\n\n    // A = X0 * Z1\n    const a = this.x.redMul(p1.z);\n\n    // B = X1 + A\n    const b = p1.x.redAdd(a);\n\n    // C = (X1 - A)^2 * X2\n    const c = p1.x.redSub(a).redSqr().redMul(p2.x);\n\n    // D = 2 * a * Z1\n    const d = this.curve.a.redMul(p1.z).redIMuln(2);\n\n    // E = B + D\n    const e = b.redIAdd(d);\n\n    // F = X0 * X1 + Z1\n    const f = this.x.redMul(p1.x).redIAdd(p1.z);\n\n    // G = E * F\n    const g = e.redMul(f);\n\n    // H = D * Z1\n    const h = d.redMul(p1.z);\n\n    // I = (G - H) * Z2\n    const i = g.redISub(h).redMul(p2.z);\n\n    // J = 2 * b * Y0\n    const j = this.curve.b.redMul(this.y).redIMuln(2);\n\n    // K = J * Z1 * Z2\n    const k = j.redMul(p1.z).redMul(p2.z);\n\n    // X = K * X1\n    const x = k.redMul(p1.x);\n\n    // Y = I - C\n    const y = i.redISub(c);\n\n    // Z = K * Z1\n    const z = k.redMul(p1.z);\n\n    // Z = 0\n    if (z.isZero())\n      return this.curve.point();\n\n    // L = 1 / Z\n    const l = z.redInvert();\n\n    // X3 = X * L\n    const nx = x.redMul(l);\n\n    // Y3 = Y * L\n    const ny = y.redMul(l);\n\n    return this.curve.point(nx, ny);\n  }\n\n  getX() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.inf)\n      throw new Error('Invalid point.');\n\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof MontPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.inf)\n      return p.inf !== 0;\n\n    // Q = O\n    if (p.inf)\n      return false;\n\n    // X1 = X2, Y1 = Y2\n    return this.x.eq(p.x)\n        && this.y.eq(p.y);\n  }\n\n  isInfinity() {\n    // Infinity cannot be represented in\n    // the affine space, except by a flag.\n    return this.inf !== 0;\n  }\n\n  isOdd() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.inf)\n      return false;\n\n    return this.y.redIsEven();\n  }\n\n  toP() {\n    return this;\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    // (X3, Z3) = (1, 0)\n    if (this.inf)\n      return this.curve.xpoint();\n\n    // (X3, Z3) = (X1, 1)\n    return this.curve.xpoint(this.x, this.curve.one);\n  }\n\n  encode() {\n    return this.toX().encode();\n  }\n\n  static decode(curve, bytes, sign) {\n    assert(curve instanceof MontCurve);\n    return curve.decodeX(bytes).toP(sign);\n  }\n\n  toJSON(pre) {\n    if (this.inf)\n      return [];\n\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof MontCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0\n        || json.length === 2\n        || json.length === 3);\n\n    if (json.length === 0)\n      return curve.point();\n\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n\n    return curve.point(x, y);\n  }\n\n  [custom]() {\n    if (this.inf)\n      return '<MontPoint: Infinity>';\n\n    return '<MontPoint:'\n         + ' x=' + this.x.fromRed().toString(16, 2)\n         + ' y=' + this.y.fromRed().toString(16, 2)\n         + '>';\n  }\n}\n\n/**\n * XPoint\n */\n\nclass XPoint extends Point {\n  constructor(curve, x, z) {\n    assert(curve instanceof MontCurve);\n\n    super(curve, types.PROJECTIVE);\n\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n\n    if (x != null)\n      this._init(x, z);\n  }\n\n  _init(x, z) {\n    assert(x instanceof BN);\n    assert(z == null || (z instanceof BN));\n\n    this.x = x;\n    this.z = z || this.curve.one;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n  }\n\n  clone() {\n    return this.curve.xpoint(this.x.clone(),\n                             this.z.clone());\n  }\n\n  swap(point, flag) {\n    assert(point instanceof XPoint);\n\n    this.x.cswap(point.x, flag);\n    this.z.cswap(point.z, flag);\n\n    return this;\n  }\n\n  precompute(power, rng) {\n    // No-op.\n    return this;\n  }\n\n  validate() {\n    if (this.isInfinity())\n      return true;\n\n    // B * y^2 * z = x^3 + A * x^2 * z + x * z^2\n    const {x, z} = this;\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const z2 = z.redSqr();\n    const ax2 = this.curve.a.redMul(x2).redMul(z);\n    const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));\n    const y2 = by2.redMul(this.curve.bi);\n\n    // sqrt(y^2 * z^4) = y * z^2\n    return y2.redMul(z).redJacobi() !== -1;\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale\n    // 1I + 1M\n\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    // Z1 = 1\n    if (this.z.eq(this.curve.one))\n      return this;\n\n    // X3 = X1 / Z1\n    this.x = this.x.redDiv(this.z);\n\n    // Z3 = 1\n    this.z = this.curve.one;\n\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN);\n\n    // P = O\n    if (this.isInfinity())\n      return this.curve.xpoint();\n\n    // X3 = X1 * A\n    const nx = this.x.redMul(a);\n\n    // Y3 = Y1 * A\n    const nz = this.z.redMul(a);\n\n    return this.curve.xpoint(nx, nz);\n  }\n\n  neg() {\n    // -(X1, Z1) = (X1, Z1)\n    return this;\n  }\n\n  dbl() {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n    // 2M + 2S + 4A + 1*a24\n\n    // A = X1 + Z1\n    const a = this.x.redAdd(this.z);\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // B = X1 - Z1\n    const b = this.x.redSub(this.z);\n\n    // BB = B^2\n    const bb = b.redSqr();\n\n    // C = AA - BB\n    const c = aa.redSub(bb);\n\n    // X3 = AA * BB\n    const nx = aa.redMul(bb);\n\n    // Z3 = C * (BB + a24 * C)\n    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));\n\n    return this.curve.xpoint(nx, nz);\n  }\n\n  diffAdd(p, q) {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n    // 4M + 2S + 6A\n    assert(p instanceof XPoint);\n    assert(q instanceof XPoint);\n\n    // A = X2 + Z2\n    const a = p.x.redAdd(p.z);\n\n    // B = X2 - Z2\n    const b = p.x.redSub(p.z);\n\n    // C = X3 + Z3\n    const c = q.x.redAdd(q.z);\n\n    // D = X3 - Z3\n    const d = q.x.redSub(q.z);\n\n    // DA = D * A\n    const da = d.redMul(a);\n\n    // CB = C * B\n    const cb = c.redMul(b);\n\n    // X5 = Z1 * (DA + CB)^2\n    const nx = this.z.redMul(da.redAdd(cb).redSqr());\n\n    // Z5 = X1 * (DA - CB)^2\n    const nz = this.x.redMul(da.redISub(cb).redSqr());\n\n    return this.curve.xpoint(nx, nz);\n  }\n\n  diffAddDbl(p, q) {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3\n    // Note that we swap P2 and P3 here (for consistency).\n    // 6M + 4S + 8A + 1*a24\n    assert(p instanceof XPoint);\n    assert(q instanceof XPoint);\n\n    // A = X2 + Z2\n    const a = q.x.redAdd(q.z);\n\n    // AA = A^2\n    const aa = a.redSqr();\n\n    // B = X2 - Z2\n    const b = q.x.redSub(q.z);\n\n    // BB = B^2\n    const bb = b.redSqr();\n\n    // E = AA - BB\n    const e = aa.redSub(bb);\n\n    // C = X3 + Z3\n    const c = p.x.redAdd(p.z);\n\n    // D = X3 - Z3\n    const d = p.x.redSub(p.z);\n\n    // DA = D * A\n    const da = d.redMul(a);\n\n    // CB = C * B\n    const cb = c.redMul(b);\n\n    // X5 = Z1 * (DA + CB)^2\n    const nx = this.z.redMul(da.redAdd(cb).redSqr());\n\n    // Z5 = X1 * (DA - CB)^2\n    const nz = this.x.redMul(da.redISub(cb).redSqr());\n\n    // X4 = AA * BB\n    const dx = aa.redMul(bb);\n\n    // Z4 = E * (BB + a24 * E)\n    const dz = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));\n\n    return [\n      this.curve.xpoint(nx, nz),\n      this.curve.xpoint(dx, dz)\n    ];\n  }\n\n  getX() {\n    if (this.isInfinity())\n      throw new Error('Invalid point.');\n\n    this.normalize();\n\n    return this.x.fromRed();\n  }\n\n  getY(sign) {\n    return this.toP(sign).getY();\n  }\n\n  eq(p) {\n    assert(p instanceof XPoint);\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // P = O\n    if (this.isInfinity())\n      return p.isInfinity();\n\n    // Q = O\n    if (p.isInfinity())\n      return false;\n\n    // Z1 = Z2\n    if (this.z.eq(p.z))\n      return this.x.eq(p.x);\n\n    // X1 * Z2 == X2 * Z1\n    const x1 = this.x.redMul(p.z);\n    const x2 = p.x.redMul(this.z);\n\n    return x1.eq(x2);\n  }\n\n  isInfinity() {\n    // Z1 = 0\n    return this.z.isZero();\n  }\n\n  isOdd() {\n    return false;\n  }\n\n  isEven() {\n    return false;\n  }\n\n  hasTorsion() {\n    if (this.isInfinity())\n      return false;\n\n    // X1 = 0, Z1 != 0 (edge case)\n    if (this.x.isZero())\n      return true;\n\n    return super.hasTorsion();\n  }\n\n  jmul(k) {\n    return this.ladder(k)[1];\n  }\n\n  jmulSimple(k) {\n    return this.ladderSimple(k)[1];\n  }\n\n  jmulBlind(k, rng) {\n    return this.ladderBlind(k, rng)[1];\n  }\n\n  jmulConst(k, rng) {\n    return this.ladderConst(k, rng)[1];\n  }\n\n  jmulAdd(k1, p2, k2) {\n    throw new Error('Not implemented.');\n  }\n\n  jmulAddSimple(k1, p2, k2) {\n    throw new Error('Not implemented.');\n  }\n\n  ladder(k) {\n    // Multiply with the Montgomery Ladder.\n    //\n    // [MONT3] Algorithm 4, Page 12, Section 4.2.\n    //\n    // Note that any clamping is meant to\n    // be done _outside_ of this function.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    const bits = k.bitLength();\n\n    let a = this;\n    let b = this.curve.xpoint();\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n\n      if (bit === 0)\n        [a, b] = this.diffAddDbl(a, b);\n      else\n        [b, a] = this.diffAddDbl(b, a);\n    }\n\n    return [a, b];\n  }\n\n  ladderSimple(k) {\n    // Montgomery Ladder with explicit\n    // additions and doubling (testing).\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    const bits = k.bitLength();\n\n    let a = this;\n    let b = this.curve.xpoint();\n\n    // Climb the ladder.\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n\n      if (bit === 0) {\n        a = this.diffAdd(a, b);\n        b = b.dbl();\n      } else {\n        b = this.diffAdd(b, a);\n        a = a.dbl();\n      }\n    }\n\n    return [a, b];\n  }\n\n  ladderBlind(k, rng) {\n    if (!rng)\n      return this.ladder(k);\n\n    // Randomize if available.\n    return this.randomize(rng).ladder(k);\n  }\n\n  ladderConst(k, rng) {\n    // Multiply with the Montgomery Ladder.\n    //\n    // [MONT3] Algorithm 7, Page 16, Section 5.3.\n    //         Algorithm 8, Page 16, Section 5.3.\n    //\n    // [RFC7748] Page 7, Section 5.\n    //\n    // Note that any clamping is meant to\n    // be done _outside_ of this function.\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    const bits = Math.max(k.bitLength(), this.curve.fieldBits);\n    const bytes = (bits + 7) >>> 3;\n\n    // Recode scalar to base256.\n    const exp = k.toArray('le', bytes);\n\n    // Randomize if available.\n    const point = rng ? this.randomize(rng) : this;\n\n    // Clone points (for safe swapping).\n    let a = point.clone();\n    let b = this.curve.xpoint().clone();\n    let swap = 0;\n\n    // Climb the ladder.\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = (exp[i >> 3] >> (i & 7)) & 1;\n\n      // Maybe swap.\n      a.swap(b, swap ^ bit);\n\n      // Single coordinate add+double.\n      [a, b] = point.diffAddDbl(a, b);\n\n      swap = bit;\n    }\n\n    // Finalize loop.\n    a.swap(b, swap);\n\n    return [a, b];\n  }\n\n  toP(sign = null) {\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (this.isInfinity())\n      return this.curve.point();\n\n    this.normalize();\n\n    return this.curve.pointFromX(this.x, sign);\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    return this;\n  }\n\n  encode() {\n    // [RFC7748] Section 5.\n    return this.curve.encodeField(this.getX());\n  }\n\n  static decode(curve, bytes) {\n    assert(curve instanceof MontCurve);\n\n    // [RFC7748] Section 5.\n    const x = curve.decodeField(bytes);\n\n    // We're supposed to ignore the hi bit\n    // on montgomery points... I think. If\n    // we don't, the X25519 test vectors\n    // break, which is pretty convincing\n    // evidence. This is a no-op for X448.\n    x.iumaskn(curve.fieldBits);\n\n    // Note: montgomery points are meant to be\n    // reduced by the prime and do not have to\n    // be explicitly validated in order to do\n    // the montgomery ladder.\n    const p = curve.xpoint(x, curve.one);\n\n    assert(!p.isInfinity());\n\n    return p;\n  }\n\n  toJSON(pre) {\n    return this.toP().toJSON(pre);\n  }\n\n  static fromJSON(curve, json) {\n    return MontPoint.fromJSON(curve, json).toX();\n  }\n\n  [custom]() {\n    if (this.isInfinity())\n      return '<XPoint: Infinity>';\n\n    return '<XPoint:'\n        + ' x=' + this.x.fromRed().toString(16, 2)\n        + ' z=' + this.z.fromRed().toString(16, 2)\n        + '>';\n  }\n}\n\n/**\n * EdwardsCurve\n */\n\nclass EdwardsCurve extends Curve {\n  constructor(conf) {\n    super(EdwardsPoint, 'edwards', conf);\n\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.d = BN.fromJSON(conf.d).toRed(this.red);\n    this.s = BN.fromJSON(conf.s || '0').toRed(this.red);\n    this.si = this.s.isZero() ? this.zero : this.s.redInvert();\n\n    this.k = this.d.redMuln(2);\n    this.smi = -this.d.redNeg().word(0);\n    this.ad6 = this.a.redAdd(this.d).redMul(this.i6);\n\n    this.twisted = !this.a.eq(this.one);\n    this.oneA = this.a.eq(this.one);\n    this.mOneA = this.a.eq(this.one.redNeg());\n    this.smallD = this.prime != null && this.d.redNeg().length === 1;\n    this.alt = null;\n\n    this._finalize(conf);\n  }\n\n  static _isomorphism(curveA, curveD, customA) {\n    // Twisted Edwards Isomorphism.\n    //\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    //\n    // Transformation:\n    //\n    //   a' = a'\n    //   d' = a' * d / a\n    //\n    // Where (a / a') is square.\n    assert(curveA instanceof BN);\n    assert(curveD instanceof BN);\n    assert(customA instanceof BN);\n\n    const a = customA.clone();\n    const d = customA.redMul(curveD).redDiv(curveA);\n    const c = curveA.redDiv(customA);\n\n    if (c.redJacobi() !== 1)\n      throw new Error('Invalid `a` coefficient.');\n\n    return [a, d];\n  }\n\n  _short(a0, odd) {\n    // Twisted Edwards->Short Weierstrass Equivalence.\n    //\n    // [TWISTEQ] Section 2.\n    //\n    // Transformation:\n    //\n    //   a' = -(a^2 + 14 * a * d + d^2) / 48\n    //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864\n    const {a, d} = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const d2 = d.redSqr();\n    const d3 = d2.redMul(d);\n    const ad14 = a.redMul(d).redIMuln(14);\n    const a2d = a2.redMul(d);\n    const ad2 = a.redMul(d2);\n    const t0 = a2d.redIAdd(ad2).redIMuln(33);\n    const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);\n    const wb = t0.redISub(a3).redISub(d3).redDivn(864);\n\n    if (a0 != null)\n      return ShortCurve._isomorphism(wa, wb, a0, odd);\n\n    return [wa, wb];\n  }\n\n  _mont(b0, invert = false) {\n    // Twisted Edwards->Montgomery Transformation.\n    //\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //\n    // Equivalence:\n    //\n    //   A = 2 * (a + d) / (a - d)\n    //   B = 4 / (a - d)\n    //\n    // Isomorphism:\n    //\n    //   A = 2 * (a + d) / (a - d)\n    //   B = B'\n    //\n    // Where ((4 / (a - d)) / B') is square.\n    //\n    // If `4 / (a - d)` is non-square, we can\n    // usually force B=1 by using the `invert`\n    // option. This will create an isomorphism\n    // chain of: E(a,d)->E(d,a)->M(-A,-B).\n    //\n    // The equivalence between E(a,d) and E(d,a)\n    // is:\n    //\n    //   (x, y) = (x, 1 / y)\n    //\n    // Meaning our map to M(-A,-B) is:\n    //\n    //   u = (1 + 1 / y) / (1 - 1 / y)\n    //     = (y + 1) / (y - 1)\n    //   v = u / x\n    assert(typeof invert === 'boolean');\n\n    let apd, amd;\n\n    if (invert) {\n      apd = this.d.redAdd(this.a);\n      amd = this.d.redSub(this.a);\n    } else {\n      apd = this.a.redAdd(this.d);\n      amd = this.a.redSub(this.d);\n    }\n\n    const z = amd.redInvert();\n    const a = apd.redMuln(2).redMul(z);\n    const b = z.redMuln(4);\n\n    if (b0 != null)\n      return MontCurve._isomorphism(a, b, b0);\n\n    return [a, b];\n  }\n\n  _edwards(a0) {\n    return EdwardsCurve._isomorphism(this.a, this.d, a0);\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    const [u2, u3] = curve._scale(this);\n\n    return [this.field(u2.redInvert()),\n            this.field(u3.redInvert())];\n  }\n\n  _scaleMont(curve, invert = false) {\n    // Calculate isomorphism factor between\n    // Twisted Edwards and Montgomery with:\n    //\n    //   a = (A + 2) / B\n    //   c = +-sqrt(a / a')\n    //\n    // Which can be reduced to:\n    //\n    //   c = +-sqrt((A + 2) / (B * a'))\n    //\n    // If base points are available, we can do:\n    //\n    //   x = u / v\n    //   c = x' / x\n    //\n    // Which can be reduced to:\n    //\n    //   c = v * x' / u\n    //\n    // We can now calculate the Edwards `x` with:\n    //\n    //   x' = c * u / v\n    //\n    // And likewise, the Montgomery `v`:\n    //\n    //   v = c * u / x'\n    assert(curve instanceof MontCurve);\n    assert(typeof invert === 'boolean');\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a] = curve._edwards(null, invert);\n\n      return this.field(a).redDivSqrt(this.a);\n    }\n\n    const x = curve.g.x.redDiv(curve.g.y);\n\n    return this.g.x.redDiv(this.field(x));\n  }\n\n  _scaleEdwards(curve) {\n    // We can extract the isomorphism factor with:\n    //\n    //   c = +-sqrt(a / a')\n    //\n    // If base points are available, we can do:\n    //\n    //   c = x' / x\n    assert(curve instanceof EdwardsCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity())\n      return this.field(curve.a).redDivSqrt(this.a);\n\n    return this.g.x.redDiv(this.field(curve.g.x));\n  }\n\n  _mulA(num) {\n    assert(num instanceof BN);\n\n    // n * a = n\n    if (this.oneA)\n      return num.clone();\n\n    // n * a = -n\n    if (this.mOneA)\n      return num.redNeg();\n\n    return this.a.redMul(num);\n  }\n\n  _mulD(num) {\n    assert(num instanceof BN);\n\n    // -d < 0x4000000\n    if (this.smallD)\n      return num.redMuln(this.smi);\n\n    return this.d.redMul(num);\n  }\n\n  _elligator1(t) {\n    // Elligator 1.\n    //\n    // Distribution: 1/2.\n    //\n    // [ELL1] Page 6, Section 3.\n    //        Page 15, Appendix A.\n    // [ELL2] Page 7, Section 3.2.\n    //\n    // Assumptions:\n    //\n    //   - Let p be a prime power congruent to 3 mod 4.\n    //   - Let s be a nonzero element of F(p).\n    //   - Let c = 2 / s^2.\n    //   - Let r = c + 1 / c.\n    //   - Let d = -(c + 1)^2 / (c - 1)^2.\n    //   - (s^2 - 2) * (s^2 + 2) != 0.\n    //   - c * (c - 1) * (c + 1) != 0.\n    //   - r != 0.\n    //   - d is not square.\n    //   - x^2 + y^2 = 1 + d * x^2 * y^2.\n    //   - u * v * X * Y * x * (Y + 1) != 0.\n    //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.\n    //\n    // Elligator 1, as devised by Fouque et al,\n    // takes place on the hyperelliptic curve of:\n    //\n    //   y^2 = x^5 + (r^2 - 2) * x^3 + x\n    //\n    // Not only must our Edwards curve be complete,\n    // with a prime congruent to 3 mod 4, and a = 1,\n    // our curve must be isomorphic to a hyperelliptic\n    // curve of the above form. Roughly one half of\n    // all Edwards curves are isomorphic to a curve\n    // of said form.\n    //\n    // We can derive the isomorphism with:\n    //\n    //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)\n    //   s = +-sqrt(2 / c)\n    //   r = c + 1 / c\n    //\n    // Note that even if your curve is an Elligator 1\n    // curve, Elligator 2 is probably still preferable,\n    // as it has nearly the same properties (i.e. the\n    // same distribution), and is much less complex.\n    //\n    // Map:\n    //\n    //   f(a) = a^((p - 1) / 2)\n    //   u = (1 - t) / (1 + t)\n    //   v = u^5 + (r^2 - 2) * u^3 + u\n    //   X = f(v) * u\n    //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)\n    //   Y = 1, if u = 0\n    //   x = (c - 1) * s * X * (1 + X) / Y\n    //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)\n    //\n    // When t = +-1, we create the hyperelliptic\n    // 2-torsion point of (0, 0). This needs to be\n    // mapped to (0, -1) in Edwards form, but the x\n    // denominator becomes zero. As far as I can\n    // tell, this is the only exceptional case.\n    //\n    // The only other exceptional case initially\n    // appears to be when the y denominator sums to\n    // zero (when t = sqrt(4 / r + 1)), however, the\n    // hyperelliptic `X` is negated by the sign of\n    // `v`, making this impossible.\n    const {s, si, i2, one, two} = this;\n    const c = si.redSqr().redIMuln(2);\n    const ci = s.redSqr().redMul(i2);\n    const ci2 = ci.redSqr();\n    const r = c.redAdd(ci);\n    const r2 = r.redSqr().redISub(two);\n    const cm1 = c.redSub(one);\n    const e0 = this.p.subn(2);\n    const e1 = this.p.subn(1).iushrn(1);\n    const e2 = this.p.addn(1).iushrn(2);\n    const uu = one.redSub(t);\n    const uz = one.redAdd(t);\n    const u = uu.redMul(uz.redPow(e0));\n    const u2 = u.redSqr();\n    const u3 = u2.redMul(u);\n    const u5 = u3.redMul(u2);\n    const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);\n    const f0 = v.redPow(e1);\n    const f1 = u2.redAdd(ci2).redPow(e1);\n    const f2 = f0.redMul(f1);\n    const X = f0.redMul(u);\n    const Y = f0.redMul(v).redPow(e2).redMul(f2);\n    const X1 = one.redAdd(X);\n    const rX = r.redMul(X);\n    const X12 = X1.redSqr();\n    const xx = cm1.redMul(s).redMul(X).redMul(X1);\n    const xz = Y.cinject(this.one, u.czero());\n    const yy = rX.redSub(X12);\n    const yz = rX.redAdd(X12);\n\n    return this.cpoint(xx, xz, yy, yz);\n  }\n\n  _invert1(p, hint) {\n    // Inverting the Map (Elligator 1).\n    //\n    // [ELL1] Page 6, Section 3.\n    //        Page 15, Appendix A.\n    // [ELL2] Page 7, Section 3.3.\n    //\n    // Assumptions:\n    //\n    //   - y + 1 != 0.\n    //   - (1 + n * r)^2 - 1 is square in F(p).\n    //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.\n    //   - Y = (c - 1) * s * X * (1 + X) / x.\n    //\n    // Map:\n    //\n    //   f(a) = a^((p - 1) / 2)\n    //   n = (y - 1) / (2 * (y + 1))\n    //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)\n    //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))\n    //   u = z * X\n    //   t = (1 - u) / (1 + u)\n    const {s, si, i2, one} = this;\n    const {x, y, z} = p;\n    const sign = hint & 1;\n    const c = si.redSqr().redIMuln(2);\n    const ci = s.redSqr().redMul(i2);\n    const ci2 = ci.redSqr();\n    const r = c.redAdd(ci);\n    const cm1 = c.redSub(one);\n    const e0 = this.p.subn(2);\n    const e1 = this.p.subn(1).iushrn(1);\n    const e2 = this.p.addn(1).iushrn(2);\n    const nn = y.redSub(z);\n    const nz = y.redAdd(z).redIMuln(2);\n    const n = nn.redMul(nz.redPow(e0));\n    const nr1 = one.redAdd(n.redMul(r));\n    const w2 = nr1.redSqr().redISub(one);\n    const w = w2.redPow(e2);\n    const sqr = w.redSqr().ceq(w2);\n    const X = w.redSub(nr1);\n    const X1 = one.redAdd(X);\n    const YY = cm1.redMul(s).redMul(X).redMul(X1);\n    const Y = YY.redMul(x.redMul(z));\n    const X2 = X.redSqr().redIAdd(ci2);\n    const Z = Y.redMul(X2).redPow(e1);\n    const u = Z.redMul(X);\n    const tt = one.redSub(u);\n    const tz = one.redAdd(u);\n    const t = tt.redMul(tz.redPow(e0));\n\n    t.cinject(t.redNeg(), t.redIsOdd() ^ sign);\n\n    if (!sqr)\n      throw new Error('Invalid point.');\n\n    return t;\n  }\n\n  _alt() {\n    if (!this.alt)\n      this.alt = this.toMont();\n\n    return this.alt;\n  }\n\n  isElliptic() {\n    const ad = this.a.redMul(this.d);\n    const amd = this.a.redSub(this.d);\n\n    // a * d * (a - d) != 0\n    return !ad.redMul(amd).isZero();\n  }\n\n  jinv() {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    const {a, d} = this;\n    const ad = a.redMul(d);\n    const amd4 = a.redSub(d).redPown(4);\n    const a2 = a.redSqr();\n    const d2 = d.redSqr();\n    const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);\n    const lhs = t0.redPown(3).redIMuln(16);\n    const rhs = ad.redMul(amd4);\n\n    if (rhs.isZero())\n      throw new Error('Curve is not elliptic.');\n\n    // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  isComplete() {\n    return this.a.redJacobi() === 1\n        && this.d.redJacobi() === -1;\n  }\n\n  point(x, y, z, t) {\n    return new EdwardsPoint(this, x, y, z, t);\n  }\n\n  jpoint(x, y, z) {\n    assert(x == null && y == null && z == null);\n    return this.point();\n  }\n\n  cpoint(xx, xz, yy, yz) {\n    assert(xx instanceof BN);\n    assert(xz instanceof BN);\n    assert(yy instanceof BN);\n    assert(yz instanceof BN);\n\n    const x = xx.redMul(yz);\n    const y = yy.redMul(xz);\n    const z = xz.redMul(yz);\n    const t = xx.redMul(yy);\n\n    return this.point(x, y, z, t);\n  }\n\n  solveX2(y) {\n    // [RFC8032] Section 5.1.3 & 5.2.3.\n    assert(y instanceof BN);\n\n    // x^2 = (y^2 - 1) / (d * y^2 - a)\n    const y2 = y.redSqr();\n    const rhs = this._mulD(y2).redISub(this.a);\n    const lhs = y2.redISub(this.one);\n    const x2 = lhs.redDiv(rhs);\n\n    return x2;\n  }\n\n  solveX(y) {\n    // Optimize with inverse square root trick.\n    //\n    // Note that `0 / 0` can only occur if\n    // `a == d` (i.e. the curve is singular).\n    const y2 = y.redSqr();\n    const rhs = this._mulD(y2).redISub(this.a);\n    const lhs = y2.redISub(this.one);\n\n    return lhs.redDivSqrt(rhs);\n  }\n\n  solveY2(x) {\n    assert(x instanceof BN);\n\n    // y^2 = (a * x^2 - 1) / (d * x^2 - 1)\n    const x2 = x.redSqr();\n    const lhs = this._mulA(x2).redISub(this.one);\n    const rhs = this._mulD(x2).redISub(this.one);\n    const y2 = lhs.redDiv(rhs);\n\n    return y2;\n  }\n\n  solveY(x) {\n    // Optimize with inverse square root trick.\n    //\n    // Note that `0 / 0` can only occur if\n    // `a == d` (i.e. the curve is singular).\n    const x2 = x.redSqr();\n    const lhs = this._mulA(x2).redISub(this.one);\n    const rhs = this._mulD(x2).redISub(this.one);\n\n    return lhs.redDivSqrt(rhs);\n  }\n\n  validate(point) {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    //           Page 11, Section 6.\n    assert(point instanceof EdwardsPoint);\n\n    // Z1 = 1\n    if (point.zOne) {\n      // a * x^2 + y^2 = 1 + d * x^2 * y^2\n      const x2 = point.x.redSqr();\n      const y2 = point.y.redSqr();\n      const dxy = this._mulD(x2).redMul(y2);\n      const lhs = this._mulA(x2).redIAdd(y2);\n      const rhs = this.one.redAdd(dxy);\n      const tz = point.t;\n      const xy = point.x.redMul(point.y);\n\n      return lhs.eq(rhs) && tz.eq(xy);\n    }\n\n    // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2\n    const x2 = point.x.redSqr();\n    const y2 = point.y.redSqr();\n    const z2 = point.z.redSqr();\n    const z4 = z2.redSqr();\n    const dxy = this._mulD(x2).redMul(y2);\n    const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);\n    const rhs = z4.redIAdd(dxy);\n    const tz = point.t.redMul(point.z);\n    const xy = point.x.redMul(point.y);\n\n    return lhs.eq(rhs) && tz.eq(xy);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!x.red)\n      x = x.toRed(this.red);\n\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.isZero() && sign)\n        throw new Error('Invalid point.');\n\n      if (y.redIsOdd() !== sign)\n        y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  pointFromY(y, sign = null) {\n    assert(y instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n\n    if (!y.red)\n      y = y.toRed(this.red);\n\n    const x = this.solveX(y);\n\n    if (sign != null) {\n      if (x.isZero() && sign)\n        throw new Error('Invalid point.');\n\n      if (x.redIsOdd() !== sign)\n        x.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve, invert = false) {\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //           Definition 2.1, Page 3, Section 2.\n    assert(curve instanceof Curve);\n    assert(typeof invert === 'boolean');\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    // E(a,d) <-> E(a,b)\n    if (curve.type === 'short')\n      return curve.isIsomorphic(this);\n\n    // E(a,d) <-> M(A,B)\n    // E(a,d) <-> M(-A,-B)\n    if (curve.type === 'mont') {\n      // A * (a - d) = 2 * (a + d)\n      const a = this.field(curve.a);\n\n      let apd, amd;\n\n      if (invert) {\n        apd = this.d.redAdd(this.a);\n        amd = this.d.redSub(this.a);\n      } else {\n        apd = this.a.redAdd(this.d);\n        amd = this.a.redSub(this.d);\n      }\n\n      return a.redMul(amd).eq(apd.redIMuln(2));\n    }\n\n    // E(a,d) <-> E(a',a'd/a)\n    if (curve.type === 'edwards') {\n      // a' * d = a * d'\n      const a = this.field(curve.a);\n      const d = this.field(curve.d);\n\n      return this.a.redMul(d).eq(a.redMul(this.d));\n    }\n\n    return false;\n  }\n\n  isIsogenous(curve) {\n    // Check for the 4-isogenies described by Hamburg:\n    // https://moderncrypto.org/mail-archive/curves/2016/000806.html\n    assert(curve instanceof Curve);\n\n    if (!curve.p.eq(this.p))\n      return false;\n\n    // E(1,d) <-> M(2-4d,1)\n    if (curve.type === 'mont') {\n      if (!this.a.eq(this.one))\n        return false;\n\n      const a = this.field(curve.a);\n      const b = this.field(curve.b);\n      const d24 = this.two.redSub(this.d.redMuln(4));\n\n      return a.eq(d24) && b.eq(this.one);\n    }\n\n    // E(a,d) <-> E(-a,d-a)\n    if (curve.type === 'edwards') {\n      const a = this.field(curve.a);\n      const d = this.field(curve.d);\n\n      return a.eq(this.a.redNeg())\n          && d.eq(this.d.redSub(this.a));\n    }\n\n    return false;\n  }\n\n  pointFromShort(point) {\n    // [TWISTEQ] Section 1.\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,b)->E(a',d'):\n      //\n      //   x' = (6 * x - a' - d') / (6 * y)\n      //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')\n      //\n      // Undefined for x = (5 * d' - a') / 12 or y = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - ((a' + d') / 6, 0) -> (0, -1)\n      //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)\n      //\n      // Unexceptional Cases:\n      //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.y.isZero())\n        return this.point(this.zero, this.one.redNeg());\n\n      const {a, d} = this;\n      const [u2, u3] = this._scale(point.curve);\n      const a5 = a.redMuln(5);\n      const d5 = d.redMuln(5);\n      const x = this.field(point.x).redMul(u2);\n      const y = this.field(point.y).redMul(u3);\n      const x6 = x.redMuln(6);\n      const x12 = x.redMuln(12);\n      const xx = x6.redSub(a).redISub(d);\n      const xz = y.redMuln(6);\n      const yy = x12.redSub(a5).redIAdd(d);\n      const yz = x12.redAdd(a).redISub(d5);\n\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [RFC7748] Section 4.1 & 4.2.\n    // [MONT3] Page 6, Section 2.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    assert(point instanceof MontPoint);\n    assert(point.curve.p.eq(this.p));\n\n    // Montgomery `u`, `v`.\n    const u = this.field(point.x);\n    const v = this.field(point.y);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for M(2-4d,1)->E(1,d):\n      //\n      //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)\n      //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /\n      //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)\n      //\n      // Undefined for u = 0 and v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, 1)\n      //\n      // Unexceptional Cases:\n      //   - (-1, +-sqrt(A - 2)) -> (0, 1)\n      //   - (1, +-sqrt(A + 2)) -> (0, -1)\n      //\n      // The point (1, v) is invalid on Curve448.\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point();\n\n      const u2 = u.redSqr();\n      const u3 = u2.redMul(u);\n      const u4 = u3.redMul(u);\n      const u5 = u4.redMul(u);\n      const v2 = v.redSqr();\n      const a = v.redMuln(4);\n      const b = u2.redSub(this.one);\n      const c = u2.redMuln(2);\n      const d = v2.redMuln(4);\n      const e = u3.redIMuln(2);\n      const f = u.redMul(v2).redIMuln(4);\n      const g = u2.redMul(v2).redIMuln(2);\n      const h = v2.redIMuln(2);\n      const xx = a.redMul(b);\n      const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);\n      const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();\n      const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);\n\n      return this.cpoint(xx, xz, yy, yz).divn(4);\n    }\n\n    if (this.isIsomorphic(point.curve, true)) {\n      // Isomorphic maps for M(-A,-B)->E(a,d):\n      //\n      //   x = +-sqrt((A - 2) / (B * a)) * u / v\n      //   y = (u + 1) / (u - 1)\n      //\n      // Undefined for u = 1 or v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, -1)\n      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)\n      //\n      // Unexceptional Cases:\n      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)\n      //\n      // The point (1, v) is invalid on Curve448.\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.one.redNeg());\n\n      const c = this._scale(point.curve, true);\n      const xx = c.redMul(u);\n      const xz = v;\n      const yy = u.redAdd(this.one);\n      const yz = u.redSub(this.one);\n\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    if (this.isIsomorphic(point.curve, false)) {\n      // Isomorphic maps for M(A,B)->E(a,d):\n      //\n      //   x = +-sqrt((A + 2) / (B * a)) * u / v\n      //   y = (u - 1) / (u + 1)\n      //\n      // Undefined for u = -1 or v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, -1)\n      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)\n      //\n      // Unexceptional Cases:\n      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)\n      //\n      // The point (-1, v) is invalid on Curve25519.\n      if (point.isInfinity())\n        return this.point();\n\n      if (point.x.isZero())\n        return this.point(this.zero, this.one.redNeg());\n\n      const c = this._scale(point.curve, false);\n      const xx = c.redMul(u);\n      const xz = v;\n      const yy = u.redSub(this.one);\n      const yz = u.redAdd(this.one);\n\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    // [ISOGENY] Page 2, Section 2.\n    assert(point instanceof EdwardsPoint);\n    assert(point.curve.p.eq(this.p));\n\n    // Edwards `x`, `y`, `z`, `t`.\n    const a = this.field(point.curve.a);\n    const x = this.field(point.x);\n    const y = this.field(point.y);\n    const z = this.field(point.z);\n    const t = this.field(point.t);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for E(a,d)<->E(-a,d-a):\n      //\n      //   x' = (2 * x * y) / (y^2 - a * x^2)\n      //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)\n      //\n      // Undefined for y^2 - a * x^2 = 0\n      //            or y^2 + a * x^2 = 2.\n      const xy = x.redMul(y);\n      const x2 = x.redSqr();\n      const y2 = y.redSqr();\n      const z2 = z.redSqr();\n      const ax2 = a.redMul(x2);\n      const xx = xy.redIMuln(2);\n      const xz = y2.redSub(ax2);\n      const yy = y2.redAdd(ax2);\n      const yz = z2.redIMuln(2).redISub(yy);\n      const p = this.cpoint(xx, xz, yy, yz);\n\n      return !this.twisted ? p.divn(4) : p;\n    }\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for E(a,d)<->E(a',a'd/a):\n      //\n      //   x' = +-sqrt(a / a') * x\n      //   y' = y\n      //\n      // Undefined when (a / a') is not square.\n      const c = this._scale(point.curve);\n      const nx = c.redMul(x);\n      const ny = y;\n      const nz = z;\n      const nt = c.redMul(t);\n\n      return this.point(nx, ny, nz, nt);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u, curve = null) {\n    assert(u instanceof BN);\n    assert(u.red === this.red);\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    const u0 = curve.field(u);\n    const p0 = curve.pointFromUniform(u0);\n\n    return this.pointFromMont(p0);\n  }\n\n  pointToUniform(p, hint, curve = null) {\n    assert(p instanceof EdwardsPoint);\n    assert((hint >>> 0) === hint);\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    // Add a random torsion component.\n    const i = ((hint >> 4) & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    // Convert and invert.\n    const p0 = curve.pointFromEdwards(q);\n    const u0 = curve.pointToUniform(p0, hint & 15);\n\n    return this.field(u0);\n  }\n\n  pointFromHash(bytes, pake, curve = null) {\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    const p0 = curve.pointFromHash(bytes, pake);\n\n    return this.pointFromMont(p0);\n  }\n\n  pointToHash(p, subgroup, rng, curve = null) {\n    assert(p instanceof EdwardsPoint);\n    assert((subgroup >>> 0) === subgroup);\n    assert(curve == null || (curve instanceof MontCurve));\n\n    if (!curve)\n      curve = this._alt();\n\n    // Add a random torsion component.\n    const i = subgroup % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n\n    // Convert and invert.\n    const p0 = curve.pointFromEdwards(q);\n\n    return curve.pointToHash(p0, 0, rng);\n  }\n\n  decodePoint(bytes) {\n    return EdwardsPoint.decode(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign)\n        u3.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromEdwards(this.g);\n\n    for (let i = 0; i < this.h; i++)\n      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, invert, sign = null) {\n    const [a, b] = this._mont(b0, invert);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = this._scale(curve, invert);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity())\n      curve.g = curve.pointFromEdwards(this.g);\n\n    for (let i = 0; i < this.h; i++)\n      curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, sign = null) {\n    const [a, d] = this._edwards(a0);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this);\n\n      if (c.redIsOdd() !== sign)\n        c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromEdwards(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return EdwardsPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n\n    json.a = this.a.fromRed().toJSON();\n    json.d = this.d.fromRed().toJSON();\n\n    if (!this.s.isZero())\n      json.s = this.s.fromRed().toJSON();\n\n    return json;\n  }\n}\n\n/**\n * EdwardsPoint\n */\n\nclass EdwardsPoint extends Point {\n  constructor(curve, x, y, z, t) {\n    assert(curve instanceof EdwardsCurve);\n\n    super(curve, types.EXTENDED);\n\n    this.x = this.curve.zero;\n    this.y = this.curve.one;\n    this.z = this.curve.one;\n    this.t = this.curve.zero;\n    this.zOne = 1;\n\n    if (x != null)\n      this._init(x, y, z, t);\n  }\n\n  _init(x, y, z, t) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    assert(z == null || (z instanceof BN));\n    assert(t == null || (t instanceof BN));\n\n    this.x = x;\n    this.y = y;\n    this.z = z || this.curve.one;\n    this.t = t || null;\n\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n\n    if (!this.z.red)\n      this.z = this.z.toRed(this.curve.red);\n\n    if (this.t && !this.t.red)\n      this.t = this.t.toRed(this.curve.red);\n\n    this.zOne = this.z.eq(this.curve.one) | 0;\n\n    this._check();\n\n    if (!this.t) {\n      this.t = this.x.redMul(this.y);\n      if (!this.zOne)\n        this.t = this.t.redDiv(this.z);\n    }\n  }\n\n  _check() {\n    // In order to achieve complete\n    // addition formulas, `a` must\n    // be a square (always the case\n    // for a=1), and `d` must be a\n    // non-square.\n    //\n    // If this is not the case, the\n    // addition formulas may have\n    // exceptional cases where Z3=0.\n    //\n    // In particular, this can occur\n    // when: Q*h = -P*h and Q != -P.\n    //\n    // This is assuming 4-torsion is\n    // involved (the 4-torsion point\n    // is _not_ representable when\n    // `d` is square).\n    if (this.z.isZero())\n      throw new Error('Invalid point.');\n  }\n\n  clone() {\n    return this.curve.point(this.x.clone(),\n                            this.y.clone(),\n                            this.z.clone(),\n                            this.t.clone());\n  }\n\n  swap(point, flag) {\n    assert(point instanceof EdwardsPoint);\n\n    const cond = ((flag >> 31) | (-flag >> 31)) & 1;\n    const zOne1 = this.zOne;\n    const zOne2 = point.zOne;\n\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n    this.z.cswap(point.z, flag);\n    this.t.cswap(point.t, flag);\n\n    this.zOne = (zOne1 & (cond ^ 1)) | (zOne2 & cond);\n    point.zOne = (zOne2 & (cond ^ 1)) | (zOne1 & cond);\n\n    return this;\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z\n    // 1I + 2M (+ 1M if extended)\n\n    // Z1 = 1\n    if (this.zOne)\n      return this;\n\n    // A = 1 / Z1\n    const a = this.z.redInvert();\n\n    // X3 = X1 * A\n    this.x = this.x.redMul(a);\n\n    // Y3 = Y1 * A\n    this.y = this.y.redMul(a);\n\n    // T3 = T1 * A\n    this.t = this.t.redMul(a);\n\n    // Z3 = 1\n    this.z = this.curve.one;\n    this.zOne = 1;\n\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN);\n\n    // X3 = X1 * A\n    const nx = this.x.redMul(a);\n\n    // Y3 = Y1 * A\n    const ny = this.y.redMul(a);\n\n    // Z3 = Z1 * A\n    const nz = this.z.redMul(a);\n\n    // T3 = T1 * A\n    const nt = this.t.redMul(a);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  neg() {\n    // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)\n    const nx = this.x.redNeg();\n    const ny = this.y;\n    const nz = this.z;\n    const nt = this.t.redNeg();\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  add(p) {\n    assert(p instanceof EdwardsPoint);\n\n    // P = O\n    if (this.isInfinity())\n      return p;\n\n    // Q = O\n    if (p.isInfinity())\n      return this;\n\n    // Z1 = 1\n    if (this.zOne)\n      return p._add(this, 0);\n\n    return this._add(p, 0);\n  }\n\n  _add(p, flag) {\n    // a = -1\n    if (this.curve.mOneA)\n      return this._addM1(p, flag);\n\n    return this._addA(p, flag);\n  }\n\n  _addM1(p, flag) {\n    // Assumes a = -1.\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n    // 8M + 8A + 1*k + 1*2\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3\n    // 7M + 8A + 1*k + 1*2\n    const zOne = p.zOne & (flag ^ 1);\n\n    // A = (Y1 - X1) * (Y2 - X2)\n    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));\n\n    // B = (Y1 + X1) * (Y2 + X2)\n    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));\n\n    // C = T1 * k * T2\n    const c = this.t.redMul(this.curve.k).redMul(p.t);\n\n    // D = Z1 * 2 * Z2\n    const d = zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2);\n\n    // E = B - A\n    const e = b.redSub(a);\n\n    // F = D - C\n    const f = d.redSub(c);\n\n    // G = D + C\n    const g = d.redIAdd(c);\n\n    // H = B + A\n    const h = b.redIAdd(a);\n\n    // X3 = E * F\n    const nx = e.redMul(f);\n\n    // Y3 = G * H\n    const ny = g.redMul(h);\n\n    // T3 = E * H\n    const nt = e.redMul(h);\n\n    // Z3 = F * G\n    const nz = f.redMul(g);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  _addA(p, flag) {\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // 9M + 7A + 1*a + 1*d\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd\n    // 8M + 7A + 1*a + 1*d\n    const zOne = p.zOne & (flag ^ 1);\n\n    // A = X1 * X2\n    const a = this.x.redMul(p.x);\n\n    // B = Y1 * Y2\n    const b = this.y.redMul(p.y);\n\n    // C = T1 * d * T2\n    const c = this.curve._mulD(this.t).redMul(p.t);\n\n    // D = Z1 * Z2\n    const d = zOne ? this.z.clone() : this.z.redMul(p.z);\n\n    // + XYXY = (X1 + Y1) * (X2 + Y2)\n    const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y));\n\n    // E = (X1 + Y1) * (X2 + Y2) - A - B\n    const e = xyxy.redISub(a).redISub(b);\n\n    // F = D - C\n    const f = d.redSub(c);\n\n    // G = D + C\n    const g = d.redIAdd(c);\n\n    // H = B - a * A\n    const h = b.redISub(this.curve._mulA(a));\n\n    // X3 = E * F\n    const nx = e.redMul(f);\n\n    // Y3 = G * H\n    const ny = g.redMul(h);\n\n    // T3 = E * H\n    const nt = e.redMul(h);\n\n    // Z3 = F * G\n    const nz = f.redMul(g);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  dbl() {\n    // P = O\n    if (this.isInfinity())\n      return this;\n\n    return this._dbl(0);\n  }\n\n  _dbl(flag) {\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // 4M + 4S + 6A + 1*a + 1*2\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd\n    // 3M + 4S + 7A + 1*a + 1*2\n    const zOne = this.zOne & (flag ^ 1);\n\n    // A = X1^2\n    const a = this.x.redSqr();\n\n    // B = Y1^2\n    const b = this.y.redSqr();\n\n    // C = 2 * Z1^2\n    const c = zOne ? this.curve.two : this.z.redSqr().redIMuln(2);\n\n    // D = a * A\n    const d = this.curve._mulA(a);\n\n    // E = (X1 + Y1)^2 - A - B\n    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);\n\n    // G = D + B\n    const g = d.redAdd(b);\n\n    // F = G - C\n    const f = g.redSub(c);\n\n    // H = D - B\n    const h = d.redISub(b);\n\n    // X3 = E * F\n    const nx = e.redMul(f);\n\n    // Y3 = G * H\n    const ny = g.redMul(h);\n\n    // T3 = E * H\n    const nt = e.redMul(h);\n\n    // Z3 = F * G\n    const nz = f.redMul(g);\n\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  uadd(p) {\n    assert(p instanceof EdwardsPoint);\n    return this._add(p, 1);\n  }\n\n  udbl() {\n    return this._dbl(1);\n  }\n\n  getX() {\n    this.normalize();\n    return this.x.fromRed();\n  }\n\n  getY() {\n    this.normalize();\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof EdwardsPoint);\n    assert(!this.z.isZero());\n    assert(!p.z.isZero());\n\n    // P = Q\n    if (this === p)\n      return true;\n\n    // Z1 = Z2\n    if (this.z.eq(p.z)) {\n      return this.x.eq(p.x)\n          && this.y.eq(p.y);\n    }\n\n    // X1 * Z2 == X2 * Z1\n    const x1 = this.x.redMul(p.z);\n    const x2 = p.x.redMul(this.z);\n\n    if (!x1.eq(x2))\n      return false;\n\n    const y1 = this.y.redMul(p.z);\n    const y2 = p.y.redMul(this.z);\n\n    return y1.eq(y2);\n  }\n\n  isInfinity() {\n    assert(!this.z.isZero());\n\n    // X1 = 0\n    if (!this.x.isZero())\n      return false;\n\n    // Y1 = Z1\n    return this.y.eq(this.z);\n  }\n\n  isOdd() {\n    this.normalize();\n    return this.x.redIsOdd();\n  }\n\n  isEven() {\n    this.normalize();\n    return this.x.redIsEven();\n  }\n\n  toP() {\n    return this.normalize();\n  }\n\n  toJ() {\n    return this;\n  }\n\n  encode() {\n    // [RFC8032] Section 5.1.2.\n    const y = this.getY();\n\n    // Note: `x` normalized from `getY()` call.\n    y.setn(this.curve.signBit, this.x.redIsOdd());\n\n    return this.curve.encodeAdjusted(y);\n  }\n\n  static decode(curve, bytes) {\n    // [RFC8032] Section 5.1.3.\n    assert(curve instanceof EdwardsCurve);\n\n    const y = curve.decodeAdjusted(bytes);\n    const sign = y.testn(curve.signBit) !== 0;\n\n    y.setn(curve.signBit, 0);\n\n    if (y.cmp(curve.p) >= 0)\n      throw new Error('Invalid point.');\n\n    return curve.pointFromY(y, sign);\n  }\n\n  toJSON(pre) {\n    if (this.isInfinity())\n      return [];\n\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n\n    if (pre === true && this.pre)\n      return [x, y, this.pre.toJSON()];\n\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof EdwardsCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0\n        || json.length === 2\n        || json.length === 3);\n\n    if (json.length === 0)\n      return curve.point();\n\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    const point = curve.point(x, y);\n\n    if (json.length > 2 && json[2] != null)\n      point.pre = Precomp.fromJSON(point, json[2]);\n\n    return point;\n  }\n\n  [custom]() {\n    if (this.isInfinity())\n      return '<EdwardsPoint: Infinity>';\n\n    return '<EdwardsPoint:'\n        + ' x=' + this.x.fromRed().toString(16, 2)\n        + ' y=' + this.y.fromRed().toString(16, 2)\n        + ' z=' + this.z.fromRed().toString(16, 2)\n        + '>';\n  }\n}\n\n/**\n * Mask\n */\n\nclass Mask {\n  constructor(curve) {\n    assert(curve instanceof Curve);\n\n    // Get prime bit length.\n    let bits = curve.fieldBits;\n    let top = bits & 7;\n\n    if (top === 0)\n      top = 8;\n\n    // Adjust for low order.\n    if (curve.scalarSize < curve.fieldSize) {\n      bits = curve.scalarSize * 8;\n      top = 8;\n    }\n\n    // Our curve.\n    this.curve = curve;\n\n    // Cofactor mask (p25519=-8, p448=-4).\n    this.h = -curve.h.word(0) & 0xff;\n\n    // Prime top byte (p25519=0x7f, p448=0xff).\n    this.n = (1 << top) - 1;\n\n    // High bit (p25519=0x40, p448=0x80).\n    this.b = 1 << (top - 1);\n\n    // AND mask (p25519=0x7fff...f8, p448=0xffff...fc).\n    this.and = BN.mask(bits).iuxorn(this.h ^ 0xff);\n\n    // OR mask (p25519=0x4000..., p448=0x8000...).\n    this.or = BN.shift(1, bits - 1);\n  }\n\n  reduce(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n\n    k.iuand(this.and);\n    k.iuor(this.or);\n\n    return k;\n  }\n\n  clamp(bytes) {\n    assert(Buffer.isBuffer(bytes));\n    assert(bytes.length === this.curve.scalarSize);\n\n    let i = 0;\n    let j = this.curve.scalarSize - 1;\n\n    if (this.curve.endian === 'be')\n      [i, j] = [j, i];\n\n    // Adjust for high order.\n    if (this.curve.scalarSize > this.curve.fieldSize) {\n      if (this.curve.endian === 'be')\n        bytes[j++] = 0;\n      else\n        bytes[j--] = 0;\n    }\n\n    // Ensure a multiple of the cofactor.\n    bytes[i] &= this.h;\n\n    // Clamp to the prime.\n    bytes[j] &= this.n;\n\n    // Set the high bit.\n    bytes[j] |= this.b;\n\n    return bytes;\n  }\n\n  splitHash(bytes) {\n    assert(Buffer.isBuffer(bytes));\n    assert(bytes.length === this.curve.adjustedSize * 2);\n\n    let off = 0;\n\n    if (this.curve.endian === 'be')\n      off = this.curve.adjustedSize - this.curve.scalarSize;\n\n    const scalar = bytes.slice(off, off + this.curve.scalarSize);\n    const prefix = bytes.slice(this.curve.adjustedSize);\n\n    this.clamp(scalar);\n\n    return [scalar, prefix];\n  }\n}\n\n/**\n * Precomp\n */\n\nclass Precomp {\n  constructor() {\n    this.naf = null;\n    this.windows = null;\n    this.doubles = null;\n    this.blinding = null;\n    this.beta = null;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n\n    const out = new this.constructor();\n\n    if (this.naf)\n      out.naf = this.naf.map(func);\n\n    if (this.doubles)\n      out.doubles = this.doubles.map(func);\n\n    return out;\n  }\n\n  toJSON() {\n    return {\n      naf: this.naf ? this.naf.toJSON() : null,\n      windows: this.windows ? this.windows.toJSON() : null,\n      doubles: this.doubles ? this.doubles.toJSON() : null,\n      blinding: this.blinding ? this.blinding.toJSON() : undefined\n    };\n  }\n\n  fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n\n    if (json.naf != null)\n      this.naf = NAF.fromJSON(point, json.naf);\n\n    if (json.windows != null)\n      this.windows = Windows.fromJSON(point, json.windows);\n\n    if (json.doubles != null)\n      this.doubles = Doubles.fromJSON(point, json.doubles);\n\n    if (json.blinding != null)\n      this.blinding = Blinding.fromJSON(point, json.blinding);\n\n    return this;\n  }\n\n  static fromJSON(point, json) {\n    return new this().fromJSON(point, json);\n  }\n}\n\n/**\n * NAF\n */\n\nclass NAF {\n  constructor(width, points) {\n    this.width = width;\n    this.points = points;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n\n    const {width} = this;\n    const points = [];\n\n    for (const point of this.points)\n      points.push(func(point));\n\n    return new this.constructor(width, points);\n  }\n\n  toJSON() {\n    return {\n      width: this.width,\n      points: this.points.slice(1).map((point) => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert((json.width >>> 0) === json.width);\n    assert(Array.isArray(json.points));\n\n    const {curve} = point;\n    const {width} = json;\n    const points = [point];\n\n    for (const item of json.points)\n      points.push(curve.pointFromJSON(item));\n\n    return new this(width, points);\n  }\n}\n\n/**\n * Windows\n */\n\nclass Windows {\n  constructor(width, bits, points) {\n    this.width = width;\n    this.bits = bits;\n    this.points = points;\n  }\n\n  toJSON() {\n    return {\n      width: this.width,\n      bits: this.bits,\n      points: this.points.slice(1).map((point) => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert((json.width >>> 0) === json.width);\n    assert((json.bits >>> 0) === json.bits);\n    assert(Array.isArray(json.points));\n\n    const {curve} = point;\n    const {width, bits} = json;\n    const points = [point];\n\n    for (const item of json.points)\n      points.push(curve.pointFromJSON(item));\n\n    return new this(width, bits, points);\n  }\n}\n\n/**\n * Doubles\n */\n\nclass Doubles {\n  constructor(step, points) {\n    this.step = step;\n    this.points = points;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n\n    const {step} = this;\n    const points = [];\n\n    for (const point of this.points)\n      points.push(func(point));\n\n    return new this.constructor(step, points);\n  }\n\n  toJSON() {\n    return {\n      step: this.step,\n      points: this.points.slice(1).map((point) => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert((json.step >>> 0) === json.step);\n    assert(Array.isArray(json.points));\n\n    const {curve} = point;\n    const {step} = json;\n    const points = [point];\n\n    for (const item of json.points)\n      points.push(curve.pointFromJSON(item));\n\n    return new this(step, points);\n  }\n}\n\n/**\n * Blinding\n */\n\nclass Blinding {\n  constructor(blind, unblind) {\n    this.blind = blind;\n    this.unblind = unblind;\n  }\n\n  toJSON() {\n    return {\n      blind: this.blind.toJSON(),\n      unblind: this.unblind.toJSON()\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n\n    const {curve} = point;\n    const blind = BN.fromJSON(json.blind);\n    const unblind = curve.pointFromJSON(json.unblind);\n\n    return new this(blind, unblind);\n  }\n}\n\n/**\n * Endo\n */\n\nclass Endo {\n  constructor(beta, lambda, basis, pre) {\n    this.beta = beta;\n    this.lambda = lambda;\n    this.basis = basis;\n    this.pre = pre;\n  }\n\n  toJSON() {\n    return {\n      beta: this.beta.fromRed().toJSON(),\n      lambda: this.lambda.toJSON(),\n      basis: [\n        this.basis[0].toJSON(),\n        this.basis[1].toJSON()\n      ],\n      pre: [\n        this.pre[0].toJSON(),\n        this.pre[1].toJSON()\n      ]\n    };\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof Curve);\n    assert(json && typeof json === 'object');\n    assert(Array.isArray(json.basis));\n    assert(Array.isArray(json.pre));\n    assert(json.basis.length === 2);\n    assert(json.pre.length === 2);\n\n    const beta = BN.fromJSON(json.beta).toRed(curve.red);\n    const lambda = BN.fromJSON(json.lambda);\n\n    const basis = [\n      Vector.fromJSON(json.basis[0]),\n      Vector.fromJSON(json.basis[1])\n    ];\n\n    const pre = [\n      BN.fromJSON(json.pre[0]),\n      BN.fromJSON(json.pre[1])\n    ];\n\n    return new this(beta, lambda, basis, pre);\n  }\n}\n\n/**\n * Vector\n */\n\nclass Vector {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  toJSON() {\n    return {\n      a: this.a.toJSON(),\n      b: this.b.toJSON()\n    };\n  }\n\n  static fromJSON(json) {\n    assert(json && typeof json === 'object');\n\n    const a = BN.fromJSON(json.a);\n    const b = BN.fromJSON(json.b);\n\n    return new this(a, b);\n  }\n}\n\n/**\n * P192\n * https://tinyurl.com/fips-186-2 (page 29)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\nclass P192 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P192',\n      ossl: 'prime192v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p192',\n      // 2^192 - 2^64 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff fffffffc'],\n      b: ['64210519 e59c80e7 0fa7e9ab 72243049',\n          'feb8deec c146b9b1'],\n      n: ['ffffffff ffffffff ffffffff 99def836',\n          '146bc9b1 b4d22831'],\n      h: '1',\n      // Icart\n      z: '-5',\n      g: [\n        ['188da80e b03090f6 7cbf20eb 43a18800',\n         'f4ff0afd 82ff1012'],\n        ['07192b95 ffc8da78 631011ed 6b24cdd5',\n         '73f977a1 1e794811'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P224\n * https://tinyurl.com/fips-186-2 (page 30)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\nclass P224 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P224',\n      ossl: 'secp224r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p224',\n      // 2^224 - 2^96 + 1 (no congruence)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          '00000000 00000000 00000001'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff ffffffff fffffffe'],\n      b: ['b4050a85 0c04b3ab f5413256 5044b0b7',\n          'd7bfd8ba 270b3943 2355ffb4'],\n      n: ['ffffffff ffffffff ffffffff ffff16a2',\n          'e0b8f03e 13dd2945 5c5c2a3d'],\n      h: '1',\n      // SSWU\n      z: '1f',\n      g: [\n        ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3',\n         '56c21122 343280d6 115c1d21'],\n        ['bd376388 b5f723fb 4c22dfe6 cd4375a0',\n         '5a074764 44d58199 85007e34'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P256\n * https://tinyurl.com/fips-186-2 (page 31)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\nclass P256 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P256',\n      ossl: 'prime256v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)\n      p: ['ffffffff 00000001 00000000 00000000',\n          '00000000 ffffffff ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff 00000001 00000000 00000000',\n          '00000000 ffffffff ffffffff fffffffc'],\n      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc',\n          '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],\n      n: ['ffffffff 00000000 ffffffff ffffffff',\n          'bce6faad a7179e84 f3b9cac2 fc632551'],\n      h: '1',\n      // SSWU\n      z: '-a',\n      g: [\n        ['6b17d1f2 e12c4247 f8bce6e5 63a440f2',\n         '77037d81 2deb33a0 f4a13945 d898c296'],\n        ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16',\n         '2bce3357 6b315ece cbb64068 37bf51f5'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P384\n * https://tinyurl.com/fips-186-2 (page 32)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\nclass P384 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P384',\n      ossl: 'secp384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff 00000000 00000000 ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff fffffffe',\n          'ffffffff 00000000 00000000 fffffffc'],\n      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19',\n          '181d9c6e fe814112 0314088f 5013875a',\n          'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],\n      n: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff c7634d81 f4372ddf',\n          '581a0db2 48b0a77a ecec196a ccc52973'],\n      h: '1',\n      // Icart\n      z: '-c',\n      g: [\n        ['aa87ca22 be8b0537 8eb1c71e f320ad74',\n         '6e1d3b62 8ba79b98 59f741e0 82542a38',\n         '5502f25d bf55296c 3a545e38 72760ab7'],\n        ['3617de4a 96262c6f 5d9e98bf 9292dc29',\n         'f8f41dbd 289a147c e9da3113 b5f0b8c0',\n         '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * P521\n * https://tinyurl.com/fips-186-2 (page 33)\n * https://tinyurl.com/fips-186-3 (page 90)\n */\n\nclass P521 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P521',\n      ossl: 'secp521r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: 'p521',\n      // 2^521 - 1 (= 3 mod 4)\n      p: ['000001ff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff'],\n      // -3 mod p\n      a: ['000001ff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'fffffffc'],\n      b: ['00000051 953eb961 8e1c9a1f 929a21a0',\n          'b68540ee a2da725b 99b315f3 b8b48991',\n          '8ef109e1 56193951 ec7e937b 1652c0bd',\n          '3bb1bf07 3573df88 3d2c34f1 ef451fd4',\n          '6b503f00'],\n      n: ['000001ff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'fffffffa 51868783 bf2f966b 7fcc0148',\n          'f709a5d0 3bb5c9b8 899c47ae bb6fb71e',\n          '91386409'],\n      h: '1',\n      // SSWU\n      z: '-4',\n      g: [\n        ['000000c6 858e06b7 0404e9cd 9e3ecb66',\n         '2395b442 9c648139 053fb521 f828af60',\n         '6b4d3dba a14b5e77 efe75928 fe1dc127',\n         'a2ffa8de 3348b3c1 856a429b f97e7e31',\n         'c2e5bd66'],\n        ['00000118 39296a78 9a3bc004 5c8a5fb4',\n         '2c7d1bd9 98f54449 579b4468 17afbd17',\n         '273e662c 97ee7299 5ef42640 c550b901',\n         '3fad0761 353c7086 a272c240 88be9476',\n         '9fd16650'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * SECP256K1\n * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)\n * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)\n */\n\nclass SECP256K1 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'SECP256K1',\n      ossl: 'secp256k1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'k256',\n      // 2^256 - 2^32 - 977 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe fffffc2f'],\n      a: '0',\n      b: '7',\n      n: ['ffffffff ffffffff ffffffff fffffffe',\n          'baaedce6 af48a03b bfd25e8c d0364141'],\n      h: '1',\n      // SVDW\n      z: '1',\n      // sqrt(-3)\n      c: ['0a2d2ba9 3507f1df 233770c2 a797962c',\n          'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],\n      g: [\n        ['79be667e f9dcbbac 55a06295 ce870b07',\n         '029bfcdb 2dce28d9 59f2815b 16f81798'],\n        ['483ada77 26a3c465 5da4fbfc 0e1108a8',\n         'fd17b448 a6855419 9c47d08f fb10d4b8'],\n        pre\n      ],\n      // Precomputed endomorphism.\n      endo: {\n        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9',\n               '9cf04975 12f58995 c1396c28 719501ee'],\n        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a',\n                 '122e22ea 20816678 df02967c 1b23bd72'],\n        basis: [\n          {\n            a: '3086d221a7d46bcde86c90e49284eb15',\n            b: '-e4437ed6010e88286f547fa90abfe4c3'\n          },\n          {\n            a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n            b: '3086d221a7d46bcde86c90e49284eb15'\n          }\n        ],\n        pre: [\n          '3086d221a7d46bcde86c90e49284eb153dab',\n          '-e4437ed6010e88286f547fa90abfe4c42212'\n        ]\n      }\n    });\n  }\n}\n\n/**\n * BRAINPOOLP256\n * https://tools.ietf.org/html/rfc5639#section-3.4\n */\n\nclass BRAINPOOLP256 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP256',\n      ossl: 'brainpoolP256r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72',\n          '6e3bf623 d5262028 2013481d 1f6e5377'],\n      a: ['7d5a0975 fc2c3057 eef67530 417affe7',\n          'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],\n      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf',\n          '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],\n      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71',\n          '8c397aa3 b561a6f7 901e0e82 974856a7'],\n      h: '1',\n      // Icart\n      z: '-2',\n      g: [\n        ['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af',\n         'b9de27e1 e3bd23c2 3a4453bd 9ace3262'],\n        ['547ef835 c3dac4fd 97f8461a 14611dc9',\n         'c2774513 2ded8e54 5c1d54c7 2f046997'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * BRAINPOOLP384\n * https://tools.ietf.org/html/rfc5639#section-3.6\n */\n\nclass BRAINPOOLP384 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP384',\n      ossl: 'brainpoolP384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',\n          '152f7109 ed5456b4 12b1da19 7fb71123',\n          'acd3a729 901d1a71 87470013 3107ec53'],\n      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0',\n          'c2bea28e 4fb22787 139165ef ba91f90f',\n          '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],\n      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c',\n          '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5',\n          '7cb43902 95dbc994 3ab78696 fa504c11'],\n      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df',\n          '152f7109 ed5456b3 1f166e6c ac0425a7',\n          'cf3ab6af 6b7fc310 3b883202 e9046565'],\n      h: '1',\n      // SSWU\n      z: '-5',\n      g: [\n        ['1d1c64f0 68cf45ff a2a63a81 b7c13f6b',\n         '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8',\n         'e826e034 36d646aa ef87b2e2 47d4af1e'],\n        ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552',\n         '62b70b29 feec5864 e19c054f f9912928',\n         '0e464621 77918111 42820341 263c5315'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * BRAINPOOLP512\n * https://tools.ietf.org/html/rfc5639#section-3.7\n */\n\nclass BRAINPOOLP512 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP512',\n      ossl: 'brainpoolP512r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',\n          'cb308db3 b3c9d20e d6639cca 70330871',\n          '7d4d9b00 9bc66842 aecda12a e6a380e6',\n          '2881ff2f 2d82c685 28aa6056 583a48f3'],\n      a: ['7830a331 8b603b89 e2327145 ac234cc5',\n          '94cbdd8d 3df91610 a83441ca ea9863bc',\n          '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5',\n          '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],\n      b: ['3df91610 a83441ca ea9863bc 2ded5d5a',\n          'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7',\n          '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67',\n          '984050b7 5ebae5dd 2809bd63 8016f723'],\n      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',\n          'cb308db3 b3c9d20e d6639cca 70330870',\n          '553e5c41 4ca92619 41866119 7fac1047',\n          '1db1d381 085ddadd b5879682 9ca90069'],\n      h: '1',\n      // Icart\n      z: '7',\n      g: [\n        ['81aee4bd d82ed964 5a21322e 9c4c6a93',\n         '85ed9f70 b5d916c1 b43b62ee f4d0098e',\n         'ff3b1f78 e2d0d48d 50d1687b 93b97d5f',\n         '7c6d5047 406a5e68 8b352209 bcb9f822'],\n        ['7dde385d 566332ec c0eabfa9 cf7822fd',\n         'f209f700 24a57b1a a000c55b 881f8111',\n         'b2dcde49 4a5f485e 5bca4bd8 8a2763ae',\n         'd1ca2b2f a8f05406 78cd1e0f 3ad80892'],\n        pre\n      ]\n    });\n  }\n}\n\n/**\n * X25519\n * https://tools.ietf.org/html/rfc7748#section-4.1\n */\n\nclass X25519 extends MontCurve {\n  constructor() {\n    super({\n      id: 'X25519',\n      ossl: 'X25519',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHA512',\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffed'],\n      // 486662\n      a: '76d06',\n      b: '1',\n      n: ['10000000 00000000 00000000 00000000',\n          '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [\n        ['00000000 00000000 00000000 00000000',\n         '00000000 00000000 00000000 00000009'],\n        // See: https://www.rfc-editor.org/errata/eid4730\n        ['5f51e65e 475f794b 1fe122d3 88b72eb3',\n         '6dc2b281 92839e4d d6163a5d 81312c14']\n      ],\n      torsion: [\n        // (1)\n        [],\n        // (2)\n        [\n          '0000000000000000000000000000000000000000000000000000000000000000',\n          '0000000000000000000000000000000000000000000000000000000000000000'\n        ],\n        // (4)\n        [\n          '0000000000000000000000000000000000000000000000000000000000000001',\n          '141b0b6806563d503de05885280b59109ca5ee38d7b56c9c165db7106377bbd8'\n        ],\n        // (4)\n        [\n          '0000000000000000000000000000000000000000000000000000000000000001',\n          '6be4f497f9a9c2afc21fa77ad7f4a6ef635a11c7284a9363e9a248ef9c884415'\n        ],\n        // (8)\n        [\n          '00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0',\n          '46ce3ed6a9617c5ad6b7d3eb19d74ba86cc403d6127fe4b29778eb7c6daf84d3'\n        ],\n        // (8)\n        [\n          '00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0',\n          '3931c129569e83a529482c14e628b457933bfc29ed801b4d6887148392507b1a'\n        ],\n        // (8)\n        [\n          '57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f',\n          '173a6c76c2ba719bce3935ffba04afeadf5bbcb971559722f0efc7bdfb7f9a36'\n        ],\n        // (8)\n        [\n          '57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f',\n          '68c593893d458e6431c6ca0045fb501520a443468eaa68dd0f103842048065b7'\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * X448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n */\n\nclass X448 extends MontCurve {\n  constructor() {\n    super({\n      id: 'X448',\n      ossl: 'X448',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      // 156326\n      a: '262a6',\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['00000000 00000000 00000000 00000000',\n         '00000000 00000000 00000000 00000000',\n         '00000000 00000000 00000000 00000000',\n         '00000000 00000005'],\n        ['7d235d12 95f5b1f6 6c98ab6e 58326fce',\n         'cbae5d34 f55545d0 60f75dc2 8df3f6ed',\n         'b8027e23 46430d21 1312c4b1 50677af7',\n         '6fd7223d 457b5b1a']\n      ],\n      torsion: [\n        // (1)\n        [],\n        // (2)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000']\n        ],\n        // (4)\n        [\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'],\n          ['ba4d3a0829b6112f8812e51ba0bb2abebc1cb08eb48e556936ba50fd',\n           'd2e7d68af8cb32160522425b3f990812abbe635ad37a21e17551b193']\n        ],\n        // (4)\n        [\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'],\n          ['45b2c5f7d649eed077ed1ae45f44d54143e34f714b71aa96c945af01',\n           '2d1829750734cde9faddbda4c066f7ed54419ca52c85de1e8aae4e6c']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * MONT448\n * Isomorphic to Ed448-Goldilocks.\n */\n\nclass MONT448 extends MontCurve {\n  constructor() {\n    super({\n      id: 'MONT448',\n      ossl: null,\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      // -78160 / -39082 mod p\n      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5',\n          '5d93f8d2 22746997 60ccffc6 49961ed6',\n          'c5b05fca c24864ed 6fb59697 931b78da',\n          '84ddecd8 ca2b5cfb'],\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['ac0d24cc c6c75cb0 eb71f81e 7a6edf51',\n         '48e88aee 009a2a24 e795687e c28e125a',\n         '3e6730a6 0d46367b aa7fe99d 152128dc',\n         '41321bc7 7817f059'],\n        ['5a4437f6 80c0d0db 9b061276 d5d0ffcc',\n         'e786ff33 b6a53d30 98746425 82e66f09',\n         '4433dae7 7244a6e2 6b11e905 7228f483',\n         '556c41a5 913f55fe']\n      ],\n      torsion: [\n        // (1)\n        [],\n        // (2)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000']\n        ],\n        // (4)\n        [\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'],\n          ['bec92fd06da2acf2b4e261e87cef0d3422e75c183c589857b71924e5',\n           '73c2f9cee18da5f2466e2f393c2eedf0f105a60ab40c717d4f1e1fd7']\n        ],\n        // (4)\n        [\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'],\n          ['4136d02f925d530d4b1d9e178310f2cbdd18a3e7c3a767a848e6db19',\n           '8c3d06311e725a0db991d0c6c3d1120f0efa59f54bf38e82b0e1e028']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * ED25519\n * https://tools.ietf.org/html/rfc8032#section-5.1\n */\n\nclass ED25519 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ED25519',\n      ossl: 'ED25519',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHA512',\n      prefix: 'SigEd25519 no Ed25519 collisions',\n      context: false,\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff ffffffed'],\n      a: '-1',\n      // -121665 / 121666 mod p\n      d: ['52036cee 2b6ffe73 8cc74079 7779e898',\n          '00700a4d 4141d8ab 75eb4dca 135978a3'],\n      n: ['10000000 00000000 00000000 00000000',\n          '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [\n        ['216936d3 cd6e53fe c0a4e231 fdd6dc5c',\n         '692cc760 9525a7b2 c9562d60 8f25d51a'],\n        // 4/5\n        ['66666666 66666666 66666666 66666666',\n         '66666666 66666666 66666666 66666658'],\n        pre\n      ],\n      torsion: [\n        // (0, 1) (1)\n        [\n          '0000000000000000000000000000000000000000000000000000000000000000',\n          '0000000000000000000000000000000000000000000000000000000000000001'\n        ],\n        // (0, -1) (2)\n        [\n          '0000000000000000000000000000000000000000000000000000000000000000',\n          '7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'\n        ],\n        // (-sqrt(1 / a), 0) (4)\n        [\n          '547cdb7fb03e20f4d4b2ff66c2042858d0bce7f952d01b873b11e4d8b5f15f3d',\n          '0000000000000000000000000000000000000000000000000000000000000000'\n        ],\n        // (sqrt(1 / a), 0) (4)\n        [\n          '2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0',\n          '0000000000000000000000000000000000000000000000000000000000000000'\n        ],\n        // (-sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), sqrt(a) * x) (8)\n        [\n          '602a465ff9c6b5d716cc66cdc721b544a3e6c38fec1a1dc7215eb9b93aba2ea3',\n          '7a03ac9277fdc74ec6cc392cfa53202a0f67100d760b3cba4fd84d3d706a17c7'\n        ],\n        // (sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), sqrt(a) * x) (8)\n        [\n          '1fd5b9a006394a28e933993238de4abb5c193c7013e5e238dea14646c545d14a',\n          '7a03ac9277fdc74ec6cc392cfa53202a0f67100d760b3cba4fd84d3d706a17c7'\n        ],\n        // (-sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), -sqrt(a) * x) (8)\n        [\n          '602a465ff9c6b5d716cc66cdc721b544a3e6c38fec1a1dc7215eb9b93aba2ea3',\n          '05fc536d880238b13933c6d305acdfd5f098eff289f4c345b027b2c28f95e826'\n        ],\n        // (sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), -sqrt(a) * x) (8)\n        [\n          '1fd5b9a006394a28e933993238de4abb5c193c7013e5e238dea14646c545d14a',\n          '05fc536d880238b13933c6d305acdfd5f098eff289f4c345b027b2c28f95e826'\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * ISO448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658\n */\n\nclass ISO448 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ISO448',\n      ossl: null,\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      a: '1',\n      // 39082 / 39081 mod p\n      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc',\n          'ad461572 42a50f37 809b1da3 412a12e7',\n          '9ccc9c81 264cfe9a d0809970 58fb61c4',\n          '243cc32d baa156b9'],\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['79a70b2b 70400553 ae7c9df4 16c792c6',\n         '1128751a c9296924 0c25a07d 728bdc93',\n         'e21f7787 ed697224 9de732f3 8496cd11',\n         '69871309 3e9c04fc'],\n        // Note: the RFC has this wrong.\n        ['7fffffff ffffffff ffffffff ffffffff',\n         'ffffffff ffffffff ffffffff 80000000',\n         '00000000 00000000 00000000 00000000',\n         '00000000 00000001'],\n        pre\n      ],\n      torsion: [\n        // (0, c) (1)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000001']\n        ],\n        // (0, -c) (2)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000'],\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe']\n        ],\n        // (c, 0) (4)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000001'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000']\n        ],\n        // (-c, 0) (4)\n        [\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000']\n        ]\n      ]\n    });\n  }\n}\n\n/**\n * ED448\n * https://tools.ietf.org/html/rfc8032#section-5.2\n */\n\nclass ED448 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ED448',\n      ossl: 'ED448',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff'],\n      a: '1',\n      // -39081 mod p\n      d: ['ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff fffffffe ffffffff',\n          'ffffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffff6756'],\n      n: ['3fffffff ffffffff ffffffff ffffffff',\n          'ffffffff ffffffff ffffffff 7cca23e9',\n          'c44edb49 aed63690 216cc272 8dc58f55',\n          '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [\n        ['4f1970c6 6bed0ded 221d15a6 22bf36da',\n         '9e146570 470f1767 ea6de324 a3d3a464',\n         '12ae1af7 2ab66511 433b80e1 8b00938e',\n         '2626a82b c70cc05e'],\n        ['693f4671 6eb6bc24 88762037 56c9c762',\n         '4bea7373 6ca39840 87789c1e 05a0c2d7',\n         '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad',\n         '9808795b f230fa14'],\n        pre\n      ],\n      torsion: [\n        // (0, c) (1)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000001']\n        ],\n        // (0, -c) (2)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000'],\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe']\n        ],\n        // (c, 0) (4)\n        [\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000001'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000']\n        ],\n        // (-c, 0) (4)\n        [\n          ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe',\n           'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'],\n          ['00000000000000000000000000000000000000000000000000000000',\n           '00000000000000000000000000000000000000000000000000000000']\n        ]\n      ]\n    });\n  }\n}\n\n/*\n * Curve Registry\n */\n\nconst curves = {\n  __proto__: null,\n  P192,\n  P224,\n  P256,\n  P384,\n  P521,\n  SECP256K1,\n  BRAINPOOLP256,\n  BRAINPOOLP384,\n  BRAINPOOLP512,\n  X25519,\n  X448,\n  MONT448,\n  ED25519,\n  ISO448,\n  ED448\n};\n\nconst cache = {\n  __proto__: null,\n  P192: null,\n  P224: null,\n  P256: null,\n  P384: null,\n  P521: null,\n  SECP256K1: null,\n  BRAINPOOLP256: null,\n  BRAINPOOLP384: null,\n  BRAINPOOLP512: null,\n  X25519: null,\n  X448: null,\n  MONT448: null,\n  ED25519: null,\n  ISO448: null,\n  ED448: null\n};\n\nfunction curve(name, ...args) {\n  assert(typeof name === 'string');\n\n  const key = name.toUpperCase();\n\n  let curve = cache[key];\n\n  if (!curve) {\n    const Curve = curves[key];\n\n    if (!Curve)\n      throw new Error(`Curve not found: \"${name}\".`);\n\n    curve = new Curve(...args);\n    cache[key] = curve;\n  }\n\n  return curve;\n}\n\nfunction register(name, Curve) {\n  assert(typeof name === 'string');\n  assert(typeof Curve === 'function');\n\n  const key = name.toUpperCase();\n\n  if (curves[key])\n    throw new Error(`Curve already registered: \"${name}\".`);\n\n  curves[key] = Curve;\n  cache[key] = null;\n}\n\n/*\n * Scalar Recoding\n */\n\nfunction getNAF(c, width, max) {\n  // Computing the width-w NAF of a positive integer.\n  //\n  // [GECC] Algorithm 3.35, Page 100, Section 3.3.\n  assert(c instanceof BN);\n  assert(!c.red);\n  assert((width >>> 0) === width);\n  assert((max >>> 0) === max);\n\n  const naf = new Array(max);\n  const pow = 1 << (width + 1);\n  const k = c.abs();\n  const s = c.sign() | 1;\n\n  let i = 0;\n\n  while (!k.isZero()) {\n    let z = 0;\n\n    if (k.isOdd()) {\n      z = k.andln(pow - 1);\n\n      if (z & (pow >>> 1))\n        z -= pow;\n\n      k.isubn(z);\n    }\n\n    naf[i++] = z * s;\n\n    // Optimization: shift by word if possible.\n    let shift = 1;\n\n    if (!k.isZero() && k.andln(pow - 1) === 0)\n      shift = width + 1;\n\n    for (let j = 1; j < shift; j++)\n      naf[i++] = 0;\n\n    k.iushrn(shift);\n  }\n\n  assert(i <= max);\n\n  for (; i < max; i++)\n    naf[i] = 0;\n\n  return naf;\n}\n\nfunction getFixedNAF(k, width, max, step) {\n  assert((step >>> 0) === step);\n\n  // Recode to NAF.\n  const naf = getNAF(k, width, max);\n\n  // Translate into more windowed form.\n  const len = Math.ceil(naf.length / step);\n  const repr = new Array(len);\n\n  let i = 0;\n\n  for (let j = 0; j < naf.length; j += step) {\n    let nafW = 0;\n\n    for (let k = j + step - 1; k >= j; k--)\n      nafW = (nafW << 1) + naf[k];\n\n    repr[i++] = nafW;\n  }\n\n  assert(i === len);\n\n  return repr;\n}\n\nfunction getJSF(c1, c2, max) {\n  // Joint sparse form.\n  //\n  // [GECC] Algorithm 3.50, Page 111, Section 3.3.\n  assert(c1 instanceof BN);\n  assert(c2 instanceof BN);\n  assert(!c1.red);\n  assert(!c2.red);\n  assert((max >>> 0) === max);\n\n  const jsf = [new Array(max), new Array(max)];\n  const k1 = c1.abs();\n  const k2 = c2.abs();\n  const s1 = c1.sign() | 1;\n  const s2 = c2.sign() | 1;\n\n  let i = 0;\n  let d1 = 0;\n  let d2 = 0;\n\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase.\n    let m14 = (k1.andln(3) + d1) & 3;\n    let m24 = (k2.andln(3) + d2) & 3;\n    let u1 = 0;\n    let u2 = 0;\n\n    if (m14 === 3)\n      m14 = -1;\n\n    if (m24 === 3)\n      m24 = -1;\n\n    if (m14 & 1) {\n      const m8 = (k1.andln(7) + d1) & 7;\n\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n\n    if (m24 & 1) {\n      const m8 = (k2.andln(7) + d2) & 7;\n\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n\n    jsf[0][i] = u1 * s1;\n    jsf[1][i] = u2 * s2;\n\n    // Second phase.\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n\n    k1.iushrn(1);\n    k2.iushrn(1);\n\n    i += 1;\n  }\n\n  assert(i <= max);\n\n  for (; i < max; i++) {\n    jsf[0][i] = 0;\n    jsf[1][i] = 0;\n  }\n\n  return jsf;\n}\n\nfunction getJNAF(c1, c2, max) {\n  const jsf = getJSF(c1, c2, max);\n  const naf = new Array(max);\n\n  // JSF -> NAF conversion.\n  for (let i = 0; i < max; i++) {\n    const ja = jsf[0][i];\n    const jb = jsf[1][i];\n\n    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];\n  }\n\n  return naf;\n}\n\nfunction getLadderBits(k, n) {\n  // [TIMING] Page 16, Section 6.\n  assert(k instanceof BN);\n  assert(n instanceof BN);\n\n  // Ensure positive.\n  const k0 = k.abs();\n\n  // Inflate scalar.\n  const k1 = k0.add(n);\n  const k2 = k1.add(n);\n\n  // Get bit lengths.\n  const kb = k1.bitLength();\n  const nb = n.bitLength();\n\n  // k' = k + 2 * n, if ceil(log2(k + n)) <= ceil(log2(n)),\n  //    = k + n, otherwise\n  k1.cinject(k2, (kb - nb - 1) >>> 31);\n\n  // Track sign.\n  const sign = k.isNeg() & 1;\n\n  // Calculate the new scalar's length.\n  const bits = k1.bitLength();\n\n  // Recode scalar to base256.\n  const exp = k1.toArray('le');\n\n  return [sign, bits, exp];\n}\n\nfunction getCOZBits(k, n) {\n  assert(k instanceof BN);\n  assert(n instanceof BN);\n\n  // Reduce.\n  const u = k.mod(n);\n\n  // Negate scalar.\n  const v = n.sub(u);\n\n  // Get bit lengths.\n  const ub = u.bitLength();\n  const vb = v.bitLength();\n\n  // Negate if ceil(log2(k)) < ceil(log2(-k)).\n  const sign = (ub - vb) >>> 31;\n\n  // Possibly negate.\n  u.cinject(v, sign);\n\n  // Calculate the new scalar's length.\n  const bits = u.bitLength();\n\n  // Recode scalar to base256.\n  const exp = u.toArray('le');\n\n  // Final edge case.\n  const m1 = u.ceq(n.subn(1));\n\n  return [sign, bits, exp, m1];\n}\n\n/*\n * Helpers\n */\n\nfunction assert(val, msg) {\n  if (!val) {\n    const err = new Error(msg || 'Assertion failed');\n\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(err, assert);\n\n    throw err;\n  }\n}\n\nfunction sqrt(a) {\n  assert(a instanceof BN);\n\n  try {\n    return [1, a.redSqrt()];\n  } catch (e) {\n    if (e.message === 'X is not a square mod P.')\n      return [0, a.clone()];\n    throw e;\n  }\n}\n\nfunction divSqrt(u, v) {\n  assert(u instanceof BN);\n  assert(v instanceof BN);\n\n  try {\n    return [1, u.redDivSqrt(v)];\n  } catch (e) {\n    if (e.message === 'Not invertible.'\n        || e.message === 'X is not a square mod P.') {\n      return [0, u.clone()];\n    }\n    throw e;\n  }\n}\n\nfunction randomInt(rng) {\n  return BN.randomBits(rng, 32).toNumber();\n}\n\nfunction memoize(method, self) {\n  const cache = new WeakMap();\n\n  return function memoized(curve, invert) {\n    const i = invert & 1;\n    const item = cache.get(curve);\n\n    if (item && item[i] !== null)\n      return item[i];\n\n    const result = method.call(self, curve, invert);\n\n    if (!cache.has(curve))\n      cache.set(curve, [null, null]);\n\n    cache.get(curve)[i] = result;\n\n    return result;\n  };\n}\n\n/*\n * Expose\n */\n\nexports.Curve = Curve;\nexports.Point = Point;\nexports.ShortCurve = ShortCurve;\nexports.ShortPoint = ShortPoint;\nexports.JPoint = JPoint;\nexports.MontCurve = MontCurve;\nexports.MontPoint = MontPoint;\nexports.XPoint = XPoint;\nexports.EdwardsCurve = EdwardsCurve;\nexports.EdwardsPoint = EdwardsPoint;\nexports.curves = curves;\nexports.curve = curve;\nexports.register = register;\n"]},"metadata":{},"sourceType":"script"}