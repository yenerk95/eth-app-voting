{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar PeerId = require('peer-id');\n\nvar _require2 = require('./index'),\n    Message = _require2.Message;\n\nvar SignPrefix = Buffer.from('libp2p-pubsub:');\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {Message} message\n * @returns {Promise<Message>}\n */\n\nfunction signMessage(_x, _x2) {\n  return _signMessage.apply(this, arguments);\n}\n/**\n * Verifies the signature of the given message\n * @param {rpc.RPC.Message} message\n * @returns {Promise<Boolean>}\n */\n\n\nfunction _signMessage() {\n  _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peerId, message) {\n    var bytes, signature;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Get the message in bytes, and prepend with the pubsub prefix\n            bytes = Buffer.concat([SignPrefix, Message.encode(message)]);\n            _context.next = 3;\n            return peerId.privKey.sign(bytes);\n\n          case 3:\n            signature = _context.sent;\n            return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, message), {}, {\n              signature: signature,\n              key: peerId.pubKey.bytes\n            }));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _signMessage.apply(this, arguments);\n}\n\nfunction verifySignature(_x3) {\n  return _verifySignature.apply(this, arguments);\n}\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {Message} message\n * @returns {Promise<PublicKey>}\n */\n\n\nfunction _verifySignature() {\n  _verifySignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(message) {\n    var baseMessage, bytes, pubKey;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // Get message sans the signature\n            baseMessage = _objectSpread({}, message);\n            delete baseMessage.signature;\n            delete baseMessage.key;\n            bytes = Buffer.concat([SignPrefix, Message.encode(baseMessage)]); // Get the public key\n\n            _context2.next = 6;\n            return messagePublicKey(message);\n\n          case 6:\n            pubKey = _context2.sent;\n            return _context2.abrupt(\"return\", pubKey.verify(bytes, message.signature));\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifySignature.apply(this, arguments);\n}\n\nfunction messagePublicKey(_x4) {\n  return _messagePublicKey.apply(this, arguments);\n}\n\nfunction _messagePublicKey() {\n  _messagePublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(message) {\n    var peerId, from;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!message.key) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.next = 3;\n            return PeerId.createFromPubKey(message.key);\n\n          case 3:\n            peerId = _context3.sent;\n\n            if (!peerId.isEqual(message.from)) {\n              _context3.next = 6;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", peerId.pubKey);\n\n          case 6:\n            throw new Error('Public Key does not match the originator');\n\n          case 9:\n            // should be available in the from property of the message (peer id)\n            from = PeerId.createFromBytes(message.from);\n\n            if (!from.pubKey) {\n              _context3.next = 14;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", from.pubKey);\n\n          case 14:\n            throw new Error('Could not get the public key from the originator id');\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _messagePublicKey.apply(this, arguments);\n}\n\nmodule.exports = {\n  messagePublicKey: messagePublicKey,\n  signMessage: signMessage,\n  SignPrefix: SignPrefix,\n  verifySignature: verifySignature\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-pubsub/src/message/sign.js"],"names":["require","Buffer","PeerId","Message","SignPrefix","from","signMessage","peerId","message","bytes","concat","encode","privKey","sign","signature","key","pubKey","verifySignature","baseMessage","messagePublicKey","verify","createFromPubKey","isEqual","Error","createFromBytes","module","exports"],"mappings":"AAAA;;;;;;;;eACmBA,OAAO,CAAC,QAAD,C;IAAlBC,M,YAAAA,M;;AACR,IAAMC,MAAM,GAAGF,OAAO,CAAC,SAAD,CAAtB;;gBACoBA,OAAO,CAAC,SAAD,C;IAAnBG,O,aAAAA,O;;AACR,IAAMC,UAAU,GAAGH,MAAM,CAACI,IAAP,CAAY,gBAAZ,CAAnB;AAEA;;;;;;;;SAOeC,W;;;AAgBf;;;;;;;;0EAhBA,iBAA4BC,MAA5B,EAAoCC,OAApC;AAAA;AAAA;AAAA;AAAA;AAAA;AACE;AACMC,YAAAA,KAFR,GAEgBR,MAAM,CAACS,MAAP,CAAc,CAC1BN,UAD0B,EAE1BD,OAAO,CAACQ,MAAR,CAAeH,OAAf,CAF0B,CAAd,CAFhB;AAAA;AAAA,mBAO0BD,MAAM,CAACK,OAAP,CAAeC,IAAf,CAAoBJ,KAApB,CAP1B;;AAAA;AAOQK,YAAAA,SAPR;AAAA,6EAUON,OAVP;AAWIM,cAAAA,SAAS,EAAEA,SAXf;AAYIC,cAAAA,GAAG,EAAER,MAAM,CAACS,MAAP,CAAcP;AAZvB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAqBeQ,e;;;AAiBf;;;;;;;;;;8EAjBA,kBAAgCT,OAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AACE;AACMU,YAAAA,WAFR,qBAE2BV,OAF3B;AAGE,mBAAOU,WAAW,CAACJ,SAAnB;AACA,mBAAOI,WAAW,CAACH,GAAnB;AACMN,YAAAA,KALR,GAKgBR,MAAM,CAACS,MAAP,CAAc,CAC1BN,UAD0B,EAE1BD,OAAO,CAACQ,MAAR,CAAeO,WAAf,CAF0B,CAAd,CALhB,EAUE;;AAVF;AAAA,mBAWuBC,gBAAgB,CAACX,OAAD,CAXvC;;AAAA;AAWQQ,YAAAA,MAXR;AAAA,8CAcSA,MAAM,CAACI,MAAP,CAAcX,KAAd,EAAqBD,OAAO,CAACM,SAA7B,CAdT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAwBeK,gB;;;;;+EAAf,kBAAiCX,OAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBACMA,OAAO,CAACO,GADd;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAEyBb,MAAM,CAACmB,gBAAP,CAAwBb,OAAO,CAACO,GAAhC,CAFzB;;AAAA;AAEUR,YAAAA,MAFV;;AAAA,iBAKQA,MAAM,CAACe,OAAP,CAAed,OAAO,CAACH,IAAvB,CALR;AAAA;AAAA;AAAA;;AAAA,8CAK6CE,MAAM,CAACS,MALpD;;AAAA;AAAA,kBAOU,IAAIO,KAAJ,CAAU,0CAAV,CAPV;;AAAA;AASI;AACMlB,YAAAA,IAVV,GAUiBH,MAAM,CAACsB,eAAP,CAAuBhB,OAAO,CAACH,IAA/B,CAVjB;;AAAA,iBAYQA,IAAI,CAACW,MAZb;AAAA;AAAA;AAAA;;AAAA,8CAaaX,IAAI,CAACW,MAblB;;AAAA;AAAA,kBAeY,IAAIO,KAAJ,CAAU,qDAAV,CAfZ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAoBAE,MAAM,CAACC,OAAP,GAAiB;AACfP,EAAAA,gBAAgB,EAAhBA,gBADe;AAEfb,EAAAA,WAAW,EAAXA,WAFe;AAGfF,EAAAA,UAAU,EAAVA,UAHe;AAIfa,EAAAA,eAAe,EAAfA;AAJe,CAAjB","sourcesContent":["'use strict'\nconst { Buffer } = require('buffer')\nconst PeerId = require('peer-id')\nconst { Message } = require('./index')\nconst SignPrefix = Buffer.from('libp2p-pubsub:')\n\n/**\n * Signs the provided message with the given `peerId`\n *\n * @param {PeerId} peerId\n * @param {Message} message\n * @returns {Promise<Message>}\n */\nasync function signMessage (peerId, message) {\n  // Get the message in bytes, and prepend with the pubsub prefix\n  const bytes = Buffer.concat([\n    SignPrefix,\n    Message.encode(message)\n  ])\n\n  const signature = await peerId.privKey.sign(bytes)\n\n  return {\n    ...message,\n    signature: signature,\n    key: peerId.pubKey.bytes\n  }\n}\n\n/**\n * Verifies the signature of the given message\n * @param {rpc.RPC.Message} message\n * @returns {Promise<Boolean>}\n */\nasync function verifySignature (message) {\n  // Get message sans the signature\n  const baseMessage = { ...message }\n  delete baseMessage.signature\n  delete baseMessage.key\n  const bytes = Buffer.concat([\n    SignPrefix,\n    Message.encode(baseMessage)\n  ])\n\n  // Get the public key\n  const pubKey = await messagePublicKey(message)\n\n  // verify the base message\n  return pubKey.verify(bytes, message.signature)\n}\n\n/**\n * Returns the PublicKey associated with the given message.\n * If no, valid PublicKey can be retrieved an error will be returned.\n *\n * @param {Message} message\n * @returns {Promise<PublicKey>}\n */\nasync function messagePublicKey (message) {\n  if (message.key) {\n    const peerId = await PeerId.createFromPubKey(message.key)\n\n    // the key belongs to the sender, return the key\n    if (peerId.isEqual(message.from)) return peerId.pubKey\n    // We couldn't validate pubkey is from the originator, error\n    throw new Error('Public Key does not match the originator')\n  } else {\n    // should be available in the from property of the message (peer id)\n    const from = PeerId.createFromBytes(message.from)\n\n    if (from.pubKey) {\n      return from.pubKey\n    } else {\n      throw new Error('Could not get the public key from the originator id')\n    }\n  }\n}\n\nmodule.exports = {\n  messagePublicKey,\n  signMessage,\n  SignPrefix,\n  verifySignature\n}\n"]},"metadata":{},"sourceType":"script"}