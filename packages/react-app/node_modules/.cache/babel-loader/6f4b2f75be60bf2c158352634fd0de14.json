{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst c = require('../constants');\n\nconst LimitedPeerList = require('../peer-list/limited-peer-list');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nmodule.exports = dht => {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n  const findProvidersSingle = async (peer, key) => {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0);\n    return dht.network.sendRequest(peer, msg);\n  };\n\n  return {\n    /**\n     * Announce to the network that we can provide given key's value.\n     * @param {CID} key\n     * @returns {Promise<void>}\n     */\n    async provide(key) {\n      dht._log('provide: %s', key.toBaseEncodedString());\n\n      const errors = []; // Add peer as provider\n\n      await dht.providers.addProvider(key, dht.peerId);\n      const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];\n      const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0);\n      msg.providerPeers = [{\n        id: dht.peerId,\n        multiaddrs\n      }]; // Notify closest peers\n\n      await utils.mapParallel(dht.getClosestPeers(key.buffer), async peer => {\n        dht._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n        try {\n          await dht.network.sendMessage(peer, msg);\n        } catch (err) {\n          errors.push(err);\n        }\n      });\n\n      if (errors.length) {\n        // TODO:\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        throw errcode(new Error(`Failed to provide to ${errors.length} of ${dht.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED'), {\n          errors\n        });\n      }\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async *findProviders(key, options = {}) {\n      const providerTimeout = options.timeout || c.minute;\n      const n = options.maxNumProviders || c.K;\n\n      dht._log('findProviders %s', key.toBaseEncodedString());\n\n      const out = new LimitedPeerList(n);\n      const provs = await dht.providers.getProviders(key);\n      provs.forEach(id => {\n        const peerData = dht.peerStore.get(id) || {};\n        out.push({\n          id: peerData.id || id,\n          multiaddrs: (peerData.addresses || []).map(address => address.multiaddr)\n        });\n      }); // All done\n\n      if (out.length >= n) {\n        // yield values\n        for (const pData of out.toArray()) {\n          yield pData;\n        }\n\n        return;\n      } // need more, query the network\n\n\n      const paths = [];\n      const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(n - out.length, numPaths);\n        const pathProviders = new LimitedPeerList(pathSize);\n        paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n        return async peer => {\n          const msg = await findProvidersSingle(peer, key);\n          const provs = msg.providerPeers;\n\n          dht._log('(%s) found %s provider entries', dht.peerId.toB58String(), provs.length);\n\n          provs.forEach(prov => {\n            pathProviders.push({\n              id: prov.id\n            });\n          }); // hooray we have all that we want\n\n          if (pathProviders.length >= pathSize) {\n            return {\n              pathComplete: true\n            };\n          } // it looks like we want some more\n\n\n          return {\n            closerPeers: msg.closerPeers\n          };\n        };\n      });\n      const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize);\n\n      try {\n        await pTimeout(query.run(peers), providerTimeout);\n      } catch (err) {\n        if (err.name !== pTimeout.TimeoutError.name) {\n          throw err;\n        }\n      } finally {\n        query.stop();\n      } // combine peers from each path\n\n\n      paths.forEach(path => {\n        path.toArray().forEach(peer => {\n          out.push(peer);\n        });\n      });\n\n      if (out.length === 0) {\n        throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND');\n      }\n\n      for (const pData of out.toArray()) {\n        yield pData;\n      }\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/libp2p-kad-dht/src/content-routing/index.js"],"names":["errcode","require","pTimeout","c","LimitedPeerList","Message","Query","utils","module","exports","dht","findProvidersSingle","peer","key","msg","TYPES","GET_PROVIDERS","buffer","network","sendRequest","provide","_log","toBaseEncodedString","errors","providers","addProvider","peerId","multiaddrs","libp2p","ADD_PROVIDER","providerPeers","id","mapParallel","getClosestPeers","toB58String","sendMessage","err","push","length","Error","kBucketSize","findProviders","options","providerTimeout","timeout","minute","n","maxNumProviders","K","out","provs","getProviders","forEach","peerData","peerStore","get","addresses","map","address","multiaddr","pData","toArray","paths","query","pathIndex","numPaths","pathSize","pathProviders","prov","pathComplete","closerPeers","peers","routingTable","closestPeers","run","name","TimeoutError","stop","path"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAxB;;AAEA,MAAME,CAAC,GAAGF,OAAO,CAAC,cAAD,CAAjB;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,gCAAD,CAA/B;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMK,KAAK,GAAGL,OAAO,CAAC,UAAD,CAArB;;AACA,MAAMM,KAAK,GAAGN,OAAO,CAAC,UAAD,CAArB;;AAEAO,MAAM,CAACC,OAAP,GAAkBC,GAAD,IAAS;AACxB;;;;;;;;;AASA,QAAMC,mBAAmB,GAAG,OAAOC,IAAP,EAAaC,GAAb,KAAqB;AAAE;AACjD,UAAMC,GAAG,GAAG,IAAIT,OAAJ,CAAYA,OAAO,CAACU,KAAR,CAAcC,aAA1B,EAAyCH,GAAG,CAACI,MAA7C,EAAqD,CAArD,CAAZ;AACA,WAAOP,GAAG,CAACQ,OAAJ,CAAYC,WAAZ,CAAwBP,IAAxB,EAA8BE,GAA9B,CAAP;AACD,GAHD;;AAKA,SAAO;AACL;;;;;AAKA,UAAMM,OAAN,CAAeP,GAAf,EAAoB;AAClBH,MAAAA,GAAG,CAACW,IAAJ,CAAS,aAAT,EAAwBR,GAAG,CAACS,mBAAJ,EAAxB;;AAEA,YAAMC,MAAM,GAAG,EAAf,CAHkB,CAKlB;;AACA,YAAMb,GAAG,CAACc,SAAJ,CAAcC,WAAd,CAA0BZ,GAA1B,EAA+BH,GAAG,CAACgB,MAAnC,CAAN;AAEA,YAAMC,UAAU,GAAGjB,GAAG,CAACkB,MAAJ,GAAalB,GAAG,CAACkB,MAAJ,CAAWD,UAAxB,GAAqC,EAAxD;AACA,YAAMb,GAAG,GAAG,IAAIT,OAAJ,CAAYA,OAAO,CAACU,KAAR,CAAcc,YAA1B,EAAwChB,GAAG,CAACI,MAA5C,EAAoD,CAApD,CAAZ;AACAH,MAAAA,GAAG,CAACgB,aAAJ,GAAoB,CAAC;AACnBC,QAAAA,EAAE,EAAErB,GAAG,CAACgB,MADW;AAEnBC,QAAAA;AAFmB,OAAD,CAApB,CAVkB,CAelB;;AACA,YAAMpB,KAAK,CAACyB,WAAN,CAAkBtB,GAAG,CAACuB,eAAJ,CAAoBpB,GAAG,CAACI,MAAxB,CAAlB,EAAmD,MAAOL,IAAP,IAAgB;AACvEF,QAAAA,GAAG,CAACW,IAAJ,CAAS,sBAAT,EAAiCR,GAAG,CAACS,mBAAJ,EAAjC,EAA4DV,IAAI,CAACsB,WAAL,EAA5D;;AACA,YAAI;AACF,gBAAMxB,GAAG,CAACQ,OAAJ,CAAYiB,WAAZ,CAAwBvB,IAAxB,EAA8BE,GAA9B,CAAN;AACD,SAFD,CAEE,OAAOsB,GAAP,EAAY;AACZb,UAAAA,MAAM,CAACc,IAAP,CAAYD,GAAZ;AACD;AACF,OAPK,CAAN;;AASA,UAAIb,MAAM,CAACe,MAAX,EAAmB;AACjB;AACA;AACA;AACA;AACA,cAAMtC,OAAO,CAAC,IAAIuC,KAAJ,CAAW,wBAAuBhB,MAAM,CAACe,MAAO,OAAM5B,GAAG,CAAC8B,WAAY,QAAtE,EAA+E,0BAA/E,CAAD,EAA6G;AAAEjB,UAAAA;AAAF,SAA7G,CAAb;AACD;AACF,KAtCI;;AAwCL;;;;;;;;AAQA,WAAQkB,aAAR,CAAuB5B,GAAvB,EAA4B6B,OAAO,GAAG,EAAtC,EAA0C;AACxC,YAAMC,eAAe,GAAGD,OAAO,CAACE,OAAR,IAAmBzC,CAAC,CAAC0C,MAA7C;AACA,YAAMC,CAAC,GAAGJ,OAAO,CAACK,eAAR,IAA2B5C,CAAC,CAAC6C,CAAvC;;AAEAtC,MAAAA,GAAG,CAACW,IAAJ,CAAS,kBAAT,EAA6BR,GAAG,CAACS,mBAAJ,EAA7B;;AAEA,YAAM2B,GAAG,GAAG,IAAI7C,eAAJ,CAAoB0C,CAApB,CAAZ;AACA,YAAMI,KAAK,GAAG,MAAMxC,GAAG,CAACc,SAAJ,CAAc2B,YAAd,CAA2BtC,GAA3B,CAApB;AAEAqC,MAAAA,KAAK,CAACE,OAAN,CAAerB,EAAD,IAAQ;AACpB,cAAMsB,QAAQ,GAAG3C,GAAG,CAAC4C,SAAJ,CAAcC,GAAd,CAAkBxB,EAAlB,KAAyB,EAA1C;AACAkB,QAAAA,GAAG,CAACZ,IAAJ,CAAS;AACPN,UAAAA,EAAE,EAAEsB,QAAQ,CAACtB,EAAT,IAAeA,EADZ;AAEPJ,UAAAA,UAAU,EAAE,CAAC0B,QAAQ,CAACG,SAAT,IAAsB,EAAvB,EAA2BC,GAA3B,CAAgCC,OAAD,IAAaA,OAAO,CAACC,SAApD;AAFL,SAAT;AAID,OAND,EATwC,CAiBxC;;AACA,UAAIV,GAAG,CAACX,MAAJ,IAAcQ,CAAlB,EAAqB;AACnB;AACA,aAAK,MAAMc,KAAX,IAAoBX,GAAG,CAACY,OAAJ,EAApB,EAAmC;AACjC,gBAAMD,KAAN;AACD;;AACD;AACD,OAxBuC,CA0BxC;;;AACA,YAAME,KAAK,GAAG,EAAd;AACA,YAAMC,KAAK,GAAG,IAAIzD,KAAJ,CAAUI,GAAV,EAAeG,GAAG,CAACI,MAAnB,EAA2B,CAAC+C,SAAD,EAAYC,QAAZ,KAAyB;AAChE;AACA,cAAMC,QAAQ,GAAG3D,KAAK,CAAC2D,QAAN,CAAepB,CAAC,GAAGG,GAAG,CAACX,MAAvB,EAA+B2B,QAA/B,CAAjB;AACA,cAAME,aAAa,GAAG,IAAI/D,eAAJ,CAAoB8D,QAApB,CAAtB;AACAJ,QAAAA,KAAK,CAACzB,IAAN,CAAW8B,aAAX,EAJgE,CAMhE;;AACA,eAAO,MAAOvD,IAAP,IAAgB;AACrB,gBAAME,GAAG,GAAG,MAAMH,mBAAmB,CAACC,IAAD,EAAOC,GAAP,CAArC;AACA,gBAAMqC,KAAK,GAAGpC,GAAG,CAACgB,aAAlB;;AACApB,UAAAA,GAAG,CAACW,IAAJ,CAAS,gCAAT,EAA2CX,GAAG,CAACgB,MAAJ,CAAWQ,WAAX,EAA3C,EAAqEgB,KAAK,CAACZ,MAA3E;;AAEAY,UAAAA,KAAK,CAACE,OAAN,CAAegB,IAAD,IAAU;AACtBD,YAAAA,aAAa,CAAC9B,IAAd,CAAmB;AAAEN,cAAAA,EAAE,EAAEqC,IAAI,CAACrC;AAAX,aAAnB;AACD,WAFD,EALqB,CASrB;;AACA,cAAIoC,aAAa,CAAC7B,MAAd,IAAwB4B,QAA5B,EAAsC;AACpC,mBAAO;AAAEG,cAAAA,YAAY,EAAE;AAAhB,aAAP;AACD,WAZoB,CAcrB;;;AACA,iBAAO;AAAEC,YAAAA,WAAW,EAAExD,GAAG,CAACwD;AAAnB,WAAP;AACD,SAhBD;AAiBD,OAxBa,CAAd;AA0BA,YAAMC,KAAK,GAAG7D,GAAG,CAAC8D,YAAJ,CAAiBC,YAAjB,CAA8B5D,GAAG,CAACI,MAAlC,EAA0CP,GAAG,CAAC8B,WAA9C,CAAd;;AAEA,UAAI;AACF,cAAMtC,QAAQ,CACZ6D,KAAK,CAACW,GAAN,CAAUH,KAAV,CADY,EAEZ5B,eAFY,CAAd;AAID,OALD,CAKE,OAAOP,GAAP,EAAY;AACZ,YAAIA,GAAG,CAACuC,IAAJ,KAAazE,QAAQ,CAAC0E,YAAT,CAAsBD,IAAvC,EAA6C;AAC3C,gBAAMvC,GAAN;AACD;AACF,OATD,SASU;AACR2B,QAAAA,KAAK,CAACc,IAAN;AACD,OAnEuC,CAqExC;;;AACAf,MAAAA,KAAK,CAACV,OAAN,CAAe0B,IAAD,IAAU;AACtBA,QAAAA,IAAI,CAACjB,OAAL,GAAeT,OAAf,CAAwBxC,IAAD,IAAU;AAC/BqC,UAAAA,GAAG,CAACZ,IAAJ,CAASzB,IAAT;AACD,SAFD;AAGD,OAJD;;AAMA,UAAIqC,GAAG,CAACX,MAAJ,KAAe,CAAnB,EAAsB;AACpB,cAAMtC,OAAO,CAAC,IAAIuC,KAAJ,CAAU,oBAAV,CAAD,EAAkC,eAAlC,CAAb;AACD;;AAED,WAAK,MAAMqB,KAAX,IAAoBX,GAAG,CAACY,OAAJ,EAApB,EAAmC;AACjC,cAAMD,KAAN;AACD;AACF;;AAnII,GAAP;AAqID,CApJD","sourcesContent":["'use strict'\n\nconst errcode = require('err-code')\nconst pTimeout = require('p-timeout')\n\nconst c = require('../constants')\nconst LimitedPeerList = require('../peer-list/limited-peer-list')\nconst Message = require('../message')\nconst Query = require('../query')\nconst utils = require('../utils')\n\nmodule.exports = (dht) => {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n  const findProvidersSingle = async (peer, key) => { // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0)\n    return dht.network.sendRequest(peer, msg)\n  }\n\n  return {\n    /**\n     * Announce to the network that we can provide given key's value.\n     * @param {CID} key\n     * @returns {Promise<void>}\n     */\n    async provide (key) {\n      dht._log('provide: %s', key.toBaseEncodedString())\n\n      const errors = []\n\n      // Add peer as provider\n      await dht.providers.addProvider(key, dht.peerId)\n\n      const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : []\n      const msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0)\n      msg.providerPeers = [{\n        id: dht.peerId,\n        multiaddrs\n      }]\n\n      // Notify closest peers\n      await utils.mapParallel(dht.getClosestPeers(key.buffer), async (peer) => {\n        dht._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String())\n        try {\n          await dht.network.sendMessage(peer, msg)\n        } catch (err) {\n          errors.push(err)\n        }\n      })\n\n      if (errors.length) {\n        // TODO:\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        throw errcode(new Error(`Failed to provide to ${errors.length} of ${dht.kBucketSize} peers`, 'ERR_SOME_PROVIDES_FAILED'), { errors })\n      }\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async * findProviders (key, options = {}) {\n      const providerTimeout = options.timeout || c.minute\n      const n = options.maxNumProviders || c.K\n\n      dht._log('findProviders %s', key.toBaseEncodedString())\n\n      const out = new LimitedPeerList(n)\n      const provs = await dht.providers.getProviders(key)\n\n      provs.forEach((id) => {\n        const peerData = dht.peerStore.get(id) || {}\n        out.push({\n          id: peerData.id || id,\n          multiaddrs: (peerData.addresses || []).map((address) => address.multiaddr)\n        })\n      })\n\n      // All done\n      if (out.length >= n) {\n        // yield values\n        for (const pData of out.toArray()) {\n          yield pData\n        }\n        return\n      }\n\n      // need more, query the network\n      const paths = []\n      const query = new Query(dht, key.buffer, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(n - out.length, numPaths)\n        const pathProviders = new LimitedPeerList(pathSize)\n        paths.push(pathProviders)\n\n        // Here we return the query function to use on this particular disjoint path\n        return async (peer) => {\n          const msg = await findProvidersSingle(peer, key)\n          const provs = msg.providerPeers\n          dht._log('(%s) found %s provider entries', dht.peerId.toB58String(), provs.length)\n\n          provs.forEach((prov) => {\n            pathProviders.push({ id: prov.id })\n          })\n\n          // hooray we have all that we want\n          if (pathProviders.length >= pathSize) {\n            return { pathComplete: true }\n          }\n\n          // it looks like we want some more\n          return { closerPeers: msg.closerPeers }\n        }\n      })\n\n      const peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize)\n\n      try {\n        await pTimeout(\n          query.run(peers),\n          providerTimeout\n        )\n      } catch (err) {\n        if (err.name !== pTimeout.TimeoutError.name) {\n          throw err\n        }\n      } finally {\n        query.stop()\n      }\n\n      // combine peers from each path\n      paths.forEach((path) => {\n        path.toArray().forEach((peer) => {\n          out.push(peer)\n        })\n      })\n\n      if (out.length === 0) {\n        throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND')\n      }\n\n      for (const pData of out.toArray()) {\n        yield pData\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}