{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport { Buffer } from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport { encode, decode } from 'it-length-prefixed';\nimport { XXHandshake } from \"./handshake-xx\";\nimport { IKHandshake } from \"./handshake-ik\";\nimport { XXFallbackHandshake } from \"./handshake-xx-fallback\";\nimport { generateKeypair, getPayload } from \"./utils\";\nimport { uint16BEDecode, uint16BEEncode } from \"./encoder\";\nimport { decryptStream, encryptStream } from \"./crypto\";\nimport { KeyCache } from \"./keycache\";\nimport { logger } from \"./logger\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from \"./constants\";\nexport class Noise {\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  constructor(staticNoiseKey, earlyData) {\n    _defineProperty(this, \"protocol\", \"/noise\");\n\n    _defineProperty(this, \"prologue\", Buffer.alloc(0));\n\n    _defineProperty(this, \"staticKeys\", void 0);\n\n    _defineProperty(this, \"earlyData\", void 0);\n\n    _defineProperty(this, \"useNoisePipes\", void 0);\n\n    this.earlyData = earlyData || Buffer.alloc(0); //disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey\n      };\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureOutbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = Wrap(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureInbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = Wrap(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param params\n   */\n\n\n  async performHandshake(params) {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n\n    if (params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      //if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n    if (tryIK) {\n      // Try IK first\n      const {\n        remotePeer,\n        connection,\n        isInitiator\n      } = params;\n      const ikHandshake = new IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, //safe to cast as we did checks\n      KeyCache.load(params.remotePeer) || Buffer.alloc(32), remotePeer);\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger(e);\n      throw new Error(\"Error occurred during XX Fallback handshake: \".concat(e.message));\n    }\n\n    return handshake;\n  }\n\n  async performXXHandshake(params, payload) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      throw new Error(\"Error occurred during XX handshake: \".concat(e.message));\n    }\n\n    return handshake;\n  }\n\n  async performIKHandshake(handshake) {\n    await handshake.stage0();\n    await handshake.stage1();\n    return handshake;\n  }\n\n  async createSecureConnection(connection, handshake) {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair();\n    const network = connection.unwrap();\n    pipe(secure, // write to wrapper\n    ensureBuffer, // ensure any type of data is converted to buffer\n    encryptStream(handshake), // data is encrypted\n    encode({\n      lengthEncoder: uint16BEEncode\n    }), // prefix with message length\n    network, // send to the remote peer\n    decode({\n      lengthDecoder: uint16BEDecode\n    }), // read message length prefix\n    ensureBuffer, // ensure any type of data is converted to buffer\n    decryptStream(handshake), // decrypt the incoming data\n    secure // pipe to the wrapper\n    );\n    return user;\n  }\n\n}","map":{"version":3,"sources":["../src/noise.ts"],"names":["Buffer","constructor","earlyData","publicKey","x25519","privateKey","generateKeypair","wrappedConnection","Wrap","lengthEncoder","lengthDecoder","maxDataLength","NOISE_MSG_MAX_LENGTH_BYTES","handshake","connection","isInitiator","remotePeer","conn","remoteEarlyData","payload","getPayload","params","tryIK","KeyCache","ikHandshake","ephemeralKeys","e","logger","DuplexPair","network","pipe","encryptStream","encode","uint16BEEncode","decode","uint16BEDecode","decryptStream"],"mappings":"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","sourcesContent":["import x25519 from 'bcrypto/lib/js/x25519';\nimport {Buffer} from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport {encode, decode} from 'it-length-prefixed';\n\nimport {XXHandshake} from \"./handshake-xx\";\nimport {IKHandshake} from \"./handshake-ik\";\nimport {XXFallbackHandshake} from \"./handshake-xx-fallback\";\nimport {generateKeypair, getPayload} from \"./utils\";\nimport {uint16BEDecode, uint16BEEncode} from \"./encoder\";\nimport {decryptStream, encryptStream} from \"./crypto\";\nimport {bytes} from \"./@types/basic\";\nimport {INoiseConnection, KeyPair, SecureOutbound} from \"./@types/libp2p\";\nimport {Duplex} from \"it-pair\";\nimport {IHandshake} from \"./@types/handshake-interface\";\nimport {KeyCache} from \"./keycache\";\nimport {logger} from \"./logger\";\nimport PeerId from \"peer-id\";\nimport {NOISE_MSG_MAX_LENGTH_BYTES} from \"./constants\";\n\nexport type WrappedConnection = ReturnType<typeof Wrap>;\n\ntype HandshakeParams = {\n  connection: WrappedConnection;\n  isInitiator: boolean;\n  localPeer: PeerId;\n  remotePeer?: PeerId;\n};\n\nexport class Noise implements INoiseConnection {\n  public protocol = \"/noise\";\n\n  private readonly prologue = Buffer.alloc(0);\n  private readonly staticKeys: KeyPair;\n  private readonly earlyData?: bytes;\n  private useNoisePipes: boolean;\n\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  constructor(staticNoiseKey?: bytes, earlyData?: bytes) {\n    this.earlyData = earlyData || Buffer.alloc(0);\n    //disabled until properly specked\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey,\n      }\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureOutbound(localPeer: PeerId, connection: any, remotePeer: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer,\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer,\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureInbound(localPeer: PeerId, connection: any, remotePeer?: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    );\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param params\n   */\n  private async performHandshake(params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n    if(params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      //if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    }\n    // Try IK if acting as responder or initiator that has remote's static key.\n    if (tryIK) {\n      // Try IK first\n      const { remotePeer, connection, isInitiator } = params;\n      const ikHandshake = new IKHandshake(\n        isInitiator,\n        payload,\n        this.prologue,\n        this.staticKeys,\n        connection,\n        //safe to cast as we did checks\n        KeyCache.load(params.remotePeer) || Buffer.alloc(32),\n        remotePeer as PeerId,\n      );\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  private async performXXFallbackHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n    initialMsg: bytes,\n    ephemeralKeys?: KeyPair,\n  ): Promise<XXFallbackHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake =\n      new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger(e);\n      throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performXXHandshake(\n    params: HandshakeParams,\n    payload: bytes,\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      throw new Error(`Error occurred during XX handshake: ${e.message}`);\n    }\n\n    return handshake;\n  }\n\n  private async performIKHandshake(\n    handshake: IKHandshake,\n  ): Promise<IKHandshake> {\n\n    await handshake.stage0();\n    await handshake.stage1();\n\n    return handshake;\n  }\n\n  private async createSecureConnection(\n    connection: WrappedConnection,\n    handshake: IHandshake,\n  ): Promise<Duplex> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair();\n    const network = connection.unwrap();\n\n    pipe(\n      secure, // write to wrapper\n      ensureBuffer, // ensure any type of data is converted to buffer\n      encryptStream(handshake), // data is encrypted\n      encode({ lengthEncoder: uint16BEEncode }), // prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode}), // read message length prefix\n      ensureBuffer, // ensure any type of data is converted to buffer\n      decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n    );\n\n    return user;\n  }\n\n\n}\n"]},"metadata":{},"sourceType":"module"}