{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar AggregateError = require('aggregate-error');\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(iterable, mapper) {\n    var _ref2,\n        _ref2$concurrency,\n        concurrency,\n        _ref2$stopOnError,\n        stopOnError,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref2$concurrency = _ref2.concurrency, concurrency = _ref2$concurrency === void 0 ? Infinity : _ref2$concurrency, _ref2$stopOnError = _ref2.stopOnError, stopOnError = _ref2$stopOnError === void 0 ? true : _ref2$stopOnError;\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              if (typeof mapper !== 'function') {\n                throw new TypeError('Mapper function is required');\n              }\n\n              if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n                throw new TypeError(\"Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `\".concat(concurrency, \"` (\").concat(typeof concurrency, \")\"));\n              }\n\n              var result = [];\n              var errors = [];\n              var iterator = iterable[Symbol.iterator]();\n              var isRejected = false;\n              var isIterableDone = false;\n              var resolvingCount = 0;\n              var currentIndex = 0;\n\n              var next = function next() {\n                if (isRejected) {\n                  return;\n                }\n\n                var nextItem = iterator.next();\n                var index = currentIndex;\n                currentIndex++;\n\n                if (nextItem.done) {\n                  isIterableDone = true;\n\n                  if (resolvingCount === 0) {\n                    if (!stopOnError && errors.length !== 0) {\n                      reject(new AggregateError(errors));\n                    } else {\n                      resolve(result);\n                    }\n                  }\n\n                  return;\n                }\n\n                resolvingCount++;\n\n                _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  var element;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.prev = 0;\n                          _context.next = 3;\n                          return nextItem.value;\n\n                        case 3:\n                          element = _context.sent;\n                          _context.next = 6;\n                          return mapper(element, index);\n\n                        case 6:\n                          result[index] = _context.sent;\n                          resolvingCount--;\n                          next();\n                          _context.next = 14;\n                          break;\n\n                        case 11:\n                          _context.prev = 11;\n                          _context.t0 = _context[\"catch\"](0);\n\n                          if (stopOnError) {\n                            isRejected = true;\n                            reject(_context.t0);\n                          } else {\n                            errors.push(_context.t0);\n                            resolvingCount--;\n                            next();\n                          }\n\n                        case 14:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[0, 11]]);\n                }))();\n              };\n\n              for (var i = 0; i < concurrency; i++) {\n                next();\n\n                if (isIterableDone) {\n                  break;\n                }\n              }\n            }));\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/yenerkaraca/Documents/GitHub/eth-app/node_modules/p-map/index.js"],"names":["AggregateError","require","module","exports","iterable","mapper","concurrency","Infinity","stopOnError","Promise","resolve","reject","TypeError","Number","isSafeInteger","result","errors","iterator","Symbol","isRejected","isIterableDone","resolvingCount","currentIndex","next","nextItem","index","done","length","value","element","push","i"],"mappings":"AAAA;;;;;;AACA,IAAMA,cAAc,GAAGC,OAAO,CAAC,iBAAD,CAA9B;;AAEAC,MAAM,CAACC,OAAP;AAAA,sEAAiB,kBAChBC,QADgB,EAEhBC,MAFgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,+EAMZ,EANY,4BAIfC,WAJe,EAIfA,WAJe,kCAIDC,QAJC,gDAKfC,WALe,EAKfA,WALe,kCAKD,IALC;AAAA,8CAQT,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvC,kBAAI,OAAON,MAAP,KAAkB,UAAtB,EAAkC;AACjC,sBAAM,IAAIO,SAAJ,CAAc,6BAAd,CAAN;AACA;;AAED,kBAAI,EAAE,CAACC,MAAM,CAACC,aAAP,CAAqBR,WAArB,KAAqCA,WAAW,KAAKC,QAAtD,KAAmED,WAAW,IAAI,CAApF,CAAJ,EAA4F;AAC3F,sBAAM,IAAIM,SAAJ,qFAAgGN,WAAhG,gBAAkH,OAAOA,WAAzH,OAAN;AACA;;AAED,kBAAMS,MAAM,GAAG,EAAf;AACA,kBAAMC,MAAM,GAAG,EAAf;AACA,kBAAMC,QAAQ,GAAGb,QAAQ,CAACc,MAAM,CAACD,QAAR,CAAR,EAAjB;AACA,kBAAIE,UAAU,GAAG,KAAjB;AACA,kBAAIC,cAAc,GAAG,KAArB;AACA,kBAAIC,cAAc,GAAG,CAArB;AACA,kBAAIC,YAAY,GAAG,CAAnB;;AAEA,kBAAMC,IAAI,GAAG,SAAPA,IAAO,GAAM;AAClB,oBAAIJ,UAAJ,EAAgB;AACf;AACA;;AAED,oBAAMK,QAAQ,GAAGP,QAAQ,CAACM,IAAT,EAAjB;AACA,oBAAME,KAAK,GAAGH,YAAd;AACAA,gBAAAA,YAAY;;AAEZ,oBAAIE,QAAQ,CAACE,IAAb,EAAmB;AAClBN,kBAAAA,cAAc,GAAG,IAAjB;;AAEA,sBAAIC,cAAc,KAAK,CAAvB,EAA0B;AACzB,wBAAI,CAACb,WAAD,IAAgBQ,MAAM,CAACW,MAAP,KAAkB,CAAtC,EAAyC;AACxChB,sBAAAA,MAAM,CAAC,IAAIX,cAAJ,CAAmBgB,MAAnB,CAAD,CAAN;AACA,qBAFD,MAEO;AACNN,sBAAAA,OAAO,CAACK,MAAD,CAAP;AACA;AACD;;AAED;AACA;;AAEDM,gBAAAA,cAAc;;AAEd,yEAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAEuBG,QAAQ,CAACI,KAFhC;;AAAA;AAEOC,0BAAAA,OAFP;AAAA;AAAA,iCAGuBxB,MAAM,CAACwB,OAAD,EAAUJ,KAAV,CAH7B;;AAAA;AAGCV,0BAAAA,MAAM,CAACU,KAAD,CAHP;AAICJ,0BAAAA,cAAc;AACdE,0BAAAA,IAAI;AALL;AAAA;;AAAA;AAAA;AAAA;;AAOC,8BAAIf,WAAJ,EAAiB;AAChBW,4BAAAA,UAAU,GAAG,IAAb;AACAR,4BAAAA,MAAM,aAAN;AACA,2BAHD,MAGO;AACNK,4BAAAA,MAAM,CAACc,IAAP;AACAT,4BAAAA,cAAc;AACdE,4BAAAA,IAAI;AACJ;;AAdF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAD;AAiBA,eA1CD;;AA4CA,mBAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,WAApB,EAAiCyB,CAAC,EAAlC,EAAsC;AACrCR,gBAAAA,IAAI;;AAEJ,oBAAIH,cAAJ,EAAoB;AACnB;AACA;AACD;AACD,aApEM,CARS;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAjB;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}